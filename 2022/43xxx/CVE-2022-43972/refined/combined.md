=== Content from youtu.be_33721354_20250115_101055.html ===
[00:01] so in the last video we covered the
[00:03] reconnaissance stage of vulnerability
[00:05] research just gathering information that
[00:08] might be useful to know later when we go
[00:10] about trying to attack the device
[00:13] we also dug into how the client and the
[00:15] web server interact
[00:17] in what form is it expecting data that
[00:20] kind of thing just to get an idea of
[00:22] what our attacks might possibly look
[00:24] like
[00:26] we also got really lucky and managed to
[00:28] find an existing vulnerability that
[00:30] affects this product
[00:32] that we were able to use to actually get
[00:34] a root shell on the device and start
[00:36] poking around the operating system in an
[00:38] interactive fashion
[00:40] so at this point we're going to stop the
[00:42] information gathering process and turn
[00:44] our attention towards finding novel ways
[00:46] to achieve code execution on this device
[00:53] all right the first thing that we're
[00:54] going to do is to get the binary that's
[00:56] serving the Management console the web
[00:58] server httpd off of the router and onto
[01:01] our research machine so we can open it
[01:03] up in our reverse engineering tool of
[01:04] choice and start looking for some
[01:06] low-hanging fruit
[01:07] now the reason that we can't just start
[01:09] reversing the version of httpd that we
[01:12] got from the latest version of the
[01:14] firmware is that we know that the router
[01:16] is running firmware that's several
[01:17] versions out of date and the release
[01:19] notes show this that several updates
[01:21] have been made to the web server in
[01:24] between those two versions
[01:26] so if we want to hack this version of
[01:28] the router we need to get our hands on
[01:30] that binary now I should mention at this
[01:33] point that if we were actually doing
[01:34] vulner research I get the whole point of
[01:36] this exercise was to find a high impact
[01:39] volume of the kind that we might want to
[01:41] shop around to conferences and that kind
[01:42] of thing the first thing that we would
[01:44] have done is update the router to the
[01:45] latest version of the firmware
[01:47] the reason being that if
[01:50] you spend all of this time developing an
[01:53] exploit after you found a vulnerability
[01:55] in an old version of the firmware you
[01:57] run the risk of updating the router and
[02:00] suddenly that vulnerability is no longer
[02:02] there either it's been patched directly
[02:04] or the introduction of some other
[02:06] feature has just made that chunk of code
[02:08] unreachable so the general rule of thumb
[02:11] in actual research scenario is to update
[02:14] to the latest version immediately hack
[02:15] the latest and greatest but we don't
[02:18] care at this stage so our next step is
[02:21] going to be to actually get our hands on
[02:23] that binary so we can compare apples to
[02:25] apples
[02:27] but there's no real easy way of doing
[02:28] that because even though we have a root
[02:31] shell and we have tools like wget wget's
[02:34] only good for downloading
[02:36] files
[02:37] the specific version that's running on
[02:39] the router doesn't allow you to upload
[02:42] files which is what we're going to
[02:43] ultimately need to do in order to get
[02:46] our hands on it
[02:47] so the side step this issue we're going
[02:49] to cross compile a tool called netcat if
[02:51] you're not familiar with the netcats
[02:53] just a really common command line
[02:55] utility for reading information from
[02:58] network sockets
[03:00] sending bytes to another host over the
[03:03] network sending whole files
[03:04] executing commands remotely that kind of
[03:07] thing
[03:09] so I'm going to go go ahead and grab the
[03:13] source for it
[03:15] so that we can cross compile it for mips
[03:18] little endian 32-bit which is what the
[03:21] the router over here is running so it
[03:24] looks like we can grab that from Source
[03:25] Forge so let's go ahead and do that
[03:28] download the tar file here
[03:33] now the other thing that we're going to
[03:34] need of course is a compiler for mips a
[03:37] compiler that's going to take C code and
[03:39] then spit out a an executable that we
[03:41] can actually run on the router
[03:44] so unfortunately Linksys is really good
[03:46] about making their tool chains public
[03:49] the the tool chain being all of the
[03:51] tools necessary to like actually compile
[03:54] the firmware for yourself or build the
[03:56] firmware so you can make modifications
[03:57] to it and kind of play around
[03:59] so if we just search Linksys tool chain
[04:03] we can go to their
[04:05] general public license code Center and
[04:08] scroll down to our specific model the
[04:12] wrt54gl and download the tool chain it
[04:15] looks like there's two versions let's
[04:16] grab this second one
[04:20] download that straight into Cali
[04:23] this is going to take a second
[04:26] so this is going to ideally include all
[04:29] the compilers plus some source files
[04:31] that are probably present on the router
[04:33] now notice that this is the latest
[04:34] version of the tool chain but I think
[04:36] it's a pretty safe bet that any
[04:38] compilers are are going to be kept the
[04:39] same even as different versions of the
[04:42] of the firm of the firmware
[04:44] are released
[04:47] so we'll just extract this whoops
[04:51] and look to make sure that we know that
[04:55] the compilers are in there
[04:57] probably a good first step
[05:04] so I'm just going to look for all of the
[05:06] files that end
[05:08] in GCC
[05:12] yeah
[05:14] oops
[05:15] and we see that there are several
[05:18] but the ones these final three the ones
[05:22] that are in bin folders are the ones
[05:25] that we're interested in because these
[05:27] are the the runnable binaries and so
[05:29] that there are three here
[05:30] and I figured out by trial and error
[05:33] that it's this middle one that we want
[05:36] it's the middle one that's going to give
[05:38] us
[05:40] a file that we can actually run on the
[05:43] router
[05:44] an executable rather
[05:46] so in order to actually do the cross
[05:49] compilation to
[05:51] compile The netcat Source on our x86
[05:54] machine for mips I'm going to use a
[05:57] Docker container
[05:58] this is just how I do it whenever I have
[06:00] to cross compile something for mips
[06:05] I'm going to use the image
[06:08] i686 it's an Ubuntu
[06:11] image
[06:13] I figured out just by looking around on
[06:15] stack Overflow that this is the one that
[06:17] works for cross compiling for mips
[06:19] didn't really dig too deeply into why I
[06:23] it just works and I've been using it
[06:24] ever since
[06:25] so first of all we'll update our package
[06:28] lists and
[06:30] set the worker to a root
[06:38] and first things first we're going to
[06:40] want to copy in
[06:42] our
[06:44] what's it called there we go copy in the
[06:48] GPL file using this add directive which
[06:51] will automatically extract it into
[06:53] whatever our working directory is
[06:57] and then when we do that we're also
[06:59] going to want to
[07:01] actually install the tool chain so to do
[07:04] that we'll look here in the readme
[07:08] where there are instructions for how to
[07:10] build the entire image now we don't need
[07:12] to build the entire firmware image
[07:13] obviously but we do need to install the
[07:16] tool chain
[07:17] so it looks like running this sequence
[07:20] of commands and exporting the path we'll
[07:24] do it
[07:25] so we'll just copy all of these into our
[07:28] Docker file
[07:30] even though I could just spin up a a
[07:33] container and then issue all these
[07:36] commands from the command line I like to
[07:37] put as much as I can into the docker
[07:39] file because it sort of acts as you know
[07:42] on the Fly documentation
[07:47] clean this up a little bit here
[08:01] okay it looks like these commands are
[08:03] being run from
[08:05] within that folder the extracted folder
[08:10] yep
[08:12] okay so we're also going to have to see
[08:13] the
[08:15] into this guy
[08:17] that if anything else
[08:26] and we need to export that environment
[08:29] variable what was it
[08:35] yeah here we go
[08:38] just copy that directly trying to
[08:41] adhere as much as possible to exactly
[08:44] what's written here
[08:47] in the instructions
[08:49] okay so at this point we should be able
[08:52] to build
[08:54] or rather execute commands that are in
[08:58] all of these bin folders
[09:00] specifically the the compilers so I'll
[09:03] just check that really quick I'll just
[09:04] do Docker build
[09:07] call it tool chain
[09:10] and oops Docker file is not in that
[09:13] folder
[09:20] and that was pretty quick all right
[09:24] so now if I run this I should be able to
[09:27] have access to all of those compilers
[09:33] from anywhere in the file system
[09:36] Insanity check that really quick
[09:45] yeah perfect okay so we have
[09:48] GC we have G plus plus we have a bunch
[09:50] of other stuff great okay so the tool
[09:53] chain
[09:54] has been installed correctly
[09:57] now the next thing that we need to do is
[09:58] we need to copy in our netcat source
[10:01] which I downloaded let's move that over
[10:05] here from my
[10:07] Windows machine
[10:18] and this too will be automatically
[10:21] extracted sweet
[10:24] and we'll of course have to see the into
[10:25] it as well
[10:30] all right so at this point there's going
[10:31] to be a little bit of trial and error
[10:32] involved
[10:34] so
[10:35] I'll build this guy again
[10:40] run it
[10:48] and we're going to now look for
[10:51] probably not the readme let's let's look
[10:53] in this install file that should have
[10:55] some instructions
[11:04] all right here we go so the simplest way
[11:06] to compile the package is CD into the
[11:08] directory yep
[11:10] and then run configure
[11:13] okay
[11:14] so even if this doesn't work
[11:17] right off the bat
[11:19] hopefully it'll give us some productive
[11:22] error messages that we can adapt to if
[11:24] in case there are some dependencies or
[11:26] something
[11:28] okay so no acceptable C compiler found
[11:30] in path all right
[11:33] well they should be we definitely have
[11:39] GCC in the path huh
[11:42] well
[11:44] I guess we can just specify which C
[11:46] compiler we want to use directly
[11:49] by using the the CC variable
[11:52] for configure I'll just say which
[11:55] nipcl Linux GCC
[12:00] and that will tell configure exactly
[12:01] where to look for the compiler that we
[12:03] want
[12:06] so it still doesn't like it it says
[12:08] cannot run C compiled programs so that
[12:10] means that whatever
[12:14] the output file for this compiler is is
[12:18] not runnable on the on the current
[12:21] architecture but it says if you want if
[12:25] you meant to cross compile then use the
[12:27] host variable okay
[12:29] well that's exactly what we want to do I
[12:31] suggest we follow those directions
[12:33] and so we'll just specify that the host
[12:35] that we want to eventually run these
[12:37] compiled programs on is nipcl
[12:43] and now we're off and running and it
[12:45] looks like
[12:46] that works
[12:49] Grand
[12:50] okay so now what's the next instruction
[12:53] [Music]
[13:02] next instruction is just to run make
[13:05] to compile the package okay so we need
[13:07] to have make in here
[13:19] go ahead and install that
[13:24] and we can just run make that was quick
[13:28] okay so now
[13:32] where's our binary
[13:39] there we go
[13:46] oh of course I did the file
[13:58] cool okay so we now have a net cap
[14:01] binary
[14:02] it's no file 32-bid executable for mips
[14:07] but we noticed that it's dynamically
[14:09] linked that means that it's relying on
[14:12] some other files some shared objects
[14:13] that are present on this file system so
[14:15] it'll run fine in this environment well
[14:18] actually it won't because it's not maps
[14:21] but
[14:23] it's not going to run once we put it on
[14:25] the router because it's going to be
[14:27] looking for those shared objects and
[14:29] they're not going to be there
[14:31] so that means that we need to
[14:34] configure this build
[14:36] differently
[14:38] probably run make clean on this first
[14:40] just to delete everything start it
[14:42] afresh
[14:47] and we're going to add another variable
[14:49] here to the
[14:52] configure command the C Flags
[14:55] variable and we're going to specify that
[14:58] we want this to be a static build which
[15:00] means include everything that is
[15:04] required to run this binary all in the
[15:06] same file I don't want any dependencies
[15:08] on shared objects or that kind of thing
[15:12] so we can reconfigure the build
[15:17] run make
[15:23] and now we see that we're statically
[15:24] linked so
[15:26] in other words this file this executable
[15:29] now stands alone no external
[15:31] dependencies however
[15:37] this file is really big
[15:39] it's
[15:40] what's that three and a half megabytes
[15:42] so I'm sort of worried that if we
[15:45] download this onto the router we might
[15:47] fill up the available space I mean this
[15:49] is a a pretty big file it we may not it
[15:53] may be totally fine but
[15:57] I'm going to save us
[15:59] a potential headache down the road
[16:03] by doing some size optimization to this
[16:06] build so I'll just make clean again
[16:11] and add some additional C Flags so
[16:13] specifically
[16:15] I'm going to say
[16:17] optimize for size with Dash OS and I'm
[16:21] also going to do dash s which means
[16:22] strip so take out all of the symbols
[16:27] anything that is
[16:29] not necessary just to run this file we
[16:32] don't care about reversing it we don't
[16:35] care about symbol names make this file
[16:37] as small as possible
[16:44] and we'll run make again
[16:47] and so now
[16:49] when we look at the size here we see
[16:51] that it is significantly smaller it's
[16:53] 766 kilobytes
[16:55] so that's nice and small I like that
[16:59] so now we can open up
[17:01] another terminal here and actually copy
[17:04] out that file onto our
[17:05] into our Cali Linux file system
[17:10] so I believe the way you do that is just
[17:13] like grabbing the container ID
[17:18] saying Docker CP container
[17:22] and let's see where are we
[17:30] nice and source and the file is called
[17:33] netcat so I'm going to rename that on
[17:35] our local file system to Simply NC
[17:37] that's the that's typically what the
[17:39] what the netcat binary is called
[17:44] now if we run file we see
[17:46] the netcat is successfully
[17:49] cross-compiled for mips it's statically
[17:51] linked and it's nice and small
[17:53] okay great
[17:55] so now we need to download this onto the
[17:58] router so that we can run it and make
[18:00] sure that everything's okay and that
[18:02] means that we need our root shell back
[18:07] so I'm just going to copy over from our
[18:10] Recon folder
[18:14] script that is used to actually get the
[18:18] root shell that we use during the Recon
[18:19] stage
[18:21] just in case we have to make changes to
[18:23] it it can't hurt to make a copy
[18:25] also just for good measures probably
[18:28] make note of this we're cross compiling
[18:31] net cap
[18:33] and doing that with a Docker file
[18:37] nice to have all of our notes
[18:40] in one place
[18:43] okay so now if I want to
[18:48] get that root shell I need to start my
[18:51] python
[18:52] server which has got our our root shell
[18:56] in here
[18:58] so we'll get that spun up
[19:02] on Port 8000.
[19:05] and I also need
[19:07] my reverse shell Handler which is also
[19:09] going to be netcat funnily enough
[19:17] and now I'll connect
[19:19] to the router over here
[19:30] Okay so
[19:33] we have all of our setup encapsulated
[19:36] into this run exploit file
[19:39] so we can just run this as a
[19:42] standalone
[19:47] all right it got the reverse shell
[19:56] yep perfect
[20:00] okay
[20:01] so now I'm going to double you get
[20:04] to The Parent Directory the netcat file
[20:08] oh
[20:09] I forgot to put that in our
[20:15] download folder over there
[20:18] so we'll just copy netcat
[20:24] into my Windows File system
[20:39] oh
[20:42] where'd it go
[20:51] hmm
[20:54] that's strange uh just a second ago oh
[20:57] well I won't spend time looking for it
[20:59] I'll just copy that again
[21:22] that's right we didn't save all of those
[21:26] changes
[21:28] that's so weird where did the that cap
[21:31] file go
[21:36] what's in here
[21:39] nope
[21:44] oh
[21:47] we'll just copy that again so since we
[21:49] have this Docker file
[21:51] all the changes
[21:54] should be made
[22:01] or actually they won't because I didn't
[22:03] copy them out
[22:05] and making mistakes left right and
[22:06] Center here
[22:09] at least I remember
[22:12] what the commands were uh oh
[22:19] that's right we actually need internet
[22:21] for this
[22:23] disconnect from
[22:25] the router
[22:27] I'm still weirded out by the fact that
[22:29] we've seen both lost that
[22:32] cat file
[22:39] and move it to the wrong place
[22:47] maybe I don't want to hunt around here
[22:49] too much
[22:55] best to just rebuild the whole thing
[22:56] okay so the command was
[22:59] nipcl we specified which compiler we
[23:03] wanted manually
[23:05] just with nips
[23:07] El
[23:09] IX GCC
[23:12] and our C Flags
[23:16] were
[23:18] optimized for size strip and
[23:22] static
[23:51] okay great
[23:58] so now we'll copy it out into our bones
[24:00] folder make sure it works this time
[24:14] or whoops Docker copy from our container
[24:19] and the path is
[24:25] oh yeah it's just weird another netcat
[24:28] folder
[24:32] source
[24:34] and the file is called
[24:40] okay perfect so now
[24:43] after that little
[24:45] side Journey
[24:47] we'll copy that
[24:51] into our folder that's actually serving
[24:56] the files that we want to download to
[24:59] the router
[25:01] actually I'll just make totally sure
[25:03] before we restart the server that it
[25:06] ends up in the right place now I'm
[25:07] paranoid
[25:15] Grand
[25:17] okay
[25:18] so restarting the python server
[25:22] Now kill off the container
[25:32] and run the exploits to get us a root
[25:36] shell
[25:50] ah I need to log back into the router
[25:54] or connect to it rather
[26:09] all right here we go
[26:32] oh
[26:35] maybe when we exploited it last time it
[26:37] kind of messed something up so this is
[26:39] something that I might not have
[26:40] mentioned during the Recon stage
[26:43] but when you run the exploit that was
[26:46] described in the blog over here
[26:50] it actually kind of messes up the front
[26:52] end it sort of messes up the the
[26:54] configuration of the of the server
[26:56] because
[26:58] the exploit uses a copy command which
[27:02] is meant to handle like all the language
[27:03] stuff so if if we were to look at the at
[27:07] the Management console for the router
[27:09] after exploiting it we would see no text
[27:12] in any language because it's it's
[27:13] failing to load
[27:15] um all of the language stuff
[27:18] so
[27:22] I just restarted the router and now we
[27:25] can reconnect to it and hopefully this
[27:28] will work
[27:49] and there we go okay now we're off and
[27:51] running
[27:58] cool
[28:00] okay so now we can double you get
[28:03] into the temp directory
[28:07] our netcat file
[28:14] which is just called NC
[28:20] so there's that successful get request
[28:27] and now we see that we have netcat down
[28:30] here
[28:32] so I am going to make that runnable
[28:43] and I'm going to run it with this help
[28:45] option just so we can see what the
[28:47] available options are okay so
[28:50] we can connect to somewhere just by
[28:52] specifying the hostname and Port but we
[28:54] don't want to connect to a listener
[28:55] right now we want to listen for an
[28:58] inbound
[28:59] connection so that looks like we need to
[29:03] specify L for listen and then P for port
[29:05] and give it a port number
[29:09] so I'll say listen for an incoming
[29:11] connection
[29:13] on Port excuse 8080. that's not being
[29:17] used anywhere else
[29:19] and I also want to specify that the
[29:22] input
[29:23] to this command is going to be a file so
[29:26] specifically the file is going to be
[29:30] rhttpv binary
[29:32] so just to pick this apart here what
[29:34] we're saying is have netcat listen for a
[29:36] command on port 8080
[29:39] and
[29:41] then
[29:42] send over the contents of httpv to
[29:47] whatever host connects to it
[29:53] so it looks like I'm going to need
[29:54] another
[29:56] terminal over here
[29:59] where I'm going to run my own
[30:01] netcat command
[30:04] and in this case
[30:06] all I want to do is connect to the host
[30:10] and then it'll print to the screen the
[30:12] contents of that binary
[30:21] so there's the router's IP and it's
[30:23] listening on Port 880.
[30:25] but I don't want to just have the
[30:27] contents of the binary flush to the
[30:29] screen that doesn't seem very useful
[30:32] instead I want a direct output to a file
[30:36] called httpv
[30:40] so it looks like it's hanging here but
[30:43] there's no more input
[30:46] being sent
[30:48] by netcat on the router side so I can
[30:51] just control C
[30:55] and then we see that we actually did get
[30:57] a file that has
[31:00] what is the 600 kilobytes worth of
[31:04] information in it okay so now we just
[31:06] want to do a sanity check here and make
[31:09] sure
[31:10] that this is the exact same size of the
[31:13] HTTP binary on the router side so this
[31:15] command should have exited so I say
[31:19] LSL
[31:23] the SR Aspen httpd
[31:28] we see that that's the same size
[31:30] right
[31:32] check that
[31:34] yep okay so now we've successfully
[31:38] gotten the file off of the router
[31:40] perfect
[31:44] all right so now I'll go over here and
[31:45] open that up in binary Ninja
[31:49] which I already set up ahead of time
[31:57] and now we can dive in and start
[31:59] reversing so I'll just disconnect from
[32:01] the router
[32:03] and restart it for later
[32:13] and we can start looking for some
[32:14] low-hanging fruit now when I say low
[32:16] hanging fruit I I mean the sort of thing
[32:18] that we can just look at the
[32:19] decompilation and spot with the naked
[32:21] eye as like oh that's a bug
[32:24] so the first place to look given that we
[32:27] already know that there are or rather
[32:30] that there is at least one command
[32:31] injection present in this router to see
[32:34] if there are any more because if we
[32:36] think back to the blog the blog said
[32:38] specifically that there was only one
[32:40] command injection found in the
[32:43] WRT54G version so maybe in this
[32:46] subsequent version of the router there
[32:49] are additional features that have more
[32:52] command injection bones in it
[32:54] so we can look for that pretty easily by
[32:56] going over here to the strings and just
[32:58] searching for percent s
[33:01] and looking through the results
[33:06] for a string that looks like
[33:08] it could be a Linux command the kind of
[33:11] thing that would be drop straight into
[33:13] system as long as it has that percent s
[33:15] in there there's a chance that we can do
[33:17] another command injection
[33:20] so I'm not really seeing much here
[33:22] there's the
[33:26] string from from the command injection
[33:28] that we use to get the root shell
[33:30] that's good but we want to look for our
[33:33] own bones here
[33:37] a lot of the cedar looks like just
[33:39] logging stuff or
[33:44] HTML that's being constructed
[33:46] programmatically
[33:53] yeah more logging logging
[33:58] this is interesting this is probably
[34:00] logging too but it does say command so
[34:02] that's promising
[34:06] ah okay here so WL is a binary that I
[34:10] remember is present on the latest
[34:11] version of the firmware
[34:13] so it stands to reason that it's
[34:15] probably on this earlier version two and
[34:18] that looks like a command
[34:20] so let's look into this it says that
[34:21] it's present in this check tssi function
[34:27] and there it is it's right here
[34:31] and it's being used in an aspirant F
[34:33] which basically just means
[34:35] replace all of these percent s tokens
[34:37] with
[34:39] these three arguments respectively I'm
[34:42] not sure why there's a fourth it's
[34:43] probably just a an error in the
[34:45] decompilation
[34:48] and then dump the resulting string into
[34:50] this variable here and then that gets
[34:53] passed immediately to this function so
[34:54] what's this function
[34:57] looks like it
[34:59] logs something to the console oh there's
[35:01] that command
[35:04] string that we saw a second ago and then
[35:07] it drops it straight in the system
[35:10] okay great so this is basically just a
[35:12] wrapper for system then so I can say
[35:15] or rename this rather system wrapper
[35:17] until I've done this before
[35:20] and I'll rename this variable which is
[35:24] going to be a string to just CMD or
[35:27] command
[35:29] cool
[35:31] and now we know that that this is going
[35:33] to be WL
[35:36] command
[35:39] and now the question is well where do
[35:42] these
[35:43] values come from
[35:46] are they values that we can control
[35:47] because the whole point is to find a
[35:51] command or a format string that becomes
[35:53] a Linux command and gets past the system
[35:56] where the values that get put in the
[35:58] format string are
[36:00] controllable
[36:02] or at at any rate are the kind of thing
[36:06] that that we can manipulate from the
[36:09] client side let's suppose that kind of
[36:11] means the same thing so
[36:13] the first value that gets put in the
[36:15] format string is the argument to the
[36:17] check tssi function so let's see where
[36:18] that comes from
[36:21] it looks like check tssi is called by
[36:23] the supply CGI function
[36:27] and it gets called
[36:29] right here
[36:33] Okay so
[36:35] this value
[36:37] that gets passed to check tssi
[36:40] comes from a call to get CGI so remember
[36:43] from the Recon step the get CGI is the
[36:47] function that parses the URL parameters
[36:51] that are included in a post request body
[36:54] so
[36:56] in the Recon step we
[36:58] packet captured a post request to the
[37:02] apply.cgimpoint with a a request body
[37:06] that was just a bunch of URL style
[37:09] parameters and corresponding values
[37:13] so
[37:14] we'll just annotate this for
[37:18] this older version of httpd we've
[37:22] remember that the arguments is the key
[37:25] and what gets returned here is the value
[37:28] and these are both strings or at least
[37:30] for all intents and purposes
[37:32] their strings
[37:36] all right
[37:37] great
[37:40] so
[37:43] the argument that is passed to check
[37:46] tssi is the value corresponding to the
[37:50] CGI
[37:51] key WL 10 BB
[37:55] so without knowing or caring what
[37:57] exactly that means I'll just rename the
[37:59] variable
[38:01] so we'll just do a little bit of cleanup
[38:02] here
[38:03] oh this is kind of interesting there's a
[38:05] printf that says Barry I wonder who
[38:07] Barry is
[38:09] WL attend BB with the value yeah okay so
[38:13] that's just general logging you don't
[38:15] have to worry about that
[38:18] great so that means that this value
[38:21] which ends up
[38:23] in our format string down here and then
[38:25] gets passed to system
[38:28] is controllable
[38:29] so the next question is well
[38:32] how does this
[38:34] apply a CGI function actually get
[38:36] invoked
[38:41] well first of all we're going to have to
[38:43] invoke apply.cgi which
[38:46] has one single cross reference
[38:51] gets called by this function that
[38:53] doesn't have a symbol
[39:00] and what calls this guy
[39:03] huh
[39:05] no direct cross references okay so this
[39:07] is probably just
[39:08] some Handler function
[39:12] for post requests
[39:14] now
[39:15] if we recall that the post request that
[39:18] that corresponded to us
[39:21] turning off https in in the Recon stage
[39:25] was made to slash
[39:27] apply.cgi I think it's pretty safe to
[39:31] assume that this apply underscore CGI
[39:34] function is meant to handle all the post
[39:37] requests to the apply.cgi endpoint we
[39:40] don't know that for sure but it seems
[39:42] like a pretty safe bet
[39:46] so
[39:49] now let's just go ahead and make sure
[39:52] that we understand all of the code and
[39:53] apply CGI
[39:55] that
[39:57] leads up to the call to check tssi so
[40:01] that we know what values we need to
[40:03] include or not include
[40:05] in order to actually reach this line of
[40:07] code here
[40:09] so I'll just do some annotation here
[40:13] might be a little bit of Overkill but
[40:14] still worth doing if you ask me
[40:20] just so we understand
[40:24] everything that might be valuable
[40:27] so I'll just rename these variables here
[40:29] it looks like yeah I need need reboot
[40:32] gets turned into an integer
[40:35] cool
[40:42] now you'll notice that
[40:45] this is not a perfect decompilation I
[40:48] mean there's there's really no reason to
[40:49] actually write the code this way but
[40:52] it's close enough the logic is
[40:54] probably all the same or at least close
[40:58] enough for us to
[41:00] work out what's going on here
[41:03] in a reliable fashion
[41:18] all right so it's reading a lot of
[41:20] different
[41:22] CGI parameters
[41:39] again some of the stuff might be totally
[41:41] irrelevant but in my opinion it's worth
[41:44] going through
[41:46] to
[41:47] and annotating all these variables just
[41:50] so that you have them in in case it
[41:51] becomes relevant somewhere down the line
[42:00] I'm not going to look into that function
[42:02] right now
[42:21] ah and we've already
[42:22] annotated this section
[42:25] okay
[42:26] so now we've cleaned that up a little
[42:28] bit let's just Trace through the logic
[42:29] so we know what to include and not
[42:31] include in order to get
[42:35] to this step here
[42:38] oh I should actually update the notes
[42:40] just a little bit
[42:42] which is another important thing to do
[42:43] we don't want to forget
[42:47] how to do any of this in case we have to
[42:49] do it again later
[42:55] there we go and then what was
[42:56] what was the command that we ran
[43:00] to actually exfiltrate the file it was
[43:02] netcat listen
[43:03] port 8080
[43:06] and send over
[43:10] osr S Pen
[43:12] httpd and on the other end on the other
[43:15] end we just did
[43:18] not cat to the router
[43:24] port 8080 and then redirect output
[43:27] to httpd okay
[43:31] so now we're reversing httpd
[43:37] and we found a possible command
[43:40] injection
[43:46] and check
[43:51] what's it called
[43:54] check tssi
[43:57] and that gets called by apply
[44:02] dot CGI
[44:05] and now we're assuming
[44:11] but apply CGI is a Handler for
[44:16] post requests
[44:20] made to
[44:21] the apply
[44:23] .cgim
[44:27] now that is an assumption we're not sure
[44:28] but
[44:30] like I said I think that's a pretty safe
[44:31] bet
[44:37] and so assuming that that's the case
[44:43] we want to make sure that we know what
[44:45] URL parameters we need to include or
[44:48] exclude in order to hit
[44:51] this function call
[44:52] so just starting from the top
[44:55] first
[44:57] CGI parameter that gets
[45:00] red is need reboot
[45:05] and it doesn't look like anything
[45:07] relevance has done with that okay so I
[45:10] don't really care what happens to need
[45:11] reboot
[45:18] what about need restarts
[45:24] nope nothing
[45:27] all right so change action is the next
[45:29] one
[45:32] so change action actually gets used in
[45:34] an if statement that controls whether or
[45:36] not this entire block gets executed so
[45:38] let's dig into this a little bit
[45:40] so in the event the change action is
[45:43] null
[45:45] it looks like it gets the value of some
[45:48] Global variable
[45:50] okay
[45:52] if change actions not null
[45:55] then its value is compared to Gozilla
[45:58] CGI which is
[46:01] 11 bytes long
[46:05] and
[46:07] if it is in fact Gozilla CGI then it
[46:10] gets passed to this Handler function
[46:13] and this if statement
[46:16] does not get executed okay
[46:20] well we're not going to dig into that
[46:22] because we only care about what happens
[46:23] if this condition is not true
[46:26] so if change action is equal to no
[46:31] or it's not null and is not
[46:35] Gozilla CGI
[46:38] then we execute this block so I think
[46:41] that this the easiest way to get this
[46:43] block to execute is is just to have
[46:45] change action be equal to null
[46:49] or just not included I'm assuming that
[46:52] if we make a call to get CGI and that
[46:56] key is not present in the underlying
[46:59] hash table it's just going to return
[47:00] null I believe I read that somewhere in
[47:02] the documentation for each search so
[47:05] we'll
[47:06] go with that assumption for now
[47:09] so if we want this block to execute we
[47:11] just have to Omit change action
[47:15] so
[47:16] to trigger
[47:18] call to
[47:20] check
[47:22] tssi
[47:28] we're just going to emit
[47:35] change action
[47:38] parameter
[47:42] Okay cool so now we're here
[47:43] so now we fetch the submit button value
[47:48] and if that's no it gets some default
[47:52] value
[47:54] and it doesn't appear to be used down
[47:55] here so we can disregard that as well
[47:58] now what's arg5 arc5 is one of the
[48:01] arguments that gets passed to apply.cgi
[48:05] and if we look for the only cross
[48:07] reference to apply.cgi we see that the
[48:09] fifth argument is the first argument so
[48:13] string
[48:15] to this function which has no cross
[48:18] references
[48:20] so it's probably just assigned as a
[48:21] function pointer or
[48:23] to a function pointer or something like
[48:25] that to
[48:26] handle these requests
[48:29] but it doesn't look like we're going to
[48:30] be easily able to easily track down the
[48:33] answer to that so for now we'll just not
[48:35] worry about it
[48:38] and continue a course
[48:42] just hoping that we don't screw
[48:44] something up and make that null later on
[48:45] down the line
[48:47] so what about this client HTTP client IP
[48:51] that gets read from non-volatile Ram is
[48:53] that used in any way
[48:56] yes gets passed this legal IP net mask
[49:00] function
[49:04] but it doesn't appear that that's
[49:07] critical to whether or not we reach this
[49:08] line okay so we can move past that
[49:13] so the next thing is that we grab the
[49:15] value for start continue TX probably
[49:19] means transaction
[49:21] and then
[49:24] if that value is not null
[49:28] then
[49:30] we call the start continue transaction
[49:32] function and the rest of this stuff
[49:35] doesn't get executed
[49:37] so that means that we also want to emit
[49:45] this parameter start continue
[49:47] transaction so we make sure that we
[49:49] don't Branch this way but instead
[49:51] execute whatever is in this else block
[49:53] and it looks like this pattern kind of
[49:55] continues so
[49:57] if the stop continue transaction
[50:01] key is in the hash table if that has a
[50:04] value associated with it then we execute
[50:07] the
[50:08] the stop continue transaction function
[50:10] and this else stuff which includes our
[50:13] check tssi gets skipped entirely
[50:16] okay so we also need to to admit that
[50:24] great
[50:25] so here we are at
[50:28] our call to check tssi so if WL attend
[50:34] BB
[50:36] gets or is included in in our in our CGI
[50:40] parameters
[50:42] and is not null
[50:45] then we execute the the check tssi
[50:47] function
[50:50] so we certainly need to include
[50:53] WL attend
[50:56] BB if we want to
[50:58] trigger the call to check tssi
[51:03] so now we've got to look through this
[51:04] function
[51:06] and kind of go through the exact same
[51:08] steps up until
[51:10] the point where this Linux command gets
[51:14] past the system and makes sure that we
[51:16] understand what's going on here
[51:18] so we'll just clean up all these strings
[51:23] even the ones that are
[51:25] not totally related to what we're doing
[51:27] just for good measure
[51:31] and we should also
[51:34] make note of the fact that ARG one
[51:36] before it gets
[51:38] used in our in our format string here to
[51:40] construct the the WL command it also
[51:43] gets stored in nvram set so let's just
[51:46] annotate this to while we're at it
[51:49] is going to be a string
[51:51] called WL attend BB
[51:55] and what about the rest of this stuff so
[51:57] we we see that we're fetching from
[52:00] the CGI hash table a little bit more
[52:02] whoops
[52:05] and it looks like
[52:10] this
[52:11] value that gets fetched from get CGI is
[52:15] WL at 10.
[52:19] control okay
[52:22] so I can rename that
[52:25] somehow I skipped over this guy okay so
[52:27] this is WL at 10 radio
[52:34] and this last one here is WL
[52:37] delay
[52:39] which we also get from get CGI
[52:49] all right
[52:52] we could also annotate from here but I
[52:55] don't really think that there's enough
[52:56] quite enough going on to really make
[52:58] that necessary so
[53:00] so now we know this that actually we
[53:02] control at least two of the values that
[53:05] are going to get dumped into that format
[53:07] string we control obviously WL attend
[53:09] baby that gets read from get CGI and in
[53:13] the in the calling function
[53:15] we also control WL attend radio
[53:19] as that's also getting
[53:22] extracted from
[53:25] the CGI parameter hash table here
[53:28] now what's this guy
[53:31] this looks like it's just a renamed
[53:33] version of WL 10 control so I can make
[53:35] note of that
[53:41] great so
[53:43] it appears
[53:45] unless we've made a faulty assumption
[53:46] that we control every single value that
[53:49] gets put into this Linux command
[53:52] any number of these
[53:55] so if we were to go about constructing
[54:01] a payload to kind of prove these
[54:04] assumptions
[54:06] it would look something like a post to
[54:09] apply.cgi
[54:13] there's an HTTP request I think version
[54:17] 1.1 should be supported the host is just
[54:20] going to be
[54:22] the router
[54:24] and I don't need to specify a port in
[54:26] this case because it's HTTP and so it's
[54:29] just going to assume 480.
[54:31] oh but we also need
[54:34] an authorization
[54:37] header so this is sort of the element
[54:39] the elephant sitting on on the corner of
[54:41] my desk here this attack is a
[54:45] authenticated attack in other words it's
[54:47] not going to work unless you already
[54:49] know the router password but we won't
[54:52] bother ourselves with that too much for
[54:54] now so I seem to recall that from our
[54:57] initial packet capture that this is just
[55:00] using basic authentication which means
[55:03] that the credentials are in plain text
[55:05] but they're based but they're base64
[55:07] encoded
[55:11] so I'll just Echo
[55:14] admin admin which are our credentials
[55:20] into this base64 command
[55:26] and that gives us
[55:28] that string so I'll put that in there
[55:32] and at this point just as a sanity check
[55:35] we should probably make sure that all of
[55:36] this is correct so
[55:40] I'm going to make another file that's
[55:41] just an HTTP file a little let us use
[55:45] the the rest clients this kind of built
[55:47] into Visual Studio here and I'll instead
[55:50] just make this a get request to the the
[55:53] root of the www folder just to make sure
[55:56] that we've done everything correct
[55:59] correctly
[56:00] and I'll connect to the router
[56:13] Suite
[56:22] oh okay so I sent the request we got a
[56:26] response but it's a 401 which means
[56:28] something about these credentials
[56:31] are messed up now I know that that's the
[56:35] the correct username and password to
[56:38] access the console
[56:41] but something went wrong
[56:43] so
[56:44] maybe it's because Echo by default
[56:48] includes a new line at the end of
[56:50] whatever you're echoing so I if I
[56:52] specify this
[56:54] and
[56:55] flag that'll say don't give me a new one
[56:58] I'll say
[57:00] well I guess the the new line is
[57:03] included here but
[57:06] we just pipe this to something like xxd
[57:09] we see that there's there's no new line
[57:12] at the end here there's just this 6E
[57:15] which of course is the hex code for
[57:18] little n
[57:20] okay cool
[57:24] so it looks like this is the format or
[57:27] sorry the base64 string that we want so
[57:31] we'll just replace that
[57:34] and we can try this again
[57:41] and now we see that we actually do get a
[57:44] 200 response and it looks like that's a
[57:47] bunch of JavaScript
[57:49] and then some HTML
[57:52] at the bottom okay great
[57:55] so let's just update in our notes the
[57:59] the authorization header
[58:03] and now we have to construct our request
[58:05] body so we know that we need to emit
[58:07] these three parameters that's easy
[58:09] enough and we need to include for sure
[58:13] WL a 10 BB
[58:16] and that's going to get a value
[58:20] but we also
[58:22] control
[58:25] these other values
[58:27] namely WL attend radio which has the CGI
[58:32] key
[58:34] big WL the 10 radio
[58:38] so we can include that as well and keep
[58:40] in mind these are URL parameters so so
[58:42] all the key value pairs are separated by
[58:44] ampersands
[58:47] and there's one more there's WL a 10
[58:51] which probably stands for attenuate
[58:53] control
[58:57] and that is big WL
[59:00] 10 CTL
[59:06] okay
[59:07] it's great
[59:11] so since we control all of these then
[59:12] the only thing we have to decide is well
[59:15] which one do we want to use for our
[59:17] payload which one do we want to include
[59:19] our Command
[59:20] and so
[59:24] I'm going to use this WL attend BB
[59:30] argument because
[59:32] if we look up and apply CGI that's the
[59:35] only one that has any kind of
[59:37] checking associated with it we check to
[59:39] make sure that it's not null
[59:41] these other ones
[59:43] these two
[59:44] nowhere is there any checking to make
[59:47] sure that they're not known
[59:48] or at least not the
[59:51] I can see let's just simply check that
[59:53] yeah this doesn't get checked at all
[59:56] this just gets dropped straight in there
[59:59] and same
[60:02] with this guy so the only one that that
[60:04] might have a hang up is WL attend BB so
[60:06] we will use that one
[60:09] now since this is a this is a command
[60:11] injection we want to use
[60:14] a semicolon to end the WL command
[60:18] and we'll just for good measure put
[60:21] another one on the end just to wrap
[60:22] around the command that we want to
[60:25] inject
[60:26] and I'm going to choose a choose wget as
[60:31] my
[60:32] command here
[60:34] so we want to double you get to the temp
[60:36] directory
[60:39] some file from our running server
[60:45] and it's kind of arbitrary what
[60:47] that file is so
[60:50] I'll just do netcat again
[60:53] why not
[60:55] just to use a file that we know is
[60:57] already there
[60:58] so at this point we should have
[61:01] a working
[61:03] command injection here
[61:08] move that over to our rest client
[61:14] and we'll give it a shot
[61:17] so if this works
[61:19] we should have
[61:21] a another get request with 200 status
[61:26] that will appear here in the logs for
[61:28] our python server
[61:37] so we got a response that means that at
[61:39] least the format of our Command was
[61:41] correct
[61:42] but we didn't get
[61:45] a get request to our python server
[61:49] so that means that we did something
[61:51] wrong here
[61:54] now keep in mind
[61:56] that these are URL parameters and there
[61:59] are certain reserved characters in url
[62:02] parameters
[62:03] and specifically if you want to include
[62:06] one of those reserved characters in a
[62:10] URL parameter you have to use something
[62:13] called percent encoding
[62:18] ah
[62:20] let me disconnect from the router here
[62:23] so you can actually access the internet
[62:27] that will render soon enough there we go
[62:31] so this is a a list of all of the
[62:34] characters that are reserved so to speak
[62:37] um when you're using
[62:40] percent encoding or sorry in in a in a
[62:44] URL parameter context and so we could go
[62:47] through and and just look to see if any
[62:50] of these characters like the like the
[62:51] semicolon occur in our string and just
[62:53] do the manual substitution it looks like
[62:55] it's just
[62:56] percent and then whatever their hex
[62:59] value is and ASCII
[63:01] but I want a more General way to do this
[63:05] in case we have to do it again
[63:07] so I'm going to create a quick python
[63:10] script here that will just do URL
[63:12] encoding
[63:16] make that a verb
[63:20] and to do that I'm going to
[63:23] include this function in url lab
[63:29] the performance percent encoding
[63:32] on whatever string you give it it's
[63:34] called quote
[63:36] so I want to print
[63:39] the results of quotes on whatever string
[63:42] we give it by a standard input
[63:45] so super short script here it's just
[63:47] gonna
[63:48] read a line from standard input pass it
[63:51] to this quote function which will do
[63:53] which which will substitute any reserved
[63:55] character with the appropriate percent
[63:58] encoded value
[64:01] and then print it to the screen
[64:04] cool
[64:08] so we'll just copy my command here
[64:10] whoops
[64:12] I didn't finish that one off that needs
[64:13] to be at
[64:14] my host and at 48
[64:17] 000.
[64:20] so now I'll just copy this whole thing
[64:24] including
[64:26] the semicolons
[64:30] and then Echo it to not base64 to that
[64:34] script
[64:35] that I just made
[64:37] and so what we get is a fully present
[64:39] encoded
[64:41] version of our Command
[64:48] awesome
[64:54] let's delete this
[64:58] and now this should work
[65:04] so we'll go over here and we're
[65:05] expecting a third get request to appear
[65:15] ah
[65:17] gotta connect back to the router
[65:35] all right
[65:39] are we connected yes we are okay
[65:43] Moment of Truth
[65:48] okay so we we got our 200 response and
[65:51] we see that this get request was logged
[65:56] which means that our wget Command must
[65:59] have run
[66:01] so we were able to find a novel command
[66:04] injection in the router that allowed us
[66:06] to achieve arbitrary code execution over
[66:08] the network great a new cve Fantastic
[66:12] the command injections are relatively
[66:13] easy to find and almost trivially easy
[66:16] to defend against
[66:17] so in the next video we're going to be
[66:19] going over a totally different type of
[66:21] exploit that is still widely used today
[66:24] and is essential to any hackers toolkit
[66:27] so I'll see you there

=== Content from youtu.be_1a09904b_20250115_101053.html ===
[00:01] so in the last video we talked about how
[00:04] to identify and exploit a command
[00:06] injection vulnerability but those kinds
[00:09] of attacks are becoming rare and rarer
[00:10] the industry is kind of wised up to how
[00:13] dangerous it is to have user-controlled
[00:15] values in a format string that gets past
[00:18] the system
[00:19] so we have to have other avenues of
[00:21] attack in order to achieve arbitrary
[00:22] code execution so in this video we're
[00:25] going to talk about how to identify and
[00:27] exploit a buffer overflow
[00:30] so there are a number of functions in
[00:32] the C standard Library which if used
[00:34] incorrectly can lead to vulnerabilities
[00:36] things like stir copy or mem copy s
[00:40] printf stuff like that just anytime when
[00:42] you're copying information from a source
[00:45] to a destination and the amount of
[00:47] information in the source exceeds the
[00:50] amount of space that you have in the
[00:52] destination this can lead to something
[00:53] called a buffer overflow
[00:56] so we're going to cut straight to the
[00:58] chase here and home in on this function
[01:01] that gets called by apply CGI just like
[01:04] the the function we found the command
[01:05] injection in
[01:07] previously
[01:09] functions called start epi
[01:11] and as always I'm just going to start
[01:13] off by
[01:14] doing a bit of cleanup here
[01:16] even if it's a little bit Overkill it's
[01:18] nice to annotate a little bit just so we
[01:20] have a firm idea of what's going on I
[01:23] also have to annotate this guy don't I
[01:30] this is all stuff that we've done
[01:33] previously it just helps populate the
[01:35] types and whatnot
[01:37] for
[01:38] when we go back to start epi
[01:41] now
[01:42] I'm going to do some variable renaming
[01:44] here
[01:48] so we know what values end up where
[01:54] I love how easily binary ninja lets you
[01:56] do this
[01:58] pretty easy to infer
[02:01] with these variables mean just
[02:03] semantically in the program
[02:14] so we know this that down here we have
[02:16] four different calls to s printf
[02:19] and we can find buffer overflows and it
[02:22] looks like every one of them
[02:25] just based on just a quick scan of the
[02:27] logic but I'm I'm going to focus in on
[02:29] this first one looking top to bottom
[02:32] so here we have a variable which is a
[02:36] local variable it's on the stack
[02:39] that is going to be the destination for
[02:42] whatever the result of
[02:45] format stringing this value which we get
[02:48] from get CGI as we know we control that
[02:50] value
[02:51] into this string
[02:54] and then the result of course will end
[02:56] up right here
[02:58] so
[03:00] if we go over here and we take a look at
[03:02] the stack View
[03:06] we see here's our var120
[03:09] which just for the time being I'll I'll
[03:11] go ahead and rename
[03:13] destination
[03:17] you know the these two being the source
[03:19] in this case I suppose
[03:21] we can see visually just how much space
[03:24] is given to whatever this guy's pointing
[03:28] to this is actually not a void that's a
[03:29] pointer of some kind might as well
[03:33] oops that's not right might as well just
[03:36] go ahead and
[03:38] update this one back
[03:47] just so that it's kind of clear that
[03:49] it's a pointer here we see how much
[03:51] space is given over to this variable
[03:58] and it looks like it's about okay so
[04:01] that's sitting it offset 120 and hex
[04:04] looks like it ends at 20 in HEX that's
[04:09] what 256 bytes okay so maybe in fact
[04:13] we'll we'll change this further and
[04:15] we'll say that this is a character away
[04:17] array
[04:20] that is 200
[04:23] and 56 bytes long
[04:29] and actually you know what I'll I'll
[04:31] work in decimal just to make it a little
[04:33] bit more interpretable here even though
[04:36] the hex kind of looks cleaner this is
[04:39] not going to let me change that it's not
[04:40] going to let me change it oh well
[04:43] okay
[04:44] so we have a finite amount of space in
[04:47] the destination and we control
[04:50] how much information gets sent in
[04:52] there's
[04:53] at least up to this point there's been
[04:55] no limit on how much information we can
[04:57] pack into a single CGI parameter value
[05:01] so if we want to just do a a quick
[05:05] sanity check on on this and confirm that
[05:07] we actually do have a buffer overflow I
[05:10] can connect to the router
[05:14] and pop open our
[05:17] little HD HTTP file here which is
[05:23] where we're kind of doing all of our
[05:24] quick and dirty send a packet over the
[05:26] network work
[05:28] and
[05:30] we can actually confirm this suspicion
[05:32] so all right so we're connected
[05:35] now if I want to reach this function
[05:40] it looks like I obviously need that WL
[05:42] ant
[05:46] parameter in there somewhere and if I
[05:49] want to be able to access
[05:50] or actually reach this function rather
[05:52] from apply.cgi
[05:55] I need to
[05:58] also include this start epi
[06:02] parameter and it looks as though the
[06:04] only restriction here is that that value
[06:07] not be null in other words that it is
[06:09] present but if we go back into the
[06:11] function we notice that
[06:13] the first thing that's being done is
[06:15] comparing the
[06:17] argument that we pass in
[06:19] the CGI parameter value
[06:22] which is called
[06:25] start API
[06:27] and it's comparing it to make sure it's
[06:28] one and if it's not one then don't
[06:31] bother to do any of this so we also know
[06:33] now that we need
[06:36] start API
[06:37] and that has to have a value of one if
[06:40] we want to reach this code
[06:42] now the rest is kind of going to be plug
[06:45] and chug
[06:46] that'll stay the same
[06:54] and so if we send
[06:56] sufficiently many values or rather
[07:00] a sufficiently long value
[07:03] for WL and it should
[07:06] overflow the buffer that's available in
[07:11] destination here and start
[07:14] trampling all over this saved s0 saved
[07:19] US1
[07:20] Etc
[07:21] all the way down to saved ra now RA in
[07:25] mips is the the register that holds the
[07:29] return address so when
[07:33] apply CGI is running it's making use of
[07:36] all of those registers right but then
[07:38] it's it's going to jump from the apply
[07:40] CGI context into the start Epi context
[07:44] and then eventually start Epi will exit
[07:46] and execution will resume in apply CGI
[07:50] so apply CGI basically just needs to
[07:53] record what the current state of all
[07:55] those registers were so that it can pick
[07:57] up seamlessly
[07:58] so that's what's being done
[08:01] over here it's it's saving all the
[08:04] registers that had meaningful values in
[08:06] it including of course the return
[08:08] address where we need to jump back to
[08:10] and apply CGI once we're done with start
[08:13] epi
[08:15] so that it can it can pick up later
[08:17] that's
[08:19] that's the whole idea of saving the
[08:21] values of those registers to the stack
[08:23] that's what this means
[08:25] so if we trample all over this
[08:28] that's going to cause serious problems
[08:31] in in execution once we return back to
[08:34] apply CGI
[08:36] and that's if we just go through and
[08:40] overwrite all of these if we overwrite
[08:42] the return address
[08:44] then the processor has no idea how to
[08:46] get back to apply CGI we've destroyed
[08:50] the only record of where we're at in
[08:52] apply CGI
[08:54] so what I'm going to do here is
[08:58] just generate using python
[09:01] something like 500 A's that's Overkill
[09:05] we could probably get away with doing
[09:07] less than 300 but let's just make sure
[09:09] that
[09:10] we properly squash the stack here
[09:23] and we'll send this over the network so
[09:25] at the moment our web server is running
[09:28] just fine we can
[09:31] just prove that to ourselves
[09:33] really quick we'll log in
[09:39] yeah there it is
[09:42] now when we send this over
[09:45] we shouldn't get a response if we do
[09:47] we've done something wrong
[09:48] because the server Should Crash it it
[09:51] should crash at the point where it tries
[09:53] to return to apply CGI and it can't
[09:56] because
[09:58] that address is going to be overwritten
[10:02] with a whole bunch of A's so that's like
[10:04] 41 in HEX
[10:07] just four of those
[10:08] so let's give this a shot here
[10:11] and sure enough as we see we got sock
[10:13] and hang up which
[10:14] means that the web server crashed and
[10:18] it's no longer there so we can satisfy
[10:19] ourselves
[10:20] of that fact just by hitting refresh
[10:25] and we get nothing it can try forever
[10:27] but the the web server has in fact
[10:29] crashed
[10:32] which means actually I need to restart
[10:34] the router because that web server is
[10:37] not going to come back up on its own
[10:42] okay so now what can we do with this
[10:45] well
[10:47] I think we've done just about as much as
[10:49] we can in this direction just by the use
[10:51] of static analysis so we're going to
[10:53] have to
[10:54] take the more Dynamic route now
[10:56] fortunately
[10:58] we have a debugger included in the
[11:06] GPL here in the in our tool chain
[11:09] so I just ran a pretty standard search
[11:11] for everything with GDB the gnu debugger
[11:19] inside of the tool chain and there were
[11:23] a ton of results but the ones that we'll
[11:25] focus on here are the fact that we have
[11:27] GDB and GDB server present
[11:32] inside of our of our tool chain and
[11:34] presumably those will work perfectly on
[11:36] the architecture that the router is
[11:39] using because well it's it's included in
[11:41] in the tool chain this is what the
[11:42] developers used
[11:43] now why they would include it in the
[11:45] tool chains kind of Beyond me but I'm
[11:47] not going to look a gift horse in the
[11:49] mouth
[11:50] so
[11:51] gbb is a pretty big program I'm I'm not
[11:55] confident in the same way I wasn't
[11:57] confident that the big bloated build of
[12:00] of netcat
[12:02] wouldn't fill up the amount of available
[12:04] space that we have in our in our temp
[12:06] directory I I have a hunch that GDB
[12:09] might do that too but fortunately we
[12:11] also get GDB server
[12:13] which is a lot more lightweight and can
[12:15] do pretty much the same thing provided
[12:18] that we're able to connect to it from
[12:20] our research machine
[12:23] and we'll see what that looks like in a
[12:24] second so
[12:26] I'm going to copy this guy
[12:29] into
[12:31] the directory that is
[12:35] being served by our python server that
[12:38] we've been using throughout
[12:45] and we'll just check and make sure that
[12:47] it's actually there yep there it is
[12:51] okay and now we're going to
[12:54] copy or rather download actually GDB
[12:57] over to the router now I've written this
[13:01] script here
[13:03] that is going to automate this process
[13:06] so we don't have to go through the
[13:07] laborious motions of using that that
[13:10] Pock that we used to originally get the
[13:12] reverse shell and instead we're actually
[13:14] going to be leveraging the vulnerability
[13:17] found in the previous video which I like
[13:19] more it it doesn't end up messing up the
[13:21] front end it doesn't cause any problems
[13:24] to the execution of the httpd binary
[13:27] it's a much more sneaky command
[13:30] injection than the one that we were able
[13:33] to find during the Recon stage
[13:36] so usage wise we're just going to
[13:38] specify whatever files
[13:40] that exist in this folder as command
[13:43] line arguments
[13:46] so we obviously want our reverse shell
[13:49] meaning that I should probably
[13:51] start up the Handler now while I'm
[13:53] thinking about it
[13:58] I'll start the server too
[14:09] and so what we'll say here is we want to
[14:11] download the reverse shell and
[14:15] of course make it executable
[14:18] and we also want to download
[14:21] GDB and make it executable as well so
[14:24] I'll connect back to the router here
[14:34] all right looks like it's up and now we
[14:37] can get this
[14:56] brilliant
[14:59] okay so now I'll go over here and
[15:06] look at the help for GDB server it looks
[15:10] like we have two options so
[15:12] we can either run GDB server with the
[15:16] whoever that con is Con is either a tcy
[15:20] device or host Port okay so we would
[15:22] want host Port by default it will just
[15:26] um use localhost and we'll specify a
[15:28] port in a second
[15:30] and we can give it which program we want
[15:33] so that would be httpd
[15:35] and then whatever arguments we don't
[15:37] have any arguments to worry about or we
[15:39] can attach to a process that's already
[15:41] running using this attach flag so it
[15:45] looks like the ladder is what we want so
[15:47] I'm going to have GDB server listen on
[15:50] Port 44444
[15:53] which is
[15:54] pretty standard I feel like I see that a
[15:56] lot whenever gbb is used
[16:00] and we're going to attach to oh shoot I
[16:04] don't know
[16:05] what the process ID of httpd is
[16:11] it looks like it's 60 okay
[16:16] cool
[16:19] so now we've attached to httpb and we're
[16:22] listening for connections on Port 44444
[16:25] so I'm going to open up a new terminal
[16:27] over here
[16:29] which is going to be
[16:34] the terminal where we use GDB it's just
[16:36] easy to have a designated terminal for
[16:37] GDB and just and just keep it running
[16:40] now given that we're debugging mips here
[16:44] I can't just use normal GDB I have to
[16:46] use GDB
[16:47] multi-arch
[16:48] which is which you would download in the
[16:51] exact same way you can just download it
[16:52] using apt-get or whatever
[16:55] and we're going to specify that we're
[16:57] debugging httpd so that it knows that it
[17:00] can load up all all of the symbols on
[17:02] our research machine side
[17:06] I also installed jeff which just makes
[17:08] GDB a little bit prettier you can look
[17:11] that up yourself it's super useful if
[17:13] you're if you're using GDB
[17:16] and what we're going to do here is we're
[17:18] going to Target
[17:19] remote
[17:21] and then specify
[17:23] the router's IP
[17:26] and the port number that the GDB server
[17:28] is listening on
[17:33] and when we do that you can see that
[17:35] we're now hooked in we get all of our
[17:36] register values we know what
[17:40] instruction we're on it looks like
[17:42] there's a
[17:43] Sig trap
[17:44] I never really understood what that was
[17:47] but I think it's just something that
[17:48] happens when a remote connection is
[17:51] received
[17:53] and as we can see it now says okay
[17:55] remote debugging from our IP
[17:59] great now I want to place a break point
[18:03] on this start API function and clearly
[18:07] the symbol is still there so I can just
[18:09] say B for break point
[18:12] start
[18:14] epi
[18:18] and then hit continue
[18:22] and I'll run
[18:24] the exact same experiment trying to get
[18:27] this router to crash
[18:29] or the the web server to crash rather
[18:38] and it's waiting
[18:42] why
[18:47] hmm
[18:57] okay well maybe something went wrong
[19:01] when we attached to the running process
[19:04] so
[19:05] what we can do here is we can just kill
[19:08] the the current session startup netcat
[19:10] again
[19:14] and retrace our steps just doing things
[19:16] a little bit differently
[19:24] so this time
[19:26] we're going to I guess we only really
[19:28] need the reverse to all GDB is still on
[19:29] there
[19:38] oh
[19:40] didn't get the green check mark that
[19:41] means something went wrong
[19:43] maybe we have to restart the router
[19:44] again
[19:47] using gvb
[19:49] typically involves a lot of restarting
[19:53] just to get everything reset make sure
[19:54] that we have a router that's used
[19:57] processes or in pristine condition to
[20:00] get started they couldn't check too it
[20:01] shouldn't take too long
[20:04] this router gets up and running pretty
[20:06] quick
[20:12] yep there we go
[20:16] oh but GDB is going to be gone
[20:19] uh download that guy again
[20:28] so there it is
[20:32] and we've got our reverse shell again
[20:35] okay so
[20:37] first thing I'm going to do is I'm going
[20:39] to kill off httpv just stop the process
[20:42] we're going to try to use GDB
[20:47] to in in in the first of the two
[20:51] options
[20:54] that we saw here where you're specifying
[20:56] the program that you want to run and
[20:57] you're going to start running it with
[20:58] GDB as opposed to just attaching to the
[21:00] running process
[21:06] and I believe I need the full path here
[21:08] can't hurt
[21:13] all right there we go
[21:18] so once again I can Target remote
[21:21] and there we go we've got the Sig trap
[21:23] our break point is still there so now we
[21:25] can continue and
[21:28] oh no it says
[21:31] the remote Target exit normally darn
[21:38] yeah so GDB server crashed bummer
[21:45] httpd is still running though so maybe
[21:48] I'll kill that off
[21:56] so the last thing that we can try is
[21:58] just starting it manually
[22:09] and then attaching to it from there
[22:23] and we'll give this a go again
[22:29] there's our break point okay
[22:34] well it didn't crash the thing this time
[22:36] that's good let's see if we can actually
[22:37] interact with it we'll just I'll do
[22:39] something simple I won't even try to
[22:40] crash it at this point I'll just do a
[22:42] simple
[22:43] get request
[22:45] and that worked fantastic okay so it
[22:47] looks like if we want to successfully
[22:49] run GDB on the httpb binary we have to
[22:54] first kill off all running instances
[22:56] start up a new one and then attach to it
[22:59] which is
[23:01] kind of weird but I feel like
[23:04] whenever you're doing this kind of
[23:06] remote debugging thing it never works
[23:07] seamlessly or an obviously sensical way
[23:12] of course there is some some reason for
[23:14] it but I sure don't know what it is I'm
[23:16] just glad that it works
[23:18] okay so now we can
[23:21] actually trigger this breakpoint
[23:28] and as you can see we've we've broken at
[23:30] the very start of start API
[23:34] so
[23:35] we are now right
[23:37] here
[23:39] right at the very start in fact I think
[23:41] it'd probably be easy to also have the
[23:43] disassembly
[23:44] in front of us just so we have the
[23:48] the actual instructions that are being
[23:49] run through the CPU at this stage
[23:54] so if I want to go to the start of this
[23:56] function it's
[23:57] here
[23:59] should line up with what we're looking
[24:01] at yep
[24:04] values everything awesome this is
[24:06] another reason why why it was kind of
[24:08] essential to have the exact version of
[24:11] httpd on our file system for this kind
[24:14] of analysis otherwise
[24:16] these addresses wouldn't line up
[24:21] all right so we've broken at the top but
[24:24] I'm really interested in what happens
[24:26] after s printf has has been run so
[24:30] I'm going to scroll down here to
[24:34] where the first printf gets called I'm
[24:36] just going to break on this no off here
[24:47] and I can hit continue and we should
[24:49] just fall straight through down to this
[24:51] to this no off which
[24:54] if I've done this right is
[24:59] oh that's right before the call to S
[25:00] printf we actually don't want that
[25:03] we want the no up right after me
[25:10] so I can delete that break point
[25:13] instead break at
[25:19] but no up after the Caldwell Sprint Cup
[25:24] last minute he checked to make sure I
[25:25] didn't screw that up again
[25:27] yeah there we go
[25:30] cool so now I'm going to continue and as
[25:32] you can see we've stopped on
[25:39] is that did it actually execute the s
[25:41] printf
[25:45] not sure I'll just go one instruction
[25:47] further
[25:48] make sure I did this right
[25:52] yeah there we go
[25:54] okay
[25:59] so now we're right here we're right in
[26:01] between these two function calls and so
[26:03] destination
[26:06] should contain a whole bunch of A's
[26:13] so now what's the address of
[26:18] destination
[26:21] you're going to get me or rather get to
[26:24] watch me struggle with this in in real
[26:26] time
[26:27] here okay
[26:46] I guess we can just start looking around
[26:47] on the stack
[26:53] uh 50 will do
[26:57] so this is saying
[26:59] give me the
[27:02] current status of the stack using the
[27:04] string rep representation so ideally we
[27:07] would just see a string with a whole
[27:08] bunch of A's in it
[27:13] don't we see other stuff
[27:15] hmm
[27:18] where is it
[27:25] foreign
[27:37] you know what I guess that this step is
[27:39] kind of unnecessary the the
[27:42] moment of truth will come at this
[27:45] instruction here where we try to return
[27:48] to apply CGI
[27:51] because at that point
[27:54] according to Theory
[27:57] the ra register will be full of A's
[28:01] so
[28:02] that'll be an even better Telltale sign
[28:04] since I I can't remember off the top of
[28:07] my head exactly where we would find
[28:10] the A's once they've been put in in
[28:12] destination
[28:14] so shortcutting this a little bit
[28:17] make another break point we can delete
[28:20] breakpoint three wasn't it
[28:35] right okay so now we see that
[28:38] registers s0 S1 S2 S3 S4 and the return
[28:45] address so everything
[28:48] here that was saved
[28:52] from the previous
[28:53] function
[28:54] which is apply CGI has been overwritten
[28:57] with our A's
[29:00] so this is a serious problem now if I if
[29:02] I go one instruction further
[29:04] the whole thing should should crash
[29:07] right because this is not a valid
[29:09] address or at least it's very unlikely
[29:11] to be like it's very unlikely that there
[29:14] is actual valid executable instructions
[29:17] at the address represented here
[29:20] so I'll just go ahead and do that we'll
[29:22] do next die
[29:27] and we get a warning yeah okay cannot
[29:29] access memory address
[29:31] 41s
[29:33] so now if I hit continue
[29:38] we should have seen
[29:40] a crash what's going on
[29:54] hmm
[30:04] well maybe it was somehow able to
[30:06] recover from that it shouldn't have been
[30:11] cannot execute this command while the
[30:13] selected thread is running strange
[30:20] okay
[30:22] well
[30:24] let me just quit out of here when in
[30:25] doubt but
[30:29] this page certainly shouldn't refresh
[30:31] okay there we go
[30:38] so the reason to go through that step is
[30:40] to just verify that our user supplied
[30:42] data actually ends up in those registers
[30:44] meaning that we control them
[30:47] so let's just make note of this
[30:50] where our notes
[30:54] so we'll copy this guy off all of it yep
[31:01] go over to our notes
[31:06] and we can say that when
[31:08] this request is sent
[31:17] we have all of this information
[31:21] printed to the screen
[31:26] from GDB
[31:30] I wonder if there's a GDB markdown it's
[31:33] skin thing
[31:36] I guess not whatever maybe let's call it
[31:38] log just to give us some colors yeah
[31:40] there we go I like that
[31:44] so clearly we can see that we control
[31:46] these registers
[31:49] we also control the return address
[31:54] so this means that we can likely use
[31:57] this I'm gonna have to restart the
[31:58] router again
[32:01] to perform what's called a return to
[32:03] live C attack
[32:05] we can just pull up the Wikipedia page
[32:06] for that just out of intrigue
[32:15] so this means that you've overflowed a
[32:18] buffer you've gained control of the
[32:19] return address whatever that may be it's
[32:22] going to look differently depending on
[32:24] the architecture
[32:26] and if you specify and address
[32:30] that is in the executable part of of lib
[32:33] C you can use that to jump to the to
[32:36] system the system function
[32:39] which we used explicitly in the in the
[32:42] previous video to get a command
[32:44] injection this is just another way of
[32:45] accessing system
[32:49] so if we want to go this route what
[32:52] we're going to have to do is is to
[32:53] somehow inject the command that we want
[32:56] to execute on system
[32:59] we need to jump to system after loading
[33:04] the string representing whatever command
[33:07] we want to run with system and to
[33:09] register a0 which is the
[33:12] uh register that is used to specify the
[33:15] first argument that you want to pass to
[33:18] whatever function that you're calling
[33:20] and if we've done all that correctly we
[33:22] should be able to just execute
[33:25] whatever command we provided with the
[33:27] same privileges that the process that
[33:31] we're exploiting has which in this case
[33:33] is root
[33:36] so that's the theory now there are a
[33:39] couple of things that can get in the way
[33:42] here
[33:43] the first of which is uh this thing
[33:46] called the NX bit
[33:51] actually this isn't directly relevant
[33:53] this would only be relevant if if if we
[33:55] were trying to use Shell Code as opposed
[33:57] to return to live C but it's still an
[33:59] interesting aside another way that we
[34:01] could do it if we didn't want to do a
[34:03] return to libc attack is to actually
[34:06] write the the the op codes corresponding
[34:10] to all the operations needed to load our
[34:13] string into register a0
[34:17] and then jump to system we could do all
[34:22] of that by just writing the assembly
[34:24] turning it into op codes and then
[34:26] encoding it that way there are a couple
[34:29] of problems with that though one of them
[34:31] is is the NX bit so so so basically this
[34:33] means that
[34:36] certain
[34:38] portions of memory
[34:41] are reserved as non-executable
[34:43] so even if there are valid op codes in
[34:46] there
[34:47] they will not be executed just because
[34:49] of where they sit in memory this is
[34:50] designated as something that you write
[34:52] to not something that you execute from
[34:56] so
[34:57] we'll we'll check in a second to see if
[34:59] if this is
[35:01] in place or not
[35:04] but in in any case this is one of the
[35:06] benefits to a return to lib see attack
[35:08] you don't have to worry about that since
[35:11] you aren't actually writing your own
[35:14] instructions into memory you're just
[35:17] using instructions that are already
[35:18] there
[35:20] the other thing that could get in our
[35:21] way is something called aslr or address
[35:24] space layout randomization which
[35:27] basically means that every time a
[35:29] process is spawned and all of its
[35:31] dependent libraries and stuff are are
[35:33] loaded into memory
[35:35] the addresses at which those
[35:37] instructions are loaded differs from how
[35:42] they
[35:43] or rather where they were loaded before
[35:44] and where they'll be loaded the next
[35:46] time that you run it it's it's
[35:49] specifically to throw a wrench in
[35:52] something like a return to live C attack
[35:54] because this attack relies on you
[35:58] knowing where certain instructions are
[36:00] in memory and having those instructions
[36:02] be consistent they're like they're
[36:04] always there
[36:06] aslr makes that assumption completely
[36:09] unreliable
[36:11] it's going to change every time the
[36:12] router boots up let's just say
[36:18] so
[36:20] at this point we should probably back up
[36:22] a little bit and use this tool called
[36:25] check sac
[36:27] to make sure
[36:29] that
[36:31] our httpb binary doesn't have these
[36:34] kinds of restrictions in place it won't
[36:36] tell us anything about aslr that's an
[36:38] operating system thing
[36:40] but it will tell us whether or not NX is
[36:42] in place
[36:45] and if there's something like a stack
[36:47] Canary so let's make this a little bit
[36:49] bigger for now
[36:50] and see the whole thing so we don't have
[36:52] railroad oh geez I I knew at one point
[36:55] when I was in school what railroad was
[36:57] we know we don't have a stack Canary now
[36:59] we already kind of knew this so a stock
[37:01] Canary is just a specific a specific set
[37:05] of bytes they'll be included on on the
[37:08] stack and if it gets overwritten with
[37:12] data that sends the media signal to I
[37:16] guess to be the CPU that um
[37:21] that the stack has been smashed is
[37:23] probably being used in a way that's
[37:25] unintended and we should just crash to
[37:28] avoid something like an rce
[37:31] of the type that we're trying to achieve
[37:33] here
[37:37] we see that NX is disabled so we could
[37:40] try shell code here
[37:43] now Pi I'll know what the rest of the
[37:45] stuff means but that was the big answers
[37:47] that we that we wanted to to get the
[37:49] ones that are most apical we don't have
[37:50] a stacking area we don't have NX
[37:53] but again even if MX was there we could
[37:56] probably get around it because we're
[37:57] doing a return to live C attack
[38:01] okay
[38:08] so
[38:10] continuing a course
[38:13] foreign
[38:16] we know that we controlled these
[38:17] registers
[38:19] we know that we can
[38:22] use control of RA to jump to wherever we
[38:26] want in active memory provided that
[38:29] those are valid instructions that can be
[38:30] executed so we need to know where those
[38:32] instructions are
[38:35] so the next thing that we're going to do
[38:38] is take a peek
[38:42] at the process memory map for httpd
[38:45] which means I now need to connect back
[38:46] to the router
[39:03] are we up
[39:05] we're up
[39:07] Grand
[39:10] okay so we'll go back here and we'll run
[39:12] our
[39:13] command to put our reverse shell and GDB
[39:16] server on there again
[39:32] and we see now we have httpd on with
[39:35] process id60 so now I'm going to cut out
[39:40] the memory map for for this process
[39:46] it's a proc whatever the process ID is
[39:49] and then Maps
[39:53] and this should tell us all of the
[39:55] information
[39:56] that we need
[39:58] so I'll just copy this off into our
[40:00] notes over here
[40:12] so what this is saying is that the
[40:13] following libraries have been have been
[40:16] loaded for use by httpd and they're
[40:19] loaded at
[40:21] in in this address range so this is
[40:24] micro C libc let's just use libc as an
[40:27] example since we're attempting a return
[40:29] to libc attack
[40:31] so there are three different sections
[40:33] here that are all
[40:35] libc
[40:39] and it's this top one that we're
[40:40] interested in so there's this X
[40:43] present here which means that we can
[40:46] read from it we can't write to it we can
[40:48] execute it too so this is the executable
[40:50] section this is where the the
[40:51] instructions are contained so system is
[40:54] going to be somewhere in this range
[41:13] so in order to find out exactly where
[41:15] we're going to have to use our old
[41:17] netcat trick
[41:20] to
[41:21] exfiltrate this file
[41:26] so let's go ahead and put netcat on here
[41:40] oh
[41:42] I don't think we've gotten that cat
[41:45] no
[41:47] why
[41:54] hmm
[42:01] is HTTP video
[42:12] strange
[42:13] looks like HTTP these now
[42:28] I guess when in doubt just restart the
[42:30] whole thing
[42:39] means a lot to kill on map I guess I
[42:40] don't really care
[42:52] come on where is it
[42:54] there it is
[43:11] okay so before anything else
[43:15] I'm going to download everything
[43:17] is our Handler still there it's not
[43:24] all right
[43:28] so now we'll run this we see we just
[43:30] grabbed our reverse shell we grabbed GDB
[43:32] server
[43:34] the grab netcut
[43:40] wonderful
[43:43] so now we have everything
[43:48] and I want to grab
[43:50] this file so once again I will run
[43:55] netcat with
[43:58] the L and P Flags to listen on Port
[44:01] 8080.
[44:04] and we're going to send over
[44:06] Lipsy
[44:11] so now over here I can connect to
[44:14] the router
[44:15] from port 8080
[44:17] and redirect the output to
[44:20] whoopsy
[44:31] all right so looks like that process is
[44:33] done so
[44:38] oh wait I might have messed it up
[44:40] by typing stuff in there
[44:43] rats
[44:47] let's see
[44:55] nope looks good
[45:01] all right so its size ends in 72.
[45:09] probably a little bit too paranoid here
[45:10] but
[45:11] just want to make sure we got the exact
[45:13] file intact
[45:19] we did okay so we got all of it
[45:21] great
[45:26] all right sweet
[45:30] so what I'm looking for
[45:32] is the address
[45:35] of system so I can go
[45:37] through each entry and like the output
[45:40] of redel for something like like that if
[45:42] I wanted to but I just want the symbol
[45:45] so I'm going to use NM with the GD Flags
[45:49] to do this
[45:55] and we've got a bunch of stuff okay
[45:59] where is system
[46:02] screw it
[46:08] there it is okay so it is sitting
[46:11] at offset
[46:14] 25 430 all right so I'll copy that
[46:39] cool oh yeah we grew up for system
[46:42] why not just be thorough here
[46:45] okay
[46:47] so we also know that the executable
[46:51] section here starts at this address so
[46:53] if we want to get the
[46:56] address of system
[47:00] that's going to be at this
[47:02] Plus
[47:05] the offset here and of course these are
[47:07] both hacks right
[47:15] so I'm just going to use the calculator
[47:17] that comes with Windows here to actually
[47:20] perform this calculation
[47:31] and I get this address
[47:34] great
[47:39] so we can be pretty sure
[47:41] at this stage
[47:45] but that's the address of system in case
[47:47] we or unless we've done something wrong
[47:49] here
[47:52] okay right on so now we know where where
[47:54] system is
[47:57] we also of course though need to find
[48:00] some sequence of instructions that's
[48:02] already in memory that'll allow us to to
[48:06] jump to this system because it's it's
[48:09] going to be no good just to write this
[48:11] directly to the return address because
[48:15] whatever value is in a0 whatever the
[48:17] argument to system is going to be it's
[48:19] not what we want it's not a value that
[48:22] we control
[48:25] so in order to do that we're going to
[48:26] have to use something called a ROP
[48:28] Gadget ROP is return oriented
[48:30] programming it's a way to once you've
[48:34] hijacked
[48:35] control of execution however you jump
[48:38] around to different
[48:40] uh sequences of instructions in in
[48:42] memory that they themselves include
[48:44] jumps
[48:46] so as to do various operations and set
[48:48] up whatever you're trying to do as part
[48:50] of your exploit typically it's to invoke
[48:53] a call to system
[48:58] so in order to do that I'm going to use
[49:01] this tool called robber
[49:06] although I do not want the command line
[49:09] interface that comes with it I just want
[49:11] to use the
[49:13] use it as a normal command
[49:16] so there are a ton of options here but
[49:19] what it does is it'll skim through a
[49:21] binary and pick out every chunk of
[49:24] instructions that
[49:26] will do something do something do
[49:28] something jump to somewhere in memory
[49:31] that's a rock Gadget so if I just run
[49:37] dropper
[49:41] on lib C
[49:43] you can tell I get way too many results
[49:48] way too many results to work with
[49:56] so instead what I'm looking for here how
[50:00] we'll pair this down this is just make
[50:01] it really explicit what we're looking
[50:03] for out of our ROP Gadget or gadgets it
[50:06] may take more than one
[50:09] so so the first thing that we need to do
[50:10] is we need to
[50:13] load our Command
[50:17] which is a string
[50:22] into register
[50:27] a0
[50:29] okay that's the first thing that we need
[50:30] to do we need to set up the argument
[50:33] the second thing that we need to do
[50:37] is
[50:39] jump
[50:41] to system
[50:43] and in theory that's it
[50:50] so how we're going to load our Command
[50:53] into a0
[50:56] well
[50:57] we know that we can send a whole bunch
[50:59] of data
[51:01] via our WR and
[51:05] CGI parameter
[51:08] and have it end up on the stack
[51:10] so what if we
[51:13] expanded
[51:17] our payload here to include some command
[51:19] that we want to run I mean we could make
[51:22] that
[51:24] um well we can just reuse
[51:27] the command that we used previously
[51:31] because we know that'll work
[51:34] and if we've done that I mean this won't
[51:37] work as is but
[51:38] we put something else before it
[51:40] something to set up all of this jumping
[51:42] around memory and then what if we just
[51:45] load into a0
[51:48] the address of wherever this ends up on
[51:50] the stack
[51:53] that seems like a good idea
[51:56] okay
[51:59] so now we're going to back up a little
[52:00] bit and we're going to figure out well
[52:05] exactly what
[52:07] data at what offset ends up in s0 S1 S2
[52:11] S3 all these registers that we control
[52:14] so like how much stuff before we get to
[52:18] our important stuff like our Command and
[52:21] our hard-coded addresses do we need to
[52:24] provide in in order that our payload
[52:27] lines up with that space on the stack
[52:29] that we control or I guess we control
[52:32] all of it but
[52:34] how how do we make sure that our
[52:37] intended values end up in the registers
[52:39] that we want to control
[52:43] so in order to do that I'm going to
[52:45] write a little script here that's going
[52:47] to generate a pattern that's not just
[52:49] all A's because all A's in this case are
[52:51] created equal like I can't distinguish
[52:53] that a from that a it'll be hard to work
[52:56] out where our relevant offsets are
[53:00] so I'm just going to write this quick
[53:02] script so I'll just call generate
[53:04] pattern
[53:05] he's gonna use Python file
[53:10] and I'm going to generate a long string
[53:14] of characters that are they come in sets
[53:17] of four
[53:18] you know four bytes 32 bits per address
[53:22] that will let us figure out what the
[53:24] offset
[53:26] of our various hard-coded
[53:28] addresses are going to have to be to
[53:31] make sure that they end up in those
[53:32] registers
[53:34] so I can just say uh for
[53:37] I don't know
[53:39] character
[53:41] probably gonna want to use more than
[53:42] just letters here
[53:45] in
[53:47] range hmm
[53:49] let's just use ASCII why not so the the
[53:52] the first ASCII character
[53:55] that's not like
[53:56] you know some control sequence thing or
[53:59] in principles the space
[54:02] I believe
[54:07] all the way up to the last one which is
[54:09] the squiggle
[54:12] or tilde
[54:14] I want to
[54:18] print out all of those in bunches of
[54:19] four
[54:28] oh of course those are just numbers
[54:30] whoops we want the character
[54:31] representation
[54:36] we also want it to be all on one line
[54:46] okay there we go
[54:49] actually I really don't like the space
[54:51] in there I want them all to be printable
[54:52] so the first one after the space is the
[54:54] exclamation point so we'll start there
[54:56] that pattern's still going to be long
[54:58] enough right
[55:02] okay cool
[55:03] so we'll just save that off to a to a
[55:06] file
[55:08] so we have it
[55:14] and so now
[55:20] we can figure out what the relevant
[55:22] offsets are
[55:25] for the values that end up in each of
[55:27] those registers
[55:43] oh wait I just remembered
[55:50] these are URL parameters so a lot of
[55:52] these characters are going to have to be
[55:53] URL encoded otherwise they're just going
[55:55] to get rejected
[55:57] so
[55:59] in fact we actually have to reuse that
[56:02] URL encode
[56:05] like mini script that we use to encode
[56:08] the command
[56:10] I guess the best way to do this is just
[56:12] going to be the
[56:14] pipe the output of generate pattern
[56:16] straight into
[56:18] URL encode there we go
[56:22] that'll work
[56:29] all right so we're still running here
[56:38] doesn't look like it
[56:52] waiting waiting
[57:02] there it is
[57:13] all right bro
[57:17] sweet
[57:18] okay
[57:21] so let's get GDB started again
[57:39] there it is
[57:40] and while we include netcat 2 can't hurt
[58:02] all right so now temp GDP server
[58:07] oh wait before we do that we need to
[58:15] kill httpd
[58:20] get it started again
[58:27] and then grab his process ID Okay so
[58:34] let's hope that this works again
[58:58] all right so we want to set a break
[59:00] point
[59:01] on
[59:03] the return instruction
[59:09] s this guy
[59:24] now I can continue
[59:31] yep server still works okay
[59:36] and there we go
[59:38] all right so now we can start figuring
[59:41] out what the relevant offsets are
[59:44] for s0 S1 S2 S3 S4
[60:11] using injected they're in a very loose
[60:14] sense
[60:15] okay
[60:18] so now I'm just going to search for
[60:23] carrot
[60:27] and three underscores
[60:34] so that at this point
[60:36] and is that going to tell me
[60:38] yeah there we go okay so that is a
[60:41] column
[60:43] two five two that doesn't look right
[60:45] because it's halfway through like a
[60:47] multiple of four
[60:49] it's weird maybe this is indexed to zero
[60:52] or at one rather
[60:56] it is okay so we just need to subtract
[60:58] one for for from whatever the in the
[61:01] index is
[61:06] okay
[61:10] so it's going to be 247.
[61:21] yeah
[61:22] that
[61:24] 247.
[61:28] which means
[61:32] given the order
[61:35] in which these are saved
[61:37] to the stack
[61:38] and then thus read back into the
[61:42] registers it looks like we can just add
[61:44] four
[61:45] to each one for these s's so that's
[61:47] going to be
[61:48] 51 that's this one
[61:54] 55
[61:56] press two
[62:04] 59 for S3
[62:08] and the last one is
[62:12] 263.
[62:16] press 4.
[62:19] and we'll just sanity check that because
[62:21] you can
[62:37] yep 264 minus 1 is 263.
[62:43] okay now what about the attorney the
[62:45] return address
[62:46] that's going to be d-e-e
[62:57] so that's going to be 271.
[63:11] right on
[63:14] okay so now that we know once we figure
[63:16] out all the memory addresses that we
[63:18] want to actually place
[63:21] into these registers
[63:23] we now know exactly where we need to put
[63:24] them in our payload
[63:26] okay
[63:28] phenomenal
[63:32] now
[63:34] let's see what's next
[63:37] so
[63:38] we know where system is
[63:40] we know that we need to
[63:45] find
[63:46] a rock Gadget
[63:48] that is going to load
[63:51] whatever value is in one of these
[63:54] registers that we control into register
[63:58] with its T9
[64:00] it's what you use to execute
[64:03] the jump to a function yeah so so this
[64:05] is just a mips thing T9 is always where
[64:07] the address of of a function
[64:10] gets moved to and then you just jump to
[64:13] the address in in register T9 that's how
[64:17] a function gets gets actually called
[64:19] that's how the jump gets performed so
[64:21] we're looking for some Gadget
[64:25] that includes
[64:28] the the instruction or an instruction
[64:30] similar to
[64:32] move into
[64:36] register T9
[64:40] the value
[64:43] in register
[64:45] S one through a router zero
[64:49] through four just a reg exit there a
[64:52] little bit that's what we're looking for
[65:01] we also know
[65:04] that the gadget must include
[65:09] a move instruction or something similar
[65:12] there are a couple ways to load values
[65:14] and do
[65:16] a register
[65:18] that will move something from
[65:21] one of the S registers that we control
[65:24] into a0
[65:28] all right so let's get about that let's
[65:32] try to find ourselves
[65:34] a rock Gadget using robber
[65:43] so I can use this search flag to
[65:46] specify a pattern kind of like this
[65:52] to kind of narrow down that massive list
[65:54] of gadgets that we have that we're
[65:56] looking for in the in the lib C library
[66:00] so
[66:04] I'll just start with um
[66:06] a0 we needed to satisfy both of this
[66:09] criteria but I Believe I Can Only search
[66:11] for one
[66:15] now if I do that you can see we have
[66:17] significantly less results but this but
[66:19] this first instruction in each Gadget
[66:22] is a move from register s x
[66:28] to register a0 so all of these satisfy
[66:31] the second criteria
[66:35] now let's see if any of them also
[66:36] satisfy the second one
[66:38] you can see that all the jumps are
[66:40] register T9 but a lot of them are being
[66:43] loaded directly from either an offset
[66:45] from the what is that the global pointer
[66:48] or maybe a few from the stack perhaps
[66:53] doesn't look like it so
[66:56] what we're going to do here is we're
[66:58] just going to grab
[67:01] for
[67:06] a move instruction involving T9
[67:12] I saw a few
[67:14] oh you know what
[67:16] they're using ANSI codes to give us a
[67:20] nice colorized output so maybe I I
[67:22] believe that for Robert if you just say
[67:24] no color it'll just give it to you
[67:27] without the ANSI codes
[67:29] yeah there we go
[67:32] okay
[67:33] so here we have
[67:36] the move from S7 to T9
[67:39] there's v0 v0
[67:42] V 0 V 0 V 0. okay darn
[67:45] so even though this is an S register
[67:47] it's not one of the ones that we control
[67:50] wheel control S7
[67:52] so if we're going to find a gadget that
[67:55] that fits this criteria
[67:57] we're going to have to look elsewhere
[67:59] now fortunately there are a whole bunch
[68:01] of libraries
[68:03] that are loaded up
[68:05] for use in
[68:10] in the in in the running of httpv and so
[68:14] all of these are going to be available
[68:15] in the in the process memory space so
[68:19] I guess we just have to pick another one
[68:21] and hope for the best I I happen to know
[68:23] that expat is pretty big so that would
[68:25] be a good one
[68:27] to look at next
[68:32] whoops I needed that
[68:37] it's our netcat listener
[68:40] I mean we're gonna have to restart
[68:42] everything anyway
[68:45] since that web service crashed and we've
[68:47] probably lost our shell
[68:50] okay
[68:53] so I want the Rev shell I want GDB
[68:58] and I definitely want that cat
[69:00] oh but that's not gonna work of course
[69:02] because we have to
[69:04] connect back to the router
[69:18] and we're back up all right
[69:22] service running listener in place let's
[69:25] go
[69:44] sweet so
[69:47] once again netcat
[69:49] listen on Port 8080.
[69:56] and we want expat
[70:04] so over here we'll do the same thing
[70:06] that we've done before
[70:10] my Expo trading files
[70:23] so the size of Xpat ends with 320.
[70:31] 320.
[70:34] sweets all right so
[70:40] same thing again except we're not
[70:42] looking in lib C we're looking in
[70:49] so now we see we've got a ton this is
[70:51] great
[70:52] um I don't really want to look through
[70:53] that manually so I'll just say
[70:57] pass something
[71:02] I believe this is a regular expression
[71:04] so we can just output only that
[71:08] oh maybe it's not
[71:17] What's Happening Here
[71:21] oh well maybe we won't get clever with
[71:24] it we'll just look at this by eye so
[71:25] that's b0 V 0 V 0 V 0 V 1
[71:29] zero be zero
[71:32] t0
[71:34] not sure if we control that one
[71:39] doesn't look like it
[71:44] b0 b0 b0 B zero V1 there's another t
[71:48] zero B zero B zero B zero
[71:52] all of these look like V zeros
[71:58] yeah okay
[72:00] well no luck so
[72:03] on to the next one
[72:09] lib crypto is pretty big so it's lib SSL
[72:12] let's do lib SSL next
[72:45] all right
[72:46] so that one exited cleanly now we have
[72:51] live SSL I'll just verify it for size
[72:53] although it's probably becoming
[72:57] unnecessary at this point
[73:02] that's the right size
[73:06] all right wonderful
[73:09] so robber once again except this time we
[73:12] are
[73:14] digging through with SSL
[73:20] and so here we see pretty close to the
[73:22] top we actually do have an instance
[73:24] where we're moving a value that's in
[73:27] register s0 which we do control
[73:30] into T9 and then jump into it
[73:34] but that one's not going to work because
[73:35] it's only using s0 so those values are
[73:38] going to get messed up
[73:41] what about this one so this one is
[73:44] move the contents of register s0 into
[73:47] register a0 okay that's an automatic
[73:51] and this one
[73:53] is move the contents of register S1 into
[73:56] register T9 and jump to it
[73:58] so that's exactly what we want
[74:01] so it looks like this
[74:06] actually there are a couple of options
[74:07] here might as well just grab all of them
[74:13] so this is going to give us exactly what
[74:15] we want
[74:18] let me separate this out a little bit
[74:20] here just for good measure
[74:33] ground all right so we'll start out with
[74:36] this guy now we need to know exactly the
[74:39] address
[74:41] of our Gadget in
[74:44] memory
[74:53] so that's going to be the offset from
[74:55] zero when we look at the library in
[74:57] isolation
[74:58] plus rather
[75:01] wherever it gets loaded into into memory
[75:04] when being used by
[75:09] httpv which is
[75:15] this value
[75:17] yep that's the executable section it is
[75:23] okay good oh I should check and make
[75:24] sure that when we were doing this
[75:26] calculation for system I actually did
[75:27] use the start of the executable chunk
[75:39] I did wonderful okay
[75:43] so far so good
[75:52] let's get out my calculator again
[75:53] because
[75:55] to do that in my head
[76:01] cool
[76:07] I don't know about you but I always
[76:08] prefer with my hex is lowercase
[76:14] that's the same value right
[76:19] yep
[76:22] cool
[76:26] so now we know
[76:28] that we want
[76:34] s0
[76:40] to equal
[76:43] this guy
[76:52] which is the address of
[76:56] our Gadget
[76:59] or excuse me I this is not the address
[77:02] of the gadget this is the
[77:05] oh no it is
[77:07] it is so this is not going to be as zero
[77:11] this is going to be the return address
[77:12] because we want to jump to the gadget
[77:14] that's right
[77:20] this is why taking notes is so essential
[77:22] because it's so easy to get mixed up
[77:24] with all these different registers and
[77:26] addresses that you're working with
[77:28] I mean this is literally what my
[77:31] scratch paper my you know little Notepad
[77:34] text file looks like
[77:37] and then the address of system
[77:40] that's going to have to be
[77:42] in S1
[77:45] Okay so
[77:49] that's one
[77:54] is going to be the address of system
[78:12] and then the last one
[78:16] it's gonna be s0 so
[78:20] this one's kind of tricky
[78:23] because since we are
[78:25] ultimately going to have to I mean the
[78:28] only way that we can inject our our
[78:30] Command at least without you know
[78:32] finding a totally different way of doing
[78:33] it is to be the Reddit to the stack we
[78:37] have to figure out where the stack is so
[78:40] stack address of command
[78:44] let's see where's the stack
[78:51] It's gotta be nice right
[78:58] this is reserved for stack I'm sure
[79:05] and because it's
[79:07] writable and executable that'd be
[79:09] another tip off that NX is not enabled
[79:20] okay so it's going to be impossible just
[79:23] to figure out without using GDB to look
[79:26] at and where exactly our Command is
[79:28] going to end up but let's start getting
[79:30] just a little bit more deliberate
[79:33] about how we craft our payload here I
[79:35] think we've probably used our little
[79:38] rest clients that's built into vs code
[79:41] to the extent that we can
[79:43] so let's start thinking about it so our
[79:45] our payload
[79:49] is going to have to be
[79:55] a bunch of just padding I guess up until
[79:58] the point that that
[80:00] we started getting bytes that are going
[80:02] to be loaded into registers so
[80:06] we can say here that uh well you know
[80:09] what I'll just I'll just do this in
[80:10] Python
[80:13] it seems smart
[80:18] uh let's call that pock
[80:22] y
[80:26] you probably use reuse some of the
[80:30] functionality here can't we
[80:33] just copy all of this
[80:36] I'm going to delete all of it to for a
[80:38] lot of it
[80:40] we don't need command line arguments
[80:45] don't need handlers we don't need my IP
[80:49] we do need the target URL and the
[80:50] timeout can't hurt either
[80:59] so
[81:01] the payload is going to be different
[81:03] that's for sure
[81:05] in fact this doesn't even need to be a
[81:06] function does it
[81:25] and it's not a command so we'll remove
[81:27] that print
[81:33] and we're expecting this knot to return
[81:35] a response at all
[81:41] trim that down
[81:45] okay
[81:46] so the payload is going to be you know
[81:49] some bite that we don't care about let's
[81:51] make it something
[81:54] really easy to see
[81:57] as being meaningless what about
[82:01] see my instinct is to use null but of
[82:03] course we can't use null because that
[82:05] was terminate it as soon as we
[82:07] as soon as as it gets transferred into a
[82:09] string I don't think you can send he
[82:10] said no bytes over http
[82:15] not sure I don't think so
[82:17] let's just use two two that's a
[82:21] single quote or a double quote I believe
[82:24] could be wrong
[82:26] don't have the whole ASCII table
[82:27] memorized but we know that that's going
[82:29] to have to be uh
[82:33] uh 104 or 247
[82:39] bytes of just padding
[82:50] and then what do we want then we want to
[82:53] include our value for s0 s0 is
[82:59] well no that's unknown we're trying to
[83:01] figure that out so
[83:04] for right now I'm just going to put
[83:07] four question marks
[83:10] just to
[83:11] I guess paylip service to the fact that
[83:13] we don't know what that is going to be
[83:21] and then we're also using S1
[83:26] and S1 is the address of system that's
[83:30] this guy
[83:45] and I believe we have to reverse the
[83:47] order of the bytes here
[83:48] yeah yeah we do okay so the first bite
[83:51] is going to be
[83:52] 30
[83:56] F4
[83:59] and d e and then
[84:02] 2A
[84:04] it'll be really embarrassing if this is
[84:06] one of the cases where you don't but
[84:08] pretty darn sure you do
[84:11] an Envy in this thing
[84:34] and then what's the offset for ra so
[84:38] this has already been accounted for
[84:47] so we're going to need to put ra
[84:48] whatever
[84:50] 271 minus 255 is which would be
[84:54] 16.
[85:04] you know I wouldn't just make this a
[85:05] constant
[85:20] or like a good self-documenting exploit
[85:38] and now we can put in the address of our
[85:41] Gadget
[85:43] would be
[85:44] maybe zero
[85:47] six d
[85:51] c f
[85:57] 2 okay
[86:07] you know I'm actually going to
[86:08] self-document this a little bit further
[86:16] because it'd be good to have some
[86:19] knowledge in our code here of of what
[86:21] the registers are
[86:24] so this is going to be S1
[86:31] so here I'll just say
[86:33] that's one is equal to
[86:36] this guy
[86:39] and then this will be ra
[86:52] and then whatever comes after in
[86:54] principle doesn't matter
[86:56] because we're already stomping all over
[86:58] the stacks we might as well just include
[86:59] whatever we want
[87:05] so we can make this whatever command we
[87:07] want
[87:10] so let's put up here we got
[87:12] we'll make the command a constant
[87:16] and what command did we decide that we
[87:17] wanted to run we decided we wanted to do
[87:21] double you get
[87:24] right
[87:27] so
[87:30] I'll just write this out here
[87:34] until we get to the temp directory
[87:41] sum file
[87:46] doesn't really matter which file this is
[87:55] but it would be nice if it was a file
[87:57] that actually existed
[88:02] so maybe I'll just create like a tiny
[88:05] file called X and we'll just use that
[88:13] single byte file nice and Tiny
[88:30] or and yeah there it is okay
[88:34] let's start this server
[88:44] oh
[88:45] that'd be bad
[88:47] I get it from my host
[88:51] and we're going to have to quote this
[88:55] in fact we should probably quote the
[88:57] entire thing
[88:58] I realize now so
[89:01] the payload itself
[89:06] line up as equal signs
[89:12] is going to be just what it was before
[89:15] but
[89:17] URL encoded
[89:29] okay
[89:31] I like that
[89:39] so now we get to restart httpv
[89:49] and then restart it
[89:57] hopefully we can just make this all one
[89:59] line
[90:03] yep there we go
[90:04] does that work
[90:06] it did okay
[90:15] attached to it with GDB
[90:26] and we'll connect
[90:34] uh-oh does that mess it up nope okay
[90:36] good
[90:40] uh oh what happened
[90:49] you crashed like totally crashed
[90:55] but if we started on this end okay so it
[90:57] looks like we'll still be okay
[91:03] yep
[91:04] right on
[91:11] uh rats I shouldn't have hit continue I
[91:13] should have set my break point
[91:15] bummer
[91:22] I don't know if I do this ah
[91:27] I don't know I might have messed it up
[91:30] rats
[91:32] it's a bummer that whenever you hit Ctrl
[91:34] C inside of this reverse shell it just
[91:37] kills the entire thing it doesn't just
[91:40] terminate the process you're running you
[91:43] know from the reverse shell
[91:45] oh well
[91:52] so I just need to
[91:55] download the reverse shell again
[92:06] yeah
[92:08] of course
[92:09] the server process also got messed up
[92:16] see if people understood just how long
[92:19] hacking takes I feel like the movies
[92:21] would probably be different
[92:40] all right
[92:50] Handler server
[93:10] oh but of course now I do have GDB do I
[93:15] uh
[93:43] why doesn't that work the second time
[93:45] around
[93:52] oh well
[93:55] at least while we're waiting for that
[93:57] router to boot back up I can make sure
[93:59] that I set my break point where I want
[94:02] it
[94:06] which is right here
[94:17] all right
[94:19] so we'll connect back to the router
[94:47] and I'm going to make sure to grab both
[94:49] of them this time
[94:56] this GDB server
[95:00] there's the reverse shell
[95:10] great now I have both of them
[95:13] sweet
[95:14] so same thing again
[95:17] kill off httpd
[95:20] start it up
[95:23] and grab this process ID
[95:49] that looks right
[95:51] uh oh
[95:57] huh
[96:00] it's weird
[96:13] oh there we go
[96:19] now we can run our Pock Dot py
[96:24] so unless I've made a mistake here this
[96:25] should send
[96:28] are payload over and we can verify
[96:31] well two things are valuable about doing
[96:33] this at this point
[96:35] we'll know that we've got everything
[96:36] right
[96:37] in terms of just how we've got how we
[96:39] calculated the offsets and now we've
[96:41] translated those into a program
[96:44] and we can also do some poking around
[96:46] the stack to see where our payload
[96:49] actually ends up and that will tell us
[96:52] what to put
[96:53] right here
[96:56] and
[96:58] this zero
[97:00] which right now
[97:03] is unknown
[97:14] all right
[97:23] well that's not good
[97:26] what did I do wrong
[97:46] is at least
[97:48] working
[97:55] hmm
[98:10] now that's very weird
[98:28] I don't know
[98:32] well nothing to do here other than to
[98:35] restart try again
[98:42] but maybe we'll we'll set this up so
[98:44] that alternatively we can have like a
[98:46] benign
[98:48] payload
[98:51] so what's like a sensible value for that
[98:53] uh WL and
[98:59] I don't even know maybe uh
[99:03] maybe we'll just put a a couple of
[99:07] semicolons just so we we cause it to
[99:09] fail but we don't cause the the program
[99:13] crash
[99:53] and you know what now I'm paranoid now
[99:54] I'm going to start a packet capture
[99:58] to make absolutely sure
[100:02] this is actually working
[100:05] as we expect it to
[100:15] okay
[100:36] oh
[100:37] for heaven's sakes
[100:40] I forgot to use the
[100:43] I forgot to start it with GDB
[101:53] all right
[102:08] now it's making absolutely sure that we
[102:10] have our break point in the right place
[102:16] 274 you know what I'm also
[102:18] because I'm paranoid now
[102:20] I'm gonna also put one at the start of
[102:22] the function
[102:27] and now we can continue
[102:29] so we'll just restart that packet
[102:30] capture
[102:56] hmm
[103:06] so this happens I always assume I've
[103:08] made a stupid mistake
[103:19] Maybe
[103:22] going over here to our
[103:24] Pock file which we used earlier oh okay
[103:27] so that works
[103:34] oh you know what it was
[103:39] I wasn't including as part of creating
[103:42] the the payload
[103:46] the URL
[103:49] parameter setup part
[103:52] oh yeah yeah
[103:55] okay well
[103:57] now we know
[104:02] so we can delete that
[104:06] that's another thing about hacking all
[104:08] the dumb mistakes that cost you time
[104:09] along the way
[104:25] cool I feel a lot better about that now
[104:36] but naturally we're going to have to
[104:38] restart
[104:40] the whole thing
[105:10] all right
[106:06] all right it will set up there we go
[106:24] all right so yeah we still want a break
[106:26] point on
[106:28] the start of the function
[106:30] satisfy the paranoia
[106:33] even further
[106:36] and another one
[106:38] on the return address
[106:41] which is right before ideally we'll make
[106:43] that jump to the gadget
[106:46] and everything will be right except for
[106:50] the fact that the arguments is going to
[106:51] be bogus
[106:58] oh yeah right
[107:08] cool
[107:23] beautiful there we go
[107:25] all right so now we are
[107:28] yep at the start of
[107:31] start API okay so now I can continue
[107:37] you'll know this for some reason we've
[107:39] got some of those double quotes which
[107:42] are unused bytes and the temporary
[107:43] registers I'm not quite sure why that is
[107:47] it will continue and now we're at break
[107:49] point two okay
[107:54] so
[107:58] at this point we should have
[108:05] the proper value in
[108:08] ra which is the address of our Gadget
[108:10] which is this thing
[108:12] so let's look at ra
[108:17] uh oh
[108:22] all right does not contain that
[108:27] hmm
[108:36] about s0
[108:44] s0 starting somewhere totally different
[108:56] very weird
[108:58] well let's just continue see what
[108:59] happens
[109:02] and we got a failure
[109:09] and the target disconnects
[109:19] and this thing hung up too
[109:22] okay so that wasn't at all what I
[109:25] expected
[109:30] but I'm kind of interested to pick this
[109:32] apart
[109:34] and see exactly what went wrong
[109:57] so
[110:01] is this uh the first or the second break
[110:08] secondly
[110:10] okay
[110:22] hmm
[110:46] well
[110:48] while we're mulling this over I'm just
[110:49] going to restart the router
[110:51] and
[110:53] I guess we are already debugging so
[110:55] we'll just step through it with a bit
[110:57] more care perhaps
[111:04] and set some more break points
[111:18] so I'll set a breakpoint right after
[111:21] best printf gets
[111:24] actually it's not this one it gets done
[111:25] in two places
[111:28] um
[111:39] springage
[111:41] WL rate only gets used once maybe we'll
[111:44] just pivot this whole thing to using WL
[111:46] rate
[111:47] just kind of simplify matters
[111:53] instead of using
[111:56] you'll be able and I'll use WL rate
[111:58] because they're really if you if you
[112:00] look at the logic here
[112:02] if WL ant isn't present it's just going
[112:05] to skip that entire block WL rate is
[112:08] then it's just going to execute this one
[112:10] and maybe you could have something to do
[112:12] with
[112:13] the fact that it's being written twice I
[112:15] don't know
[112:17] but in any case it will make our entire
[112:19] setup slightly simpler
[112:32] so that router is going to be back up
[112:34] now
[112:49] and we're back
[113:05] Maybe
[113:06] it has something to do with the fact
[113:08] that I'm quoting the entire payload
[113:12] it shouldn't but we're trying things
[113:13] here so
[113:16] why not it can't hurt maybe instead of
[113:18] quoting the entire payload it'll just
[113:19] quote the command
[113:22] or actually it's not even a command I'm
[113:24] so I'm in the command injection mindset
[113:26] it's the um
[113:28] no no there's the command
[113:31] yeah so I'll just quote that
[113:35] quote meaning encode for a URL
[114:01] foreign
[114:05] so far so good
[114:39] still got my brake points
[114:41] maybe we'll just step through the
[114:43] function
[114:46] that'll help
[114:58] so once again
[115:01] kill off the running version of httpd
[115:11] routes process ID
[115:34] now any more break points that we want
[115:37] stepping through it I realized can cause
[115:40] a few problems I think we're probably
[115:42] going to want to set one
[115:45] here right before this
[115:49] function gets called
[115:57] so like right here maybe
[116:11] try again
[116:32] all right
[116:36] so at this stage nothing's happened I
[116:38] can just keep going to the next break
[116:39] point
[116:40] which isn't that no upgrade okay
[116:45] so
[116:47] s0 is
[116:51] nothing that's to be expected
[117:04] nothing's happened yet but
[117:08] I do want to know what the value is at
[117:12] the destination
[117:25] it's like I need to look back quite a
[117:27] bit for that so we'll just say
[117:34] SP minus
[117:39] 140.
[117:44] well that looks like
[117:46] something meaningful there we go
[117:56] well here's the start of our
[117:59] payload looks like it's
[118:05] at this address I always forget exactly
[118:07] where the stack pointer is
[118:11] maybe if we dump
[118:14] Max 100
[118:17] starting here
[118:26] ah here we go
[118:40] right on so if I run the
[118:44] same GDB
[118:46] well now you take out the 100 don't I
[118:52] okay
[118:57] good well at least that answers the
[118:59] question of where
[119:04] our payload winds up
[119:17] we know the address
[119:21] it does not answer the question
[119:29] of why we didn't see
[119:32] intended values in our s variables oh
[119:35] actually yeah there we go
[119:40] huh
[119:41] I have no idea why it worked that time
[119:43] well
[119:45] okay
[119:47] let's take a peek at this so it looks
[119:49] like we have some kind of off by one
[119:53] error here because s0 is not
[119:57] totally filled up with
[120:00] question marks as we would like
[120:03] it looks like we just went one too far
[120:07] or not far enough
[120:11] all the Envy in this is kind of mixing
[120:13] me up here but
[120:15] looks like S1 is also just
[120:19] off by one
[120:35] so perhaps we need
[120:40] yeah I think we should push this along
[120:41] one more so let's try 248.
[120:50] and we'll tear it down to it again
[121:17] now the only break point that I want now
[121:19] that I'm confident that I've got a
[121:21] working
[121:23] Hawk right here well almost working
[121:26] is this final break point which is the
[121:30] jump back to the return address
[121:52] so I'll connect back
[121:54] router
[122:37] ah
[122:39] kill all httpd
[122:43] and restart it
[123:32] now we've got everything lined up
[123:33] beautiful okay
[123:35] so here's s0
[123:41] which you can tell has all of our
[123:44] question marks on it you know what I'm
[123:46] just going to
[123:51] kind of Benchmark this with
[123:55] like copying it off and
[123:58] saving it so we have it
[124:24] yep okay
[124:26] cool
[124:33] now
[124:34] this means we have everything lined up
[124:36] properly
[124:40] and so we can start figuring out
[124:43] how to
[124:45] find what this value ought to be
[124:48] you know in the notes from when we
[124:50] looked at this last time
[124:54] it said that my string appeared at this
[124:57] address
[125:04] and it still does
[125:19] okay
[125:26] so
[125:30] now we need to figure out
[125:37] where the wget parts starts
[125:41] so it ought to be whatever
[125:45] um
[125:46] let's see it would be
[125:50] WL rate
[125:53] or actually I can just do this in
[125:57] python really quick over here so it
[125:59] would be
[126:01] the length of uh
[126:04] WL rate space
[126:07] because that's
[126:13] this part of the string
[126:16] so whatever that is
[126:24] plus the length of my payload which is
[126:25] going to be
[126:29] 248 Plus
[126:41] so that's why it was messed up again it
[126:43] was just me being shoddy
[126:45] and careless this needs to be 16.
[126:58] all right
[127:04] well there's another blade in the stake
[127:07] that we're just going to start over if
[127:08] we want to get this remotely right
[127:16] yeah see that's
[127:18] definitely not our return address all
[127:21] right well
[127:25] I'm not a perfect human being
[127:33] at least now we know though
[127:58] we're connected again
[128:40] all right
[129:14] all right so we'll just double check our
[129:17] Pock here
[129:20] yeah we've still got the question marks
[129:22] but that's fine because we're gonna
[129:24] sort those out with this next run
[129:39] now ra looks correct
[129:42] let's see it's ended d a zero d a zero
[129:46] perfect
[129:47] S1 is exactly what we want it to be
[129:53] all right fantastic
[129:55] and then if I run this again we should
[129:57] see our command that should be correct
[130:05] yeah there we go
[130:21] right on
[130:27] all right
[130:33] so now it just
[130:35] becomes a matter of figuring out
[130:41] just how much we have to add
[130:43] to this value
[130:47] in order to find the address on the
[130:50] stack
[130:55] of our commands so it's going to be that
[130:57] plus
[130:59] whatever the length of WL rate is this
[131:03] is where I'm going to use python
[131:14] Plus
[131:16] 248
[131:24] plus 4 plus 4 plus 16.
[131:28] it's 24.
[131:29] plus another four that's 28.
[131:36] and that should do it
[131:45] all right 248. now what's that in HEX
[131:56] okay plus
[132:33] so now we can fill this in and say
[132:38] s0 is going to be string
[132:44] representation of that address
[132:50] which is going to be 34.
[132:52] followed by
[132:54] 2f
[132:57] followed by FF
[133:00] followed by 7f
[133:04] sweet
[133:11] and if we've done this right
[133:15] our Gadget
[133:17] which where did I put that I put that in
[133:19] the notes somewhere didn't I
[133:21] the better of
[133:23] yeah there we go it's that uh this one
[133:27] we will move the address of our
[133:31] command that's on the stack into a0
[133:35] move the address of
[133:38] system
[133:40] into T9 and then jump to it
[133:42] and we got here by overwriting the
[133:45] return address
[133:48] quick recap there
[133:51] so hopefully for the last time I will
[133:53] restart the router
[134:02] reset our Handler here
[135:24] a break point in place and now we're
[135:26] continuing
[135:28] and I can run the exploits which looks
[135:32] finished
[135:39] so here we go we've hit the break point
[135:43] and as you can see we're looking ahead
[135:46] we can see our Gadget
[135:48] moving s0 into a0 S1 into T9
[135:54] now
[135:57] is this
[136:00] address correct
[136:02] it is
[136:03] wonderful so that calculation went okay
[136:08] phenomenal all right so
[136:13] if everything's been done right
[136:16] we should see a get request for that
[136:19] little single byte x file when I hit
[136:21] continue
[136:29] and there you have it
[136:31] so to recap we were able to find a
[136:34] vulnerable call to esperantev
[136:37] we then were able to trigger a buffer
[136:39] overflow and cause a crash and then we
[136:42] use GDB to figure out that not only did
[136:44] we cause a crash but we controlled the
[136:46] return address and several key registers
[136:49] we then found a sequence of instructions
[136:52] that loaded the value from a register
[136:54] that we control into the argument
[136:56] register a0 and loaded the address of a
[137:00] function from a register that we control
[137:03] and jump to it
[137:05] we then figured out where the system
[137:07] function exists in memory
[137:10] and where the pattern of bytes that we
[137:13] had written to the stack existed in
[137:16] memory and then we put it all together
[137:18] and we're able to successfully
[137:21] execute arbitrary code over the network
[137:24] thus pounding the device
[137:26] now I'm sure that there are are more
[137:29] bones of this kind or of a similar
[137:32] nature in the web server I just didn't
[137:35] have time to look into it I had actual
[137:36] work to do but I'd like to leave you
[137:39] with I I suppose an open question
[137:42] in the first video we didn't look into
[137:45] the upmp attack Vector but I'm sure that
[137:48] there are probably some bones in there
[137:50] even if it's just a denial of service
[137:53] so why don't you go ahead and buy the
[137:55] router off Amazon it costs like thirty
[137:57] dollars
[137:58] and have a look at it see if you can
[138:01] find anything
[138:02] and if you do please shoot me in the
[138:03] email at jesse.chick trellix.com I'd
[138:06] love to hear about it
[138:08] alrighty hack the planet

=== Content from youtu.be_105b9ea7_20250115_101052.html ===
[00:01] hi my name is Jessie chick I'm a
[00:03] vulnerability researcher with trellix
[00:05] Arc and in this video series I'll be
[00:06] walking you through my adventures with
[00:09] the Linksys
[00:10] wrt54gl or at least the highlights of
[00:12] them
[00:13] so this route your first hit the shelves
[00:15] in 2005 and was supported through 2016.
[00:18] and according to some sources it's the
[00:20] best-selling router of all time
[00:22] I have no idea whether or not that's
[00:23] still true but needless to say it found
[00:25] its way into a lot of homes and
[00:27] businesses
[00:29] so I found this router while I was
[00:31] rummaging around in the electronic waste
[00:33] section of our office building here in
[00:34] Hillsboro Oregon and wound up taking it
[00:37] back to the lab getting it set up and
[00:40] just having a poke around to see if I
[00:41] could find any vulnerabilities
[00:43] as it turns out I was able to find
[00:45] several ways to completely take over the
[00:47] device over the network and we disclose
[00:49] those vulnerabilities to linksys Last
[00:52] Summer
[00:53] now for various reasons This research
[00:55] and its findings is not the kind of
[00:57] thing that we would wind up submitting
[00:58] to one of the big conferences
[01:00] but I do feel that the process of
[01:03] finding the vulnerabilities really
[01:05] showcases a lot of the key methodologies
[01:07] that we own the vulner research team use
[01:09] to hack devices of all kinds while also
[01:12] being rudimentary enough to be
[01:13] accessible to somebody without a strong
[01:15] background in security or understanding
[01:18] of reverse engineering
[01:20] so with that audience in mind I really
[01:22] make an effort to explain Key
[01:25] terminology justify each step that I
[01:28] take and describe which tools are
[01:31] valuable for which step and that kind of
[01:33] thing so if you're interested in
[01:35] learning how we go from a router in a
[01:37] box to having complete control over that
[01:39] device or if you're looking to do some
[01:41] bone research of your own and are
[01:43] looking for some cues as to how to get
[01:45] started I really think that you'll find
[01:47] this series valuable
[01:49] so without further Ado let's get started
[01:53] so to start things off here I was able
[01:55] to find a ton of publicly available
[01:57] technical information about this router
[02:00] before I even bothered to set it up so
[02:03] I'll just go through here and pick out
[02:05] the two avenues that I found to be the
[02:07] most valuable so the first one actually
[02:09] came from the vendor's website so we'll
[02:12] just go to linksys that's our vendor and
[02:15] I was punch in the model number here
[02:18] and the second result down is the
[02:19] product support page
[02:21] so this has links to a user guide which
[02:24] I didn't even bother looking at but I
[02:26] did spend a lot of time with the
[02:29] firmware
[02:30] so this router gets firmware updates
[02:34] just by you downloading it off of their
[02:36] web page and then uploading it through
[02:38] the Management console there's no
[02:40] over-the-air firmware updates so this is
[02:42] how you do it
[02:45] and so you can download the firmware I'm
[02:46] just going to download it directly into
[02:48] my Cali WSL install over here
[02:53] and I'm also going to grab the release
[02:54] the release notes we'll take a peek at
[02:56] those two later
[03:00] so the firmware says emea only
[03:04] I'm pretty sure that that means Europe
[03:05] the Middle East and Africa so this is
[03:08] like the version of the firmware that
[03:09] they ship with products in those regions
[03:13] I don't think it makes much of a
[03:15] difference particularly because we're
[03:17] only looking at this at this firmware
[03:18] which is the latest version of the
[03:20] firmware in order to get a very general
[03:22] idea of what kind of software the
[03:26] the router leverages it's almost
[03:29] a certainty that whatever firmware
[03:31] version got shipped with a device
[03:33] is not the latest one
[03:35] was given how old this product is but
[03:38] anyway
[03:39] so the first thing that I'm going to do
[03:41] is I'm going to download this tool
[03:42] called binwalk
[03:44] which is an awesome tool of a pending
[03:48] kernel upgrade
[03:50] oh I don't care
[03:52] which is a really awesome tool for just
[03:54] scanning through binaries that contain
[03:56] multiple chunks it's going to look for
[03:59] you know key patterns of of bits to
[04:01] figure out okay this chunk is compressed
[04:03] data this is part of a file system that
[04:05] kind of thing super useful when working
[04:07] with firmware so if I run binwalk here
[04:11] on our firmware image
[04:14] it's picked out some header at the at
[04:17] the first bite there
[04:19] uh gives us a firmware version which
[04:23] appears to be incorrect that's kind of
[04:25] weird and then another header of some
[04:27] kind some compressed data with the
[04:31] original file named piggy I don't know
[04:32] what that means and then down here at
[04:34] the bottom we see that there's a squash
[04:35] FS file system so squash FS is a way of
[04:39] taking an entire file file hierarchy
[04:41] like the root directory of Linux intent
[04:45] and squashing it down into a single
[04:49] continuous chunk of data
[04:53] so one of the other things that Ben walk
[04:55] can do what we're going to really
[04:56] leverage it for here is to extract this
[04:59] firmware which means pick it apart
[05:01] separate it into its logical chunks and
[05:05] allow us to work with it file by file
[05:09] so I'm going to run Ben walk again with
[05:13] this Dash e flag for extract and I'm
[05:15] going to add a couple more so the first
[05:17] one is R which just means remove all of
[05:20] the files all of all the the full chunks
[05:22] of files like the squash FS file after
[05:25] they've been successfully extracted it
[05:27] just helps keep the workspace cleaner
[05:30] I'm also going to add this dash one
[05:34] option which means if you come across a
[05:36] symbolic link don't change it keep it
[05:39] intact I don't care about whatever
[05:40] relevant security risks don't change my
[05:43] symbolic links
[05:45] just a personal preference for me there
[05:49] and so when I do this you'll see that we
[05:51] get a couple of Errors it says here or
[05:54] Warnings router it says that the
[05:56] extractor failed to run external
[05:58] extractors Sasquatch
[06:01] oh yeah okay so since this version of
[06:04] squash FS is pretty old
[06:08] it can't be extracted correctly by the
[06:13] the version of um of like squash FS that
[06:17] I have installed in in Cali so I have to
[06:19] use this Nifty GitHub repo
[06:23] where they actually patch your squash FS
[06:26] install so I'm just going to clone this
[06:28] down
[06:32] it would help if I had get
[06:42] really hope that warning doesn't keep
[06:46] popping up on us
[06:50] but if it does whatever okay
[06:54] so I believe
[06:57] that yeah installing this is as simple
[06:59] as running build
[07:04] so it looks like it downloaded the
[07:06] source for squash fs and is now patching
[07:09] it and building it
[07:11] and it gave us an error oh shoot
[07:15] collect to error LD return one exit
[07:18] status oh okay I've seen this before
[07:20] so this can typically be sidestepped by
[07:23] just adding the C flag F common
[07:26] so I'll just say C Flags equals
[07:31] common in the Run build again we
[07:33] countered this one before
[07:35] it's just going to do that that process
[07:37] over except hopefully it'll build
[07:39] correctly it'll look like it did so if I
[07:42] just run
[07:43] which
[07:45] Sasquatch
[07:47] yes okay so we have it now
[07:49] great so
[07:52] now I can go up here and delete the
[07:58] extraction folder that had all those
[08:00] errors in it and I can just run that
[08:02] bimlock command again
[08:08] and now it looked like it worked without
[08:09] giving us any warnings
[08:12] so let's go in here and check out what
[08:13] we've got so we have
[08:15] this file called piggy see what that is
[08:19] all right just data
[08:21] I don't know I don't I don't really
[08:23] think that it's worth looking into that
[08:25] right now
[08:26] so let's go into our squash Fest route
[08:28] so this is the root of the file system
[08:31] that is included in this firmware and as
[08:34] you can see it contains all of the
[08:35] directories that you would expect on a
[08:38] Linux file system let's just look really
[08:40] quickly at how many entities are in here
[08:42] total
[08:44] 539 okay so that's something that we can
[08:46] probably look at quickly by eye
[08:49] so first thing that I'm going to do is
[08:52] just go down the roster here and and try
[08:55] to look for any interesting files just
[08:57] anything that that stands out and I'll
[08:58] make notes of them in fact
[09:00] probably
[09:03] make some notes here anyway
[09:08] a little notes file
[09:14] call me weird but I like taking notes
[09:16] and markdowns so this is our
[09:19] Recon section
[09:22] I'm just looking for interesting files
[09:25] just anything that that we think would
[09:27] be worth making out of so first of all
[09:29] in the bin folder
[09:32] we see that we only have two binaries so
[09:34] there's BusyBox which is all of the
[09:36] Linux commands that you know and love
[09:37] included in one binary and then you
[09:41] would just symbolic link things like cat
[09:43] to it so that you don't have to have all
[09:46] of these as like Standalone binary it's
[09:47] just save space
[09:50] and the other one here is eapd I don't
[09:53] know what that is
[09:54] and at this point I don't see much of a
[09:58] reason to care
[10:02] so continuing along Dev ought to be
[10:05] empty yep
[10:06] what about Etsy
[10:08] so Etsy has a few things in it it's got
[10:12] a cron d link to a temp folder okay so
[10:17] hint Cron's probably involved let's make
[10:21] note of that
[10:29] links where the temp
[10:32] cron d
[10:34] that could be important later
[10:37] uh we have a hosts file typically not
[10:39] that interesting
[10:41] whatever this is I'm not quite sure
[10:43] there's a open SSL configuration file
[10:46] okay so that's good to know
[10:49] now we know that
[10:52] https is probably supported in some way
[10:55] shape or form
[10:57] and then we have protocols and services
[11:00] that's pretty standard you expect that
[11:02] on a router and then another link so
[11:06] not too much that's interesting there
[11:08] what about lib
[11:11] all of these look pretty generic micro C
[11:14] web c
[11:16] live MSL I don't know what that is
[11:19] whatever what about within this module
[11:23] subfolder
[11:26] okay so this is just kernel stuff
[11:33] yeah okay so probably stuff that's
[11:36] involved with interfacing directly with
[11:39] the hardware
[11:42] not terribly interesting to us at this
[11:44] stage
[11:47] so next Mount that should be empty yep
[11:50] proc should also be empty
[11:52] what about Aspen
[11:57] so Aspen's got a lot of stuff in it but
[11:59] only one binary there's this RC binary
[12:02] what does our c stand for I always
[12:04] forget
[12:11] the RC at the end of a file is related
[12:13] to the phrase run commands it uses
[12:17] its use derives from the SCRC files used
[12:20] in most gaming systems okay so run
[12:22] commands
[12:24] so that makes some sense because a lot
[12:26] of these
[12:28] uh links in here are are linking to RC a
[12:31] few the busy box but most of them to RC
[12:33] including this init
[12:36] link to RC so S Pen and knit is
[12:39] typically what what runs when the
[12:42] operating system first boots up
[12:45] so that's good so now we know that if we
[12:48] ever want to
[12:50] enumerate the startup scripts or the
[12:53] startup processes just figure out like
[12:56] when this operating system first boots
[12:58] up what processes get spawned it's sort
[13:01] of like the equivalent of running PS
[13:03] when you have an active shell
[13:05] we would want to pop open this RC binary
[13:08] in our reverse engineering tool of
[13:10] choice
[13:11] and
[13:14] kind of root through the code Trace out
[13:15] the logic to figure out okay well what
[13:17] services get spawned on on Startup
[13:21] that depending on on the situation that
[13:23] might be something that you would do
[13:24] right away it might not let's leave it
[13:26] for now but certainly make note that
[13:29] it's there
[13:30] okay so what else we got here we've got
[13:32] a couple of temp directories those are
[13:34] almost always empty
[13:36] and yes they appear to be viewing system
[13:40] resources always has some good stuff in
[13:42] it let's look in bin
[13:45] so it looks like we we just have more
[13:48] shell command type things
[13:51] including kill all roots
[13:54] sort and wget okay so so that's
[13:56] interesting so maybe somewhere down the
[13:58] line if we're able to execute our own
[14:00] commands it might be useful to be able
[14:01] to download stuff onto the router's file
[14:04] system so that'd be a good thing to make
[14:05] note of here we have
[14:08] USR bin
[14:11] wget
[14:13] that's there for our use it's the busy
[14:15] box version
[14:20] okay what about the lib folder
[14:28] okay a lot of libraries that I don't
[14:30] recognize right away lib crypto more
[14:32] cryptography stuff
[14:33] network configuration
[14:36] non-volatile Ram okay
[14:39] kind of interesting
[14:41] SSL whatever lib zebra is so none of
[14:45] these really stand out but what about
[14:49] in those subfolders okay
[14:51] so IP table stuff
[14:54] just seems more systemy
[14:58] and I really want to work with right now
[15:01] I don't know I never really find that
[15:03] looking at libraries up front is
[15:06] terribly useful unless you see something
[15:08] that really stands out
[15:10] so let's stop there
[15:12] what about in local
[15:16] uh-oh more SSL all right so it it looks
[15:19] like there's only the one file given the
[15:22] tab completion just led me right there
[15:24] and it's another open SSL config file
[15:26] I'm not going to bother to look in there
[15:27] we it's all pretty typical not
[15:30] interesting stuff
[15:32] what about an S bin
[15:35] okay so here we see a whole bunch of
[15:37] binaries and these are Standalone we
[15:40] notice we have KRON we have DNS mask
[15:44] we have httpd so that's going to be our
[15:47] web server almost always that's kind of
[15:49] a sure bet
[15:52] you have an nvram binary we have open
[15:55] SSL for generating certificates that
[15:58] kind of thing
[16:02] tftpd forget what that is that's Idina
[16:05] of some sort we have Dynamic host
[16:08] configuration all right
[16:11] and we have a designated binary for UPnP
[16:15] so UPnP stands for universal plug and
[16:17] play
[16:20] that's good to know is going to be
[16:22] present on there if you don't know what
[16:24] what universal plug and play is
[16:27] it's basically this extension to httpd
[16:31] it's just a product specification used
[16:33] by or protocol specification rather
[16:36] for iot devices and routers to discover
[16:40] each other on the network advertise
[16:42] different Services get spun up easily
[16:45] and it's typically unauthenticated
[16:48] so that in and of itself would be a
[16:51] viable attack Factor let's make note of
[16:52] some of these other things so we we know
[16:54] we have cron that might be useful
[16:57] somewhere down the line particularly if
[16:59] we get to the post exploitation step
[17:02] we have DNS mask
[17:04] that's probably going to be listening on
[17:07] a port
[17:09] let's see what else we have httpd good
[17:11] to know where that is that's our web
[17:13] server that's definitely going to have
[17:14] an open port and of course we have UPnP
[17:19] why what zebra is
[17:21] but probably not worth looking into
[17:25] right now
[17:27] okay
[17:29] so what else is in
[17:31] C system resources oh just a link to the
[17:33] temp directory okay
[17:37] so last but not least there's this www
[17:40] folder so
[17:42] this as we might expect is is going to
[17:45] be our web client
[17:47] and it looks like it just has a bunch of
[17:49] pages corresponding to the various pages
[17:52] on the the Management console and
[17:55] interestingly they're they're dot ASP
[17:57] which is active server pages
[17:59] so that that includes stuff like scripts
[18:01] and in addition to HTML it's
[18:04] I guess like an alternative to the
[18:06] normal uh HTML and JavaScript
[18:12] um framework for like making a front end
[18:14] it looks like it's including both though
[18:16] I'm not sure what to think about that
[18:18] but in any case you don't see ASP very
[18:21] much anymore this is the kind of thing
[18:23] that was a lot more common you know 10
[18:24] or 15 years ago which sort of makes
[18:26] sense I believe that this router first
[18:28] hit the Shelf in like 2009 or something
[18:30] like that
[18:31] it's Obama era
[18:36] so okay probably not going to be that
[18:39] useful to root around in the client
[18:42] right now
[18:45] so that's good we have we have a
[18:46] relatively unsophisticated
[18:50] file hierarchy here not that many files
[18:52] just I I think we saw something like
[18:54] 540.
[18:56] so pretty manageable pretty small
[18:58] footprint
[19:02] so with those notes that we've already
[19:03] taken I think it's probably appropriate
[19:06] to
[19:07] leave that there for the time being
[19:10] let's take a peek at the release notes
[19:13] so release notes are are useful because
[19:16] as firmware updates come out they they
[19:18] typically introduce new features
[19:21] patch known vulnerabilities and that
[19:23] sort of thing so it can give you an idea
[19:25] of of the the life cycle
[19:29] of one of these routers
[19:31] so we see that in the in the latest
[19:33] firmware version here which is minor
[19:36] version 18 build number doesn't really
[19:38] matter all they did was address a
[19:40] manufacturing issue that we don't need
[19:42] to care about
[19:44] previous version
[19:46] it
[19:49] when the compliance with something okay
[19:51] resolved a cross-site scripting issue
[19:54] and code injection via DHCP okay
[19:58] interesting
[20:00] that's something to
[20:02] maybe make note of
[20:13] you know any any time where you where
[20:15] you see that a a major vulnerability in
[20:17] the product that you're trying to hack
[20:20] was was patched in the latest firmware
[20:24] that's good to make note of because
[20:26] it could be the case that one of these
[20:29] vulnerabilities affects the version of
[20:32] the firmware on the router that shipped
[20:35] with our router as opposed to to the
[20:37] latest one it's entirely possible that
[20:40] the version of the firmware that shipped
[20:41] with our router is not up to date
[20:44] and even though ideally you would want
[20:46] to get a volume in the latest and
[20:47] greatest firmware
[20:48] evolved in an old version is still a
[20:50] volume still fun for our purposes
[20:56] say okay we're looking at release notes
[20:58] Here
[21:05] so in version 16 there was a
[21:07] vulnerability in the UPnP stack but it
[21:09] doesn't tell us what it is still might
[21:13] be worth
[21:14] making note of
[21:16] for later that was fixed in what
[21:21] minor version 16. okay
[21:24] there was another cross-site scripting
[21:25] issue
[21:27] kind of
[21:29] generic in build 16 2. yeah one
[21:43] can't hurt to make note of this stuff
[21:48] and then there were there were a lot of
[21:50] changes in version 14 so they updated a
[21:53] I think that's point-to-point tunneling
[21:56] protocol
[21:58] internet connection functionality
[21:59] probably not a big deal issue with UPnP
[22:04] issues with Access Control not
[22:06] functioning in router mode that's bad
[22:10] time zone stuff okay a ton of things
[22:13] fixed in in 14 might as well just copy
[22:15] this well maybe not the whole thing
[22:19] what about just the UPnP vulnerability
[22:29] that's probably enough we can go back to
[22:31] this if it if it becomes necessary
[22:34] because once again we still don't know
[22:35] which which version of of the firmware
[22:38] shipped shipped with our router it may
[22:40] well be the latest we just don't know at
[22:42] this point or we're pretending not to
[22:44] know
[22:47] okay so I think I'll leave it there when
[22:50] it comes to the release notes
[22:52] so something else that is always a good
[22:55] idea to do when you when you get a fresh
[22:58] product is
[23:00] to look for other existing
[23:03] vulnerabilities stuff that may not be
[23:04] directly referenced in the in the
[23:06] release notes particularly because these
[23:08] release notes were came out with the
[23:10] latest version of the firmware which was
[23:11] in 2016. so it's entirely possible that
[23:15] some researcher has subsequently found a
[23:18] vulnerability you know after the period
[23:20] of time that it was actively supported
[23:23] and
[23:25] wrote up a blog or reported it in in
[23:27] some other way
[23:30] and that could be very useful to us in
[23:33] gaining additional access to the device
[23:35] in service of finding our own
[23:38] vulnerabilities and as a matter of fact
[23:40] that's that was exactly the case in my
[23:43] exploration of this router so I came
[23:46] across a vulnerability that was found in
[23:49] 2021 so just last year you know long
[23:51] after the period of time that this
[23:52] product stopped being supported
[23:54] from a researcher out of Israel who
[23:58] hacked a very very similar router so
[24:01] this differs from our model number by
[24:03] just one character he's dropped the L
[24:05] off the end so it stands to reason that
[24:08] this is a very very similar product it
[24:10] could be a parallel product it could be
[24:11] like the previous generation or whatever
[24:16] but
[24:18] it's an entirely valid question to ask
[24:20] as to whether or not whatever
[24:21] vulnerability he found is also present
[24:23] on the on the router that we have here
[24:26] even though it's a slightly different
[24:27] model
[24:28] so we won't dive too deeply right now
[24:32] into
[24:34] the details of the vulnerability that he
[24:37] found we'll just kind of cut straight to
[24:38] the Chase and
[24:40] so we can understand this at a cursory
[24:43] level so here's the vulnerable chunk of
[24:45] code
[24:47] let's take a look at this for a second
[24:50] so basically what he did is he figured
[24:52] out
[24:53] that there was a command injection
[24:55] vulnerability in this router and used it
[24:59] to download a reverse shell the heat
[25:01] cross compiled
[25:03] and used that to actually get like an
[25:07] Interactive
[25:08] shell session going
[25:13] so what's a command injection a command
[25:15] injection is is where there there is
[25:18] some value some user input that you
[25:20] control that finds itself getting format
[25:23] stringed or something similar into
[25:27] a call to the system function so we see
[25:30] that right down here a system is a c
[25:32] function that just takes a string that
[25:34] represents a Linux command in this case
[25:36] it's a copy command
[25:38] and then executes it on the underlying
[25:40] Linux operating system
[25:43] so what he found is that is that this
[25:45] value here this looks like it's
[25:47] decompiled C code from ghidra
[25:50] I believe that that's how they annotate
[25:52] variables he discovered that that this
[25:55] value here is user controlled so what's
[25:58] happening is is the the value that winds
[26:00] up in this variable is getting read from
[26:02] non-volatile memory specifically the the
[26:05] value of UI language so this under under
[26:08] normal circumstances would have like for
[26:11] example the value en if you want to you
[26:13] know view your Management console say in
[26:16] English or it'd be FR if you want to be
[26:18] within Fringe SP for Spanish d e for
[26:21] German that kind of thing
[26:25] but what he found it is that when you
[26:27] set this UI language value
[26:30] there is no validation that gets done on
[26:32] on what value you set for UI language
[26:35] typically this is done directly through
[26:37] the Management console oh I should have
[26:39] mentioned he he does in this blog
[26:42] that this chunk of code is from the
[26:46] httpd binary so the file that that
[26:49] serves the Management console just how
[26:51] you configure particular settings for
[26:53] your router and that kind of thing so
[26:55] typically when you're setting the UI
[26:56] language you would do that through the
[26:58] through the the client all the scripts
[27:01] and stuff that were in our www folder
[27:05] but if you don't if you decide to just
[27:08] use your own post request and you know
[27:11] use netcat or
[27:14] some some similar tool to just send it
[27:16] over the wire to the router it'll still
[27:18] process all of that information all
[27:21] those settings that you update
[27:23] and it performs no validation
[27:26] on what UI language is
[27:28] so he basically he does a a two-part
[27:31] attack so the first packet that he sends
[27:34] is just a post request which contains
[27:37] some malicious payload and it gets
[27:40] stored in non-volatile memory
[27:42] as the value for the for UI language
[27:46] and then he spoofs a firmware update in
[27:49] order to get this function to trigger so
[27:53] then the malicious payload that
[27:55] corresponds to the UI to UI language
[27:57] here gets loaded into memory and then
[27:59] dropped into this
[28:03] copy command here and executed by System
[28:06] so what he figured out that you could do
[28:08] is replace this percent s
[28:14] the percent s token here with the
[28:15] following so you put first a semicolon
[28:19] to terminate the the command there
[28:23] and then added his own command so just
[28:26] for example that could just be touching
[28:29] a temporary file that just says pwned
[28:32] for example it could be whatever you
[28:33] want he actually used wget here but just
[28:36] to keep matters simple we'll stick with
[28:38] touch
[28:39] and then put another semicolon
[28:42] in there
[28:44] so in effect your system is going to be
[28:46] executing three commands two of them are
[28:48] are going to fail
[28:49] this leading command is going to fail
[28:52] because of course copy requires two
[28:53] arguments a source and a destination
[28:56] and this last one is going to fail
[28:58] because that's not a valid command
[28:59] that's just a the trailing fragment of
[29:02] the of the copy command
[29:05] now this command in the middle
[29:08] since it's surrounded by semicolons on
[29:11] on both sides is going to execute no
[29:14] problem provided that it's a valid
[29:17] show command
[29:20] so this is a a classic OS command
[29:22] injection
[29:24] and he figured out how how to to trigger
[29:27] that on on this
[29:29] similar rather to the one that that
[29:31] we're working with
[29:33] so that got me thinking well huh
[29:35] is it possible that the same httpd
[29:39] binary is being reused in this later
[29:41] product or at any rate is is this
[29:43] vulnerable chunk of code
[29:45] still present
[29:47] so to verify that we can just grep
[29:50] for
[29:52] for this string here
[29:54] so I could I could just run strings on
[29:56] the httpd binary
[29:59] which I believe is in
[30:01] USR Aspen yeah
[30:03] so I'll just run strings
[30:09] on that file and I'm sure that there are
[30:11] a ton
[30:14] so we'll just pipe that to grep and look
[30:16] for
[30:17] let's just say copy www it should be
[30:20] enough
[30:23] and we see that there are are three
[30:24] matches one of which
[30:27] is
[30:29] this vulnerable format string
[30:32] great and then the other two happen to
[30:34] also be visible in this in this snippet
[30:36] of code so this is really encouraging
[30:37] this means
[30:39] that in all likelihood unless there's
[30:42] are some other changes that made this
[30:44] path unreachable
[30:47] this exact same vulnerability that is
[30:49] described at Great length and detail
[30:52] in in this blog also affects the router
[30:55] that we
[30:57] have here
[31:00] now I didn't see this documented
[31:02] anywhere I went into
[31:04] I I actually did some digging on this
[31:07] vulnerability I figured out the the CBE
[31:08] number because our our researcher friend
[31:11] here did report it
[31:13] but the MVD entry is kind of cryptic it
[31:16] doesn't mention either of the of the
[31:18] routers here neither the one that we
[31:19] have nor the one in in the blog but
[31:22] instead this older version of router
[31:25] from likely the same series I'm not
[31:28] quite sure why but you can tell
[31:30] it's the same vault
[31:31] it references that that UI language
[31:34] parameter the vulnerable function httpd
[31:39] everything it also says note this
[31:42] vulnerability only affects products that
[31:43] are no longer supported by the
[31:45] maintainer
[31:47] okay
[31:49] so this is all very very promising
[31:51] these are things that we can that we can
[31:54] likely leverage down the line if we want
[31:56] to get a cheap reverse shell on our
[32:00] router now in into this in end of the
[32:03] self this isn't terribly valuable we
[32:05] don't just want to prove that the volume
[32:07] exists on this new product we want to
[32:12] find our own
[32:14] but it'll give us access to
[32:17] an interactive session on the device we
[32:19] can run commands we can do a lot more
[32:21] detailed Recon get a lot more
[32:22] information about the running processes
[32:25] of this router
[32:28] so at this point
[32:31] I'm going to shift to actually working
[32:33] with the router itself so I took the
[32:35] liberty of getting this set up
[32:37] with all the defaults ahead of time
[32:41] so I'll just go ahead and connect to it
[32:43] right here I'll hop off our lab Network
[32:46] here in Hillsboro
[32:51] connect to our router
[32:57] and so the first thing
[33:00] that we want to do now that we're
[33:02] actually interacting with the router
[33:03] directly is to try and narrow down our
[33:05] attack surface so since this is a router
[33:08] any conceivable attack that we have is
[33:10] probably going to occur over the network
[33:12] I think it stands to reason
[33:15] so the first thing that I'm going to do
[33:17] is use nmap which requires no
[33:20] introduction to do a port scan see with
[33:23] open ports are available on this router
[33:26] I'm also going to use this Dash a flag
[33:28] which basically means
[33:29] run a bunch of scripts that tries to
[33:32] identify what services are sitting
[33:34] behind those open ports
[33:37] and I know that the IP of the router
[33:40] is pretty standard so let's get this
[33:44] port scan Running Oh I need to install
[33:46] in the that would help
[33:59] ah rats
[34:02] of course that router is not connected
[34:04] to the internet
[34:05] oops
[34:15] now we can install that map
[34:18] pending kernel upgrade I don't know what
[34:20] that
[34:22] and don't really want to look into it
[34:24] now
[34:28] seems like everything's running so we're
[34:30] just going to ignore it
[34:35] so now I can connect back to the router
[34:38] and run
[34:40] our service discovery
[34:44] command
[34:46] this is definitely something to make
[34:48] note of
[35:05] taking that sweet time nmap is
[35:22] okay great
[35:23] so now it's returned a whole bunch of
[35:26] results
[35:28] just copy this off here
[35:32] you can kind of pick through it
[35:34] so
[35:36] first things first we see that Port 80
[35:39] is open
[35:41] all right great
[35:42] that's our web server that's just normal
[35:44] unencrypted HTTP traffic
[35:47] that gives us that Management console
[35:50] and of course
[35:52] it's going to be password protected so
[35:54] we aren't allowed to pull down any
[35:56] information other than the fact that
[35:58] we're not authorized
[36:00] we also noticed that Port 443 which is
[36:03] https
[36:04] is also open no surprises there we knew
[36:08] that SSL was already present on the
[36:10] device
[36:11] and then there's some certificate
[36:13] information that I don't think is worth
[36:15] looking into right now and then we have
[36:17] this higher Port which is 5431 which
[36:22] mmap is telling us is UPnP now you can't
[36:25] always trust nmap's guests as to what
[36:28] the service is going to be
[36:30] but in this case I think it's a pretty
[36:32] safe bet particularly given
[36:34] that we already
[36:36] kind of established the upmp is
[36:38] supported as there's a designated binary
[36:40] for it
[36:42] so none of this is too surprising so
[36:44] basically we have we have two Services
[36:45] here
[36:46] we have
[36:48] our normal web server
[36:52] and we have UPnP so those are our our
[36:54] two possible attack vectors these are
[36:57] our network-based attacks that we could
[36:59] that we could launch over the network
[37:01] they're either going to affect UPnP or
[37:03] HTTP d
[37:07] so it's it's sort of dealer's Choice as
[37:09] to as to which one we go with I I'm
[37:13] going to run with the the web server
[37:16] first and look into this further but we
[37:18] could totally go after up and P2 that's
[37:21] a totally viable attack Vector we're
[37:23] just going to stick
[37:24] with http
[37:28] so given that we're going to do that the
[37:29] next question is well
[37:32] how do I Supply my own input to that
[37:35] httpd binary that's running the web
[37:38] server
[37:40] because it's it's it's great to know
[37:42] what what port it's it's listening on
[37:44] but if I actually want to supply data
[37:47] that's going to be processed by that by
[37:49] that binary by that running program
[37:52] I need to know what format it's
[37:54] expecting data to be in
[37:56] other than just to know that it's going
[37:58] to be coming in over http
[38:01] so to do that I'm I'm going to start a
[38:03] Wireshark capture here
[38:07] and I'm going to open up the Management
[38:10] console here in my browser
[38:13] so that should be available just by
[38:15] going to the
[38:18] to the router's IP at Port 80 and
[38:22] immediately it prompts me for a username
[38:23] and password I set this
[38:26] to just admin admins to keep things easy
[38:30] let's not save that for now
[38:32] okay and so we're presented with this
[38:36] landing page where you can do
[38:38] various things like you know Set static
[38:41] IPS use
[38:43] a different configuration protocols for
[38:45] signing up IPS we'll just keep the
[38:47] default for that now
[38:50] and we can go to
[38:52] you know any number of these various
[38:55] tabs and look at all of the of the
[38:58] different places where you could
[38:59] possibly Supply user input
[39:03] but I don't think there's that there's
[39:05] any real need to do that here we should
[39:07] notice though that up in the top right
[39:09] we are given the firmware version
[39:12] so this is the current firmware version
[39:14] on the device it's minor version 14. so
[39:17] we're definitely going to make note of
[39:18] that
[39:27] is good to know for sure maybe
[39:29] cross-reference that with some of the
[39:31] release notes later if necessary
[39:36] but I still want to know if if I make
[39:39] some change
[39:40] via the the Management console how is
[39:44] that change going to be transferred from
[39:46] the client to the server so that the
[39:49] server can update its internal
[39:51] configuration and that kind of thing so
[39:54] I think that what we'll do here is just
[39:57] make a a really small change and that
[39:59] can be as simple as just turning off
[40:01] https let's just say no I want all of
[40:04] the the the traffic to be unencrypted
[40:09] no matter what
[40:11] so I'm just going to save settings there
[40:15] looks like we're going to get redirected
[40:17] in a few seconds thank you
[40:20] and now that box is
[40:22] is no longer checked
[40:24] so now I'm going to go back over here
[40:25] and I'm going to stop this packet
[40:27] capture
[40:30] maybe make this full screen to make it a
[40:32] little bit easy and now I'm I'm looking
[40:35] for a post request or patch or whatever
[40:39] was initiated when I hit save settings
[40:43] there and made that change so
[40:46] there were a lot of packets here
[40:48] some DNS stuff and there's our http
[40:54] simple service Discovery okay so that's
[40:55] probably up UPnP related that's worth
[40:58] making of ah here we go here's our post
[41:01] request
[41:04] so if I follow this TCP stream I'm going
[41:07] to get the entire dialogue associated
[41:09] with this with this update here
[41:12] and I don't really care about the
[41:13] response that's just going to be an HTML
[41:16] page with by the looks of it a bunch of
[41:18] JavaScript in it yeah yeah this is all
[41:22] HTML JavaScript okay what I really care
[41:25] about is this post request so how did
[41:28] the client
[41:30] send the data that initiated that update
[41:33] to the settings the turning off of https
[41:35] that's what I care about here
[41:38] so I can just minimize these for now
[41:40] let's
[41:41] take a look at
[41:44] what that post request looks like
[41:51] and it it looks like we're we're making
[41:54] a simple post request to the apply.cgi
[41:57] endpoint with a bunch of headers that I
[42:00] don't really care about actually it
[42:02] might be more useful to view this in the
[42:04] little markdown previewer
[42:06] over here that way it
[42:09] it's all
[42:11] the request body is going to wrap okay
[42:14] so none of this is terribly interesting
[42:15] so it looks like in the request body we
[42:17] have a whole bunch of key value pairs
[42:19] that are separated by Ampersand so sort
[42:22] of in url parameter format
[42:26] and I'm I'm looking for something that
[42:28] involves https so get Remote Management
[42:31] https is zero okay HTTP enable is one
[42:35] https enable equals zero okay so
[42:39] previously we saw from the nmap scan
[42:41] that it was definitely open https was
[42:43] enabled now
[42:47] the client is telling the server to set
[42:50] the https enable status to zero in other
[42:53] words turning it off
[42:54] okay
[42:56] so
[42:57] it stands to reason from here that most
[43:00] if not all updates to configurations
[43:03] are sent from the client to the server
[43:05] as these key value pairs in a post
[43:08] request body
[43:11] okay so that's good to know
[43:14] in fact it's crucial to now
[43:17] so the next question that you might ask
[43:20] is well now I know how to send my own
[43:24] data my own information to the router
[43:27] but how does it get processed once it
[43:29] gets there
[43:30] so in order to do that we're going to
[43:32] pop open the httpd binary
[43:36] that we extracted from the latest
[43:38] version of the firmware now keep in mind
[43:40] this is the latest version of the
[43:41] firmware not the version the firmware
[43:43] that's that's running on the router but
[43:45] we're counting on it kind of being close
[43:46] enough at this point
[43:48] in my favorite reverse engineering tool
[43:52] which is binary Ninja
[43:53] so we'll just make that full screen and
[43:57] um I'm going to search for
[43:59] this submit button parameter let's just
[44:02] see where
[44:04] this parameter gets parsed
[44:08] so I'll search through the strings
[44:11] for submit button
[44:13] we can see down here that it occurs in
[44:15] two different places let's just go to
[44:16] the first one
[44:19] so it's in this function Gozilla CGI
[44:22] okay
[44:23] and it looks like it appears as a
[44:26] hard-coded string literal
[44:29] passed as an argument to the get CGI
[44:32] function so let's take a peek at get CGI
[44:36] so it looks like the argument to get CGI
[44:41] just gets passed straight to this H
[44:44] search underscore R function so you see
[44:47] programs the UC programmers out there
[44:50] will know that H search is how you query
[44:53] a hash table
[44:55] and that first argument is the key
[44:57] so now we know that our number one is
[44:59] going to be a string and that's the key
[45:04] and this fourth value I believe it is is
[45:08] where you store the result or where age
[45:11] search stores the result
[45:13] if we kind of Trace through the logic
[45:16] here
[45:18] it looks like that is in fact
[45:20] what gets returned
[45:23] so
[45:24] you can just rename this to
[45:27] value it's the value corresponding to
[45:29] the key
[45:30] it gets returned
[45:32] okay
[45:34] so this kind of makes sense if you if
[45:37] you think about
[45:39] this as a as a key value pair submit
[45:42] button has a corresponding value in this
[45:46] case I believe it was management yeah
[45:51] then all this is doing is just querying
[45:53] a hash table that presumably contains
[45:56] all of the different key value pairs
[45:59] that are included in the in the request
[46:01] body
[46:02] and returns only the value that we care
[46:05] about for further processing
[46:11] as and as we can see this gets used
[46:14] later on it's validated for cross-site
[46:16] scripting and
[46:19] used in in various ways
[46:23] okay great so now we know
[46:26] how data gets sent from the client to
[46:28] the server and we know how it's parsed
[46:31] on the other end
[46:32] so we're already well on our way to
[46:34] figuring out how to
[46:36] inject our own our own stuff in here
[46:41] fantastic
[46:46] so I can just save that off
[46:49] or actually you know I'll just I'll just
[46:52] go ahead and
[46:53] and keep it open
[46:57] we might want to use that later
[47:01] so there's a lot more that we could do
[47:03] at this stage just more playing around
[47:04] on the on the Management console
[47:07] but what I would really like to do is is
[47:10] get some more detail I kind of want to
[47:12] follow up on that vulnerability that we
[47:13] found or not found but that we
[47:16] learned about in this in this blog and
[47:19] see if we can actually get a shell
[47:22] on the router so
[47:24] I remember
[47:25] that this guy included a puck here yeah
[47:29] he made a repository for it so let's
[47:33] take a peek at this
[47:37] to GitHub repo oh yeah that requires
[47:40] internet doesn't it
[47:46] I haven't connected the router to the
[47:48] internet
[47:49] just FYI okay so now we should be able
[47:51] to load this up
[48:00] all right so this looks like
[48:01] instructions and all this is python okay
[48:05] great
[48:06] well I'll go ahead and clone this
[48:20] and it looks like
[48:23] well you know what it's always it's
[48:25] always a good idea just to follow the
[48:27] instructions so
[48:28] just for good measure I'll go ahead and
[48:30] install whatever requirements are needed
[48:35] okay it looks like we already have all
[48:36] of them that's good
[48:38] and you know what I'll just create a
[48:40] script for this I'll just call it
[48:44] run
[48:55] that with Bash
[48:59] let's copy all this stuff in there
[49:10] when in doubt follow the instructions
[49:13] so it looks like
[49:16] the router host has a different IP
[49:20] so I'll just change this really quick
[49:22] that's our IP
[49:24] username and password are the same
[49:26] interestingly enough
[49:28] ooh what's my IP
[49:31] switch back to the router
[49:44] okay
[49:46] [Music]
[49:51] oh
[49:55] it doesn't seem to appear here
[50:01] that's the wrong subnet
[50:03] okay that's probably just because I'm
[50:06] I'm using WSL
[50:09] so
[50:11] if I just roll through here
[50:15] maybe it'll tell me where
[50:17] the addresses start oh here we go okay
[50:21] so starting IP address is
[50:25] our subnet starting up at 100.
[50:28] okay
[50:30] so I bet that my IP on this network that
[50:34] includes only my host and the router
[50:38] is
[50:41] 192.168.1.100.
[50:46] a little bit of guesswork here but I
[50:48] think it's probably a safe bet
[50:50] All Things Considered so
[50:53] I'll just keep that the way it is just
[50:54] change the
[50:55] subnet part there we go and then there's
[50:58] this attack attacker HTTP service host
[51:04] okay
[51:06] oh that's right because we have to set
[51:08] up a server to serve up the reverse
[51:10] shell that he downloads yeah okay
[51:13] so that's this bit
[51:15] and then we need to start a netcat
[51:17] Handler
[51:20] to receive the reverse shell
[51:23] okay and then it's running the exploit
[51:25] so given that I'm working in WSL I'm
[51:27] just gonna have to comment all this out
[51:28] and do that in Powershell
[51:33] fortunately I know how to do that so I'm
[51:34] just gonna
[51:39] change directory into here this is where
[51:41] we'll set up our
[51:45] our python server
[51:47] and I have to copy the reverse shell so
[51:50] there's this
[51:52] rev shell folder
[51:54] that contains two things so
[51:57] let's see
[51:59] should be source and
[52:02] the binary okay great
[52:05] cool so this is an L file this is the
[52:07] cross-compiled reverse shell for
[52:10] nips little endian and then here's the
[52:13] source so let's just take a look at the
[52:14] source for good measure
[52:19] so this is a super simple program as you
[52:22] can see literally all all that it does
[52:24] is create the connection
[52:27] and then on that connection say okay
[52:30] yeah we're interacting with Ben sh
[52:33] it great
[52:34] and so this is already cross-compiled so
[52:36] we need to copy it
[52:39] into
[52:42] my Windows system where it is reachable
[52:44] from the outside world
[52:51] oh looks like I've already done this
[52:53] makes sense okay
[52:57] so there we go now we'll go back to
[52:58] Powershell
[53:00] and we'll start up a python server this
[53:04] by the way is the python 2
[53:07] Syntax for doing this I'm using python3
[53:10] so it's just going to be a little bit
[53:11] different but it's the same exact thing
[53:14] and then we're setting the
[53:17] the server port to 8000. okay great so
[53:21] I'll just go ahead and start
[53:23] that server right there
[53:29] now I'm going to need another one
[53:31] is going to be our netcat Handler so
[53:34] it's netcat.exe
[53:37] is that right yeah
[53:40] yeah
[53:42] and then we're going to say that we're
[53:43] listening and we're going to listen on
[53:45] Port 4141
[53:47] pretty arbitrary but just keeping the
[53:49] defaults here
[53:52] okay so now this is just listening for
[53:55] connections it's not really doing
[53:56] anything now
[53:59] and then this final command actually
[54:02] runs the exploit now do I have just
[54:04] normal python
[54:07] I do okay good so I'll need to change
[54:09] that to python 3.
[54:11] all right well
[54:14] moment of truth let's just make this
[54:16] runnable
[54:19] and see what we get here
[54:24] so here we go it says it's running this
[54:27] command
[54:28] that is attempting to download
[54:31] the reverse Shell let's see if it did
[54:33] okay yep it worked so we got a get
[54:36] request for the reverse shell
[54:38] and then
[54:40] it's making it executable
[54:45] and then it's running the reverse shell
[54:46] on our IP
[54:48] on poor 441 so now if I were to example
[54:52] just run LS assuming that I got the IP
[54:55] correct this should give us some results
[54:58] and it does Okay so
[55:01] these are all those ASP files that we
[55:03] saw in the www folder so it looks like
[55:09] the httpb program is being run from that
[55:12] folder maybe not quite sure I guess it
[55:14] doesn't really matter
[55:16] but if we LS in in root we see
[55:20] the file system that we would expect
[55:23] okay fantastic
[55:24] so now we have an active session on the
[55:29] device where we can issue commands and
[55:31] read more information so it's time to do
[55:33] to do just a little bit more Recon here
[55:35] so what happens if I run
[55:37] PS
[55:42] so if I run PS I get all of the
[55:45] processes that are are currently running
[55:48] on the device including by the way
[55:50] the command
[55:53] that is spawning our reverse shell or
[55:56] that spawned our reverse shell and as
[55:58] you can see it's all janky since it was
[56:00] done by command injections so let's just
[56:02] copy this off
[56:17] and let's see what else can we run we
[56:19] can run DF
[56:22] oh DF isn't there okay what about
[56:26] I have config I saw that
[56:30] Maybe
[56:34] no there we go
[56:39] okay so we have a bunch
[56:43] I don't know if I want to copy off all
[56:45] of this
[56:48] but we definitely could certainly the
[56:49] first couple
[56:52] or just all of it went on camera
[57:08] and that's a lot
[57:13] but it's always good to copy off this
[57:16] information before you've done any
[57:18] experimentation
[57:19] on the router just because you know
[57:21] things might change later on so what
[57:24] else what about Mount
[57:27] not that okay
[57:29] I'm just trying to think of commands
[57:31] here that are
[57:32] they're going to give us interesting
[57:34] information about the status of the
[57:36] system
[57:38] okay
[57:41] well I'm just going to put that kind of
[57:43] down below good to keep if necessary but
[57:46] I don't want it getting in our way here
[57:51] so what else can we do here
[57:53] well
[57:54] not a lot other than just create some
[57:56] files let's see if the whole thing is
[57:59] writable so let's just try to
[58:01] touch
[58:03] the file in the root
[58:07] okay read-only file system
[58:13] all right well what about
[58:15] VAR
[58:28] all right cool it looks like I can I can
[58:30] write to VAR
[58:31] I can almost certainly write a temp
[58:42] yep there we go and we see our reverse
[58:45] shell which got renamed at X
[58:48] right there
[58:50] okay great
[58:53] now one thing I I can't do or well maybe
[58:57] I can but I'm not sure what command
[58:58] would do this that I have access to I
[59:01] can't see how much space we have but I
[59:04] can of course as we've already
[59:06] demonstrated here use wget to download
[59:09] stuff from my host to the router
[59:13] so that's really useful
[59:15] tremendously useful actually
[59:18] so
[59:20] at this point we've been able to do
[59:22] recon at three different levels we we
[59:24] first took a look at what information we
[59:27] could find
[59:29] without ever even having to touch the
[59:31] router without even having to get it set
[59:33] up we were able to download the latest
[59:34] firmware figure out roughly what kinds
[59:37] of files programs services are are on
[59:41] there
[59:42] and we were able to find a vulnerability
[59:45] that does in fact affect our router and
[59:49] then eventually confirm it
[59:51] once we were able to get the router up
[59:53] up and running and load up the
[59:55] Management console we we were able to
[59:57] figure out
[59:58] which ports are open we noticed that
[60:00] there was the the web server
[60:03] and a up mp service which I believe we
[60:07] also confirmed here just by the the PS
[60:10] output
[60:11] yeah there it is UPnP is definitely
[60:13] running
[60:17] we were also able to figure out how user
[60:22] input is transferred from the client to
[60:24] the server and how it gets parsed on the
[60:26] other end
[60:27] it gets put into a hash table and that
[60:31] get CGI function
[60:33] fetches it
[60:35] so then once we were able to get this
[60:38] Pock working
[60:40] this commanded injection exploit we were
[60:42] able to get a full reverse shell with I
[60:47] believe root privileges
[60:50] I'm pretty sure that this is running as
[60:52] root yep yep uid zero okay so httpd is
[60:56] is running its root we were able to get
[60:58] a reverse shell
[61:00] on the router
[61:01] so that's fantastic we've been able to
[61:04] do recon at three different levels and
[61:06] we have the ability to run arbitrary
[61:08] commands on the file system provided
[61:10] that they're supported
[61:13] so we're now set up really well to look
[61:16] for vulnerabilities and develop our own
[61:19] exploits but that's for another video
