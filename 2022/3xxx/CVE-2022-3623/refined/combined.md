=== Content from www.debian.org_92bfbf63_20250114_221558.html ===


---

[[Date Prev](msg00012.html)][[Date Next](msg00014.html)]
[[Thread Prev](msg00012.html)][[Thread Next](msg00014.html)]
[[Date Index](maillist.html#00013)]
[[Thread Index](threads.html#00013)]

# [SECURITY] [DSA 5324-1] linux security update

---

* *To*: debian-security-announce@lists.debian.org
* *Subject*: [SECURITY] [DSA 5324-1] linux security update
* *From*: Salvatore Bonaccorso <carnil@debian.org>
* *Date*: Mon, 23 Jan 2023 20:11:44 +0000
* *Message-id*: <[[ðŸ”Ž]](/msgid-search/E1pK3AO-006ihI-7r%40seger.debian.org)Â [E1pK3AO-006ihI-7r@seger.debian.org](msg00013.html)>
* *Reply-to*: debian-security-announce-request@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

- -------------------------------------------------------------------------
Debian Security Advisory DSA-5324-1                   security@debian.org
<https://www.debian.org/security/>                     Salvatore Bonaccorso
January 23, 2023                      <https://www.debian.org/security/faq>
- -------------------------------------------------------------------------

Package        : linux
CVE ID         : CVE-2022-2873 CVE-2022-3545 CVE-2022-3623 CVE-2022-4696
                 CVE-2022-36280 CVE-2022-41218 CVE-2022-45934 CVE-2022-47929
                 CVE-2023-0179 CVE-2023-0266 CVE-2023-0394 CVE-2023-23454
                 CVE-2023-23455

Several vulnerabilities have been discovered in the Linux kernel that
may lead to a privilege escalation, denial of service or information
leaks.

CVE-2022-2873

    Zheyu Ma discovered that an out-of-bounds memory access flaw in the
    Intel iSMT SMBus 2.0 host controller driver may result in denial of
    service (system crash).

CVE-2022-3545

    It was discovered that the Netronome Flow Processor (NFP) driver
    contained a use-after-free flaw in area_cache_get(), which may
    result in denial of service or the execution of arbitrary code.

CVE-2022-3623

    A race condition when looking up a CONT-PTE/PMD size hugetlb page
    may result in denial of service or an information leak.

CVE-2022-4696

    A use-after-free vulnerability was discovered in the io_uring
    subsystem.

CVE-2022-36280

    An out-of-bounds memory write vulnerability was discovered in the
    vmwgfx driver, which may allow a local unprivileged user to cause a
    denial of service (system crash).

CVE-2022-41218

    Hyunwoo Kim reported a use-after-free flaw in the Media DVB core
    subsystem caused by refcount races, which may allow a local user to
    cause a denial of service or escalate privileges.

CVE-2022-45934

    An integer overflow in l2cap_config_req() in the Bluetooth subsystem
    was discovered, which may allow a physically proximate attacker to
    cause a denial of service (system crash).

CVE-2022-47929

    Frederick Lawler reported a NULL pointer dereference in the traffic
    control subsystem allowing an unprivileged user to cause a denial of
    service by setting up a specially crafted traffic control
    configuration.

CVE-2023-0179

    Davide Ornaghi discovered incorrect arithmetics when fetching VLAN
    header bits in the netfilter subsystem, allowing a local user to
    leak stack and heap addresses or potentially local privilege
    escalation to root.

CVE-2023-0266

    A use-after-free flaw in the sound subsystem due to missing locking
    may result in denial of service or privilege escalation.

CVE-2023-0394

    Kyle Zeng discovered a NULL pointer dereference flaw in
    rawv6_push_pending_frames() in the network subsystem allowing a
    local user to cause a denial of service (system crash).

CVE-2023-23454

    Kyle Zeng reported that the Class Based Queueing (CBQ) network
    scheduler was prone to denial of service due to interpreting
    classification results before checking the classification
    return code.

CVE-2023-23455

    Kyle Zeng reported that the ATM Virtual Circuits (ATM) network
    scheduler was prone to a denial of service due to interpreting
    classification results before checking the classification
    return code.

For the stable distribution (bullseye), these problems have been fixed in
version 5.10.162-1.

We recommend that you upgrade your linux packages.

For the detailed security status of linux please refer to its security
tracker page at:
<https://security-tracker.debian.org/tracker/linux>

Further information about Debian Security Advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://www.debian.org/security/>

Mailing list: debian-security-announce@lists.debian.org
-----BEGIN PGP SIGNATURE-----

iQKTBAEBCgB9FiEERkRAmAjBceBVMd3uBUy48xNDz0QFAmPO6CtfFIAAAAAALgAo
aXNzdWVyLWZwckBub3RhdGlvbnMub3BlbnBncC5maWZ0aGhvcnNlbWFuLm5ldDQ2
NDQ0MDk4MDhDMTcxRTA1NTMxRERFRTA1NENCOEYzMTM0M0NGNDQACgkQBUy48xND
z0Ra0w//fLN39l/vLOzDs++lrDvYDVGpTFS/D3CfMq6ucxI36BEoxPXk5aKyH/la
red6SnuLf7lI+4CcH3vvLpo1vHreqOXRXoE/u1JdWij9vvLHyHjJKLgCkn43UlLN
ukdEnmls3DCJr42apdHhV7nyjLXfBzocgOfq8+oOUHS2/K2SPYc1dqtn96Dsmogu
nH/Mcorr9kHX1wjWtCPQCCSsjo3+xxRzc1WDpbdqolox979s7hFSIqZ65T74w/mV
KksIg/4CJHNlwo/piiwH6/Gi419v6Tj4HPUPcJpFEJou6adnnXqrBX+aNE9WvHEe
Y/Fmj2DSxBvCJ+MKzCVWNf94lfjxcb4mE8VlUxUTa6BR0BGC7/iKDz0HglYPnbue
zdNMEUcsgw3pxLB9sorFmcPbKOgzquwp2WLGCPxw04UMDmK5bBTZ/zKVa1b639C9
BGeOmDCfg9+b33Er9pKvvuky/C3divGbZ3TnWKcztVPR33Y2e2E1WtvvbLtayFsO
0ezn8r7vNCu+3hBTT09wXJQzil7o1zyfb9MwtzgSuxksLoFbm/B21rw1KEzTgyCC
FiQDJF2OQNmzKJokNgsmpIknx75/x1WG1UQbMeO15tZW8zSjItrDtiydw8Uyrs+8
BU0Ta3tiqtyOrlc22k+K2yDWrg16pRw9ik3iNokYgM7z/RcHwv4=
=7Ixp
-----END PGP SIGNATURE-----

```

---



=== Content from lists.debian.org_2bafc90c_20250114_221557.html ===


---

[Date Prev][[Date Next](msg00001.html)]
[Thread Prev][[Thread Next](msg00001.html)]
[[Date Index](maillist.html#00000)]
[[Thread Index](threads.html#00000)]

# [SECURITY] [DLA 3349-1] linux-5.10 security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 3349-1] linux-5.10 security update
* *From*: Ben Hutchings <benh@debian.org>
* *Date*: Thu, 2 Mar 2023 23:05:14 +0100
* *Message-id*: <[[ðŸ”Ž]](/msgid-search/ZAEdmsNQXriVISie%40decadent.org.uk)Â [ZAEdmsNQXriVISie@decadent.org.uk](msg00000.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-------------------------------------------------------------------------
Debian LTS Advisory DLA-3349-1                debian-lts@lists.debian.org
<https://www.debian.org/lts/security/>                        Ben Hutchings
March 02, 2023                                <https://wiki.debian.org/LTS>
-------------------------------------------------------------------------

Package        : linux-5.10
Version        : 5.10.162-1~deb10u1
CVE ID         : CVE-2022-2873 CVE-2022-3545 CVE-2022-3623 CVE-2022-4696
                 CVE-2022-36280 CVE-2022-41218 CVE-2022-45934 CVE-2022-47929
                 CVE-2023-0179 CVE-2023-0240 CVE-2023-0266 CVE-2023-0394
                 CVE-2023-23454  CVE-2023-23455 CVE-2023-23586
Debian Bug     : 825141 1008501 1027430 1027483

Several vulnerabilities have been discovered in the Linux kernel that
may lead to a privilege escalation, denial of service or information
leaks.

CVE-2022-2873

    Zheyu Ma discovered that an out-of-bounds memory access flaw in
    the Intel iSMT SMBus 2.0 host controller driver may result in
    denial of service (system crash).

CVE-2022-3545

    It was discovered that the Netronome Flow Processor (NFP) driver
    contained a use-after-free flaw in area_cache_get(), which may
    result in denial of service or the execution of arbitrary code.

CVE-2022-3623

    A race condition when looking up a CONT-PTE/PMD size hugetlb page
    may result in denial of service or an information leak.

CVE-2022-4696

    A use-after-free vulnerability was discovered in the io_uring
    subsystem.

CVE-2022-36280

    An out-of-bounds memory write vulnerability was discovered in the
    vmwgfx driver, which may allow a local unprivileged user to cause
    a denial of service (system crash).

CVE-2022-41218

    Hyunwoo Kim reported a use-after-free flaw in the Media DVB core
    subsystem caused by refcount races, which may allow a local user
    to cause a denial of service or escalate privileges.

CVE-2022-45934

    An integer overflow in l2cap_config_req() in the Bluetooth
    subsystem was discovered, which may allow a physically proximate
    attacker to cause a denial of service (system crash).

CVE-2022-47929

    Frederick Lawler reported a NULL pointer dereference in the
    traffic control subsystem allowing an unprivileged user to cause a
    denial of service by setting up a specially crafted traffic
    control configuration.

CVE-2023-0179

    Davide Ornaghi discovered incorrect arithmetics when fetching VLAN
    header bits in the netfilter subsystem, allowing a local user to
    leak stack and heap addresses or potentially local privilege
    escalation to root.

CVE-2023-0240

    A flaw was discovered in the io_uring subsystem that could lead
    to a use-after-free.  A local user could exploit this to cause
    a denial of service (crash or memory corruption) or possibly for
    privilege escalation.

CVE-2023-0266

    A use-after-free flaw in the sound subsystem due to missing
    locking may result in denial of service or privilege escalation.

CVE-2023-0394

    Kyle Zeng discovered a NULL pointer dereference flaw in
    rawv6_push_pending_frames() in the network subsystem allowing a
    local user to cause a denial of service (system crash).

CVE-2023-23454

    Kyle Zeng reported that the Class Based Queueing (CBQ) network
    scheduler was prone to denial of service due to interpreting
    classification results before checking the classification return
    code.

CVE-2023-23455

    Kyle Zeng reported that the ATM Virtual Circuits (ATM) network
    scheduler was prone to a denial of service due to interpreting
    classification results before checking the classification return
    code.

CVE-2023-23586

    A flaw was discovered in the io_uring subsystem that could lead to
    an information leak.  A local user could exploit this to obtain
    sensitive information from the kernel or other users.

For Debian 10 buster, these problems have been fixed in version
5.10.162-1~deb10u1.

This update also fixes Debian bugs #825141, #1008501, #1027430, and
#1027483, and includes many more bug fixes from stable updates
5.10.159-5.10.162 inclusive.

We recommend that you upgrade your linux-5.10 packages.

For the detailed security status of linux-5.10 please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/linux-5.10>

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>

```

**Attachment:
[signature.asc](pgpaqzwJDO6b5.pgp)**

*Description:* PGP signature

---



=== Content from git.kernel.org_22c570fc_20250114_221557.html ===


| [cgit logo](/) | [index](/) : [kernel/git/bpf/bpf-next.git](/pub/scm/linux/kernel/git/bpf/bpf-next.git/) | for-next master net |
| --- | --- | --- |
| BPF next kernel tree | BPF Group |

| [about](/pub/scm/linux/kernel/git/bpf/bpf-next.git/about/)[summary](/pub/scm/linux/kernel/git/bpf/bpf-next.git/)[refs](/pub/scm/linux/kernel/git/bpf/bpf-next.git/refs/?id=fac35ba763ed07ba93154c95ffc0c4a55023707f)[log](/pub/scm/linux/kernel/git/bpf/bpf-next.git/log/)[tree](/pub/scm/linux/kernel/git/bpf/bpf-next.git/tree/?id=fac35ba763ed07ba93154c95ffc0c4a55023707f)[commit](/pub/scm/linux/kernel/git/bpf/bpf-next.git/commit/?id=fac35ba763ed07ba93154c95ffc0c4a55023707f)[diff](/pub/scm/linux/kernel/git/bpf/bpf-next.git/diff/?id=fac35ba763ed07ba93154c95ffc0c4a55023707f)[stats](/pub/scm/linux/kernel/git/bpf/bpf-next.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Baolin Wang <baolin.wang@linux.alibaba.com> | 2022-09-01 18:41:31 +0800 |
| --- | --- | --- |
| committer | Andrew Morton <akpm@linux-foundation.org> | 2022-10-11 19:05:44 -0700 |
| commit | [fac35ba763ed07ba93154c95ffc0c4a55023707f](/pub/scm/linux/kernel/git/bpf/bpf-next.git/commit/?id=fac35ba763ed07ba93154c95ffc0c4a55023707f) ([patch](/pub/scm/linux/kernel/git/bpf/bpf-next.git/patch/?id=fac35ba763ed07ba93154c95ffc0c4a55023707f)) | |
| tree | [1481c3ae84db3e9eeb1fa5d11e9fcffe489f3f81](/pub/scm/linux/kernel/git/bpf/bpf-next.git/tree/?id=fac35ba763ed07ba93154c95ffc0c4a55023707f) | |
| parent | [1c8e2349f2d033f634d046063b704b2ca6c46972](/pub/scm/linux/kernel/git/bpf/bpf-next.git/commit/?id=1c8e2349f2d033f634d046063b704b2ca6c46972) ([diff](/pub/scm/linux/kernel/git/bpf/bpf-next.git/diff/?id=fac35ba763ed07ba93154c95ffc0c4a55023707f&id2=1c8e2349f2d033f634d046063b704b2ca6c46972)) | |
| download | [bpf-next-fac35ba763ed07ba93154c95ffc0c4a55023707f.tar.gz](/pub/scm/linux/kernel/git/bpf/bpf-next.git/snapshot/bpf-next-fac35ba763ed07ba93154c95ffc0c4a55023707f.tar.gz) | |

mm/hugetlb: fix races when looking up a CONT-PTE/PMD size hugetlb pageOn some architectures (like ARM64), it can support CONT-PTE/PMD size
hugetlb, which means it can support not only PMD/PUD size hugetlb (2M and
1G), but also CONT-PTE/PMD size(64K and 32M) if a 4K page size specified.
So when looking up a CONT-PTE size hugetlb page by follow\_page(), it will
use pte\_offset\_map\_lock() to get the pte entry lock for the CONT-PTE size
hugetlb in follow\_page\_pte(). However this pte entry lock is incorrect
for the CONT-PTE size hugetlb, since we should use huge\_pte\_lock() to get
the correct lock, which is mm->page\_table\_lock.
That means the pte entry of the CONT-PTE size hugetlb under current pte
lock is unstable in follow\_page\_pte(), we can continue to migrate or
poison the pte entry of the CONT-PTE size hugetlb, which can cause some
potential race issues, even though they are under the 'pte lock'.
For example, suppose thread A is trying to look up a CONT-PTE size hugetlb
page by move\_pages() syscall under the lock, however antoher thread B can
migrate the CONT-PTE hugetlb page at the same time, which will cause
thread A to get an incorrect page, if thread A also wants to do page
migration, then data inconsistency error occurs.
Moreover we have the same issue for CONT-PMD size hugetlb in
follow\_huge\_pmd().
To fix above issues, rename the follow\_huge\_pmd() as follow\_huge\_pmd\_pte()
to handle PMD and PTE level size hugetlb, which uses huge\_pte\_lock() to
get the correct pte entry lock to make the pte entry stable.
Mike said:
Support for CONT\_PMD/\_PTE was added with bb9dd3df8ee9 ("arm64: hugetlb:
refactor find\_num\_contig()"). Patch series "Support for contiguous pte
hugepages", v4. However, I do not believe these code paths were
executed until migration support was added with 5480280d3f2d ("arm64/mm:
enable HugeTLB migration for contiguous bit HugeTLB pages") I would go
with 5480280d3f2d for the Fixes: targe.
Link: [https://lkml.kernel.org/r/635f43bdd85ac2615a58405da82b4d33c6e5eb05.1662017562.git.baolin.wang@linux.alibaba.com](https://lkml.kernel.org/r/635f43bdd85ac2615a58405da82b4d33c6e5eb05.1662017562.git.baolin.wang%40linux.alibaba.com)
Fixes: 5480280d3f2d ("arm64/mm: enable HugeTLB migration for contiguous bit HugeTLB pages")
Signed-off-by: Baolin Wang <baolin.wang@linux.alibaba.com>
Suggested-by: Mike Kravetz <mike.kravetz@oracle.com>
Reviewed-by: Mike Kravetz <mike.kravetz@oracle.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: Muchun Song <songmuchun@bytedance.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
[Diffstat](/pub/scm/linux/kernel/git/bpf/bpf-next.git/diff/?id=fac35ba763ed07ba93154c95ffc0c4a55023707f)

| -rw-r--r-- | [include/linux/hugetlb.h](/pub/scm/linux/kernel/git/bpf/bpf-next.git/diff/include/linux/hugetlb.h?id=fac35ba763ed07ba93154c95ffc0c4a55023707f) | 8 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [mm/gup.c](/pub/scm/linux/kernel/git/bpf/bpf-next.git/diff/mm/gup.c?id=fac35ba763ed07ba93154c95ffc0c4a55023707f) | 14 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [mm/hugetlb.c](/pub/scm/linux/kernel/git/bpf/bpf-next.git/diff/mm/hugetlb.c?id=fac35ba763ed07ba93154c95ffc0c4a55023707f) | 27 | |  |  |  | | --- | --- | --- | |

3 files changed, 30 insertions, 19 deletions

| diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.hindex 3ec981a0d8b3a5..67c88b82fc32d4 100644--- a/[include/linux/hugetlb.h](/pub/scm/linux/kernel/git/bpf/bpf-next.git/tree/include/linux/hugetlb.h?id=1c8e2349f2d033f634d046063b704b2ca6c46972)+++ b/[include/linux/hugetlb.h](/pub/scm/linux/kernel/git/bpf/bpf-next.git/tree/include/linux/hugetlb.h?id=fac35ba763ed07ba93154c95ffc0c4a55023707f)@@ -207,8 +207,8 @@ struct page \*follow\_huge\_addr(struct mm\_struct \*mm, unsigned long address, struct page \*follow\_huge\_pd(struct vm\_area\_struct \*vma, unsigned long address, hugepd\_t hpd, int flags, int pdshift);-struct page \*follow\_huge\_pmd(struct mm\_struct \*mm, unsigned long address,- pmd\_t \*pmd, int flags);+struct page \*follow\_huge\_pmd\_pte(struct vm\_area\_struct \*vma, unsigned long address,+ int flags); struct page \*follow\_huge\_pud(struct mm\_struct \*mm, unsigned long address, pud\_t \*pud, int flags); struct page \*follow\_huge\_pgd(struct mm\_struct \*mm, unsigned long address,@@ -312,8 +312,8 @@ static inline struct page \*follow\_huge\_pd(struct vm\_area\_struct \*vma, return NULL; } -static inline struct page \*follow\_huge\_pmd(struct mm\_struct \*mm,- unsigned long address, pmd\_t \*pmd, int flags)+static inline struct page \*follow\_huge\_pmd\_pte(struct vm\_area\_struct \*vma,+ unsigned long address, int flags) { return NULL; }diff --git a/mm/gup.c b/mm/gup.cindex 00926abb44263b..251cb6a10bc0d6 100644--- a/[mm/gup.c](/pub/scm/linux/kernel/git/bpf/bpf-next.git/tree/mm/gup.c?id=1c8e2349f2d033f634d046063b704b2ca6c46972)+++ b/[mm/gup.c](/pub/scm/linux/kernel/git/bpf/bpf-next.git/tree/mm/gup.c?id=fac35ba763ed07ba93154c95ffc0c4a55023707f)@@ -530,6 +530,18 @@ static struct page \*follow\_page\_pte(struct vm\_area\_struct \*vma, if (WARN\_ON\_ONCE((flags & (FOLL\_PIN | FOLL\_GET)) == (FOLL\_PIN | FOLL\_GET))) return ERR\_PTR(-EINVAL);++ /\*+ \* Considering PTE level hugetlb, like continuous-PTE hugetlb on+ \* ARM64 architecture.+ \*/+ if (is\_vm\_hugetlb\_page(vma)) {+ page = follow\_huge\_pmd\_pte(vma, address, flags);+ if (page)+ return page;+ return no\_page\_table(vma, flags);+ }+ retry: if (unlikely(pmd\_bad(\*pmd))) return no\_page\_table(vma, flags);@@ -662,7 +674,7 @@ static struct page \*follow\_pmd\_mask(struct vm\_area\_struct \*vma, if (pmd\_none(pmdval)) return no\_page\_table(vma, flags); if (pmd\_huge(pmdval) && is\_vm\_hugetlb\_page(vma)) {- page = follow\_huge\_pmd(mm, address, pmd, flags);+ page = follow\_huge\_pmd\_pte(vma, address, flags); if (page) return page; return no\_page\_table(vma, flags);diff --git a/mm/hugetlb.c b/mm/hugetlb.cindex 0bdfc7e1c933f5..9564bf817e6a8d 100644--- a/[mm/hugetlb.c](/pub/scm/linux/kernel/git/bpf/bpf-next.git/tree/mm/hugetlb.c?id=1c8e2349f2d033f634d046063b704b2ca6c46972)+++ b/[mm/hugetlb.c](/pub/scm/linux/kernel/git/bpf/bpf-next.git/tree/mm/hugetlb.c?id=fac35ba763ed07ba93154c95ffc0c4a55023707f)@@ -6946,12 +6946,13 @@ follow\_huge\_pd(struct vm\_area\_struct \*vma, }  struct page \* \_\_weak-follow\_huge\_pmd(struct mm\_struct \*mm, unsigned long address,- pmd\_t \*pmd, int flags)+follow\_huge\_pmd\_pte(struct vm\_area\_struct \*vma, unsigned long address, int flags) {+ struct hstate \*h = hstate\_vma(vma);+ struct mm\_struct \*mm = vma->vm\_mm; struct page \*page = NULL; spinlock\_t \*ptl;- pte\_t pte;+ pte\_t \*ptep, pte;  /\* \* FOLL\_PIN is not supported for follow\_page(). Ordinary GUP goes via@@ -6961,17 +6962,15 @@ follow\_huge\_pmd(struct mm\_struct \*mm, unsigned long address, return NULL;  retry:- ptl = pmd\_lockptr(mm, pmd);- spin\_lock(ptl);- /\*- \* make sure that the address range covered by this pmd is not- \* unmapped from other threads.- \*/- if (!pmd\_huge(\*pmd))- goto out;- pte = huge\_ptep\_get((pte\_t \*)pmd);+ ptep = huge\_pte\_offset(mm, address, huge\_page\_size(h));+ if (!ptep)+ return NULL;++ ptl = huge\_pte\_lock(h, mm, ptep);+ pte = huge\_ptep\_get(ptep); if (pte\_present(pte)) {- page = pmd\_page(\*pmd) + ((address & ~PMD\_MASK) >> PAGE\_SHIFT);+ page = pte\_page(pte) ++ ((address & ~huge\_page\_mask(h)) >> PAGE\_SHIFT); /\* \* try\_grab\_page() should always succeed here, because: a) we \* hold the pmd (ptl) lock, and b) we've just checked that the@@ -6987,7 +6986,7 @@ retry: } else { if (is\_hugetlb\_entry\_migration(pte)) { spin\_unlock(ptl);- \_\_migration\_entry\_wait\_huge((pte\_t \*)pmd, ptl);+ \_\_migration\_entry\_wait\_huge(ptep, ptl); goto retry; } /\* |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 22:14:34 +0000


