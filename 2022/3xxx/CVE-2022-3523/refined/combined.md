=== Content from git.kernel.org_fc50d926_20250114_225401.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=16ce101db85db694a91380aa4c89b25530871d33)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=16ce101db85db694a91380aa4c89b25530871d33)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=16ce101db85db694a91380aa4c89b25530871d33)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=16ce101db85db694a91380aa4c89b25530871d33)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Alistair Popple <apopple@nvidia.com> | 2022-09-28 22:01:15 +1000 |
| --- | --- | --- |
| committer | Andrew Morton <akpm@linux-foundation.org> | 2022-10-12 18:51:49 -0700 |
| commit | [16ce101db85db694a91380aa4c89b25530871d33](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=16ce101db85db694a91380aa4c89b25530871d33) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=16ce101db85db694a91380aa4c89b25530871d33)) | |
| tree | [8023eea5468f1475b012e82d2709ef97b50db864](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=16ce101db85db694a91380aa4c89b25530871d33) | |
| parent | [ab63f63f3885d492e62da55304b0483a2a9e6a7d](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ab63f63f3885d492e62da55304b0483a2a9e6a7d) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=16ce101db85db694a91380aa4c89b25530871d33&id2=ab63f63f3885d492e62da55304b0483a2a9e6a7d)) | |
| download | [linux-16ce101db85db694a91380aa4c89b25530871d33.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-16ce101db85db694a91380aa4c89b25530871d33.tar.gz) | |

mm/memory.c: fix race when faulting a device private pagePatch series "Fix several device private page reference counting issues",
v2
This series aims to fix a number of page reference counting issues in
drivers dealing with device private ZONE\_DEVICE pages. These result in
use-after-free type bugs, either from accessing a struct page which no
longer exists because it has been removed or accessing fields within the
struct page which are no longer valid because the page has been freed.
During normal usage it is unlikely these will cause any problems. However
without these fixes it is possible to crash the kernel from userspace.
These crashes can be triggered either by unloading the kernel module or
unbinding the device from the driver prior to a userspace task exiting.
In modules such as Nouveau it is also possible to trigger some of these
issues by explicitly closing the device file-descriptor prior to the task
exiting and then accessing device private memory.
This involves some minor changes to both PowerPC and AMD GPU code.
Unfortunately I lack hardware to test either of those so any help there
would be appreciated. The changes mimic what is done in for both Nouveau
and hmm-tests though so I doubt they will cause problems.
This patch (of 8):
When the CPU tries to access a device private page the migrate\_to\_ram()
callback associated with the pgmap for the page is called. However no
reference is taken on the faulting page. Therefore a concurrent migration
of the device private page can free the page and possibly the underlying
pgmap. This results in a race which can crash the kernel due to the
migrate\_to\_ram() function pointer becoming invalid. It also means drivers
can't reliably read the zone\_device\_data field because the page may have
been freed with memunmap\_pages().
Close the race by getting a reference on the page while holding the ptl to
ensure it has not been freed. Unfortunately the elevated reference count
will cause the migration required to handle the fault to fail. To avoid
this failure pass the faulting page into the migrate\_vma functions so that
if an elevated reference count is found it can be checked to see if it's
expected or not.
[mpe@ellerman.id.au: fix build]
Link: https://lkml.kernel.org/r/87fsgbf3gh.fsf@mpe.ellerman.id.au
Link: [https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple@nvidia.com](https://lkml.kernel.org/r/cover.60659b549d8509ddecafad4f498ee7f03bb23c69.1664366292.git-series.apopple%40nvidia.com)
Link: [https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple@nvidia.com](https://lkml.kernel.org/r/d3e813178a59e565e8d78d9b9a4e2562f6494f90.1664366292.git-series.apopple%40nvidia.com)
Signed-off-by: Alistair Popple <apopple@nvidia.com>
Acked-by: Felix Kuehling <Felix.Kuehling@amd.com>
Cc: Jason Gunthorpe <jgg@nvidia.com>
Cc: John Hubbard <jhubbard@nvidia.com>
Cc: Ralph Campbell <rcampbell@nvidia.com>
Cc: Michael Ellerman <mpe@ellerman.id.au>
Cc: Lyude Paul <lyude@redhat.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: Alex Sierra <alex.sierra@amd.com>
Cc: Ben Skeggs <bskeggs@redhat.com>
Cc: Christian KÃ¶nig <christian.koenig@amd.com>
Cc: Dan Williams <dan.j.williams@intel.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: "Huang, Ying" <ying.huang@intel.com>
Cc: Matthew Wilcox <willy@infradead.org>
Cc: Yang Shi <shy828301@gmail.com>
Cc: Zi Yan <ziy@nvidia.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=16ce101db85db694a91380aa4c89b25530871d33)

| -rw-r--r-- | [arch/powerpc/kvm/book3s\_hv\_uvmem.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/arch/powerpc/kvm/book3s_hv_uvmem.c?id=16ce101db85db694a91380aa4c89b25530871d33) | 19 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [drivers/gpu/drm/amd/amdkfd/kfd\_migrate.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/gpu/drm/amd/amdkfd/kfd_migrate.c?id=16ce101db85db694a91380aa4c89b25530871d33) | 17 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/gpu/drm/amd/amdkfd/kfd\_migrate.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/gpu/drm/amd/amdkfd/kfd_migrate.h?id=16ce101db85db694a91380aa4c89b25530871d33) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/gpu/drm/amd/amdkfd/kfd\_svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/gpu/drm/amd/amdkfd/kfd_svm.c?id=16ce101db85db694a91380aa4c89b25530871d33) | 11 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/linux/migrate.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/migrate.h?id=16ce101db85db694a91380aa4c89b25530871d33) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [lib/test\_hmm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/lib/test_hmm.c?id=16ce101db85db694a91380aa4c89b25530871d33) | 7 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [mm/memory.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/mm/memory.c?id=16ce101db85db694a91380aa4c89b25530871d33) | 16 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [mm/migrate.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/mm/migrate.c?id=16ce101db85db694a91380aa4c89b25530871d33) | 34 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [mm/migrate\_device.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/mm/migrate_device.c?id=16ce101db85db694a91380aa4c89b25530871d33) | 18 | |  |  |  | | --- | --- | --- | |

9 files changed, 89 insertions, 43 deletions

| diff --git a/arch/powerpc/kvm/book3s\_hv\_uvmem.c b/arch/powerpc/kvm/book3s\_hv\_uvmem.cindex 5980063016207f..965c9e9e500bce 100644--- a/[arch/powerpc/kvm/book3s\_hv\_uvmem.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_hv_uvmem.c?id=ab63f63f3885d492e62da55304b0483a2a9e6a7d)+++ b/[arch/powerpc/kvm/book3s\_hv\_uvmem.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kvm/book3s_hv_uvmem.c?id=16ce101db85db694a91380aa4c89b25530871d33)@@ -508,10 +508,10 @@ unsigned long kvmppc\_h\_svm\_init\_start(struct kvm \*kvm) static int \_\_kvmppc\_svm\_page\_out(struct vm\_area\_struct \*vma, unsigned long start, unsigned long end, unsigned long page\_shift,- struct kvm \*kvm, unsigned long gpa)+ struct kvm \*kvm, unsigned long gpa, struct page \*fault\_page) { unsigned long src\_pfn, dst\_pfn = 0;- struct migrate\_vma mig;+ struct migrate\_vma mig = { 0 }; struct page \*dpage, \*spage; struct kvmppc\_uvmem\_page\_pvt \*pvt; unsigned long pfn;@@ -525,6 +525,7 @@ static int \_\_kvmppc\_svm\_page\_out(struct vm\_area\_struct \*vma, mig.dst = &dst\_pfn; mig.pgmap\_owner = &kvmppc\_uvmem\_pgmap; mig.flags = MIGRATE\_VMA\_SELECT\_DEVICE\_PRIVATE;+ mig.fault\_page = fault\_page;  /\* The requested page is already paged-out, nothing to do \*/ if (!kvmppc\_gfn\_is\_uvmem\_pfn(gpa >> page\_shift, kvm, NULL))@@ -580,12 +581,14 @@ out\_finalize: static inline int kvmppc\_svm\_page\_out(struct vm\_area\_struct \*vma, unsigned long start, unsigned long end, unsigned long page\_shift,- struct kvm \*kvm, unsigned long gpa)+ struct kvm \*kvm, unsigned long gpa,+ struct page \*fault\_page) { int ret;  mutex\_lock(&kvm->arch.uvmem\_lock);- ret = \_\_kvmppc\_svm\_page\_out(vma, start, end, page\_shift, kvm, gpa);+ ret = \_\_kvmppc\_svm\_page\_out(vma, start, end, page\_shift, kvm, gpa,+ fault\_page); mutex\_unlock(&kvm->arch.uvmem\_lock);  return ret;@@ -634,7 +637,7 @@ void kvmppc\_uvmem\_drop\_pages(const struct kvm\_memory\_slot \*slot, pvt->remove\_gfn = true;  if (\_\_kvmppc\_svm\_page\_out(vma, addr, addr + PAGE\_SIZE,- PAGE\_SHIFT, kvm, pvt->gpa))+ PAGE\_SHIFT, kvm, pvt->gpa, NULL)) pr\_err("Can't page out gpa:0x%lx addr:0x%lx\n", pvt->gpa, addr); } else {@@ -736,7 +739,7 @@ static int kvmppc\_svm\_page\_in(struct vm\_area\_struct \*vma, bool pagein) { unsigned long src\_pfn, dst\_pfn = 0;- struct migrate\_vma mig;+ struct migrate\_vma mig = { 0 }; struct page \*spage; unsigned long pfn; struct page \*dpage;@@ -994,7 +997,7 @@ static vm\_fault\_t kvmppc\_uvmem\_migrate\_to\_ram(struct vm\_fault \*vmf)  if (kvmppc\_svm\_page\_out(vmf->vma, vmf->address, vmf->address + PAGE\_SIZE, PAGE\_SHIFT,- pvt->kvm, pvt->gpa))+ pvt->kvm, pvt->gpa, vmf->page)) return VM\_FAULT\_SIGBUS; else return 0;@@ -1065,7 +1068,7 @@ kvmppc\_h\_svm\_page\_out(struct kvm \*kvm, unsigned long gpa, if (!vma || vma->vm\_start > start || vma->vm\_end < end) goto out; - if (!kvmppc\_svm\_page\_out(vma, start, end, page\_shift, kvm, gpa))+ if (!kvmppc\_svm\_page\_out(vma, start, end, page\_shift, kvm, gpa, NULL)) ret = H\_SUCCESS; out: mmap\_read\_unlock(kvm->mm);diff --git a/drivers/gpu/drm/amd/amdkfd/kfd\_migrate.c b/drivers/gpu/drm/amd/amdkfd/kfd\_migrate.cindex b059a77b6081d8..776448bd9fe4ab 100644--- a/[drivers/gpu/drm/amd/amdkfd/kfd\_migrate.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpu/drm/amd/amdkfd/kfd_migrate.c?id=ab63f63f3885d492e62da55304b0483a2a9e6a7d)+++ b/[drivers/gpu/drm/amd/amdkfd/kfd\_migrate.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpu/drm/amd/amdkfd/kfd_migrate.c?id=16ce101db85db694a91380aa4c89b25530871d33)@@ -409,7 +409,7 @@ svm\_migrate\_vma\_to\_vram(struct amdgpu\_device \*adev, struct svm\_range \*prange, uint64\_t npages = (end - start) >> PAGE\_SHIFT; struct kfd\_process\_device \*pdd; struct dma\_fence \*mfence = NULL;- struct migrate\_vma migrate;+ struct migrate\_vma migrate = { 0 }; unsigned long cpages = 0; dma\_addr\_t \*scratch; void \*buf;@@ -668,7 +668,7 @@ out\_oom: static long svm\_migrate\_vma\_to\_ram(struct amdgpu\_device \*adev, struct svm\_range \*prange, struct vm\_area\_struct \*vma, uint64\_t start, uint64\_t end,- uint32\_t trigger)+ uint32\_t trigger, struct page \*fault\_page) { struct kfd\_process \*p = container\_of(prange->svms, struct kfd\_process, svms); uint64\_t npages = (end - start) >> PAGE\_SHIFT;@@ -676,7 +676,7 @@ svm\_migrate\_vma\_to\_ram(struct amdgpu\_device \*adev, struct svm\_range \*prange, unsigned long cpages = 0; struct kfd\_process\_device \*pdd; struct dma\_fence \*mfence = NULL;- struct migrate\_vma migrate;+ struct migrate\_vma migrate = { 0 }; dma\_addr\_t \*scratch; void \*buf; int r = -ENOMEM;@@ -699,6 +699,7 @@ svm\_migrate\_vma\_to\_ram(struct amdgpu\_device \*adev, struct svm\_range \*prange,  migrate.src = buf; migrate.dst = migrate.src + npages;+ migrate.fault\_page = fault\_page; scratch = (dma\_addr\_t \*)(migrate.dst + npages);  kfd\_smi\_event\_migration\_start(adev->kfd.dev, p->lead\_thread->pid,@@ -766,7 +767,7 @@ out: \* 0 - OK, otherwise error code \*/ int svm\_migrate\_vram\_to\_ram(struct svm\_range \*prange, struct mm\_struct \*mm,- uint32\_t trigger)+ uint32\_t trigger, struct page \*fault\_page) { struct amdgpu\_device \*adev; struct vm\_area\_struct \*vma;@@ -807,7 +808,8 @@ int svm\_migrate\_vram\_to\_ram(struct svm\_range \*prange, struct mm\_struct \*mm, }  next = min(vma->vm\_end, end);- r = svm\_migrate\_vma\_to\_ram(adev, prange, vma, addr, next, trigger);+ r = svm\_migrate\_vma\_to\_ram(adev, prange, vma, addr, next, trigger,+ fault\_page); if (r < 0) { pr\_debug("failed %ld to migrate prange %p\n", r, prange); break;@@ -851,7 +853,7 @@ svm\_migrate\_vram\_to\_vram(struct svm\_range \*prange, uint32\_t best\_loc, pr\_debug("from gpu 0x%x to gpu 0x%x\n", prange->actual\_loc, best\_loc);  do {- r = svm\_migrate\_vram\_to\_ram(prange, mm, trigger);+ r = svm\_migrate\_vram\_to\_ram(prange, mm, trigger, NULL); if (r) return r; } while (prange->actual\_loc && --retries);@@ -938,7 +940,8 @@ static vm\_fault\_t svm\_migrate\_to\_ram(struct vm\_fault \*vmf) goto out\_unlock\_prange; } - r = svm\_migrate\_vram\_to\_ram(prange, mm, KFD\_MIGRATE\_TRIGGER\_PAGEFAULT\_CPU);+ r = svm\_migrate\_vram\_to\_ram(prange, mm, KFD\_MIGRATE\_TRIGGER\_PAGEFAULT\_CPU,+ vmf->page); if (r) pr\_debug("failed %d migrate 0x%p [0x%lx 0x%lx] to ram\n", r, prange, prange->start, prange->last);diff --git a/drivers/gpu/drm/amd/amdkfd/kfd\_migrate.h b/drivers/gpu/drm/amd/amdkfd/kfd\_migrate.hindex b3f0754b32faa9..a5d7e6d2226469 100644--- a/[drivers/gpu/drm/amd/amdkfd/kfd\_migrate.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpu/drm/amd/amdkfd/kfd_migrate.h?id=ab63f63f3885d492e62da55304b0483a2a9e6a7d)+++ b/[drivers/gpu/drm/amd/amdkfd/kfd\_migrate.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpu/drm/amd/amdkfd/kfd_migrate.h?id=16ce101db85db694a91380aa4c89b25530871d33)@@ -43,7 +43,7 @@ enum MIGRATION\_COPY\_DIR { int svm\_migrate\_to\_vram(struct svm\_range \*prange, uint32\_t best\_loc, struct mm\_struct \*mm, uint32\_t trigger); int svm\_migrate\_vram\_to\_ram(struct svm\_range \*prange, struct mm\_struct \*mm,- uint32\_t trigger);+ uint32\_t trigger, struct page \*fault\_page); unsigned long svm\_migrate\_addr\_to\_pfn(struct amdgpu\_device \*adev, unsigned long addr); diff --git a/drivers/gpu/drm/amd/amdkfd/kfd\_svm.c b/drivers/gpu/drm/amd/amdkfd/kfd\_svm.cindex 11074cc8c333b2..9139e5a0b2a07c 100644--- a/[drivers/gpu/drm/amd/amdkfd/kfd\_svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpu/drm/amd/amdkfd/kfd_svm.c?id=ab63f63f3885d492e62da55304b0483a2a9e6a7d)+++ b/[drivers/gpu/drm/amd/amdkfd/kfd\_svm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpu/drm/amd/amdkfd/kfd_svm.c?id=16ce101db85db694a91380aa4c89b25530871d33)@@ -2913,13 +2913,15 @@ retry\_write\_locked: \*/ if (prange->actual\_loc) r = svm\_migrate\_vram\_to\_ram(prange, mm,- KFD\_MIGRATE\_TRIGGER\_PAGEFAULT\_GPU);+ KFD\_MIGRATE\_TRIGGER\_PAGEFAULT\_GPU,+ NULL); else r = 0; } } else { r = svm\_migrate\_vram\_to\_ram(prange, mm,- KFD\_MIGRATE\_TRIGGER\_PAGEFAULT\_GPU);+ KFD\_MIGRATE\_TRIGGER\_PAGEFAULT\_GPU,+ NULL); } if (r) { pr\_debug("failed %d to migrate svms %p [0x%lx 0x%lx]\n",@@ -3242,7 +3244,8 @@ svm\_range\_trigger\_migration(struct mm\_struct \*mm, struct svm\_range \*prange, return 0;  if (!best\_loc) {- r = svm\_migrate\_vram\_to\_ram(prange, mm, KFD\_MIGRATE\_TRIGGER\_PREFETCH);+ r = svm\_migrate\_vram\_to\_ram(prange, mm,+ KFD\_MIGRATE\_TRIGGER\_PREFETCH, NULL); \*migrated = !r; return r; }@@ -3303,7 +3306,7 @@ static void svm\_range\_evict\_svm\_bo\_worker(struct work\_struct \*work) mutex\_lock(&prange->migrate\_mutex); do { r = svm\_migrate\_vram\_to\_ram(prange, mm,- KFD\_MIGRATE\_TRIGGER\_TTM\_EVICTION);+ KFD\_MIGRATE\_TRIGGER\_TTM\_EVICTION, NULL); } while (!r && prange->actual\_loc && --retries);  if (!r && prange->actual\_loc)diff --git a/include/linux/migrate.h b/include/linux/migrate.hindex 704a04f5a0746e..52090d1f92307c 100644--- a/[include/linux/migrate.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/migrate.h?id=ab63f63f3885d492e62da55304b0483a2a9e6a7d)+++ b/[include/linux/migrate.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/migrate.h?id=16ce101db85db694a91380aa4c89b25530871d33)@@ -62,6 +62,8 @@ extern const char \*migrate\_reason\_names[MR\_TYPES]; #ifdef CONFIG\_MIGRATION  extern void putback\_movable\_pages(struct list\_head \*l);+int migrate\_folio\_extra(struct address\_space \*mapping, struct folio \*dst,+ struct folio \*src, enum migrate\_mode mode, int extra\_count); int migrate\_folio(struct address\_space \*mapping, struct folio \*dst, struct folio \*src, enum migrate\_mode mode); extern int migrate\_pages(struct list\_head \*l, new\_page\_t new, free\_page\_t free,@@ -197,6 +199,12 @@ struct migrate\_vma { \*/ void \*pgmap\_owner; unsigned long flags;++ /\*+ \* Set to vmf->page if this is being called to migrate a page as part of+ \* a migrate\_to\_ram() callback.+ \*/+ struct page \*fault\_page; };  int migrate\_vma\_setup(struct migrate\_vma \*args);diff --git a/lib/test\_hmm.c b/lib/test\_hmm.cindex 6a33f6b1b46510..e566166b557126 100644--- a/[lib/test\_hmm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/lib/test_hmm.c?id=ab63f63f3885d492e62da55304b0483a2a9e6a7d)+++ b/[lib/test\_hmm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/lib/test_hmm.c?id=16ce101db85db694a91380aa4c89b25530871d33)@@ -907,7 +907,7 @@ static int dmirror\_migrate\_to\_system(struct dmirror \*dmirror, struct vm\_area\_struct \*vma; unsigned long src\_pfns[64] = { 0 }; unsigned long dst\_pfns[64] = { 0 };- struct migrate\_vma args;+ struct migrate\_vma args = { 0 }; unsigned long next; int ret; @@ -968,7 +968,7 @@ static int dmirror\_migrate\_to\_device(struct dmirror \*dmirror, unsigned long src\_pfns[64] = { 0 }; unsigned long dst\_pfns[64] = { 0 }; struct dmirror\_bounce bounce;- struct migrate\_vma args;+ struct migrate\_vma args = { 0 }; unsigned long next; int ret; @@ -1334,7 +1334,7 @@ static void dmirror\_devmem\_free(struct page \*page)  static vm\_fault\_t dmirror\_devmem\_fault(struct vm\_fault \*vmf) {- struct migrate\_vma args;+ struct migrate\_vma args = { 0 }; unsigned long src\_pfns = 0; unsigned long dst\_pfns = 0; struct page \*rpage;@@ -1357,6 +1357,7 @@ static vm\_fault\_t dmirror\_devmem\_fault(struct vm\_fault \*vmf) args.dst = &dst\_pfns; args.pgmap\_owner = dmirror->mdevice; args.flags = dmirror\_select\_device(dmirror);+ args.fault\_page = vmf->page;  if (migrate\_vma\_setup(&args)) return VM\_FAULT\_SIGBUS;diff --git a/mm/memory.c b/mm/memory.cindex 2c7723ea437146..4ad6077164cd2f 100644--- a/[mm/memory.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/memory.c?id=ab63f63f3885d492e62da55304b0483a2a9e6a7d)+++ b/[mm/memory.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/memory.c?id=16ce101db85db694a91380aa4c89b25530871d33)@@ -3750,7 +3750,21 @@ vm\_fault\_t do\_swap\_page(struct vm\_fault \*vmf) ret = remove\_device\_exclusive\_entry(vmf); } else if (is\_device\_private\_entry(entry)) { vmf->page = pfn\_swap\_entry\_to\_page(entry);- ret = vmf->page->pgmap->ops->migrate\_to\_ram(vmf);+ vmf->pte = pte\_offset\_map\_lock(vma->vm\_mm, vmf->pmd,+ vmf->address, &vmf->ptl);+ if (unlikely(!pte\_same(\*vmf->pte, vmf->orig\_pte))) {+ spin\_unlock(vmf->ptl);+ goto out;+ }++ /\*+ \* Get a page reference while we know the page can't be+ \* freed.+ \*/+ get\_page(vmf->page);+ pte\_unmap\_unlock(vmf->pte, vmf->ptl);+ vmf->page->pgmap->ops->migrate\_to\_ram(vmf);+ put\_page(vmf->page); } else if (is\_hwpoison\_entry(entry)) { ret = VM\_FAULT\_HWPOISON; } else if (is\_swapin\_error\_entry(entry)) {diff --git a/mm/migrate.c b/mm/migrate.cindex c228afba0963d6..1379e1912772e0 100644--- a/[mm/migrate.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/migrate.c?id=ab63f63f3885d492e62da55304b0483a2a9e6a7d)+++ b/[mm/migrate.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/migrate.c?id=16ce101db85db694a91380aa4c89b25530871d33)@@ -625,6 +625,25 @@ EXPORT\_SYMBOL(folio\_migrate\_copy); \* Migration functions \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/ +int migrate\_folio\_extra(struct address\_space \*mapping, struct folio \*dst,+ struct folio \*src, enum migrate\_mode mode, int extra\_count)+{+ int rc;++ BUG\_ON(folio\_test\_writeback(src)); /\* Writeback must be complete \*/++ rc = folio\_migrate\_mapping(mapping, dst, src, extra\_count);++ if (rc != MIGRATEPAGE\_SUCCESS)+ return rc;++ if (mode != MIGRATE\_SYNC\_NO\_COPY)+ folio\_migrate\_copy(dst, src);+ else+ folio\_migrate\_flags(dst, src);+ return MIGRATEPAGE\_SUCCESS;+}+ /\*\* \* migrate\_folio() - Simple folio migration. \* @mapping: The address\_space containing the folio.@@ -640,20 +659,7 @@ EXPORT\_SYMBOL(folio\_migrate\_copy); int migrate\_folio(struct address\_space \*mapping, struct folio \*dst, struct folio \*src, enum migrate\_mode mode) {- int rc;-- BUG\_ON(folio\_test\_writeback(src)); /\* Writeback must be complete \*/-- rc = folio\_migrate\_mapping(mapping, dst, src, 0);-- if (rc != MIGRATEPAGE\_SUCCESS)- return rc;-- if (mode != MIGRATE\_SYNC\_NO\_COPY)- folio\_migrate\_copy(dst, src);- else- folio\_migrate\_flags(dst, src);- return MIGRATEPAGE\_SUCCESS;+ return migrate\_folio\_extra(mapping, dst, src, mode, 0); } EXPORT\_SYMBOL(migrate\_folio); diff --git a/mm/migrate\_device.c b/mm/migrate\_device.cindex 5ab6ab9d2ed82b..8dee38ffcda259 100644--- a/[mm/migrate\_device.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/migrate_device.c?id=ab63f63f3885d492e62da55304b0483a2a9e6a7d)+++ b/[mm/migrate\_device.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/migrate_device.c?id=16ce101db85db694a91380aa4c89b25530871d33)@@ -325,14 +325,14 @@ static void migrate\_vma\_collect(struct migrate\_vma \*migrate) \* folio\_migrate\_mapping(), except that here we allow migration of a \* ZONE\_DEVICE page. \*/-static bool migrate\_vma\_check\_page(struct page \*page)+static bool migrate\_vma\_check\_page(struct page \*page, struct page \*fault\_page) { /\* \* One extra ref because caller holds an extra reference, either from \* isolate\_lru\_page() for a regular page, or migrate\_vma\_collect() for \* a device page. \*/- int extra = 1;+ int extra = 1 + (page == fault\_page);  /\* \* FIXME support THP (transparent huge page), it is bit more complex to@@ -405,7 +405,8 @@ static void migrate\_vma\_unmap(struct migrate\_vma \*migrate) if (folio\_mapped(folio)) try\_to\_migrate(folio, 0); - if (page\_mapped(page) || !migrate\_vma\_check\_page(page)) {+ if (page\_mapped(page) ||+ !migrate\_vma\_check\_page(page, migrate->fault\_page)) { if (!is\_zone\_device\_page(page)) { get\_page(page); putback\_lru\_page(page);@@ -517,6 +518,8 @@ int migrate\_vma\_setup(struct migrate\_vma \*args) return -EINVAL; if (!args->src || !args->dst) return -EINVAL;+ if (args->fault\_page && !is\_device\_private\_page(args->fault\_page))+ return -EINVAL;  memset(args->src, 0, sizeof(\*args->src) \* nr\_pages); args->cpages = 0;@@ -747,8 +750,13 @@ void migrate\_vma\_pages(struct migrate\_vma \*migrate) continue; } - r = migrate\_folio(mapping, page\_folio(newpage),- page\_folio(page), MIGRATE\_SYNC\_NO\_COPY);+ if (migrate->fault\_page == page)+ r = migrate\_folio\_extra(mapping, page\_folio(newpage),+ page\_folio(page),+ MIGRATE\_SYNC\_NO\_COPY, 1);+ else+ r = migrate\_folio(mapping, page\_folio(newpage),+ page\_folio(page), MIGRATE\_SYNC\_NO\_COPY); if (r != MIGRATEPAGE\_SUCCESS) migrate->src[i] &= ~MIGRATE\_PFN\_MIGRATE; } |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 22:52:38 +0000


