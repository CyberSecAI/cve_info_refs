=== Content from www.brics.dk_25b53486_20250114_204100.html ===
BRICS

Basic Research in Computer Science

Proving in Zero-Knowledge that a Number
is the Product of Two Safe Primes

Jan Camenisch
Markus Michels

BRICS Report Series

ISSN 0909-0878

RS-98-29

November 1998

B
R
I
C
S
R
S
-
9
8
-
2
9

C
a
m
e
n
i
s
c
h
&
M

i
c
h
e
l
s
:

P
r
o
v
i
n
g
t
h
a
t

a
N
u
m
b
e
r

i
s

t
h
e
P
r
o
d
u
c
t

o
f

T
w
o
S
a
f
e
P
r
i
m
e
s

Copyright c(cid:13) 1998,

BRICS, Department of Computer Science
University of Aarhus. All rights reserved.

Reproduction of all or part of this work
is permitted for educational or research use
on condition that this copyright notice is
included in any copy.

See back inner page for a list of recent BRICS Report Series publications.
Copies may be obtained by contacting:

BRICS
Department of Computer Science
University of Aarhus
Ny Munkegade, building 540
DK–8000 Aarhus C
Denmark
Telephone: +45 8942 3360
Telefax:
+45 8942 3255
Internet: BRICS@brics.dk

BRICS publications are in general accessible through the World Wide
Web and anonymous FTP through these URLs:

http://www.brics.dk
ftp://ftp.brics.dk
This document in subdirectory RS/98/29/

Proving in Zero-Knowledge that a Number is
the Product of Two Safe Primes

Jan Camenisch

Markus Michelsy

BRICS(cid:3)
Department of Computer Science
University of Aarhus
DK – 8000 ˚Arhus C, Denmark
camenisch@daimi.au.dk

Entrust Technologies Europe
r3 security engineering ag
Glatt Tower
CH – 8301 Glattzentrum, Switzerland
Markus.Michels@entrust.com

November, 1998

Abstract

This paper presents the ﬁrst efﬁcient statistical zero-knowledge protocols to

prove statements such as:

(cid:15) A committed number is a pseudo-prime.
(cid:15) A committed (or revealed) number is the product of two safe primes, i.e.,

primes p and q such that (p - 1)=2 and (q - 1)=2 are primes as well.

(cid:15) A given value is of large order modulo a composite number that consists of

two safe prime factors.

So far, no methods other than inefﬁcient circuit-based proofs are known for prov-
ing such properties. Proving the second property is for instance necessary in
many recent cryptographic schemes that rely on both the hardness of computing
discrete logarithms and of difﬁculty computing roots modulo a composite.

The main building blocks of our protocols are statistical zero-knowledge
proofs that are of independent interest. Mainly, we show how to prove the cor-
rect computation of a modular addition, a modular multiplication, or a modular
exponentiation, where all values including the modulus are committed but not
publicly known. Apart from the validity of the computation, no other informa-
tion about the modulus (e.g., a generator which order equals the modulus) or
any other operand is given. Our technique can be generalized to prove in zero-
knowledge that any multivariate polynomial equation modulo a certain modu-
lus is satisﬁed, where only commitments to the variables of the polynomial and
a commitment to the modulus must be known. This improves previous results,
where the modulus is publicly known.

We show how a prover can use these building blocks to convince a veriﬁer
that a committed number is prime. This ﬁnally leads to efﬁcient protocols for

(cid:3)

y

Basic Research in Computer Science, Center of the Danish National Research Foundation.
Part of this work was done while this author was with Ubilab, UBS, Switzerland.

1

proving that a committed (or revealed) number is the product of two safe primes.
As a consequence, it can be shown that a given value is of large order modulo a
given number that is a product of two safe primes.

Keywords. RSA-based protocols, zero-knowledge proofs of knowledge, primal-
ity tests.

1 Introduction

The problem of proving that a number n is the product of two primes p and q of
special form arises in many recent cryptographic schemes (e.g., [7, 18, 19]) whose se-
curity is based on the infeasibility of computing discrete logarithms and of comput-
ing roots in groups of unknown order. In such scheme there typically is a designated
entity which knows the group’s order and hence can compute roots. Although the
other entities must not learn the group’s order, they still want to be assured that the
order is not smooth, since that would allow the designated entity to compute dis-
crete logarithms. One example of such a group are subgroups of Z(cid:3)
n. In this case, it
sufﬁces that the designated entity proves that n is the product of two safe primes,
i.e., primes p and q such that (p-1)=2 and (q-1)=2 are primes as well [19]. An other
example of such a group are elliptic curves over Zn. There, n must be the product of
two primes p and q such that (p + 1)=2 and (q + 1)=2 are also primes [23]. Finally,
standards such as X9.31 require the modulus to be the product of two primes p and
q, where (p - 1)=2, (p + 1)=2, (q - 1)=2, and (q + 1)=2 have a large prime factor1.
Previously, the only way known for proving such properties was applying inefﬁcient
general zero-knowledge proof techniques (e.g., [21, 6, 14]).

Our main results are as follows: First, we provide an efﬁcient protocol to prove
that a committed integer is in fact the modular addition of two committed integer
modulo another committed integer without revealing any other information what-
soever. Then we provide similar protocols for modular multiplication, modular ex-
ponentiation, and, more general, to any multivariate polynomial. Previous protocols
allow only to prove algebraic relations modulo a publicly known integer [5, 8, 16, 14]
were known. Our schemes work also for the class of commitments described in
[14] (that includes discrete-logarithm-based and RSA-based commitment schemes).
Second, we present an efﬁcient zero-knowledge proof for pseudo-primality of a com-
mitted number and, as a consequence, a zero-knowledge proof that an RSA modulus
n consists of two safe primes. The additional advantage of this method is that only a
commitment to n but not n itself must be publicly known. If the modulus n is pub-
licly known, however, more efﬁcient protocols can be obtained by combining our
techniques with known results described in the next paragraph.

Based on the these proofs it is simple to show that a given element a 2 Z(cid:3)
n has a
large order modulo a given n = pq when (p-1)=2 and (q-1)=2 are primes. First the
prover shows that n is indeed of this form. Then the veriﬁer checks whether a2 6(cid:17) 1

1It should be mentioned, however, that it is unnecessary to add this requirement into the RSA key
generation explicitly. For randomly chosen large primes, the probability that (p - 1)=2, (p + 1)=2, (q -
1)=2, and (q + 1)=2 have a large prime factor is overwhelming. This is sufﬁcient to guarantee that the
Pollard-Rho and Williams p+1 factoring methods [28, 33] do not work. On the other hand, a proof that an
arbitrarily generated RSA modulus is not weak without revealing the prime factors seems to be hard to
obtain, as an inﬁnite number of conditions have to be checked (e.g., see [1]).

2

(mod n) and gcd(a2 - 1; n) = 1 holds. From this it follows that a can only be of
order (p - 1)(q - 1)=4 or (p - 1)(q - 1)=2.

Let us ﬁnally summarize related results on proving properties of composite num-
bers. Van de Graaf and Peralta [32] provide an efﬁcient proof that a given modulus
n is of the form n = prqs, where r and s are odd, p and q are primes and p (cid:17) q (cid:17) 3
(mod 4). A protocol due to Boyar et al. [3] allows to prove that a given n is square-
free, i.e., there is no prime p with pjn such that p2jn. Hence, if for a given n both
properties can be shown, it follows that n is of form n = pq, where p and q are
primes and p (cid:17) q (cid:17) 3 (mod 4). This result was recently strengthened by Gennaro
et al. [20] who present a proof system for showing that a number n satisfying certain
side-conditions is the product of quasi-safe primes, i.e., primes p and q for which
(p - 1)=2 and (q - 1)=2 is a prime power. However, their protocol can not guarantee
that (p - 1)=2 and (q - 1)=2 are indeed primes which is what we are aiming for. Let
us further mention the work of Boneh and Franklin [2], who provide a proof that a
distributively generated number n indeed consists of two primes (without further
showing that these primes are of special form).
It should be noted that all these
solutions assume that n is publicly known.

2 Tools

2.1 Commitment Schemes

Our schemes build use commitment schemes that allow to algebraic prove proper-
ties of the committed value. There are two kinds of commitment scheme. The ﬁrst
kind hides the committed value information theoretically from the veriﬁer (uncondi-
tionally hiding) but is only conditionally binding, i.e., a computationally unbounded
prover can change his mind. The second kind is only computationally hiding but
unconditionally binding. Depending on the kind of the commitment scheme em-
ployed, our schemes will zero-knowledge arguments (proofs of knowledge) or be
zero-knowledge proof systems.

Cramer and Damg˚ard [14] describe a class of commitment schemes allowing to
prove algebraic properties of the committed value. These include RSA-based and
discrete-logarithm-based schemes for both kinds of commitment scheme. An ex-
ample of a computationally binding and unconditionally hiding scheme based on
the discrete logarithm problem is the one to Pedersen [27]. Given are a group G of
prime order Q and two random generators g and h such that logg h is unknown
and computing discrete logarithms is infeasible. A value a 2 ZQ is committed to
as ca := gahr, where r is randomly chosen from ZQ. For easier description, we
will use this commitment scheme for our protocols and hence they will be statistical
zero-knowledge proofs of knowledge. However, the protocol can easily be adapted
to work for all the commitment scheme exposed in [14].

2.2 Various Proof-Protocols Found in Literature
In the following we assume a group G = hgi of large known order Q and a second
generator h whose discrete logarithm to the base g is not known. We deﬁne the

3

discrete logarithm of y to the base g to be any integer x such that y = gx holds, i.e.,
discrete logarithms are allowed to be negative.

We shortly review various systems for proving knowledge of and about discrete

logarithms found in literature.

Proving the knowledge of a discrete logarithm x of a group element y to a basis g [11, 30].
The prover chooses a random r 2R ZQ and computes t := gr and sends t to the
veriﬁer. The veriﬁer picks a random challenge c 2R f0; 1gk and sends it to the
prover. The prover computes s := r - cx (mod Q) and sends s to the veriﬁer.
The veriﬁer accepts, iff gsyc = t holds. This protocol is an honest-veriﬁer zero-
knowledge proof of knowledge for k = (cid:2)(poly(log Q)) and a zero-knowledge proof
of knowledge for k = O(log log(Q)) and when serially repeated (cid:2)(poly(log Q))
times. This holds for all other protocols described in this section (when not
mentioned otherwise). Adopting the notation in [7], we denote this protocol
by PKf((cid:11)) : y = g(cid:11)g, where PK stands for “proof of knowledge”.

Proving the knowledge of a representation of the element y to the bases g1; : : : ; gl [4,
i=1 gxi
10], i.e., proving the knowledge of integers x1; : : : ; xl such that y =
i .
This protocol is an extension of the previous one to multiple bases. The prover
chooses random r1; : : : ; rl 2R ZQ, computes t :=
i , and sends t to
the veriﬁer. The veriﬁer picks a random challenge c 2R f0; 1gk and sends it to
the prover. The prover computes si := ri - cxi (mod Q) for i = 1; : : : ; l and
sends all si’s to the veriﬁer. The veriﬁer accepts, iff t = yc
i holds. This
protocol is denoted PKf((cid:11)1; : : : ; (cid:11)l) : y =

i=1 gsi

i=1 gri

Q
l

Q

Q

Q

g.

l

l

l

i=1 g(cid:11)i

i

Proving the equality of the discrete logarithms of the elements y1 and y2 to the bases g
and h, respectively [12]. Let y1 = gx and y2 = hx. The prover chooses a
random r 2 Z(cid:3)
Q, computes t1 := gr; t2 := hr, and sends t1; t2 to the veriﬁer.
The veriﬁer picks a random challenge c 2 f0; 1gk and sends it to the prover.
The prover computes s := r - cx (mod Q) and sends s to the veriﬁer. The
veriﬁer accepts, iff gsyc
2 = t2 holds. This protocol is denoted by
PKf((cid:11)) : y1 = g(cid:11) ^ y2 = h(cid:11)g.
Note that this method allows also to prove that one discrete log is the square
of another one (modulo the group order), e.g., PKf((cid:11)) : y1 = g(cid:11) ^ y2 = y(cid:11)
1

1 = t1 and hsyc

g.

Proving the knowledge of (at least) one out of the discrete logarithms of the elements y1
and y2 to the base g (proof of OR) [15]. W.l.g., we assume that the prover
knows x = logg y1. Then r1; s2 2R Z(cid:3)
Q, c2 2R f0; 1gk and computes t1 :=
gr1 ; t2 := gs2 yc2
2 and sends t1 and t2 to the veriﬁer. The veriﬁer picks a ran-
dom challenge c 2 f0; 1gk and sends it to the prover. The prover computes
c1 := c (cid:8) c2 and s1 := r1 - c1x (mod Q) and sends s1; s2; c1, and c2 to the
veriﬁer. The veriﬁer accepts, iff c1 (cid:8) c2 = c and ti = gsi yci
i holds for i 2 f1; 2g.
This protocol is denoted PKf((cid:11); (cid:12)) : y1 = g(cid:11) _ y2 = g(cid:12)g. In their paper
[15], Cramer et al. generalize this approach to an efﬁcient system for proving
arbitrary monotone statements built with ^’s and _’s.

Proving that a discrete logarithm lies in a given range. The last building block for our
protocols are statistical zero-knowledge proofs that the discrete logarithm x

4

of y to the base g satisﬁes 2‘1 - 2‘2 < x < 2‘1 + 2‘2 for given parameter ‘1
and ‘2. The parameter 2‘1 acts as an offset and can also chosen to be zero. In
principle, such a proof can be given by committing to every bit of x and prov-
ing that the committed values are indeed 0’s or 1’s and that they are the binary
representation of x. Fortunately, there is a much more efﬁcient way to achieve
this as is shown in [9, 16]. The price one has to pay is that, ﬁrst, the proto-
col is only statistical zero-knowledge and, second, it can only be shown that
2‘1 - 2(cid:15)‘2+2 < x < 2‘1 + 2(cid:15)‘2+2, where (cid:15) > 1 is a security parameter, although
x must lie in the intervals 2‘1 - 2‘2 < x < 2‘1 + 2‘2 for the prover being able
to successfully carry out the proof. Finally, if the group’s order is known, only
binary challenges are possible.
Since the protocol is not so well known, we
describe it in full detail in Appendix A. The protocol is denoted by

PKf((cid:11)) : y = g(cid:11) ^ 2‘1 - 2¨‘2 < (cid:11) < 2‘1 + 2¨‘2 g;
where ¨‘2 denotes (cid:15)‘2 +2 (we will stick to that notation for the rest of the paper).
It should be mentioned, however, that if the order of the group is not known to
the prover (e.g., if a subgroup of an RSA-ring is used) and when believing in the
non-standard strong RSA-assumption2 then larger challenges can be chosen
[16, 17]. Although we describe our protocols for the setting where the group’s
order is known to the prover, all protocols can easily be adapted to the setting
where the prover does not know the group’s order using the techniques from
[16, 17].

All described protocols can be combined in natural ways. First of all, one can use
multiple bases instead of a single one in any of the above proofs. Then, executing any
number of instances of these protocols in parallel and choosing the same challenges
for all of them in each round corresponds to the ^-composition of the statements the
single protocols prove. Using this approach, it is even possible to compose instances
according to any monotone formula [15]. In the following we will use of such com-
positions without having explained the technical details for composition for which
we refer to [5, 8, 15].

3 Secret Computations with a Secret Modulus

In this section we assume that a prover has committed to some integers a, b, d, and n.
We will provide an efﬁcient protocol for proving that ab (cid:17) d (mod n) holds for the
committed integers without revealing any further information to the veriﬁer (i.e., the
proof is zero-knowledge). However, before we can do so, we need protocols to prove
that a committed integer is the addition or the multiplication of two committed secret
integers modulo a committed secret modulus n.

The algebraic setting is as follows. Let ‘ be an integer such that -2‘ < a; b; d; n <
2‘ holds and (cid:15) > 1 be security parameters (cf. Section 2). Furthermore, we assume
that a group G of order Q > 22(cid:15)‘+5 (= 22¨‘+1) and two generators g and h are avail-
able such that logg h is not known. This group could for instance be chosen by the

2The strong RSA assumption states that, there exists a probabilistic polynomial-time algorithm G that
n such that it is infeasible to ﬁnd integers

outputs an RSA-modulus n and an element z 2 Z(cid:3)

on input 1jnj
e 62 f-1; 1g and u such that z (cid:17) ue (mod n).

5

prover in which case she would have to prove that she has chosen it correctly. Fi-
nally, let the prover’s commitments to a, b, d, and n be ca := gahr1, cb := gbhr2,
cd := gdhr3, and cn := gnhr4, where r1, r2, r3, and r4 are randomly chosen elements
of ZQ.

3.1 Secret Modular Addition and Multiplication

We assume that the veriﬁer already obtained the commitments ca, cb, cd, and cn.
Then the prover can convince the veriﬁer that a + b (cid:17) d (mod n) holds by running
the protocol denoted3:

S+ := PK

(cid:8)
((cid:11); (cid:12); γ; (cid:14); "; (cid:16); (cid:17); #; {; (cid:21)) :

ca = g(cid:11)h(cid:12) ^ -2¨‘ < (cid:11) < 2¨‘ ^ cb = gγh(cid:14) ^ -2¨‘ < γ < 2¨‘ ^
cd = g"h(cid:16) ^ -2¨‘ < " < 2¨‘ ^ cn = g(cid:17)h# ^ -2¨‘ < (cid:17) < 2¨‘^
(cid:9)
cd
:
cacb

nh(cid:21) ^ -2¨‘ < { < 2¨‘

= c{

Alternatively, she can convince the veriﬁer that ab (cid:17) d (mod n) holds by running
the protocol

(cid:8)

S(cid:3) := PK

((cid:11); (cid:12); γ; (cid:14); "; (cid:16); (cid:17); #; {; (cid:21); (cid:22); (cid:24); (cid:26); (cid:27)) :

ca = g(cid:11)h(cid:12) ^ -2¨‘ < (cid:11) < 2¨‘ ^ cb = gγh(cid:14) ^ -2¨‘ < γ < 2¨‘ ^
cd = g"h(cid:16) ^ -2¨‘ < " < 2¨‘ ^ cn = g(cid:17)h# ^ -2¨‘ < (cid:17) < 2¨‘ ^
(cid:9)
nh(cid:27) ^ -2¨‘ < (cid:26) < 2¨‘

cd = c(cid:11)

b c(cid:26)

with him.

Remark. In some applications the prover might be required to show that n has some
minimal size. This can by showing that (cid:17) lies in the range 2‘1 - 2¨‘2 < (cid:17) < 2‘1 + 2¨‘2
instead of -2¨‘ < (cid:17) < 2¨‘ for some appropriate values of ‘1 and ‘2 (cf. Section 2.2).

Theorem 1. Let a, b, d, and n be integers that are committed to by the prover as described
above. Then the protocol S+ is a statistical zero-knowledge proof that a + b (cid:17) d (mod n)
holds. Furthermore, the protocol S(cid:3) is a statistical zero-knowledge proof that ab (cid:17) d
(mod n) holds.

Proof. The statistical zero-knowledge claims follows from the statistical zero-
knowledgeness of the building blocks.

Let us argue why the modular relations hold. First, we consider what the clauses
prove that S+ and S(cid:3) have in common. Running the prover with either protocol (and
using standard techniques), the knowledge extractor can compute integers ˆa, ˆb, ˆd,
ˆn, ˆr1, ˆr2, ˆr3, and ˆr4 such that ca = g ˆah ˆr1, cb = g ˆbh ˆr2, cd = g ˆbh ˆr3, and cn = g ˆnh ˆr4
holds. Moreover, -2¨‘ < ˆa < 2¨‘, -2¨‘ < ˆb < 2¨‘, -2¨‘ < ˆd < 2¨‘, and -2¨‘ < ˆn < 2¨‘ holds
for these integers.

When running the prover with S+, the knowledge extractor can further compute
nh ˆr5 holds.

integers ˆr5 2 ZQ and ˆu with -2¨‘ < ˆu < 2¨‘ such that cd=(cacb) = c ˆu

3Recall that ¨‘ denotes (cid:15)‘ + 2.

6

Therefore we have g ˆd- ˆa- ˆbh ˆr3- ˆr1- ˆr2 = g ˆn ˆuh ˆu ˆr4+ ˆr5 and hence, provided that the
discrete log of h to the base g is not known, we must have

ˆd (cid:17) ˆa + ˆb + ˆu ˆn (mod Q) :

Thus we have ˆd = ˆa + ˆb + ˆu ˆn + ¯wQ for some integer ¯w. Since 22¨‘+1 < Q and due to
the constraints on ˆa, ˆb, ˆd, ˆn, and ˆu we can conclude that the integer ¯w must be 0 and
hence

ˆd (cid:17) ˆa + ˆb (mod ˆn)

must hold.

Now consider the case when running the prover with S(cid:3).

In this case the
knowledge-extractor can additionally compute integers ˆr6 2 ZQ and ˆv with -2¨‘ <
nhr6 and thus g ˆdh ˆr3 = g ˆa ˆb+ ˆv ˆnh ˆa ˆr2+ ˆv ˆr4+ ˆr(cid:3) holds. Again,
ˆv < 2¨‘ such that cd = c ˆa
provided that the discrete logarithm of h to the base g is not known, we have

bc ˆv

ˆd (cid:17) ˆa ˆb + ˆv ˆn (mod Q) :

As before, because of 22¨‘+1 < Q and the constraints on on ˆa, ˆb, ˆd, ˆn, and ˆv we can
conclude that

ˆd (cid:17) ˆa ˆb (mod ˆn)

must hold for the committed values.

3.2 Secret Modular Exponentiation

We now extend the ideas given in the previous paragraph to a method for proving
that ab (cid:17) d (mod n) holds. Using the same approach as above, i.e., having the
prover to provide an integer ˜a that equals ab (in Z) and proving this fact, would
required that G has order about 2b‘ and thus such a proof would become rather
inefﬁcient.

Below we expose a more efﬁcient protocol for proving this which is obtained by
constructing ab (mod n) step by step according to the square & multiply algorithm
(cf. Appendix B for easy reference). (In practice a more enhanced exponentiation
algorithm might be used (see, e.g., [13]), but one should keep in mind that it must
not leak additional information about the exponent.) In the following, we assume
that an upper-bound ‘b (cid:20) ‘ on the length of b is publicly known.

P

1. Apart from committing to a, b =

‘b-1
i=0 bi2i, d, and n the prover must also
commit to all bits of b: let cbi := gbih ˜ri with ˜ri 2R ZQ for i 2 f0; : : : ; ‘b - 1g.
Furthermore she needs to provide commitments to the intermediary results of
the square & multiply algorithm: let cvi := g(a2i
(mod n))h ˆri, (i = 1; : : : ; ‘b-1),
be her commitments to the powers of a, i.e., a2i
(mod n), where ˆri 2R ZQ,
and let cui := gui h ¯ri; (i = 0; : : : ; ‘b - 2), where ui := ui-1(a2i
)bi (mod n),
(i = 1; : : : ; ‘b - 2), u0 = ab0 (mod n), and ¯ri 2R ZQ.

7

(1)

(2)

(3)

(4)

(5)

h(cid:24)‘b-1 ^
(6)

(7)

(8)

(9)

(cid:1)(cid:17)

(10)
^ (11)

(12)

2. To prove that ab (cid:17) d (mod n) holds, the prover sends all her commitments to

the veriﬁer and then they carry out the protocol

(cid:10)

Sexp := PK

((cid:11); (cid:12); (cid:24); (cid:31); γ; (cid:14); "; (cid:16); (cid:17); ((cid:21)i; (cid:22)i; (cid:23)i; (cid:24)i; (cid:27)i; (cid:28)i; #i; ’i;  i)‘b-1

i=1 ; ({i; (cid:26)i)‘b-2

i=1 ; ) :

ca = g(cid:11)h(cid:12) ^ -2¨‘ < (cid:11) < 2¨‘ ^
cd = gγh(cid:14) ^ -2¨‘ < γ < 2¨‘ ^
cn = g"h(cid:16) ^ -2¨‘ < " < 2¨‘ ^
(cid:1)

(cid:0)‘b-1Y

c2i
bi

=cb = h(cid:17) ^

i=0

cv1 = g(cid:21)1h(cid:22)1 ^ : : : ^ cv‘b -1 = g(cid:21)‘b -1h(cid:22)‘b-1 ^
(cid:23)‘b -1
(cid:21)‘b -2
v‘b -2 c
n

n h(cid:24)2 ^ : : : ^ cv‘b -1 = c
c(cid:23)2

n h(cid:24)1 ^ cv2 = c(cid:21)1
v1

cv1 = c(cid:11)

ac(cid:23)1

-2¨‘ < (cid:21)1 < 2¨‘ ^ : : : ^ -2¨‘ < (cid:21)‘b-1 < 2¨‘ ^
-2¨‘ < (cid:23)1 < 2¨‘ ^ : : : ^ -2¨‘ < (cid:23)‘b-1 < 2¨‘ ^
cu1 = g{1 h(cid:26)1 ^ : : : ^ cu‘b -2 = g{‘b -2h(cid:26)‘b-2 ^
-2¨‘ < {1 < 2¨‘ ^ : : : ^ -2¨‘ < {‘b-2 < 2¨‘ ^

(cid:1)

(cid:0)

cb0 = h(cid:27)0 ^ cu0=g = h(cid:28)0

_

cb0 =g = h#0 ^ cu0=ca = h 0

(cid:16)(cid:0)

cb1 = h(cid:27)1 ^ cu1 =cu0 = h(cid:28)1

(cid:1)

_

(cid:16)(cid:0)

(cid:0)

cb1 =g = h#1 ^ cu1 = c(cid:21)1

u0c’1

n h 1 ^ -2¨‘ < ’1 < 2¨‘
(cid:1)

^ : : : ^

(cid:16)(cid:0)

cb‘b -2=g = h#‘b-2 ^ cu‘b -2 = c
(cid:16)(cid:0)

cb‘b -2 = h(cid:27)‘b -2 ^ cu‘b -2=cu‘b-3 = h(cid:28)i
’‘b-2
(cid:21)‘b -2
u‘b -3c
n
cb‘b -1 = h(cid:27)‘b -1 ^ cd=cu‘b-2 = h(cid:28)i

(cid:1)

_

h ‘b -2 ^-2¨‘ < ’‘b-2 < 2¨‘

cb‘b -1=g = h#‘b-1 ^ cd = c

’‘b -1
(cid:21)‘b -1
u‘b -2c
n

h ‘b -1 ^ -2¨‘ < ’‘b-1 < 2¨‘

(cid:0)

(cid:0)

(13)

(cid:1)(cid:17)

^

(14)

(cid:1)(cid:17)(cid:11)

:

(cid:1)(cid:17)

_

Let us now explain why this protocol proves that ab (cid:17) d (mod n) holds and
consider the clauses of sub-protocol Sexp. What the Clauses 1–3 prove should be
clear. The Clause 4 shows that the cbi ’s indeed commit to the bits of the integer
committed to in cb (that these are indeed bits is shown in the Clauses 11–14). From
this it can further be concluded that cb commits to a value smaller that 2‘b . The
Clauses 5–8 prove that the cvi ’s indeed contain a2i
(mod n) (cf. Section 3.1). Finally,
the Clauses 9–14 show that cui’s commit to the intermediary results of the square &
multiply algorithm and that cd commits to the result: The Clauses 9 and 10 show that
the cui ’s commit to integers that lie in f-2¨‘ + 1; : : : ; 2¨‘ - 1g (for cu0 this follows from
Clause 11). Then, Clause 11 proves that either cb0 commits to a 0 and cu0 commits to
a 1 or cb0 commits to a 1 and cu0 commits to the same integer as ca. The Clauses 12
and 13, show that for i = 1 to ‘b-2 either cbi commits to a 0 and cui commits to same

8

integer as cui-1 or cbi commits to a 1 and cui commits to the modular product of the
value cui-1 commits and of a2i
(mod n) (which cvi commits to). Finally, Clause 14
proves (in a similar manner as the Clauses 12 and 13) that cd commits to the result
of the square & multiply algorithm and thus to ab (mod n).

Theorem 2. Let a, b, d, and n be integers that are committed in ca, cb, cd, and cn by the
prover and let cb0 ; : : : ; cb‘-1 ; cv1; : : : ; cv‘b -1; cu0; : : : ; cu‘b -2 be her auxiliary commit-
ments. Then the protocol Sexp is a statistical zero-knowledge proof that the equation ab (cid:17) d
(mod n) holds.

Proof. The proof is straight forward from Theorem 1 and the explanations given
above that cb0 ; : : : ; cb‘-1 ; cv1 ; : : : ; cv‘b -1; cu0; : : : ; cu‘b -2, S implement the square
& multiply algorithm step by step.

In the following, when denoting a protocol, we will abbreviate the protocol Sexp
to the statement that is proven and assume that

(cid:1)
(cid:11)(cid:12) (cid:17) γ (mod (cid:14))

by a clause like
the prover send the veriﬁer all necessary commitments; e.g.,

(cid:0)

(cid:10)

PK

((cid:11); (cid:12); γ; (cid:14); ˜(cid:11); ˜(cid:12); ˜γ; ˜(cid:14)) : ca = g(cid:11)h ˜(cid:11) ^ cb = g(cid:12)h ˜(cid:12) ^ cd = gγh ˜γ ^

cn = g(cid:14)h ˜(cid:14) ^

(cid:0)

(cid:11)(cid:12) (cid:17) γ

(cid:1)(cid:11)
:

(mod (cid:14))

3.3 Efﬁciency Analysis

For both S+ and S(cid:3) the prover and the veriﬁer both need to compute 5 multi-
exponentiations per round. The communication per round is about the size of 10
group elements and 5(cid:15)‘ bits in case of S+ and about the size of 11 group elements
and 5(cid:15)‘ bits in case of S(cid:3).

In case of the exponentiation proof the veriﬁer and the prover need to com-
pute about 6‘b multi-exponentiations per round, while the prover needs to compute
about 3‘b multi-exponentiations for the commitments to the intermediary results of
the square & multiply algorithm. The communication cost per round is about the
size of 12‘b group elements and 4‘b(cid:15)‘ bits and an initial 3‘b group element which
are the commitments to the intermediary results of the square & multiply algorithm.

3.4 Extension to a General Multivariate Polynomial

Let us outline how the correct computation of a general multivariate polynomial
equation of form

f(x1; : : : ; xt; a1; : : : ; al; b1;1; : : : ; bl;t; n) =

ai

i=1

j=1

lX

tY

xbi;j
j

(cid:17) 0 (mod n)

Q
t

where all integers x1; : : : ; xt; a1; : : : ; al; b1;1; : : : ; bl;t, and n might only given as
commitments can be shown: The prover commits to all the summands s1 :=
j=1 xbl;j
a1
(mod n) and shows that the sum of
these summands is indeed zero modulo n. Then, she commits to all the product
terms p1;1 := xb1;1
(mod n) of the product and shows

(mod n); : : : ; pt;l := xbl;t

(mod n); : : : ; sl := al

j=1 xb1;j

Q

t

j

j

t

1

9

Q
t

j=1 pi;j (mod n). Finally, she shows that pi;j (cid:17) xbi;j
that si (cid:17) ai
(mod n) using
the modular exponentiation proof described above and that for all i the same xj is in
pi;j. Clearly, several such polynomials can be combined as well.

j

4 A Proof That a Secret Number is a Pseudo-Prime

In this section we describe how the prover and the veriﬁer can carry out a primality
test for an integer that is only given by a commitment. Some primality tests reveal
information about the structure of the prime and are hence not suited unless one is
willing to give away this information. Examples of such tests are the Miller-Rabin
test [26, 29] or the one based on Pocklington’s theorem. A test that does not reveal
such information is the one due to Lehmann [25] which we describe in the next sub-
section.

4.1 Lehmann’s Primality Test

Lehmann’s primality test is variation of the Solovay-Strassen [31] primality test and
based on the following theorem [24]:

Theorem 3. An odd integer n > 1 is prime if and only if

8a 2 Z(cid:3)

n :

a(n-1)=2 (cid:17) (cid:6)1 (mod n) and 9a 2 Z(cid:3)

n :

a(n-1)=2 (cid:17) -1 (mod n) :

This theorem suggest the following probabilistic primality test:

(cid:15) choose k random bases a1; : : : ; ak 2 Z(cid:3)
n,

(cid:15) check whether a(n-1)=2

i

(cid:17) (cid:6)1 (mod n) holds for all i’s and whether

a(n-1)=2
i

(cid:17) -1 (mod n) holds for at least one i.

The probability that a non-prime n passes this test is at most 2-k. Note that in case
n and (n - 1)=2 are both odd, the condition that a(n-1)=2
(cid:17) -1 (mod n) holds for
at least one i can be omitted. In this special case the Lehmann-test is equivalent to
the Miller-Rabin test and the failure probability is at most 4-k [29].

i

4.2 Proving the Pseudo-Primality of a Committed Number

We now show how the prover and the veriﬁer can do Lehmann’s primality test for
a number committed by prover such that the veriﬁer is convinced that the test was
correctly done but does not learn any other information. The general idea is that the
prover commits to t random bases ai (of course, the veriﬁer must be assured that
the ai’s are chosen at random) and then prove that for these bases a(n-1)=2
(cid:17) (cid:6)1
(mod n) holds. Furthermore, the prover must commit to a base, say ˜a, such that
˜a(n-1)=2 (cid:17) -1 (mod n) holds to satisfy the second condition in Theorem 3.

i

Let ‘ be an integer such that n < 2‘ holds and let (cid:15) > 1 be security parameter. As
in the previous section, a group G of prime order Q > 22(cid:15)‘+5 and two generators g
and h are chosen, such that logg h is not known. Let cn := gnhrn with rn 2R ZQ
be the prover’s commitment to the integer on which the primality test should be

10

performed.

The following four steps constitute the protocol.

1. The prover picks random ˆai 2R Zn for i = 1; : : : ; t and commits to them as
2R ZQ for i = 1; : : : ; t. She sends c ˆa1; : : : ; c ˆat to the

c ˆai := g ˆaihr ˆai with r ˆai
veriﬁer.

2. The veriﬁer picks random integers -2‘ < ˇai < 2‘ for i = 1; : : : ; t and sends

them to the prover.

3. The prover computes ai := ˆai + ˇai (mod n), cai := gaihrai with rai
(mod n), and cdi := gdi hrdi with rdi

2R ZQ,
di := a(n-1)=2
2R ZQ for all i = 1; : : : ; t.
i
Moreover, the prover commits to (n-1)=2 by cb := g(n-1)=2hrb with rb 2R ZQ.
Then the prover searches a base ˜a such that ˜a(n-1)=2 (cid:17) -1 (mod n) holds and
commits to ˜a by c ˜a := g ˜ahr ˜a with r ˜a 2R ZQ.

4. The prover sends cb; c ˜a; ca1; : : : ; cat; cd1 ; : : : ; cdt to the veriﬁer and then they

carry out the following (sub-)protocol

(cid:10)

Sp := PK

((cid:11); (cid:12); γ; (cid:23); (cid:24); (cid:26); (cid:20); ((cid:14)i; "i; (cid:16)i; (cid:17)i; #i; {i; (cid:26)i; (cid:20)i; (cid:22)i;  i)t

i=1 :

cb = g(cid:11)h(cid:12) ^ -2¨‘ < (cid:11) < 2¨‘ ^
cn = g(cid:23)h(cid:24) ^ -2¨‘ < (cid:23) < 2¨‘ ^
bg=cn = hγ ^
c2
(mod (cid:23))) ^
c ˜a = g(cid:26)h(cid:20) ^ ((cid:26)(cid:11) (cid:17) -1
c ˆa1 = g(cid:14)1 h"1 ^ : : : ^ c ˆat = g(cid:14)t h"t ^
n h(cid:17)1 ^ : : : ^ cat=g ˇat = g(cid:14)t c(cid:16)t
-2¨‘ < (cid:14)1 < 2¨‘ ^ : : : ^ -2¨‘ < (cid:14)t < 2¨‘ ^
-2¨‘ < (cid:16)1 < 2¨‘ ^ : : : ^ -2¨‘ < (cid:16)t < 2¨‘ ^
ca1 = g(cid:26)1h(cid:20)1 ^ : : : ^ cat = g(cid:26)th(cid:20)t ^

(cid:1)

(cid:0)

ca1=g ˇa1 = g(cid:14)1 c(cid:16)1

n h(cid:17)t ^

(cid:0)

cd1 =g = h#1 _ cd1 g = h#1

^ : : : ^

cdt =g = h#t _ cdt g = h#t

cd1 = g(cid:22)1 h 1 ^ : : : ^ cdt = g(cid:22)t h t ^

(cid:11)

((cid:26)(cid:11)
1

(cid:17) (cid:22)1

(mod (cid:23))) ^ : : : ^ ((cid:26)(cid:11)
t

(cid:17) (cid:22)t

(mod (cid:23)))

:

(15)

(16)

(17)
(18)

(19)

(20)

(21)

(22)

(cid:1)

(23)
^ (24)

(25)

(26)

This concludes the protocol.
In Step 1 and 2 of the protocol, the prover and the
veriﬁer together choose the random bases a1; : : : ; at for the primality test. Each
base is the sum (modulo n) of the random integer the veriﬁer chose and the one
the prover chose. Hence, both parties are ensured that the bases are random, al-
though the veriﬁer does not get any information about the bases ﬁnally used in
the primality test. That the bases are indeed chosen according to this procedure
is shown in the Clauses 19–23 of the sub-protocol Sp, the correct generation of the
random values ai, committed in cai, is proved. The Clauses 16–17 prove that in-
deed (n - 1)=2 is committed in cb and the Clause 18 shows that there exists a base
˜a such that ˜a(n-1)=2 (cid:17) -1 (mod n). In the Clause 24 it is shown that the values

11

committed in cdi are either equal to -1 or to 1. Finally, in Clause 26 (together with
the Clauses 15, 16, 23, and 25) it is proved that a (n-1)=2
(cid:17) di (mod n), i.e., a(n-1)=2
(mod n) 2 f-1; 1g and thus the conditions that n is a prime with error-probability
2-t are met.

i

i

Note that all modular exponentiations in Clause 26 have the same b and n and
hence the proofs for these parts can be optimized. In particular, this is the case for
the Clauses 3, 4, and 11–14 in Sexp.

Theorem 4. Given a commitment cn to an integer, the above protocol is a statistical zero-
knowledge proof that the committed integer is a prime with error-probability at most 2-t for
the primality-test.

Proof. The proof is straight forward from the Theorems 1, 2, and 3.

Similar as for modular exponentiation we will abbreviate the above protocol
by adding a clause such as (cid:11) 2 pseudoprimes(t) to the statement that is proven,
where t denotes the number of bases used in the primality test.

Remark. If (n - 1)=2 is odd and the prover is willing to reveal that, she can addi-
tionally prove that she knows (cid:31) and   such that cb=g = (g2)(cid:31)h  and -2¨‘ < (cid:31) < 2¨‘
holds and skip the Clause 18. This results in a statistical zero-knowledge proof that
n of form n = 2w + 1 is prime and w is odd with error-probability at most 2-2t.

4.3 Efﬁciency Analysis

Assume that the commitment to the prime n is given. Altogether t + 1 proofs that
a modular exponentiation holds are needed where the exponents are about log n
bits. Thus, the veriﬁer needs to compute about 6t log n multi-exponentiations per
round and the prover needs to compute about 2t log n multi-exponentiations for
the commitments to the intermediary results of the square & multiply algorithm.
The communication cost per round is about the size of 12t log n group elements and
4t log n(cid:15)‘ bits and an initial 2t log n group element which are the commitments to
the intermediary results of the square & multiply algorithm and the commitments to
the bases for the primality test.

5 Proving that an RSA Modulus Consists of Two Safe

Primes

We ﬁnally present protocols for proving that an RSA modulus consists of two safe
primes. First, we restrict ourselves to the case where the modulus is not known to
the veriﬁer, i.e., only a commitment of the modulus is given. Later, we will discuss
improvements for cases when the RSA modulus is known to the veriﬁer.

5.1 A Protocol For a Secret RSA Modulus

Let 2‘ be an upper-bound on the length of the largest factor of the modulus and let
(cid:15) > 1 be a security parameter. Furthermore, a group G of prime order Q > 22(cid:15)‘+5

12

and two generators g and h are chosen, such that logg h is not known and computing
discrete logarithms is infeasible.

Let cn := gnhrn be the prover’s commitment an integer n, where she choose
rn 2R ZQ and let p and q denote the two prime factors of n. The following is a
protocol that allows her to convince the veriﬁer that cn commits to the product of
two safe (pseudo-)primes.

1. The prover computes the commitments cp := gphrp, c ˜p := g(p-1)=2hr ˜p, cq :=
gqhrb, and c ˜q := g(q-1)=2hr ˜p with rp; r ˜p; rq; r ˜q 2R ZQ and sends all these
commitments to the veriﬁer.

2. The two parties carry out the following protocol

S51 := PKf((cid:11); (cid:12); γ; (cid:14); (cid:26); (cid:23); (cid:24); (cid:31); "; (cid:16); (cid:17)) :

c ˜p = g(cid:11)h(cid:12) ^ (-2¨‘ < (cid:11) < 2¨‘) ^
c ˜q = gγh(cid:14) ^ (-2¨‘ < (cid:14) < 2¨‘) ^
cp = g(cid:26)h(cid:23) ^ cq = g(cid:24)h(cid:31) ^

˜pg) = h" ^ cq=(c2

˜qg) = h(cid:16) ^ cn=(cpcq) = h(cid:17) ^
cp=(c2
(cid:11) 2 pseudoprimes(t) ^ γ 2 pseudoprimes(t) ^
(cid:26) 2 pseudoprimes(t) ^ (cid:24) 2 pseudoprimes(t)g ;

(27)

(28)

(29)

(30)

(31)

(32)

where t denotes the number of bases used in the Lehmann-primality tests.

Theorem 5. Let n be an integer that is committed by cn. Then the above protocol is a
statistical zero-knowledge proof that n is an RSA modulus of form n = pq where p; q; (p -
1)=2 and (q - 1)=2 are primes with error-probability at most 2-t each of for the primality
tests.

Proof. The proof is straight forward from the Theorems 1, 2, and 4.

The efﬁciency is reigned by the (pseudo-)primality-proofs and thus about four

times as high as for a single (pseudo-)primality-proof (cf. Subsection 4.3).

5.2 A Protocol For a Publicly Known RSA Modulus

We now consider the case where the modulus n is publicly known. In case n ful-
ﬁls certain side-conditions (see below), it is more efﬁcient to ﬁrst run the protocol
due to Gennaro et al. [20] (which includes the proofs proposed by Peralta & van
de Graaf [32] and by Boyar et al. [3]). This protocol is a statistical zero-knowledge
proof system that there exist two integers a; b (cid:21) 1 such that n consists of two primes
p = 2 ˜pa + 1 and q = 2 ˜qb + 1 with p; q; ˜p; ˜q 6(cid:17) 1 (mod 8), p 6(cid:17) q (mod 8), and ˜p 6(cid:17) ˜q
(mod 8). Given the fact that (p - 1)=2 and (p - 1)=2 are prime powers, the prob-
ability that they pass a single round of the Lehmann’s primality test for any a > 1
and b > 1, is at most ˜p1-a (cid:20)
2=(q - 1), respectively, if
they are not prime. Hence, if p and q are sufﬁciently large, a single round of the
Lehmann-primality test on (p - 1)=2 and (q - 1)=2 will be sufﬁcient to prove their
(pseudo-)primality.

2=(p - 1) and ˜q1-a (cid:20)

p

p

We now describe the protocol that allows the prover to prove the veriﬁer that a

given integer n is the product of two safe (pseudo-)primes.

13

1. First the prover computes cp := gphrp, c ˜p := g(p-1)=2hr ˜p, cq := gqhrb , and
c ˜q := g(q-1)=2hr ˜p with rp; r ˜p; rq; r ˜q 2R ZQ and sends these commitments
together with n to the veriﬁer.

2. The prover and the veriﬁer carry out the protocol by Gennaro et al. [20]

3. and then the protocol denoted

S52 := PKf((cid:11); (cid:12); γ; (cid:14); (cid:26); (cid:15); (cid:24); (cid:31); "; (cid:16); (cid:17)) :

c ˜p = g(cid:11)h(cid:12) ^ (-2¨‘=2 < (cid:11) < 2¨‘=2) ^ c ˜q = gγh(cid:14) ^ (-2¨‘=2 < (cid:14) < 2¨‘=2) ^

cp = g(cid:26)h(cid:15) ^ cq = g(cid:24)h(cid:31) ^ cp=(c2

˜pg) = h" ^ cq=(c2

˜qg) = h(cid:16) ^

(33)

(34)

gn=(cpcq) = h(cid:17) ^ γ 2 pseudoprimes(1) ^ (cid:11) 2 pseudoprimes(1)g :

(35)

Theorem 6. Let n = pq be a given integer that passes the test given in [20] with error
probability at most 2-z for an integer z (cid:21) 1. Then the above protocol is a statistical zero-
knowledge proof that n is an RSA modulus of form n = pq where p; q; (p - 1)=2 and
(q - 1)=2 are primes with error probability at most 1 - (1 - 2-z)(1 -
2=(p - 1))(1 -
p
p
2=(p - 1)

2=(q - 1)) < 2-z +

2=(q - 1) + 2-z

2=(p - 1) +

2=(q - 1).

p

p

p

p

The efﬁciency for this protocol is dominated by the efﬁciency of a single round
(i.e., t = 1) of the (pseudo-)primality proof described in the previous section and the
efﬁciency of protocol of Gennaro et al. [20].

6 Conclusion

We have presented efﬁcient protocols for proving that modular relations among se-
cret values (including the modulus!) hold and for proving that an given (or only
committed-to) number is the product of two safe primes.

We note that it is obvious how to use our techniques to get a protocol for proving
that n is the product of two strong primes [22], i.e., (p - 1)=2; (q - 1)=2; (p + 1)=2
and (q + 1)=2 are primes or have a large prime factor. Lower bounds on p, q, and
on n might also be shown. Also, factors r other than 2 in (p - 1)=r could easily be
incorporated.

References

[1] E. Bach and J. Shallit. Factoring with cyclotomic polynomials. In Proc. 26th IEEE
Symposium on Foundations of Computer Science (FOCS), pages 443–450, 1985.

[2] D. Boneh and M. Franklin. Efﬁcient generation of shared RSA keys.

In
B. Kaliski, editor, Advances in Cryptology — CRYPTO ’97, volume 1296 of Lec-
ture Notes in Computer Science, pages 425–439. Springer Verlag, 1997.

[3] J. Boyar, K. Friedl, and C. Lund. Practical zero-knowledge proofs: Giving hints

and using deﬁciencies. Journal of Cryptology, 4(3):185–206, 1991.

14

[4] S. Brands. Electronic cash systems based on the representation problem in
groups of prime order. In Preproceedings of Advances in Cryptology — CRYPTO
’93, pages 26.1–26.15, 1993.

[5] S. Brands. Rapid demonstration of linear relations connected by boolean oper-
ators. In W. Fumy, editor, Advances in Cryptology — EUROCRYPT ’97, volume
1233 of Lecture Notes in Computer Science, pages 318–333. Springer Verlag, 1997.

[6] G. Brassard, D. Chaum, and C. Cr´epeau. Minimum disclosure proofs of knowl-

edge. Journal of Computer and System Sciences, 37(2):156–189, Oct. 1988.

[7] J. Camenisch and M. Stadler. Efﬁcient group signature schemes for large groups.
In B. Kaliski, editor, Advances in Cryptology — CRYPTO ’97, volume 1296 of
Lecture Notes in Computer Science, pages 410–424. Springer Verlag, 1997.

[8] J. Camenisch and M. Stadler. Proof systems for general statements about dis-
crete logarithms. Technical Report TR 260, Institute for Theoretical Computer
Science, ETH Z ¨urich, Mar. 1997.

[9] A. Chan, Y. Frankel, and Y. Tsiounis. Easy come – easy go divisible cash. In
K. Nyberg, editor, Advances in Cryptology — EUROCRYPT ’98, volume 1403 of
Lecture Notes in Computer Science, pages 561–575. Springer Verlag, 1998.

[10] D. Chaum, J.-H. Evertse, and J. van de Graaf. An improved protocol for
demonstrating possession of discrete logarithms and some generalizations. In
D. Chaum and W. L. Price, editors, Advances in Cryptology — EUROCRYPT ’87,
volume 304 of Lecture Notes in Computer Science, pages 127–141. Springer-Verlag,
1988.

[11] D. Chaum, J.-H. Evertse, J. van de Graaf, and R. Peralta. Demonstrating pos-
session of a discrete logarithm without revealing it. In A. M. Odlyzko, editor,
Advances in Cryptology — CRYPTO ’86, volume 263 of Lecture Notes in Computer
Science, pages 200–212. Springer-Verlag, 1987.

[12] D. Chaum and T. P. Pedersen. Wallet databases with observers. In E. F. Brickell,
editor, Advances in Cryptology — CRYPTO ’92, volume 740 of Lecture Notes in
Computer Science, pages 89–105. Springer-Verlag, 1993.

[13] H. Cohen. A Course in Computational Algebraic Number Theory. Number 138 in

Graduate Texts in Mathematics. Springer-Verlag, Berlin, 1993.

[14] R. Cramer and I. Damg˚ard. Zero-knowledge proof for ﬁnite ﬁeld arithmetic, or:
Can zero-knowledge be for free? In H. Krawczyk, editor, Advances in Cryptology
— CRYPTO ’98, volume 1642 of Lecture Notes in Computer Science, pages 424–441,
Berlin, 1998. Springer Verlag.

[15] R. Cramer, I. Damg˚ard, and B. Schoenmakers. Proofs of partial knowledge and
simpliﬁed design of witness hiding protocols. In Y. G. Desmedt, editor, Advances
in Cryptology — CRYPTO ’94, volume 839 of Lecture Notes in Computer Science,
pages 174–187. Springer Verlag, 1994.

15

[16] E. Fujisaki and T. Okamoto. Statistical zero knowledge protocols to prove
modular polynomial relations. In B. Kaliski, editor, Advances in Cryptology —
CRYPTO ’97, volume 1294 of Lecture Notes in Computer Science, pages 16–30.
Springer Verlag, 1997.

[17] E. Fujisaki and T. Okamoto. A practical and provably secure scheme for publicly
In K. Nyberg, editor, Advances
veriﬁable secret sharing and its applications.
in Cryptology — EUROCRYPT ’98, volume 1403 of Lecture Notes in Computer
Science, pages 32–46. Springer Verlag, 1998.

[18] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin. Robust and efﬁcient sharing
of RSA functions. In N. Koblitz, editor, Advances in Cryptology — CRYPT0 ’96,
volume 1109 of Lecture Notes in Computer Science, pages 157–172, Berlin, 1996.
IACR, Springer Verlag.

[19] R. Gennaro, H. Krawczyk, and T. Rabin. RSA-based undeniable signatures. In
B. Kaliski, editor, Advances in Cryptology — CRYPTO ’97, volume 1296 of Lecture
Notes in Computer Science, pages 132–149. Springer Verlag, 1997.

[20] R. Gennaro, D. Micciancio, and T. Rabin. An efﬁcient non-interactive statisti-
cal zero-knowledge proof system for quasi-safe prime products. In 5rd ACM
Conference on Computer and Communicatons Security, 1998.

[21] O. Goldreich, S. Micali, and A. Wigderson. How to prove all NP statements in
zero-knowledge and a methodology of cryptographic protocol design. In A. M.
Odlyzko, editor, Advances in Cryptology — CRYPTO ’86, volume 263 of Lecture
Notes in Computer Science, pages 171–185. Springer-Verlag, 1987.

[22] J. Gordon. Strong RSA keys. Electronics Letters, 20(12):514–516, 1984.

[23] K. Koyama, U. Maurer, T. Okamoto, and S. Vanstone. New public-key schemes
based on elliptic curves over the ring Zn. In J. Feigenbaum, editor, Advances
in Cryptology — CRYPTO ’91, volume 576 of Lecture Notes in Computer Science,
pages 252–266. Springer-Verlag, 1992.

[24] E. Kranakis. Primality and Cryptography. Wiley-Teubner Series in Computer

Science, 1986.

[25] D. J. Lehmann. On primality tests. SIAM Journal of Computing, 11(2):374–375,

May 1982.

[26] G. L. Miller. Riemann’s hypothesis and tests for primality. Journal of Computer

and System Sciences, 13:300–317, 1976.

[27] T. P. Pedersen. Non-interactive and information-theoretic secure veriﬁable se-
In J. Feigenbaum, editor, Advances in Cryptology – CRYPTO ’91,
cret sharing.
volume 576 of Lecture Notes in Computer Science, pages 129–140. Springer Ver-
lag, 1992.

[28] J. M. Pollard. Theorems on factorization and primality testing. Proc. Cambridge

Philosophical Society, 76:521–528, 1974.

16

[29] M. O. Rabin. Probabilistic algorithm for testing primality.

Journal of Number

Theory, 12:128–138, 1980.

[30] C. P. Schnorr. Efﬁcient signature generation for smart cards. Journal of Cryptol-

ogy, 4(3):239–252, 1991.

[31] R. Solovay and V. Strassen. A fast monte-carlo test for primality. SIAM Journal

on Computing, 6(1):84–85, Mar. 1977.

[32] J. van de Graaf and R. Peralta. A simple and secure way to show the validity of
your public key. In C. Pomerance, editor, Advances in Cryptology — CRYPTO ’87,
volume 293 of Lecture Notes in Computer Science, pages 128–134. Springer-Verlag,
1988.

[33] H. C. Williams. A p + 1 method of factoring. Mathematics of Computation,

39(159):225–234, 1982.

A Proving a Secret’s Length in Groups with Known Or-

der

In this section we review the statistical zero-knowledge proof of knowledge of the
discrete logarithm, say x, of y to the base gand that, additionally, x lies within a given
interval. This proof is based on a protocols that appeared in [16, 9].

Prover

(g; Q; y; x)

#

r 2R f-2(cid:15)‘2; : : : ; 2(cid:15)‘2g
t := gr

s := r - c(x - 2‘1 ) (in Z)

(cid:27)

t

c

s

-

-

Veriﬁer

(g; Q; y)
#

c 2 f0; 1g

-2(cid:15)‘2+1 ?

?
< 2(cid:15)‘2+1
< s
t ?= gs-c2‘1 yc

#
(yes=no)

Figure 1: When repeated sufﬁciently many times, this protocol allows a prover to
convince a veriﬁer that the secret he committed to in y lies within the bound f2‘1 -
2(cid:15)‘2+2; : : : ; 2‘1 + 2(cid:15)‘2+2g for given parameters (cid:15), ‘1, and ‘2.

Theorem 7. Let G be a group of prime order Q, g and h two generators of G such that
logg h is unknown, (cid:15) > 1 be a security parameter, and ‘1 < log Q and ‘2 be lengths. Let
y be a public group element. When sequentially repeated j = (cid:2)(poly(log Q)) times, the

17

protocol depicted in Figure 1 is a proof of knowledge of a secret x 2 f2‘1 - 2(cid:15)‘2+2; : : : ; 2‘1 +
2(cid:15)‘2+2g such that y = gx and is statistical zero-knowledge for ‘2 = poly(log Q)) and if
x 2 f2‘1 - 2‘2 ; : : : ; 2‘1 + 2‘2 g.

Proof (Sketch). Proof of knowledge: First, the knowledge extractor needs two ﬁnd views
of accepting protocol-runs with the same t but different c’s as usual. Let (t; c; s) and
(t; ˜c; ˜s) these views. Without loss of generality we can assume that c = 0 and ˜c = 1.
Then we have t = gs-2‘1 y = g ˜s and thus y = g ˜s-s+2‘1 . Thus one can compute

ˆx := ˜s - s + 2‘1

(mod Q)

such that y = g ˆx holds. Due to the bounds that s and ˜s satisfy, it follows that
-2(cid:15)‘2+2 + 2‘1 < ˆx < 2(cid:15)‘2+2 + 2‘1 must hold, which was to be shown.

Statistical zero-knowledge: We provide only a simulator for one round of the pro-

yc 0

tocol. Extending this simulator to a simulator for all rounds is straight forward.

The simulator randomly chooses c0 2R f0; 1g and s0 2R f-2(cid:15)‘2; : : : ; 2(cid:15)‘2g ac-
cording to the uniform distribution. Using these values, the simulator computes
t 0 = gs 0
which he feeds the veriﬁer. If the veriﬁer responds with c0 the simu-
lator outputs (t 0; c 0; s 0). To prove that these values are statistical indistinguishable
from a view of a protocol run with the prover, it sufﬁces to consider the probability
distribution PS(s) of the response s of the prover and PS0(s0) according to which the
simulator chooses s0.

If the prover chooses r uniformly at random from f-2(cid:15)‘2; : : : ; -2(cid:15)‘2g and the
secret key x - 2‘1 randomly from f-2‘2; : : : ; 2‘2 g according to any distribution, we
have

8

>>>><
>>>>:

PS(s)

= 0
(cid:20) 2-(cid:15)‘2
= 2-(cid:15)‘2
(cid:20) 2-(cid:15)‘2
= 0

for s < -2(cid:15)‘2 - 2‘2
for - 2(cid:15)‘2 - 2‘2 (cid:20) s < -2(cid:15)‘2 + 2‘2
for - 2(cid:15)‘2 + 2‘2 (cid:20) s (cid:20) 2(cid:15)‘2 - 2‘2
for 2(cid:15)‘2 - 2‘2 < s (cid:20) 2(cid:15)‘2 + 2‘2
for 2(cid:15)‘2 + 2‘2 < s :

This holds for any distribution of c over f0; 1g. Thus we have

X

(cid:11)2Z

jPS((cid:11)) - PS 0 ((cid:11))j (cid:20) 2‘2+2
2(cid:15)‘2

=

4
(2‘2 )((cid:15)-1)

For ‘2 and (cid:15) as stated in the theorem, the last term can be expressed as one over
a polynomial in the input length, and therefore the two distributions are statistical
indistinguishable.

The relation (cid:15)‘2 + 2 < log Q should hold, as otherwise the any secret value will

lie within the bound.

In the above theorem there is a “hole” in the range of the prover’s secret key x,
i.e., the protocol is complete and zero-knowledge only for (x - 2‘1) 2 f-2‘2; : : : ; 2‘2g.
For (x-2‘1) 2 f-2(cid:15)‘2+1; : : : ; 2(cid:15)‘2+1g=f-2‘2; : : : ; 2‘2 g the prover’s success probability
is smaller than 1 but larger than 2-j, depending on the size of j(x - 2‘1)j - 2‘2 .

18

B Square & Multiply Algorithm for d (cid:17) ab (mod n)
The following algorithm computes d (cid:17) ab (mod n) (we use the same names for all
variables as in Section 3.2).

v0 := a
if b0 = 1 then u0 := a else u0 := 1 fi
for i = 1 to ‘b - 1 do

vi := vi-1 (cid:1) vi-1 (mod n)
if bi = 1 then

ui := ui-1 (cid:1) vi (mod n)

% thus vi (cid:17) a2i

(mod n)

% thus ui (cid:17) ui-1 (cid:1) a2i

(mod n)

else

ui := ui-1

endif
endfor
d := u‘b-1

19

Recent BRICS Report Series Publications

RS-98-29 Jan Camenisch and Markus Michels.

Proving in Zero-
Knowledge that a Number is the Product of Two Safe Primes.
November 1998. 19 pp.

RS-98-28 Rasmus Pagh. Low Redundancy in Dictionaries with O(1)

Worst Case Lookup Time. November 1998. 15 pp.

RS-98-27 Jan Camenisch and Markus Michels. A Group Signature
Scheme Based on an RSA-Variant. November 1998. 18 pp. Pre-
liminary version appeared in Ohta and Pei, editors, Advances
in Cryptology: 4th ASIACRYPT Conference on the Theory and
Applications of Cryptologic Techniques, ASIACRYPT ’98 Pro-
ceedings, LNCS 1514, 1998, pages 160–174.

RS-98-26 Paola Quaglia and David Walker. On Encoding p(cid:25) in m(cid:25). Oc-
tober 1998. 27 pp. Full version of paper to appear in Founda-
tions of Software Technology and Theoretical Computer Science:
18th Conference, FCT&TCS ’98 Proceedings, LNCS, 1998.

RS-98-25 Devdatt P. Dubhashi. Talagrand’s Inequality in Hereditary Set-

tings. October 1998. 22 pp.

RS-98-24 Devdatt P. Dubhashi. Talagrand’s Inequality and Locality in

Distributed Computing. October 1998. 14 pp.

RS-98-23 Devdatt P. Dubhashi. Martingales and Locality in Distributed

Computing. October 1998. 19 pp.

RS-98-22 Gian Luca Cattani, John Power, and Glynn Winskel. A Cate-
gorical Axiomatics for Bisimulation. September 1998. ii+21 pp.
Appears in Sangiorgi and de Simone, editors, Concurrency
Theory: 9th International Conference, CONCUR ’98 Proceed-
ings, LNCS 1466, 1998, pages 581–596.

RS-98-21 John Power, Gian Luca Cattani, and Glynn Winskel. A Rep-
resentation Result for Free Cocompletions. September 1998.
16 pp.

RS-98-20 Søren Riis and Meera Sitharam. Uniformly Generated Submod-
ules of Permutation Modules. September 1998. 35 pp.

RS-98-19 Søren Riis and Meera Sitharam. Generating Hard Tautologies
Using Predicate Logic and the Symmetric Group. September
1998. 13 pp.



=== Content from github.com_a22ad2fc_20250114_204055.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fhyperledger-archives%2Fursa%2Fsecurity%2Fadvisories%2FGHSA-2q6j-gqc4-4gw3)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fhyperledger-archives%2Fursa%2Fsecurity%2Fadvisories%2FGHSA-2q6j-gqc4-4gw3)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=hyperledger-archives%2Fursa)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

This repository has been archived by the owner on Mar 11, 2024. It is now read-only.

[hyperledger-archives](/hyperledger-archives)
/
**[ursa](/hyperledger-archives/ursa)**
Public archive

* [Notifications](/login?return_to=%2Fhyperledger-archives%2Fursa) You must be signed in to change notification settings
* [Fork
  142](/login?return_to=%2Fhyperledger-archives%2Fursa)
* [Star
   324](/login?return_to=%2Fhyperledger-archives%2Fursa)

* [Code](/hyperledger-archives/ursa)
* [Issues
  26](/hyperledger-archives/ursa/issues)
* [Pull requests
  0](/hyperledger-archives/ursa/pulls)
* [Actions](/hyperledger-archives/ursa/actions)
* [Security](/hyperledger-archives/ursa/security)
* [Insights](/hyperledger-archives/ursa/pulse)

Additional navigation options

* [Code](/hyperledger-archives/ursa)
* [Issues](/hyperledger-archives/ursa/issues)
* [Pull requests](/hyperledger-archives/ursa/pulls)
* [Actions](/hyperledger-archives/ursa/actions)
* [Security](/hyperledger-archives/ursa/security)
* [Insights](/hyperledger-archives/ursa/pulse)

# Breaking unlinkability in CL Signatures by colluding Issuers and Verifiers using malicious keys

Low

[swcurran](/swcurran)
published
GHSA-2q6j-gqc4-4gw3
Jan 16, 2024

## Package

cargo

libursa
([Rust](/advisories?query=ecosystem%3Arust))

## Affected versions

< 0.3

## Patched versions

None

## Description

# CL Signatures Issuer Key Correctness Proof lacks of prime strength checking

A weakness in the Hyperledger AnonCreds specification that is not mitigated in the Ursa and AnonCreds implementations is that the Issuer does not publish a key correctness proof demonstrating that a generated private key is sufficient to meet the unlinkability guarantees of AnonCreds. A sufficient private key is one in which it's components `p` and `q` are safe primes, such that:

* `p` and `q` are both prime numbers
* `p` and `q` are not equal
* `p` and `q` have the same, sufficiently large, size
  + For example, using two values both 1024 bits long is sufficient, whereas using one value 2040 bits long and the other 8 bits long is not.

The Ursa and AnonCreds CL-Signatures implementations always generate a sufficient private key. A malicious issuer could in theory create a custom CL Signature implementation (derived from the Ursa or AnonCreds CL-Signatures implementations) that uses weakened private keys such that presentations from holders could be shared by verifiers to the issuer who could determine the holder to which the credential was issued.

### Impact

This vulnerability could impact holders of AnonCreds credentials implemented using the CL-signature scheme in the Ursa and AnonCreds implementations of CL Signatures.

### Mitigations

[Jan Camenisch and Markus Michels. Proving in zero-knowledge that a number is the product of two safe primes](https://www.brics.dk/RS/98/29/BRICS-RS-98-29.pdf) (pages 12-13) demonstrates a key correctness proof that could be used to show the issuer has generated a sufficiently strong private key, proving the characteristics listed above.

In a future version of AnonCreds, the additional key correctness proof could be published separately or added to the Credential Definition. In the meantime, Issuers in existing ecosystems can share such a proof with their ecosystem co-participants in an ad hoc manner.

The lack of such a published key correctness proof allows a malicious Issuer to deliberately generate a private key that lacks the requirements listed above, enabling the Issuer to perform a brute force attack on presentations provided to colluding verifiers that breaks the unlinkability guarantee of AnonCreds.

### Severity

Low

3.3

# CVSS overall score

 This score calculates overall vulnerability severity from 0 to 10 and is based on the Common Vulnerability Scoring System (CVSS).

 / 10

#### CVSS v3 base metrics

Attack vector
Local

Attack complexity
Low

Privileges required
None

User interaction
Required

Scope
Unchanged

Confidentiality
Low

Integrity
None

Availability
None

Learn more about base metrics

# CVSS v3 base metrics

Attack vector:
More severe the more the remote (logically and physically) an attacker can be in order to exploit the vulnerability.

Attack complexity:
More severe for the least complex attacks.

Privileges required:
More severe if no privileges are required.

User interaction:
More severe when no user interaction is required.

Scope:
More severe when a scope change occurs, e.g. one vulnerable component impacts resources in components beyond its security scope.

Confidentiality:
More severe when loss of data confidentiality is highest, measuring the level of data access available to an unauthorized user.

Integrity:
More severe when loss of data integrity is the highest, measuring the consequence of data modification possible by an unauthorized user.

Availability:
More severe when the loss of impacted component availability is highest.

CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N

### CVE ID

CVE-2022-31021

### Weaknesses

No CWEs

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


