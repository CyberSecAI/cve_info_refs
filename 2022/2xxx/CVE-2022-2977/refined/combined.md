=== Content from security.netapp.com_ea8a4f0b_20250114_231458.html ===

[Skip to main content](#n-main-content)

* [NetApp.com](https://www.netapp.com/)
* [Support](https://mysupport.netapp.com)
* [Community](https://community.netapp.com)
* [Training](https://www.netapp.com/support-and-training/netapp-learning-services/)

* [Contact Us](https://www.netapp.com/company/contact-us/)

English
æ¥æ¬èª

[netapp-mark

NetApp

## Product Security](https://security.netapp.com)

Search

Search

* Search

Search

Search

* [Home](https://security.netapp.com/en)
* [Advisories](https://security.netapp.com/advisory/)
* [Bulletins](https://security.netapp.com/bulletins/)
* [Contact](https://security.netapp.com/contact/)
* [Policy](https://security.netapp.com/policy/)
* [Resources](https://security.netapp.com/resources/)
* [Certifications](https://security.netapp.com/certs/)

* [Home](https://security.netapp.com/en)
* [Advisory](https://security.netapp.com/advisory)
* [September 2022 Linux Kernel 5.17 Vulnerabilities in NetApp Products](https://security.netapp.com/advisory/ntap-20230214-0006)

## September 2022 Linux Kernel 5.17 Vulnerabilities in NetApp Products

circle-check-alt

This advisory should be considered the single source of current, up-to-date, authorized and accurate information from NetApp regarding Full Support products and versions.

close ×

#### Subscribe to NTAP-20230214-0006 updates

Email

Yes, please send me emails when NetApp Security Advisories are posted or updated.

 By filling and submitting this form, I understand and agree with the [NetApp privacy policy](https://www.netapp.com/company/legal/privacy-policy/ "Privacy Policy") and understand that I can unsubscribe from NetApp Security Advisory communications at any time.

Subscribe

#### Subscribe to NTAP-20230214-0006 advisory updates

OTP

Confirm

ionicons-v5-e

Confirmed your subscription to advisory alerts

close ×

#### Unsubscribe from NTAP-20230214-0006 advisory updates

Email

Unsubscribe

#### Unsubscribe from NTAP-20230214-0006 advisory updates

Email

Confirm

ionicons-v5-e

Unsubscribed successfully from advisory alerts

Subscribe to receive email updates

**Advisory ID:** NTAP-20230214-0006
**Version:**
2.0

**Last updated:**
03/14/2023

**Status:**
Final.

**CVEs:** CVE-2022-1729, CVE-2022-2977, CVE-2022-3239

Overview
#### Summary

Multiple NetApp products incorporate Linux Kernel. Linux Kernel versions prior to 5.18 are susceptible to vulnerabilities which when successfully exploited could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS).

#### Impact

Successful exploitation of these vulnerabilities could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS).

#### Vulnerability Scoring Details

| **CVE** | **Score** | **Vector** |
| --- | --- | --- |
| [CVE-2022-1729](https://nvd.nist.gov/vuln/detail/CVE-2022-1729) | 7.0 (HIGH) | CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H |
| [CVE-2022-2977](https://nvd.nist.gov/vuln/detail/CVE-2022-2977) | 7.8 (HIGH) | CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H |
| [CVE-2022-3239](https://nvd.nist.gov/vuln/detail/CVE-2022-3239) | 7.8 (HIGH) | CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H |

#### Exploitation and Public Announcements

NetApp is aware of public discussion of this vulnerability.

Affected Products
#### Affected Products

* NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H410S
* NetApp HCI Baseboard Management Controller (BMC) - H410C

#### Products Not Affected

* 7-Mode Transition Tool
* AFF Baseboard Management Controller (BMC) - A700s
* ATTO FibreBridge - 7500N
* ATTO FibreBridge - 7600N
* Active IQ Unified Manager for Linux
* Active IQ Unified Manager for Microsoft Windows
* Active IQ Unified Manager for VMware vSphere
* Active IQ mobile app
* Astra Control Center
* Astra Control Center - NetApp Kubernetes Monitoring Operator
* Astra Trident
* Astra Trident Autosupport
* Brocade Fabric Operating System Firmware
* Brocade SAN Navigator (SANnav)
* Cloud Data Sense
* Cloud Insights Acquisition Unit
* Cloud Insights Storage Workload Security Agent
* Cloud Insights Telegraf Agent
* Cloud Volumes ONTAP Mediator
* E-Series BIOS
* E-Series SANtricity OS Controller Software 11.x
* E-Series SANtricity Storage Manager
* E-Series SANtricity Unified Manager and Web Services Proxy
* Element .NET SDK
* Element HealthTools
* Element JAVA SDK
* Element Plug-in for vCenter Server
* Element Powershell Tools
* Element Python SDK
* FAS/AFF BIOS - 8080/8060/8040/8020
* FAS/AFF BIOS - 8300/8700/A400
* FAS/AFF BIOS - A250/500f
* FAS/AFF BIOS - A300/8200/A200/2650/2620/C190/A220/2720/2750
* FAS/AFF BIOS - A320
* FAS/AFF BIOS - A700/9000
* FAS/AFF BIOS - A700s
* FAS/AFF BIOS - A800
* FAS/AFF BIOS - A900/9500
* FAS/AFF Baseboard Management Controller (BMC) - 8300/8700/A400
* FAS/AFF Baseboard Management Controller (BMC) - A250/500f
* FAS/AFF Baseboard Management Controller (BMC) - A320/C190/A220/FAS2720/FAS2750/A800
* FAS/AFF Baseboard Management Controller (BMC) - A900/9500
* FAS/AFF Service Processor - 2554/2552/2520
* FAS/AFF Service Processor - 8080/8060/8040/8020
* FAS/AFF Service Processor - A300/8200/A200/2650/2620
* FAS/AFF Service Processor - A700/9000
* Global File Cache
* Host Utilities - SAN for Linux
* Host Utilities - SAN for Windows
* IOM6 SAS Disk Shelf Firmware
* Interoperability Matrix Tool
* Inventory Collect Tool
* Management Services for Element Software and NetApp HCI
* MetroCluster Tiebreaker for clustered Data ONTAP
* Multipath I/O (SANtricity DSM for Windows MPIO)
* NetApp BlueXP
* NetApp Cloud Backup OST Plug-in (formerly AltaVault OST Plug-in)
* NetApp Converged Systems Advisor Agent
* NetApp E-Series Host Collection
* NetApp E-Series SANtricity Collection
* NetApp HCI Baseboard Management Controller (BMC) - H610C
* NetApp HCI Baseboard Management Controller (BMC) - H610S
* NetApp HCI Baseboard Management Controller (BMC) - H615C
* NetApp HCI Compute Node (Bootstrap OS)
* NetApp HCI Compute Node BIOS
* NetApp HCI Storage Node BIOS
* NetApp Kubernetes Monitoring Operator
* NetApp Manageability SDK
* NetApp NFS Plug-in for VMware VAAI
* NetApp ONTAP PowerShell Toolkit (PSTK)
* NetApp SMI-S Provider
* NetApp SolidFire & HCI Management Node
* NetApp SolidFire & HCI Storage Node (Element Software)
* NetApp SolidFire Plug-in for vRealize Orchestrator (SolidFire vRO)
* NetApp Virtual Desktop Service (VDS)
* NetApp XCP NFS
* NetApp XCP SMB
* ONTAP 9 (formerly Clustered Data ONTAP)
* ONTAP Antivirus Connector
* ONTAP Mediator
* ONTAP Select Deploy administration utility
* ONTAP tools for VMware vSphere
* OnCommand Insight
* OnCommand Workflow Automation
* SANtricity Storage Plugin for vCenter
* SRA Plugin for Linux
* SRA Plugin for Windows
* Single Mailbox Recovery
* Snap Creator Framework
* SnapCenter
* SnapCenter Plug-in for VMware vSphere
* SnapManager for Hyper-V
* SolidFire Storage Replication Adapter
* Spot PC
* StorageGRID (formerly StorageGRID Webscale)
* StorageGRID BIOS SG1000/SG100
* StorageGRID BIOS SG5660/SG5612/SG5760/SG5712
* StorageGRID BIOS SG6060/SGF6024
* StorageGRID Baseboard Management Controller (BMC)
* System Manager 9.x

Remediation
#### Software Versions and Fixes

NetApp's currently available patches are listed below.

| **Product** | **First Fixed in Release** |
| --- | --- |
| **NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H410S** | NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H410S has no plans to address this vulnerability. See the [EOA announcement](https://mysupport.netapp.com/info/communications/ECMLP2884466.html) for more information. |
| **NetApp HCI Baseboard Management Controller (BMC) - H410C** | NetApp HCI Baseboard Management Controller (BMC) - H410C has no plans to address this vulnerability. See the [EOA announcement](https://mysupport.netapp.com/info/communications/ECMLP2884466.html) for more information. |

#### Workarounds

None at this time.

#### Obtaining Software Fixes

Software fixes will be made available through the NetApp Support website in the Software Download section.

<https://mysupport.netapp.com/site/downloads/>

Customers who do not have access to the Support website should contact Technical Support at the number below to obtain the patches.

#### Contact Information

Check <http://mysupport.netapp.com> for further
updates.

**Technical Support**

Revision History
#### Status of This Notice

**Final.**

This advisory should be considered the single source of current, up-to-date, authorized and accurate information from NetApp regarding Full Support products and versions.

This advisory is posted at the following link:

<https://security.netapp.com/advisory/NTAP-20230214-0006>
#### Revision History

| **Revision #** | **Date** | **Comments** |
| --- | --- | --- |
| 1.0 | 20230214 | Initial Public Release |
| 2.0 | 20230314 | Brocade Fabric Operating System Firmware, NetApp HCI Baseboard Management Controller (BMC) - H610C, NetApp HCI Baseboard Management Controller (BMC) - H610S and NetApp HCI Baseboard Management Controller (BMC) - H615C moved to Products Not Affected, Final status |

This document is provided solely for informational purposes. All information is based upon NetAppâs current knowledge and understanding of the hardware and software products tested by NetApp, and the methodology and assumptions used by NetApp. NetApp is not responsible for any errors or omissions that may be contained herein, and no warranty, representation, or other legal commitment or obligation is being provided by NetApp. Â© 2025 NetApp, Inc. All rights reserved. No portions of this document may be reproduced without prior written consent of NetApp, Inc.

 ©  NetApp

Have feedback for our website?
[Let us know](https://www.netapp.com/forms/site-feedback/)



=== Content from git.kernel.org_5413b9f3_20250114_231457.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Linus Torvalds <torvalds@linux-foundation.org> | 2022-03-21 10:26:29 -0700 |
| --- | --- | --- |
| committer | Linus Torvalds <torvalds@linux-foundation.org> | 2022-03-21 10:26:29 -0700 |
| commit | [9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)) | |
| tree | [635a83b715495ce6473f5dcaa77779ae7b7cf418](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | |
| parent | [f443e374ae131c168a065ea1748feac6b2e76613](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f443e374ae131c168a065ea1748feac6b2e76613) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f&id2=f443e374ae131c168a065ea1748feac6b2e76613)) | |
| parent | [fb5abce6b2bb5cb3d628aaa63fa821da8c4600f9](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fb5abce6b2bb5cb3d628aaa63fa821da8c4600f9) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f&id2=fb5abce6b2bb5cb3d628aaa63fa821da8c4600f9)) | |
| download | [linux-9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f.tar.gz) | |

Merge tag 'tpmdd-next-v5.18-v2' of git://git.kernel.org/pub/scm/linux/kernel/git/jarkko/linux-tpmddPull tpm updates from Jarkko Sakkinen:
"In order to split the work a bit we've aligned with David Howells more
or less that I take more hardware/firmware aligned keyring patches,
and he takes care more of the framework aligned patches.
For TPM the patches worth of highlighting are the fixes for
refcounting provided by Lino Sanfilippo and James Bottomley.
Eric B. has done a bunch obvious (but important) fixes but there's one
a bit controversial: removal of asym\_tpm. It was added in 2018 when
TPM1 was already declared as insecure and world had moved on to TPM2.
I don't know how this has passed all the filters but I did not have a
chance to see the patches when they were out. I simply cannot commit
to maintaining this because it was from all angles just wrong to take
it in the first place to the mainline kernel. Nobody should use this
module really for anything.
Finally, there is a new keyring '.machine' to hold MOK keys ('Machine
Owner Keys'). In the mok side MokListTrustedRT UEFI variable can be
set, from which kernel knows that MOK keys are kernel trusted keys and
they are populated to the machine keyring. This keyring linked to the
secondary trusted keyring, which means that can be used like any
kernel trusted keys. This keyring of course can be used to hold other
MOK'ish keys in other platforms in future"
\* tag 'tpmdd-next-v5.18-v2' of git://git.kernel.org/pub/scm/linux/kernel/git/jarkko/linux-tpmdd: (24 commits)
tpm: use try\_get\_ops() in tpm-space.c
KEYS: asymmetric: properly validate hash\_algo and encoding
KEYS: asymmetric: enforce that sig algo matches key algo
KEYS: remove support for asym\_tpm keys
tpm: fix reference counting for struct tpm\_chip
integrity: Only use machine keyring when uefi\_check\_trust\_mok\_keys is true
integrity: Trust MOK keys if MokListTrustedRT found
efi/mokvar: move up init order
KEYS: Introduce link restriction for machine keys
KEYS: store reference to machine keyring
integrity: add new keyring handler for mok keys
integrity: Introduce a Linux keyring called machine
integrity: Fix warning about missing prototypes
KEYS: trusted: Avoid calling null function trusted\_key\_exit
KEYS: trusted: Fix trusted key backends when building as module
tpm: xen-tpmfront: Use struct\_size() helper
KEYS: x509: remove dead code that set ->unsupported\_sig
KEYS: x509: remove never-set ->unsupported\_key flag
KEYS: x509: remove unused fields
KEYS: x509: clearly distinguish between key and signature algorithms
...
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)

| -rw-r--r-- | [certs/system\_keyring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/certs/system_keyring.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 44 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [crypto/asymmetric\_keys/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/crypto/asymmetric_keys/Kconfig?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 21 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [crypto/asymmetric\_keys/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/crypto/asymmetric_keys/Makefile?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 12 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [crypto/asymmetric\_keys/asym\_tpm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/crypto/asymmetric_keys/asym_tpm.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 957 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [crypto/asymmetric\_keys/pkcs7\_verify.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/crypto/asymmetric_keys/pkcs7_verify.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 13 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [crypto/asymmetric\_keys/public\_key.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/crypto/asymmetric_keys/public_key.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 126 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [crypto/asymmetric\_keys/tpm.asn1](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/crypto/asymmetric_keys/tpm.asn1?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [crypto/asymmetric\_keys/tpm\_parser.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/crypto/asymmetric_keys/tpm_parser.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 102 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [crypto/asymmetric\_keys/x509.asn1](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/crypto/asymmetric_keys/x509.asn1?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [crypto/asymmetric\_keys/x509\_cert\_parser.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/crypto/asymmetric_keys/x509_cert_parser.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 34 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [crypto/asymmetric\_keys/x509\_parser.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/crypto/asymmetric_keys/x509_parser.h?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [crypto/asymmetric\_keys/x509\_public\_key.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/crypto/asymmetric_keys/x509_public_key.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 24 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/tpm/tpm-chip.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/tpm/tpm-chip.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 46 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/tpm/tpm-dev-common.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/tpm/tpm-dev-common.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/tpm/tpm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/tpm/tpm.h?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/tpm/tpm2-space.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/tpm/tpm2-space.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 73 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/char/tpm/xen-tpmfront.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/char/tpm/xen-tpmfront.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 8 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [drivers/firmware/efi/mokvar-table.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/firmware/efi/mokvar-table.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 2 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/crypto/asym\_tpm\_subtype.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/crypto/asym_tpm_subtype.h?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 19 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [include/keys/system\_keyring.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/keys/system_keyring.h?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 14 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/integrity/Kconfig?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 13 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/integrity/Makefile?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 1 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/digsig.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/integrity/digsig.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 15 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/integrity.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/integrity/integrity.h?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 17 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/platform\_certs/keyring\_handler.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/integrity/platform_certs/keyring_handler.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 18 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/platform\_certs/keyring\_handler.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/integrity/platform_certs/keyring_handler.h?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 5 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/platform\_certs/load\_uefi.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/integrity/platform_certs/load_uefi.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 4 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/integrity/platform\_certs/machine\_keyring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/integrity/platform_certs/machine_keyring.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 77 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/keys/keyctl\_pkey.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/keys/keyctl_pkey.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 14 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [security/keys/trusted-keys/trusted\_core.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/security/keys/trusted-keys/trusted_core.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 6 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/tpm2/tpm2.py](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/tpm2/tpm2.py?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 31 | |  |  |  | | --- | --- | --- | |
| -rw-r--r-- | [tools/testing/selftests/tpm2/tpm2\_tests.py](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/tools/testing/selftests/tpm2/tpm2_tests.py?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f) | 45 | |  |  |  | | --- | --- | --- | |

32 files changed, 486 insertions, 1273 deletions

| diff --git a/certs/system\_keyring.c b/certs/system\_keyring.cindex 692365dee2bd44..05b66ce9d1c9ed 100644--- a/[certs/system\_keyring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/certs/system_keyring.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[certs/system\_keyring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/certs/system_keyring.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -22,6 +22,9 @@ static struct key \*builtin\_trusted\_keys; #ifdef CONFIG\_SECONDARY\_TRUSTED\_KEYRING static struct key \*secondary\_trusted\_keys; #endif+#ifdef CONFIG\_INTEGRITY\_MACHINE\_KEYRING+static struct key \*machine\_trusted\_keys;+#endif #ifdef CONFIG\_INTEGRITY\_PLATFORM\_KEYRING static struct key \*platform\_trusted\_keys; #endif@@ -86,11 +89,50 @@ static \_\_init struct key\_restriction \*get\_builtin\_and\_secondary\_restriction(void if (!restriction) panic("Can't allocate secondary trusted keyring restriction\n"); - restriction->check = restrict\_link\_by\_builtin\_and\_secondary\_trusted;+ if (IS\_ENABLED(CONFIG\_INTEGRITY\_MACHINE\_KEYRING))+ restriction->check = restrict\_link\_by\_builtin\_secondary\_and\_machine;+ else+ restriction->check = restrict\_link\_by\_builtin\_and\_secondary\_trusted;  return restriction; } #endif+#ifdef CONFIG\_INTEGRITY\_MACHINE\_KEYRING+void \_\_init set\_machine\_trusted\_keys(struct key \*keyring)+{+ machine\_trusted\_keys = keyring;++ if (key\_link(secondary\_trusted\_keys, machine\_trusted\_keys) < 0)+ panic("Can't link (machine) trusted keyrings\n");+}++/\*\*+ \* restrict\_link\_by\_builtin\_secondary\_and\_machine - Restrict keyring addition.+ \* @dest\_keyring: Keyring being linked to.+ \* @type: The type of key being added.+ \* @payload: The payload of the new key.+ \* @restrict\_key: A ring of keys that can be used to vouch for the new cert.+ \*+ \* Restrict the addition of keys into a keyring based on the key-to-be-added+ \* being vouched for by a key in either the built-in, the secondary, or+ \* the machine keyrings.+ \*/+int restrict\_link\_by\_builtin\_secondary\_and\_machine(+ struct key \*dest\_keyring,+ const struct key\_type \*type,+ const union key\_payload \*payload,+ struct key \*restrict\_key)+{+ if (machine\_trusted\_keys && type == &key\_type\_keyring &&+ dest\_keyring == secondary\_trusted\_keys &&+ payload == &machine\_trusted\_keys->payload)+ /\* Allow the machine keyring to be added to the secondary \*/+ return 0;++ return restrict\_link\_by\_builtin\_and\_secondary\_trusted(dest\_keyring, type,+ payload, restrict\_key);+}+#endif  /\* \* Create the trusted keyringsdiff --git a/crypto/asymmetric\_keys/Kconfig b/crypto/asymmetric\_keys/Kconfigindex 1f1f004dc75773..460bc5d0a828ce 100644--- a/[crypto/asymmetric\_keys/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/Kconfig?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[crypto/asymmetric\_keys/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/Kconfig?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -22,18 +22,6 @@ config ASYMMETRIC\_PUBLIC\_KEY\_SUBTYPE appropriate hash algorithms (such as SHA-1) must be available. ENOPKG will be reported if the requisite algorithm is unavailable. -config ASYMMETRIC\_TPM\_KEY\_SUBTYPE- tristate "Asymmetric TPM backed private key subtype"- depends on TCG\_TPM- depends on TRUSTED\_KEYS- select CRYPTO\_HMAC- select CRYPTO\_SHA1- select CRYPTO\_HASH\_INFO- help- This option provides support for TPM backed private key type handling.- Operations such as sign, verify, encrypt, decrypt are performed by- the TPM after the private key is loaded.- config X509\_CERTIFICATE\_PARSER tristate "X.509 certificate parser" depends on ASYMMETRIC\_PUBLIC\_KEY\_SUBTYPE@@ -54,15 +42,6 @@ config PKCS8\_PRIVATE\_KEY\_PARSER private key data and provides the ability to instantiate a crypto key from that data. -config TPM\_KEY\_PARSER- tristate "TPM private key parser"- depends on ASYMMETRIC\_TPM\_KEY\_SUBTYPE- select ASN1- help- This option provides support for parsing TPM format blobs for- private key data and provides the ability to instantiate a crypto key- from that data.- config PKCS7\_MESSAGE\_PARSER tristate "PKCS#7 message parser" depends on X509\_CERTIFICATE\_PARSERdiff --git a/crypto/asymmetric\_keys/Makefile b/crypto/asymmetric\_keys/Makefileindex 28b91adba2aed3..c38424f55b08d0 100644--- a/[crypto/asymmetric\_keys/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/Makefile?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[crypto/asymmetric\_keys/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/Makefile?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -11,7 +11,6 @@ asymmetric\_keys-y := \ signature.o  obj-$(CONFIG\_ASYMMETRIC\_PUBLIC\_KEY\_SUBTYPE) += public\_key.o-obj-$(CONFIG\_ASYMMETRIC\_TPM\_KEY\_SUBTYPE) += asym\_tpm.o  # # X.509 Certificate handling@@ -75,14 +74,3 @@ verify\_signed\_pefile-y := \  $(obj)/mscode\_parser.o: $(obj)/mscode.asn1.h $(obj)/mscode.asn1.h $(obj)/mscode.asn1.o: $(obj)/mscode.asn1.c $(obj)/mscode.asn1.h--#-# TPM private key parsing-#-obj-$(CONFIG\_TPM\_KEY\_PARSER) += tpm\_key\_parser.o-tpm\_key\_parser-y := \- tpm.asn1.o \- tpm\_parser.o--$(obj)/tpm\_parser.o: $(obj)/tpm.asn1.h-$(obj)/tpm.asn1.o: $(obj)/tpm.asn1.c $(obj)/tpm.asn1.hdiff --git a/crypto/asymmetric\_keys/asym\_tpm.c b/crypto/asymmetric\_keys/asym\_tpm.cdeleted file mode 100644index 0959613560b9e4..00000000000000--- a/[crypto/asymmetric\_keys/asym\_tpm.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/asym_tpm.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ /dev/null@@ -1,957 +0,0 @@-// SPDX-License-Identifier: GPL-2.0-#define pr\_fmt(fmt) "ASYM-TPM: "fmt-#include <linux/slab.h>-#include <linux/module.h>-#include <linux/export.h>-#include <linux/kernel.h>-#include <linux/seq\_file.h>-#include <linux/scatterlist.h>-#include <linux/tpm.h>-#include <linux/tpm\_command.h>-#include <crypto/akcipher.h>-#include <crypto/hash.h>-#include <crypto/sha1.h>-#include <asm/unaligned.h>-#include <keys/asymmetric-subtype.h>-#include <keys/trusted\_tpm.h>-#include <crypto/asym\_tpm\_subtype.h>-#include <crypto/public\_key.h>--#define TPM\_ORD\_FLUSHSPECIFIC 186-#define TPM\_ORD\_LOADKEY2 65-#define TPM\_ORD\_UNBIND 30-#define TPM\_ORD\_SIGN 60--#define TPM\_RT\_KEY 0x00000001--/\*- \* Load a TPM key from the blob provided by userspace- \*/-static int tpm\_loadkey2(struct tpm\_buf \*tb,- uint32\_t keyhandle, unsigned char \*keyauth,- const unsigned char \*keyblob, int keybloblen,- uint32\_t \*newhandle)-{- unsigned char nonceodd[TPM\_NONCE\_SIZE];- unsigned char enonce[TPM\_NONCE\_SIZE];- unsigned char authdata[SHA1\_DIGEST\_SIZE];- uint32\_t authhandle = 0;- unsigned char cont = 0;- uint32\_t ordinal;- int ret;-- ordinal = htonl(TPM\_ORD\_LOADKEY2);-- /\* session for loading the key \*/- ret = oiap(tb, &authhandle, enonce);- if (ret < 0) {- pr\_info("oiap failed (%d)\n", ret);- return ret;- }-- /\* generate odd nonce \*/- ret = tpm\_get\_random(NULL, nonceodd, TPM\_NONCE\_SIZE);- if (ret < 0) {- pr\_info("tpm\_get\_random failed (%d)\n", ret);- return ret;- }-- /\* calculate authorization HMAC value \*/- ret = TSS\_authhmac(authdata, keyauth, SHA1\_DIGEST\_SIZE, enonce,- nonceodd, cont, sizeof(uint32\_t), &ordinal,- keybloblen, keyblob, 0, 0);- if (ret < 0)- return ret;-- /\* build the request buffer \*/- tpm\_buf\_reset(tb, TPM\_TAG\_RQU\_AUTH1\_COMMAND, TPM\_ORD\_LOADKEY2);- tpm\_buf\_append\_u32(tb, keyhandle);- tpm\_buf\_append(tb, keyblob, keybloblen);- tpm\_buf\_append\_u32(tb, authhandle);- tpm\_buf\_append(tb, nonceodd, TPM\_NONCE\_SIZE);- tpm\_buf\_append\_u8(tb, cont);- tpm\_buf\_append(tb, authdata, SHA1\_DIGEST\_SIZE);-- ret = trusted\_tpm\_send(tb->data, MAX\_BUF\_SIZE);- if (ret < 0) {- pr\_info("authhmac failed (%d)\n", ret);- return ret;- }-- ret = TSS\_checkhmac1(tb->data, ordinal, nonceodd, keyauth,- SHA1\_DIGEST\_SIZE, 0, 0);- if (ret < 0) {- pr\_info("TSS\_checkhmac1 failed (%d)\n", ret);- return ret;- }-- \*newhandle = LOAD32(tb->data, TPM\_DATA\_OFFSET);- return 0;-}--/\*- \* Execute the FlushSpecific TPM command- \*/-static int tpm\_flushspecific(struct tpm\_buf \*tb, uint32\_t handle)-{- tpm\_buf\_reset(tb, TPM\_TAG\_RQU\_COMMAND, TPM\_ORD\_FLUSHSPECIFIC);- tpm\_buf\_append\_u32(tb, handle);- tpm\_buf\_append\_u32(tb, TPM\_RT\_KEY);-- return trusted\_tpm\_send(tb->data, MAX\_BUF\_SIZE);-}--/\*- \* Decrypt a blob provided by userspace using a specific key handle.- \* The handle is a well known handle or previously loaded by e.g. LoadKey2- \*/-static int tpm\_unbind(struct tpm\_buf \*tb,- uint32\_t keyhandle, unsigned char \*keyauth,- const unsigned char \*blob, uint32\_t bloblen,- void \*out, uint32\_t outlen)-{- unsigned char nonceodd[TPM\_NONCE\_SIZE];- unsigned char enonce[TPM\_NONCE\_SIZE];- unsigned char authdata[SHA1\_DIGEST\_SIZE];- uint32\_t authhandle = 0;- unsigned char cont = 0;- uint32\_t ordinal;- uint32\_t datalen;- int ret;-- ordinal = htonl(TPM\_ORD\_UNBIND);- datalen = htonl(bloblen);-- /\* session for loading the key \*/- ret = oiap(tb, &authhandle, enonce);- if (ret < 0) {- pr\_info("oiap failed (%d)\n", ret);- return ret;- }-- /\* generate odd nonce \*/- ret = tpm\_get\_random(NULL, nonceodd, TPM\_NONCE\_SIZE);- if (ret < 0) {- pr\_info("tpm\_get\_random failed (%d)\n", ret);- return ret;- }-- /\* calculate authorization HMAC value \*/- ret = TSS\_authhmac(authdata, keyauth, SHA1\_DIGEST\_SIZE, enonce,- nonceodd, cont, sizeof(uint32\_t), &ordinal,- sizeof(uint32\_t), &datalen,- bloblen, blob, 0, 0);- if (ret < 0)- return ret;-- /\* build the request buffer \*/- tpm\_buf\_reset(tb, TPM\_TAG\_RQU\_AUTH1\_COMMAND, TPM\_ORD\_UNBIND);- tpm\_buf\_append\_u32(tb, keyhandle);- tpm\_buf\_append\_u32(tb, bloblen);- tpm\_buf\_append(tb, blob, bloblen);- tpm\_buf\_append\_u32(tb, authhandle);- tpm\_buf\_append(tb, nonceodd, TPM\_NONCE\_SIZE);- tpm\_buf\_append\_u8(tb, cont);- tpm\_buf\_append(tb, authdata, SHA1\_DIGEST\_SIZE);-- ret = trusted\_tpm\_send(tb->data, MAX\_BUF\_SIZE);- if (ret < 0) {- pr\_info("authhmac failed (%d)\n", ret);- return ret;- }-- datalen = LOAD32(tb->data, TPM\_DATA\_OFFSET);-- ret = TSS\_checkhmac1(tb->data, ordinal, nonceodd,- keyauth, SHA1\_DIGEST\_SIZE,- sizeof(uint32\_t), TPM\_DATA\_OFFSET,- datalen, TPM\_DATA\_OFFSET + sizeof(uint32\_t),- 0, 0);- if (ret < 0) {- pr\_info("TSS\_checkhmac1 failed (%d)\n", ret);- return ret;- }-- memcpy(out, tb->data + TPM\_DATA\_OFFSET + sizeof(uint32\_t),- min(outlen, datalen));-- return datalen;-}--/\*- \* Sign a blob provided by userspace (that has had the hash function applied)- \* using a specific key handle. The handle is assumed to have been previously- \* loaded by e.g. LoadKey2.- \*- \* Note that the key signature scheme of the used key should be set to- \* TPM\_SS\_RSASSAPKCS1v15\_DER. This allows the hashed input to be of any size- \* up to key\_length\_in\_bytes - 11 and not be limited to size 20 like the- \* TPM\_SS\_RSASSAPKCS1v15\_SHA1 signature scheme.- \*/-static int tpm\_sign(struct tpm\_buf \*tb,- uint32\_t keyhandle, unsigned char \*keyauth,- const unsigned char \*blob, uint32\_t bloblen,- void \*out, uint32\_t outlen)-{- unsigned char nonceodd[TPM\_NONCE\_SIZE];- unsigned char enonce[TPM\_NONCE\_SIZE];- unsigned char authdata[SHA1\_DIGEST\_SIZE];- uint32\_t authhandle = 0;- unsigned char cont = 0;- uint32\_t ordinal;- uint32\_t datalen;- int ret;-- ordinal = htonl(TPM\_ORD\_SIGN);- datalen = htonl(bloblen);-- /\* session for loading the key \*/- ret = oiap(tb, &authhandle, enonce);- if (ret < 0) {- pr\_info("oiap failed (%d)\n", ret);- return ret;- }-- /\* generate odd nonce \*/- ret = tpm\_get\_random(NULL, nonceodd, TPM\_NONCE\_SIZE);- if (ret < 0) {- pr\_info("tpm\_get\_random failed (%d)\n", ret);- return ret;- }-- /\* calculate authorization HMAC value \*/- ret = TSS\_authhmac(authdata, keyauth, SHA1\_DIGEST\_SIZE, enonce,- nonceodd, cont, sizeof(uint32\_t), &ordinal,- sizeof(uint32\_t), &datalen,- bloblen, blob, 0, 0);- if (ret < 0)- return ret;-- /\* build the request buffer \*/- tpm\_buf\_reset(tb, TPM\_TAG\_RQU\_AUTH1\_COMMAND, TPM\_ORD\_SIGN);- tpm\_buf\_append\_u32(tb, keyhandle);- tpm\_buf\_append\_u32(tb, bloblen);- tpm\_buf\_append(tb, blob, bloblen);- tpm\_buf\_append\_u32(tb, authhandle);- tpm\_buf\_append(tb, nonceodd, TPM\_NONCE\_SIZE);- tpm\_buf\_append\_u8(tb, cont);- tpm\_buf\_append(tb, authdata, SHA1\_DIGEST\_SIZE);-- ret = trusted\_tpm\_send(tb->data, MAX\_BUF\_SIZE);- if (ret < 0) {- pr\_info("authhmac failed (%d)\n", ret);- return ret;- }-- datalen = LOAD32(tb->data, TPM\_DATA\_OFFSET);-- ret = TSS\_checkhmac1(tb->data, ordinal, nonceodd,- keyauth, SHA1\_DIGEST\_SIZE,- sizeof(uint32\_t), TPM\_DATA\_OFFSET,- datalen, TPM\_DATA\_OFFSET + sizeof(uint32\_t),- 0, 0);- if (ret < 0) {- pr\_info("TSS\_checkhmac1 failed (%d)\n", ret);- return ret;- }-- memcpy(out, tb->data + TPM\_DATA\_OFFSET + sizeof(uint32\_t),- min(datalen, outlen));-- return datalen;-}--/\* Room to fit two u32 zeros for algo id and parameters length. \*/-#define SETKEY\_PARAMS\_SIZE (sizeof(u32) \* 2)--/\*- \* Maximum buffer size for the BER/DER encoded public key. The public key- \* is of the form SEQUENCE { INTEGER n, INTEGER e } where n is a maximum 2048- \* bit key and e is usually 65537- \* The encoding overhead is:- \* - max 4 bytes for SEQUENCE- \* - max 4 bytes for INTEGER n type/length- \* - 257 bytes of n- \* - max 2 bytes for INTEGER e type/length- \* - 3 bytes of e- \* - 4+4 of zeros for set\_pub\_key parameters (SETKEY\_PARAMS\_SIZE)- \*/-#define PUB\_KEY\_BUF\_SIZE (4 + 4 + 257 + 2 + 3 + SETKEY\_PARAMS\_SIZE)--/\*- \* Provide a part of a description of the key for /proc/keys.- \*/-static void asym\_tpm\_describe(const struct key \*asymmetric\_key,- struct seq\_file \*m)-{- struct tpm\_key \*tk = asymmetric\_key->payload.data[asym\_crypto];-- if (!tk)- return;-- seq\_printf(m, "TPM1.2/Blob");-}--static void asym\_tpm\_destroy(void \*payload0, void \*payload3)-{- struct tpm\_key \*tk = payload0;-- if (!tk)- return;-- kfree(tk->blob);- tk->blob\_len = 0;-- kfree(tk);-}--/\* How many bytes will it take to encode the length \*/-static inline uint32\_t definite\_length(uint32\_t len)-{- if (len <= 127)- return 1;- if (len <= 255)- return 2;- return 3;-}--static inline uint8\_t \*encode\_tag\_length(uint8\_t \*buf, uint8\_t tag,- uint32\_t len)-{- \*buf++ = tag;-- if (len <= 127) {- buf[0] = len;- return buf + 1;- }-- if (len <= 255) {- buf[0] = 0x81;- buf[1] = len;- return buf + 2;- }-- buf[0] = 0x82;- put\_unaligned\_be16(len, buf + 1);- return buf + 3;-}--static uint32\_t derive\_pub\_key(const void \*pub\_key, uint32\_t len, uint8\_t \*buf)-{- uint8\_t \*cur = buf;- uint32\_t n\_len = definite\_length(len) + 1 + len + 1;- uint32\_t e\_len = definite\_length(3) + 1 + 3;- uint8\_t e[3] = { 0x01, 0x00, 0x01 };-- /\* SEQUENCE \*/- cur = encode\_tag\_length(cur, 0x30, n\_len + e\_len);- /\* INTEGER n \*/- cur = encode\_tag\_length(cur, 0x02, len + 1);- cur[0] = 0x00;- memcpy(cur + 1, pub\_key, len);- cur += len + 1;- cur = encode\_tag\_length(cur, 0x02, sizeof(e));- memcpy(cur, e, sizeof(e));- cur += sizeof(e);- /\* Zero parameters to satisfy set\_pub\_key ABI. \*/- memzero\_explicit(cur, SETKEY\_PARAMS\_SIZE);-- return cur - buf;-}--/\*- \* Determine the crypto algorithm name.- \*/-static int determine\_akcipher(const char \*encoding, const char \*hash\_algo,- char alg\_name[CRYPTO\_MAX\_ALG\_NAME])-{- if (strcmp(encoding, "pkcs1") == 0) {- if (!hash\_algo) {- strcpy(alg\_name, "pkcs1pad(rsa)");- return 0;- }-- if (snprintf(alg\_name, CRYPTO\_MAX\_ALG\_NAME, "pkcs1pad(rsa,%s)",- hash\_algo) >= CRYPTO\_MAX\_ALG\_NAME)- return -EINVAL;-- return 0;- }-- if (strcmp(encoding, "raw") == 0) {- strcpy(alg\_name, "rsa");- return 0;- }-- return -ENOPKG;-}--/\*- \* Query information about a key.- \*/-static int tpm\_key\_query(const struct kernel\_pkey\_params \*params,- struct kernel\_pkey\_query \*info)-{- struct tpm\_key \*tk = params->key->payload.data[asym\_crypto];- int ret;- char alg\_name[CRYPTO\_MAX\_ALG\_NAME];- struct crypto\_akcipher \*tfm;- uint8\_t der\_pub\_key[PUB\_KEY\_BUF\_SIZE];- uint32\_t der\_pub\_key\_len;- int len;-- /\* TPM only works on private keys, public keys still done in software \*/- ret = determine\_akcipher(params->encoding, params->hash\_algo, alg\_name);- if (ret < 0)- return ret;-- tfm = crypto\_alloc\_akcipher(alg\_name, 0, 0);- if (IS\_ERR(tfm))- return PTR\_ERR(tfm);-- der\_pub\_key\_len = derive\_pub\_key(tk->pub\_key, tk->pub\_key\_len,- der\_pub\_key);-- ret = crypto\_akcipher\_set\_pub\_key(tfm, der\_pub\_key, der\_pub\_key\_len);- if (ret < 0)- goto error\_free\_tfm;-- len = crypto\_akcipher\_maxsize(tfm);-- info->key\_size = tk->key\_len;- info->max\_data\_size = tk->key\_len / 8;- info->max\_sig\_size = len;- info->max\_enc\_size = len;- info->max\_dec\_size = tk->key\_len / 8;-- info->supported\_ops = KEYCTL\_SUPPORTS\_ENCRYPT |- KEYCTL\_SUPPORTS\_DECRYPT |- KEYCTL\_SUPPORTS\_VERIFY |- KEYCTL\_SUPPORTS\_SIGN;-- ret = 0;-error\_free\_tfm:- crypto\_free\_akcipher(tfm);- pr\_devel("<==%s() = %d\n", \_\_func\_\_, ret);- return ret;-}--/\*- \* Encryption operation is performed with the public key. Hence it is done- \* in software- \*/-static int tpm\_key\_encrypt(struct tpm\_key \*tk,- struct kernel\_pkey\_params \*params,- const void \*in, void \*out)-{- char alg\_name[CRYPTO\_MAX\_ALG\_NAME];- struct crypto\_akcipher \*tfm;- struct akcipher\_request \*req;- struct crypto\_wait cwait;- struct scatterlist in\_sg, out\_sg;- uint8\_t der\_pub\_key[PUB\_KEY\_BUF\_SIZE];- uint32\_t der\_pub\_key\_len;- int ret;-- pr\_devel("==>%s()\n", \_\_func\_\_);-- ret = determine\_akcipher(params->encoding, params->hash\_algo, alg\_name);- if (ret < 0)- return ret;-- tfm = crypto\_alloc\_akcipher(alg\_name, 0, 0);- if (IS\_ERR(tfm))- return PTR\_ERR(tfm);-- der\_pub\_key\_len = derive\_pub\_key(tk->pub\_key, tk->pub\_key\_len,- der\_pub\_key);-- ret = crypto\_akcipher\_set\_pub\_key(tfm, der\_pub\_key, der\_pub\_key\_len);- if (ret < 0)- goto error\_free\_tfm;-- ret = -ENOMEM;- req = akcipher\_request\_alloc(tfm, GFP\_KERNEL);- if (!req)- goto error\_free\_tfm;-- sg\_init\_one(&in\_sg, in, params->in\_len);- sg\_init\_one(&out\_sg, out, params->out\_len);- akcipher\_request\_set\_crypt(req, &in\_sg, &out\_sg, params->in\_len,- params->out\_len);- crypto\_init\_wait(&cwait);- akcipher\_request\_set\_callback(req, CRYPTO\_TFM\_REQ\_MAY\_BACKLOG |- CRYPTO\_TFM\_REQ\_MAY\_SLEEP,- crypto\_req\_done, &cwait);-- ret = crypto\_akcipher\_encrypt(req);- ret = crypto\_wait\_req(ret, &cwait);-- if (ret == 0)- ret = req->dst\_len;-- akcipher\_request\_free(req);-error\_free\_tfm:- crypto\_free\_akcipher(tfm);- pr\_devel("<==%s() = %d\n", \_\_func\_\_, ret);- return ret;-}--/\*- \* Decryption operation is performed with the private key in the TPM.- \*/-static int tpm\_key\_decrypt(struct tpm\_key \*tk,- struct kernel\_pkey\_params \*params,- const void \*in, void \*out)-{- struct tpm\_buf tb;- uint32\_t keyhandle;- uint8\_t srkauth[SHA1\_DIGEST\_SIZE];- uint8\_t keyauth[SHA1\_DIGEST\_SIZE];- int r;-- pr\_devel("==>%s()\n", \_\_func\_\_);-- if (params->hash\_algo)- return -ENOPKG;-- if (strcmp(params->encoding, "pkcs1"))- return -ENOPKG;-- r = tpm\_buf\_init(&tb, 0, 0);- if (r)- return r;-- /\* TODO: Handle a non-all zero SRK authorization \*/- memset(srkauth, 0, sizeof(srkauth));-- r = tpm\_loadkey2(&tb, SRKHANDLE, srkauth,- tk->blob, tk->blob\_len, &keyhandle);- if (r < 0) {- pr\_devel("loadkey2 failed (%d)\n", r);- goto error;- }-- /\* TODO: Handle a non-all zero key authorization \*/- memset(keyauth, 0, sizeof(keyauth));-- r = tpm\_unbind(&tb, keyhandle, keyauth,- in, params->in\_len, out, params->out\_len);- if (r < 0)- pr\_devel("tpm\_unbind failed (%d)\n", r);-- if (tpm\_flushspecific(&tb, keyhandle) < 0)- pr\_devel("flushspecific failed (%d)\n", r);--error:- tpm\_buf\_destroy(&tb);- pr\_devel("<==%s() = %d\n", \_\_func\_\_, r);- return r;-}--/\*- \* Hash algorithm OIDs plus ASN.1 DER wrappings [RFC4880 sec 5.2.2].- \*/-static const u8 digest\_info\_md5[] = {- 0x30, 0x20, 0x30, 0x0c, 0x06, 0x08,- 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, /\* OID \*/- 0x05, 0x00, 0x04, 0x10-};--static const u8 digest\_info\_sha1[] = {- 0x30, 0x21, 0x30, 0x09, 0x06, 0x05,- 0x2b, 0x0e, 0x03, 0x02, 0x1a,- 0x05, 0x00, 0x04, 0x14-};--static const u8 digest\_info\_rmd160[] = {- 0x30, 0x21, 0x30, 0x09, 0x06, 0x05,- 0x2b, 0x24, 0x03, 0x02, 0x01,- 0x05, 0x00, 0x04, 0x14-};--static const u8 digest\_info\_sha224[] = {- 0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09,- 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04,- 0x05, 0x00, 0x04, 0x1c-};--static const u8 digest\_info\_sha256[] = {- 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09,- 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01,- 0x05, 0x00, 0x04, 0x20-};--static const u8 digest\_info\_sha384[] = {- 0x30, 0x41, 0x30, 0x0d, 0x06, 0x09,- 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02,- 0x05, 0x00, 0x04, 0x30-};--static const u8 digest\_info\_sha512[] = {- 0x30, 0x51, 0x30, 0x0d, 0x06, 0x09,- 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03,- 0x05, 0x00, 0x04, 0x40-};--static const struct asn1\_template {- const char \*name;- const u8 \*data;- size\_t size;-} asn1\_templates[] = {-#define \_(X) { #X, digest\_info\_##X, sizeof(digest\_info\_##X) }- \_(md5),- \_(sha1),- \_(rmd160),- \_(sha256),- \_(sha384),- \_(sha512),- \_(sha224),- { NULL }-#undef \_-};--static const struct asn1\_template \*lookup\_asn1(const char \*name)-{- const struct asn1\_template \*p;-- for (p = asn1\_templates; p->name; p++)- if (strcmp(name, p->name) == 0)- return p;- return NULL;-}--/\*- \* Sign operation is performed with the private key in the TPM.- \*/-static int tpm\_key\_sign(struct tpm\_key \*tk,- struct kernel\_pkey\_params \*params,- const void \*in, void \*out)-{- struct tpm\_buf tb;- uint32\_t keyhandle;- uint8\_t srkauth[SHA1\_DIGEST\_SIZE];- uint8\_t keyauth[SHA1\_DIGEST\_SIZE];- void \*asn1\_wrapped = NULL;- uint32\_t in\_len = params->in\_len;- int r;-- pr\_devel("==>%s()\n", \_\_func\_\_);-- if (strcmp(params->encoding, "pkcs1"))- return -ENOPKG;-- if (params->hash\_algo) {- const struct asn1\_template \*asn1 =- lookup\_asn1(params->hash\_algo);-- if (!asn1)- return -ENOPKG;-- /\* request enough space for the ASN.1 template + input hash \*/- asn1\_wrapped = kzalloc(in\_len + asn1->size, GFP\_KERNEL);- if (!asn1\_wrapped)- return -ENOMEM;-- /\* Copy ASN.1 template, then the input \*/- memcpy(asn1\_wrapped, asn1->data, asn1->size);- memcpy(asn1\_wrapped + asn1->size, in, in\_len);-- in = asn1\_wrapped;- in\_len += asn1->size;- }-- if (in\_len > tk->key\_len / 8 - 11) {- r = -EOVERFLOW;- goto error\_free\_asn1\_wrapped;- }-- r = tpm\_buf\_init(&tb, 0, 0);- if (r)- goto error\_free\_asn1\_wrapped;-- /\* TODO: Handle a non-all zero SRK authorization \*/- memset(srkauth, 0, sizeof(srkauth));-- r = tpm\_loadkey2(&tb, SRKHANDLE, srkauth,- tk->blob, tk->blob\_len, &keyhandle);- if (r < 0) {- pr\_devel("loadkey2 failed (%d)\n", r);- goto error\_free\_tb;- }-- /\* TODO: Handle a non-all zero key authorization \*/- memset(keyauth, 0, sizeof(keyauth));-- r = tpm\_sign(&tb, keyhandle, keyauth, in, in\_len, out, params->out\_len);- if (r < 0)- pr\_devel("tpm\_sign failed (%d)\n", r);-- if (tpm\_flushspecific(&tb, keyhandle) < 0)- pr\_devel("flushspecific failed (%d)\n", r);--error\_free\_tb:- tpm\_buf\_destroy(&tb);-error\_free\_asn1\_wrapped:- kfree(asn1\_wrapped);- pr\_devel("<==%s() = %d\n", \_\_func\_\_, r);- return r;-}--/\*- \* Do encryption, decryption and signing ops.- \*/-static int tpm\_key\_eds\_op(struct kernel\_pkey\_params \*params,- const void \*in, void \*out)-{- struct tpm\_key \*tk = params->key->payload.data[asym\_crypto];- int ret = -EOPNOTSUPP;-- /\* Perform the encryption calculation. \*/- switch (params->op) {- case kernel\_pkey\_encrypt:- ret = tpm\_key\_encrypt(tk, params, in, out);- break;- case kernel\_pkey\_decrypt:- ret = tpm\_key\_decrypt(tk, params, in, out);- break;- case kernel\_pkey\_sign:- ret = tpm\_key\_sign(tk, params, in, out);- break;- default:- BUG();- }-- return ret;-}--/\*- \* Verify a signature using a public key.- \*/-static int tpm\_key\_verify\_signature(const struct key \*key,- const struct public\_key\_signature \*sig)-{- const struct tpm\_key \*tk = key->payload.data[asym\_crypto];- struct crypto\_wait cwait;- struct crypto\_akcipher \*tfm;- struct akcipher\_request \*req;- struct scatterlist src\_sg[2];- char alg\_name[CRYPTO\_MAX\_ALG\_NAME];- uint8\_t der\_pub\_key[PUB\_KEY\_BUF\_SIZE];- uint32\_t der\_pub\_key\_len;- int ret;-- pr\_devel("==>%s()\n", \_\_func\_\_);-- BUG\_ON(!tk);- BUG\_ON(!sig);- BUG\_ON(!sig->s);-- if (!sig->digest)- return -ENOPKG;-- ret = determine\_akcipher(sig->encoding, sig->hash\_algo, alg\_name);- if (ret < 0)- return ret;-- tfm = crypto\_alloc\_akcipher(alg\_name, 0, 0);- if (IS\_ERR(tfm))- return PTR\_ERR(tfm);-- der\_pub\_key\_len = derive\_pub\_key(tk->pub\_key, tk->pub\_key\_len,- der\_pub\_key);-- ret = crypto\_akcipher\_set\_pub\_key(tfm, der\_pub\_key, der\_pub\_key\_len);- if (ret < 0)- goto error\_free\_tfm;-- ret = -ENOMEM;- req = akcipher\_request\_alloc(tfm, GFP\_KERNEL);- if (!req)- goto error\_free\_tfm;-- sg\_init\_table(src\_sg, 2);- sg\_set\_buf(&src\_sg[0], sig->s, sig->s\_size);- sg\_set\_buf(&src\_sg[1], sig->digest, sig->digest\_size);- akcipher\_request\_set\_crypt(req, src\_sg, NULL, sig->s\_size,- sig->digest\_size);- crypto\_init\_wait(&cwait);- akcipher\_request\_set\_callback(req, CRYPTO\_TFM\_REQ\_MAY\_BACKLOG |- CRYPTO\_TFM\_REQ\_MAY\_SLEEP,- crypto\_req\_done, &cwait);- ret = crypto\_wait\_req(crypto\_akcipher\_verify(req), &cwait);-- akcipher\_request\_free(req);-error\_free\_tfm:- crypto\_free\_akcipher(tfm);- pr\_devel("<==%s() = %d\n", \_\_func\_\_, ret);- if (WARN\_ON\_ONCE(ret > 0))- ret = -EINVAL;- return ret;-}--/\*- \* Parse enough information out of TPM\_KEY structure:- \* TPM\_STRUCT\_VER -> 4 bytes- \* TPM\_KEY\_USAGE -> 2 bytes- \* TPM\_KEY\_FLAGS -> 4 bytes- \* TPM\_AUTH\_DATA\_USAGE -> 1 byte- \* TPM\_KEY\_PARMS -> variable- \* UINT32 PCRInfoSize -> 4 bytes- \* BYTE\* -> PCRInfoSize bytes- \* TPM\_STORE\_PUBKEY- \* UINT32 encDataSize;- \* BYTE\* -> encDataSize;- \*- \* TPM\_KEY\_PARMS:- \* TPM\_ALGORITHM\_ID -> 4 bytes- \* TPM\_ENC\_SCHEME -> 2 bytes- \* TPM\_SIG\_SCHEME -> 2 bytes- \* UINT32 parmSize -> 4 bytes- \* BYTE\* -> variable- \*/-static int extract\_key\_parameters(struct tpm\_key \*tk)-{- const void \*cur = tk->blob;- uint32\_t len = tk->blob\_len;- const void \*pub\_key;- uint32\_t sz;- uint32\_t key\_len;-- if (len < 11)- return -EBADMSG;-- /\* Ensure this is a legacy key \*/- if (get\_unaligned\_be16(cur + 4) != 0x0015)- return -EBADMSG;-- /\* Skip to TPM\_KEY\_PARMS \*/- cur += 11;- len -= 11;-- if (len < 12)- return -EBADMSG;-- /\* Make sure this is an RSA key \*/- if (get\_unaligned\_be32(cur) != 0x00000001)- return -EBADMSG;-- /\* Make sure this is TPM\_ES\_RSAESPKCSv15 encoding scheme \*/- if (get\_unaligned\_be16(cur + 4) != 0x0002)- return -EBADMSG;-- /\* Make sure this is TPM\_SS\_RSASSAPKCS1v15\_DER signature scheme \*/- if (get\_unaligned\_be16(cur + 6) != 0x0003)- return -EBADMSG;-- sz = get\_unaligned\_be32(cur + 8);- if (len < sz + 12)- return -EBADMSG;-- /\* Move to TPM\_RSA\_KEY\_PARMS \*/- len -= 12;- cur += 12;-- /\* Grab the RSA key length \*/- key\_len = get\_unaligned\_be32(cur);-- switch (key\_len) {- case 512:- case 1024:- case 1536:- case 2048:- break;- default:- return -EINVAL;- }-- /\* Move just past TPM\_KEY\_PARMS \*/- cur += sz;- len -= sz;-- if (len < 4)- return -EBADMSG;-- sz = get\_unaligned\_be32(cur);- if (len < 4 + sz)- return -EBADMSG;-- /\* Move to TPM\_STORE\_PUBKEY \*/- cur += 4 + sz;- len -= 4 + sz;-- /\* Grab the size of the public key, it should jive with the key size \*/- sz = get\_unaligned\_be32(cur);- if (sz > 256)- return -EINVAL;-- pub\_key = cur + 4;-- tk->key\_len = key\_len;- tk->pub\_key = pub\_key;- tk->pub\_key\_len = sz;-- return 0;-}--/\* Given the blob, parse it and load it into the TPM \*/-struct tpm\_key \*tpm\_key\_create(const void \*blob, uint32\_t blob\_len)-{- int r;- struct tpm\_key \*tk;-- r = tpm\_is\_tpm2(NULL);- if (r < 0)- goto error;-- /\* We don't support TPM2 yet \*/- if (r > 0) {- r = -ENODEV;- goto error;- }-- r = -ENOMEM;- tk = kzalloc(sizeof(struct tpm\_key), GFP\_KERNEL);- if (!tk)- goto error;-- tk->blob = kmemdup(blob, blob\_len, GFP\_KERNEL);- if (!tk->blob)- goto error\_memdup;-- tk->blob\_len = blob\_len;-- r = extract\_key\_parameters(tk);- if (r < 0)- goto error\_extract;-- return tk;--error\_extract:- kfree(tk->blob);- tk->blob\_len = 0;-error\_memdup:- kfree(tk);-error:- return ERR\_PTR(r);-}-EXPORT\_SYMBOL\_GPL(tpm\_key\_create);--/\*- \* TPM-based asymmetric key subtype- \*/-struct asymmetric\_key\_subtype asym\_tpm\_subtype = {- .owner = THIS\_MODULE,- .name = "asym\_tpm",- .name\_len = sizeof("asym\_tpm") - 1,- .describe = asym\_tpm\_describe,- .destroy = asym\_tpm\_destroy,- .query = tpm\_key\_query,- .eds\_op = tpm\_key\_eds\_op,- .verify\_signature = tpm\_key\_verify\_signature,-};-EXPORT\_SYMBOL\_GPL(asym\_tpm\_subtype);--MODULE\_DESCRIPTION("TPM based asymmetric key subtype");-MODULE\_AUTHOR("Intel Corporation");-MODULE\_LICENSE("GPL v2");diff --git a/crypto/asymmetric\_keys/pkcs7\_verify.c b/crypto/asymmetric\_keys/pkcs7\_verify.cindex 0b4d07aa88111e..f6321c785714c9 100644--- a/[crypto/asymmetric\_keys/pkcs7\_verify.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/pkcs7_verify.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[crypto/asymmetric\_keys/pkcs7\_verify.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/pkcs7_verify.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -174,12 +174,6 @@ static int pkcs7\_find\_key(struct pkcs7\_message \*pkcs7, pr\_devel("Sig %u: Found cert serial match X.509[%u]\n", sinfo->index, certix); - if (strcmp(x509->pub->pkey\_algo, sinfo->sig->pkey\_algo) != 0) {- pr\_warn("Sig %u: X.509 algo and PKCS#7 sig algo don't match\n",- sinfo->index);- continue;- }- sinfo->signer = x509; return 0; }@@ -226,9 +220,6 @@ static int pkcs7\_verify\_sig\_chain(struct pkcs7\_message \*pkcs7, return 0; } - if (x509->unsupported\_key)- goto unsupported\_crypto\_in\_x509;- pr\_debug("- issuer %s\n", x509->issuer); sig = x509->sig; if (sig->auth\_ids[0])@@ -245,7 +236,7 @@ static int pkcs7\_verify\_sig\_chain(struct pkcs7\_message \*pkcs7, \* authority. \*/ if (x509->unsupported\_sig)- goto unsupported\_crypto\_in\_x509;+ goto unsupported\_sig\_in\_x509; x509->signer = x509; pr\_debug("- self-signed\n"); return 0;@@ -309,7 +300,7 @@ static int pkcs7\_verify\_sig\_chain(struct pkcs7\_message \*pkcs7, might\_sleep(); } -unsupported\_crypto\_in\_x509:+unsupported\_sig\_in\_x509: /\* Just prune the certificate chain at this point if we lack some \* crypto module to go further. Note, however, we don't want to set \* sinfo->unsupported\_crypto as the signed info block may still bediff --git a/crypto/asymmetric\_keys/public\_key.c b/crypto/asymmetric\_keys/public\_key.cindex 4fefb219bfdc86..7c9e6be35c30c1 100644--- a/[crypto/asymmetric\_keys/public\_key.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/public_key.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[crypto/asymmetric\_keys/public\_key.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/public_key.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -60,39 +60,83 @@ static void public\_key\_destroy(void \*payload0, void \*payload3) }  /\*- \* Determine the crypto algorithm name.+ \* Given a public\_key, and an encoding and hash\_algo to be used for signing+ \* and/or verification with that key, determine the name of the corresponding+ \* akcipher algorithm. Also check that encoding and hash\_algo are allowed. \*/-static-int software\_key\_determine\_akcipher(const char \*encoding,- const char \*hash\_algo,- const struct public\_key \*pkey,- char alg\_name[CRYPTO\_MAX\_ALG\_NAME])+static int+software\_key\_determine\_akcipher(const struct public\_key \*pkey,+ const char \*encoding, const char \*hash\_algo,+ char alg\_name[CRYPTO\_MAX\_ALG\_NAME]) { int n; - if (strcmp(encoding, "pkcs1") == 0) {- /\* The data wangled by the RSA algorithm is typically padded- \* and encoded in some manner, such as EMSA-PKCS1-1\_5 [RFC3447- \* sec 8.2].+ if (!encoding)+ return -EINVAL;++ if (strcmp(pkey->pkey\_algo, "rsa") == 0) {+ /\*+ \* RSA signatures usually use EMSA-PKCS1-1\_5 [RFC3447 sec 8.2].+ \*/+ if (strcmp(encoding, "pkcs1") == 0) {+ if (!hash\_algo)+ n = snprintf(alg\_name, CRYPTO\_MAX\_ALG\_NAME,+ "pkcs1pad(%s)",+ pkey->pkey\_algo);+ else+ n = snprintf(alg\_name, CRYPTO\_MAX\_ALG\_NAME,+ "pkcs1pad(%s,%s)",+ pkey->pkey\_algo, hash\_algo);+ return n >= CRYPTO\_MAX\_ALG\_NAME ? -EINVAL : 0;+ }+ if (strcmp(encoding, "raw") != 0)+ return -EINVAL;+ /\*+ \* Raw RSA cannot differentiate between different hash+ \* algorithms.+ \*/+ if (hash\_algo)+ return -EINVAL;+ } else if (strncmp(pkey->pkey\_algo, "ecdsa", 5) == 0) {+ if (strcmp(encoding, "x962") != 0)+ return -EINVAL;+ /\*+ \* ECDSA signatures are taken over a raw hash, so they don't+ \* differentiate between different hash algorithms. That means+ \* that the verifier should hard-code a specific hash algorithm.+ \* Unfortunately, in practice ECDSA is used with multiple SHAs,+ \* so we have to allow all of them and not just one. \*/ if (!hash\_algo)- n = snprintf(alg\_name, CRYPTO\_MAX\_ALG\_NAME,- "pkcs1pad(%s)",- pkey->pkey\_algo);- else- n = snprintf(alg\_name, CRYPTO\_MAX\_ALG\_NAME,- "pkcs1pad(%s,%s)",- pkey->pkey\_algo, hash\_algo);- return n >= CRYPTO\_MAX\_ALG\_NAME ? -EINVAL : 0;- }-- if (strcmp(encoding, "raw") == 0 ||- strcmp(encoding, "x962") == 0) {- strcpy(alg\_name, pkey->pkey\_algo);- return 0;+ return -EINVAL;+ if (strcmp(hash\_algo, "sha1") != 0 &&+ strcmp(hash\_algo, "sha224") != 0 &&+ strcmp(hash\_algo, "sha256") != 0 &&+ strcmp(hash\_algo, "sha384") != 0 &&+ strcmp(hash\_algo, "sha512") != 0)+ return -EINVAL;+ } else if (strcmp(pkey->pkey\_algo, "sm2") == 0) {+ if (strcmp(encoding, "raw") != 0)+ return -EINVAL;+ if (!hash\_algo)+ return -EINVAL;+ if (strcmp(hash\_algo, "sm3") != 0)+ return -EINVAL;+ } else if (strcmp(pkey->pkey\_algo, "ecrdsa") == 0) {+ if (strcmp(encoding, "raw") != 0)+ return -EINVAL;+ if (!hash\_algo)+ return -EINVAL;+ if (strcmp(hash\_algo, "streebog256") != 0 &&+ strcmp(hash\_algo, "streebog512") != 0)+ return -EINVAL;+ } else {+ /\* Unknown public key algorithm \*/+ return -ENOPKG; }-- return -ENOPKG;+ if (strscpy(alg\_name, pkey->pkey\_algo, CRYPTO\_MAX\_ALG\_NAME) < 0)+ return -EINVAL;+ return 0; }  static u8 \*pkey\_pack\_u32(u8 \*dst, u32 val)@@ -113,9 +157,8 @@ static int software\_key\_query(const struct kernel\_pkey\_params \*params, u8 \*key, \*ptr; int ret, len; - ret = software\_key\_determine\_akcipher(params->encoding,- params->hash\_algo,- pkey, alg\_name);+ ret = software\_key\_determine\_akcipher(pkey, params->encoding,+ params->hash\_algo, alg\_name); if (ret < 0) return ret; @@ -179,9 +222,8 @@ static int software\_key\_eds\_op(struct kernel\_pkey\_params \*params,  pr\_devel("==>%s()\n", \_\_func\_\_); - ret = software\_key\_determine\_akcipher(params->encoding,- params->hash\_algo,- pkey, alg\_name);+ ret = software\_key\_determine\_akcipher(pkey, params->encoding,+ params->hash\_algo, alg\_name); if (ret < 0) return ret; @@ -325,9 +367,23 @@ int public\_key\_verify\_signature(const struct public\_key \*pkey, BUG\_ON(!sig); BUG\_ON(!sig->s); - ret = software\_key\_determine\_akcipher(sig->encoding,- sig->hash\_algo,- pkey, alg\_name);+ /\*+ \* If the signature specifies a public key algorithm, it \*must\* match+ \* the key's actual public key algorithm.+ \*+ \* Small exception: ECDSA signatures don't specify the curve, but ECDSA+ \* keys do. So the strings can mismatch slightly in that case:+ \* "ecdsa-nist-\*" for the key, but "ecdsa" for the signature.+ \*/+ if (sig->pkey\_algo) {+ if (strcmp(pkey->pkey\_algo, sig->pkey\_algo) != 0 &&+ (strncmp(pkey->pkey\_algo, "ecdsa-", 6) != 0 ||+ strcmp(sig->pkey\_algo, "ecdsa") != 0))+ return -EKEYREJECTED;+ }++ ret = software\_key\_determine\_akcipher(pkey, sig->encoding,+ sig->hash\_algo, alg\_name); if (ret < 0) return ret; diff --git a/crypto/asymmetric\_keys/tpm.asn1 b/crypto/asymmetric\_keys/tpm.asn1deleted file mode 100644index d7f194232f30ac..00000000000000--- a/[crypto/asymmetric\_keys/tpm.asn1](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/tpm.asn1?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ /dev/null@@ -1,5 +0,0 @@------ Unencryted TPM Blob. For details of the format, see:--- http://david.woodhou.se/draft-woodhouse-cert-best-practice.html#I-D.mavrogiannopoulos-tpmuri----PrivateKeyInfo ::= OCTET STRING ({ tpm\_note\_key })diff --git a/crypto/asymmetric\_keys/tpm\_parser.c b/crypto/asymmetric\_keys/tpm\_parser.cdeleted file mode 100644index 96405d8dcd98dd..00000000000000--- a/[crypto/asymmetric\_keys/tpm\_parser.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/tpm_parser.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ /dev/null@@ -1,102 +0,0 @@-// SPDX-License-Identifier: GPL-2.0-#define pr\_fmt(fmt) "TPM-PARSER: "fmt-#include <linux/module.h>-#include <linux/kernel.h>-#include <linux/export.h>-#include <linux/slab.h>-#include <linux/err.h>-#include <keys/asymmetric-subtype.h>-#include <keys/asymmetric-parser.h>-#include <crypto/asym\_tpm\_subtype.h>-#include "tpm.asn1.h"--struct tpm\_parse\_context {- const void \*blob;- u32 blob\_len;-};--/\*- \* Note the key data of the ASN.1 blob.- \*/-int tpm\_note\_key(void \*context, size\_t hdrlen,- unsigned char tag,- const void \*value, size\_t vlen)-{- struct tpm\_parse\_context \*ctx = context;-- ctx->blob = value;- ctx->blob\_len = vlen;-- return 0;-}--/\*- \* Parse a TPM-encrypted private key blob.- \*/-static struct tpm\_key \*tpm\_parse(const void \*data, size\_t datalen)-{- struct tpm\_parse\_context ctx;- long ret;-- memset(&ctx, 0, sizeof(ctx));-- /\* Attempt to decode the private key \*/- ret = asn1\_ber\_decoder(&tpm\_decoder, &ctx, data, datalen);- if (ret < 0)- goto error;-- return tpm\_key\_create(ctx.blob, ctx.blob\_len);--error:- return ERR\_PTR(ret);-}-/\*- \* Attempt to parse a data blob for a key as a TPM private key blob.- \*/-static int tpm\_key\_preparse(struct key\_preparsed\_payload \*prep)-{- struct tpm\_key \*tk;-- /\*- \* TPM 1.2 keys are max 2048 bits long, so assume the blob is no- \* more than 4x that- \*/- if (prep->datalen > 256 \* 4)- return -EMSGSIZE;-- tk = tpm\_parse(prep->data, prep->datalen);-- if (IS\_ERR(tk))- return PTR\_ERR(tk);-- /\* We're pinning the module by being linked against it \*/- \_\_module\_get(asym\_tpm\_subtype.owner);- prep->payload.data[asym\_subtype] = &asym\_tpm\_subtype;- prep->payload.data[asym\_key\_ids] = NULL;- prep->payload.data[asym\_crypto] = tk;- prep->payload.data[asym\_auth] = NULL;- prep->quotalen = 100;- return 0;-}--static struct asymmetric\_key\_parser tpm\_key\_parser = {- .owner = THIS\_MODULE,- .name = "tpm\_parser",- .parse = tpm\_key\_preparse,-};--static int \_\_init tpm\_key\_init(void)-{- return register\_asymmetric\_key\_parser(&tpm\_key\_parser);-}--static void \_\_exit tpm\_key\_exit(void)-{- unregister\_asymmetric\_key\_parser(&tpm\_key\_parser);-}--module\_init(tpm\_key\_init);-module\_exit(tpm\_key\_exit);--MODULE\_DESCRIPTION("TPM private key-blob parser");-MODULE\_LICENSE("GPL v2");diff --git a/crypto/asymmetric\_keys/x509.asn1 b/crypto/asymmetric\_keys/x509.asn1index 5c9f4e4a52310c..92d59c32f96a8e 100644--- a/[crypto/asymmetric\_keys/x509.asn1](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/x509.asn1?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[crypto/asymmetric\_keys/x509.asn1](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/x509.asn1?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -7,7 +7,7 @@ Certificate ::= SEQUENCE { TBSCertificate ::= SEQUENCE { version [ 0 ] Version DEFAULT, serialNumber CertificateSerialNumber ({ x509\_note\_serial }),- signature AlgorithmIdentifier ({ x509\_note\_pkey\_algo }),+ signature AlgorithmIdentifier ({ x509\_note\_sig\_algo }), issuer Name ({ x509\_note\_issuer }), validity Validity, subject Name ({ x509\_note\_subject }),diff --git a/crypto/asymmetric\_keys/x509\_cert\_parser.c b/crypto/asymmetric\_keys/x509\_cert\_parser.cindex 083405eb80c32a..2899ed80bb18e3 100644--- a/[crypto/asymmetric\_keys/x509\_cert\_parser.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/x509_cert_parser.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[crypto/asymmetric\_keys/x509\_cert\_parser.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/x509_cert_parser.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -19,15 +19,13 @@ struct x509\_parse\_context { struct x509\_certificate \*cert; /\* Certificate being constructed \*/ unsigned long data; /\* Start of data \*/- const void \*cert\_start; /\* Start of cert content \*/ const void \*key; /\* Key data \*/ size\_t key\_size; /\* Size of key data \*/ const void \*params; /\* Key parameters \*/ size\_t params\_size; /\* Size of key parameters \*/- enum OID key\_algo; /\* Public key algorithm \*/+ enum OID key\_algo; /\* Algorithm used by the cert's key \*/ enum OID last\_oid; /\* Last OID encountered \*/- enum OID algo\_oid; /\* Algorithm OID \*/- unsigned char nr\_mpi; /\* Number of MPIs stored \*/+ enum OID sig\_algo; /\* Algorithm used to sign the cert \*/ u8 o\_size; /\* Size of organizationName (O) \*/ u8 cn\_size; /\* Size of commonName (CN) \*/ u8 email\_size; /\* Size of emailAddress \*/@@ -187,11 +185,10 @@ int x509\_note\_tbs\_certificate(void \*context, size\_t hdrlen, }  /\*- \* Record the public key algorithm+ \* Record the algorithm that was used to sign this certificate. \*/-int x509\_note\_pkey\_algo(void \*context, size\_t hdrlen,- unsigned char tag,- const void \*value, size\_t vlen)+int x509\_note\_sig\_algo(void \*context, size\_t hdrlen, unsigned char tag,+ const void \*value, size\_t vlen) { struct x509\_parse\_context \*ctx = context; @@ -263,22 +260,22 @@ int x509\_note\_pkey\_algo(void \*context, size\_t hdrlen, rsa\_pkcs1: ctx->cert->sig->pkey\_algo = "rsa"; ctx->cert->sig->encoding = "pkcs1";- ctx->algo\_oid = ctx->last\_oid;+ ctx->sig\_algo = ctx->last\_oid; return 0; ecrdsa: ctx->cert->sig->pkey\_algo = "ecrdsa"; ctx->cert->sig->encoding = "raw";- ctx->algo\_oid = ctx->last\_oid;+ ctx->sig\_algo = ctx->last\_oid; return 0; sm2: ctx->cert->sig->pkey\_algo = "sm2"; ctx->cert->sig->encoding = "raw";- ctx->algo\_oid = ctx->last\_oid;+ ctx->sig\_algo = ctx->last\_oid; return 0; ecdsa: ctx->cert->sig->pkey\_algo = "ecdsa"; ctx->cert->sig->encoding = "x962";- ctx->algo\_oid = ctx->last\_oid;+ ctx->sig\_algo = ctx->last\_oid; return 0; } @@ -291,11 +288,16 @@ int x509\_note\_signature(void \*context, size\_t hdrlen, { struct x509\_parse\_context \*ctx = context; - pr\_debug("Signature type: %u size %zu\n", ctx->last\_oid, vlen);+ pr\_debug("Signature: alg=%u, size=%zu\n", ctx->last\_oid, vlen); - if (ctx->last\_oid != ctx->algo\_oid) {- pr\_warn("Got cert with pkey (%u) and sig (%u) algorithm OIDs\n",- ctx->algo\_oid, ctx->last\_oid);+ /\*+ \* In X.509 certificates, the signature's algorithm is stored in two+ \* places: inside the TBSCertificate (the data that is signed), and+ \* alongside the signature. These \*must\* match.+ \*/+ if (ctx->last\_oid != ctx->sig\_algo) {+ pr\_warn("signatureAlgorithm (%u) differs from tbsCertificate.signature (%u)\n",+ ctx->last\_oid, ctx->sig\_algo); return -EINVAL; } diff --git a/crypto/asymmetric\_keys/x509\_parser.h b/crypto/asymmetric\_keys/x509\_parser.hindex c233f136fb354d..da854c94f1115e 100644--- a/[crypto/asymmetric\_keys/x509\_parser.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/x509_parser.h?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[crypto/asymmetric\_keys/x509\_parser.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/x509_parser.h?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -36,7 +36,6 @@ struct x509\_certificate { bool seen; /\* Infinite recursion prevention \*/ bool verified; bool self\_signed; /\* T if self-signed (check unsupported\_sig too) \*/- bool unsupported\_key; /\* T if key uses unsupported crypto \*/ bool unsupported\_sig; /\* T if signature uses unsupported crypto \*/ bool blacklisted; };diff --git a/crypto/asymmetric\_keys/x509\_public\_key.c b/crypto/asymmetric\_keys/x509\_public\_key.cindex fe14cae115b51b..91a4ad50dea268 100644--- a/[crypto/asymmetric\_keys/x509\_public\_key.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/x509_public_key.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[crypto/asymmetric\_keys/x509\_public\_key.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/crypto/asymmetric_keys/x509_public_key.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -33,18 +33,6 @@ int x509\_get\_sig\_params(struct x509\_certificate \*cert) sig->data = cert->tbs; sig->data\_size = cert->tbs\_size; - if (!cert->pub->pkey\_algo)- cert->unsupported\_key = true;-- if (!sig->pkey\_algo)- cert->unsupported\_sig = true;-- /\* We check the hash if we can - even if we can't then verify it \*/- if (!sig->hash\_algo) {- cert->unsupported\_sig = true;- return 0;- }- sig->s = kmemdup(cert->raw\_sig, cert->raw\_sig\_size, GFP\_KERNEL); if (!sig->s) return -ENOMEM;@@ -128,12 +116,6 @@ int x509\_check\_for\_self\_signed(struct x509\_certificate \*cert) goto out; } - ret = -EKEYREJECTED;- if (strcmp(cert->pub->pkey\_algo, cert->sig->pkey\_algo) != 0 &&- (strncmp(cert->pub->pkey\_algo, "ecdsa-", 6) != 0 ||- strcmp(cert->sig->pkey\_algo, "ecdsa") != 0))- goto out;- ret = public\_key\_verify\_signature(cert->pub, cert->sig); if (ret < 0) { if (ret == -ENOPKG) {@@ -173,12 +155,6 @@ static int x509\_key\_preparse(struct key\_preparsed\_payload \*prep)  pr\_devel("Cert Issuer: %s\n", cert->issuer); pr\_devel("Cert Subject: %s\n", cert->subject);-- if (cert->unsupported\_key) {- ret = -ENOPKG;- goto error\_free\_cert;- }- pr\_devel("Cert Key Algo: %s\n", cert->pub->pkey\_algo); pr\_devel("Cert Valid period: %lld-%lld\n", cert->valid\_from, cert->valid\_to); diff --git a/drivers/char/tpm/tpm-chip.c b/drivers/char/tpm/tpm-chip.cindex b009e7479b702f..783d65fc71f07d 100644--- a/[drivers/char/tpm/tpm-chip.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/tpm/tpm-chip.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[drivers/char/tpm/tpm-chip.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/tpm/tpm-chip.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -274,14 +274,6 @@ static void tpm\_dev\_release(struct device \*dev) kfree(chip); } -static void tpm\_devs\_release(struct device \*dev)-{- struct tpm\_chip \*chip = container\_of(dev, struct tpm\_chip, devs);-- /\* release the master device reference \*/- put\_device(&chip->dev);-}- /\*\* \* tpm\_class\_shutdown() - prepare the TPM device for loss of power. \* @dev: device to which the chip is associated.@@ -344,7 +336,6 @@ struct tpm\_chip \*tpm\_chip\_alloc(struct device \*pdev, chip->dev\_num = rc;  device\_initialize(&chip->dev);- device\_initialize(&chip->devs);  chip->dev.class = tpm\_class; chip->dev.class->shutdown\_pre = tpm\_class\_shutdown;@@ -352,39 +343,20 @@ struct tpm\_chip \*tpm\_chip\_alloc(struct device \*pdev, chip->dev.parent = pdev; chip->dev.groups = chip->groups; - chip->devs.parent = pdev;- chip->devs.class = tpmrm\_class;- chip->devs.release = tpm\_devs\_release;- /\* get extra reference on main device to hold on- \* behalf of devs. This holds the chip structure- \* while cdevs is in use. The corresponding put- \* is in the tpm\_devs\_release (TPM2 only)- \*/- if (chip->flags & TPM\_CHIP\_FLAG\_TPM2)- get\_device(&chip->dev);- if (chip->dev\_num == 0) chip->dev.devt = MKDEV(MISC\_MAJOR, TPM\_MINOR); else chip->dev.devt = MKDEV(MAJOR(tpm\_devt), chip->dev\_num); - chip->devs.devt =- MKDEV(MAJOR(tpm\_devt), chip->dev\_num + TPM\_NUM\_DEVICES);- rc = dev\_set\_name(&chip->dev, "tpm%d", chip->dev\_num); if (rc) goto out;- rc = dev\_set\_name(&chip->devs, "tpmrm%d", chip->dev\_num);- if (rc)- goto out;  if (!pdev) chip->flags |= TPM\_CHIP\_FLAG\_VIRTUAL;  cdev\_init(&chip->cdev, &tpm\_fops);- cdev\_init(&chip->cdevs, &tpmrm\_fops); chip->cdev.owner = THIS\_MODULE;- chip->cdevs.owner = THIS\_MODULE;  rc = tpm2\_init\_space(&chip->work\_space, TPM2\_SPACE\_BUFFER\_SIZE); if (rc) {@@ -396,7 +368,6 @@ struct tpm\_chip \*tpm\_chip\_alloc(struct device \*pdev, return chip;  out:- put\_device(&chip->devs); put\_device(&chip->dev); return ERR\_PTR(rc); }@@ -445,14 +416,9 @@ static int tpm\_add\_char\_device(struct tpm\_chip \*chip) }  if (chip->flags & TPM\_CHIP\_FLAG\_TPM2 && !tpm\_is\_firmware\_upgrade(chip)) {- rc = cdev\_device\_add(&chip->cdevs, &chip->devs);- if (rc) {- dev\_err(&chip->devs,- "unable to cdev\_device\_add() %s, major %d, minor %d, err=%d\n",- dev\_name(&chip->devs), MAJOR(chip->devs.devt),- MINOR(chip->devs.devt), rc);- return rc;- }+ rc = tpm\_devs\_add(chip);+ if (rc)+ goto err\_del\_cdev; }  /\* Make the chip available. \*/@@ -460,6 +426,10 @@ static int tpm\_add\_char\_device(struct tpm\_chip \*chip) idr\_replace(&dev\_nums\_idr, chip, chip->dev\_num); mutex\_unlock(&idr\_lock); + return 0;++err\_del\_cdev:+ cdev\_device\_del(&chip->cdev, &chip->dev); return rc; } @@ -654,7 +624,7 @@ void tpm\_chip\_unregister(struct tpm\_chip \*chip) hwrng\_unregister(&chip->hwrng); tpm\_bios\_log\_teardown(chip); if (chip->flags & TPM\_CHIP\_FLAG\_TPM2 && !tpm\_is\_firmware\_upgrade(chip))- cdev\_device\_del(&chip->cdevs, &chip->devs);+ tpm\_devs\_remove(chip); tpm\_del\_char\_device(chip); } EXPORT\_SYMBOL\_GPL(tpm\_chip\_unregister);diff --git a/drivers/char/tpm/tpm-dev-common.c b/drivers/char/tpm/tpm-dev-common.cindex c08cbb306636ba..dc4c0a0a512903 100644--- a/[drivers/char/tpm/tpm-dev-common.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/tpm/tpm-dev-common.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[drivers/char/tpm/tpm-dev-common.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/tpm/tpm-dev-common.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -69,7 +69,13 @@ static void tpm\_dev\_async\_work(struct work\_struct \*work) ret = tpm\_dev\_transmit(priv->chip, priv->space, priv->data\_buffer, sizeof(priv->data\_buffer)); tpm\_put\_ops(priv->chip);- if (ret > 0) {++ /\*+ \* If ret is > 0 then tpm\_dev\_transmit returned the size of the+ \* response. If ret is < 0 then tpm\_dev\_transmit failed and+ \* returned an error code.+ \*/+ if (ret != 0) { priv->response\_length = ret; mod\_timer(&priv->user\_read\_timer, jiffies + (120 \* HZ)); }diff --git a/drivers/char/tpm/tpm.h b/drivers/char/tpm/tpm.hindex 283f78211c3a7b..2163c6ee0d364f 100644--- a/[drivers/char/tpm/tpm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/tpm/tpm.h?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[drivers/char/tpm/tpm.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/tpm/tpm.h?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -234,6 +234,8 @@ int tpm2\_prepare\_space(struct tpm\_chip \*chip, struct tpm\_space \*space, u8 \*cmd, size\_t cmdsiz); int tpm2\_commit\_space(struct tpm\_chip \*chip, struct tpm\_space \*space, void \*buf, size\_t \*bufsiz);+int tpm\_devs\_add(struct tpm\_chip \*chip);+void tpm\_devs\_remove(struct tpm\_chip \*chip);  void tpm\_bios\_log\_setup(struct tpm\_chip \*chip); void tpm\_bios\_log\_teardown(struct tpm\_chip \*chip);diff --git a/drivers/char/tpm/tpm2-space.c b/drivers/char/tpm/tpm2-space.cindex 97e916856cf3e2..ffb35f0154c16c 100644--- a/[drivers/char/tpm/tpm2-space.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/tpm/tpm2-space.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[drivers/char/tpm/tpm2-space.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/tpm/tpm2-space.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -58,12 +58,12 @@ int tpm2\_init\_space(struct tpm\_space \*space, unsigned int buf\_size)  void tpm2\_del\_space(struct tpm\_chip \*chip, struct tpm\_space \*space) {- mutex\_lock(&chip->tpm\_mutex);- if (!tpm\_chip\_start(chip)) {++ if (tpm\_try\_get\_ops(chip) == 0) { tpm2\_flush\_sessions(chip, space);- tpm\_chip\_stop(chip);+ tpm\_put\_ops(chip); }- mutex\_unlock(&chip->tpm\_mutex);+ kfree(space->context\_buf); kfree(space->session\_buf); }@@ -574,3 +574,68 @@ out: dev\_err(&chip->dev, "%s: error %d\n", \_\_func\_\_, rc); return rc; }++/\*+ \* Put the reference to the main device.+ \*/+static void tpm\_devs\_release(struct device \*dev)+{+ struct tpm\_chip \*chip = container\_of(dev, struct tpm\_chip, devs);++ /\* release the master device reference \*/+ put\_device(&chip->dev);+}++/\*+ \* Remove the device file for exposed TPM spaces and release the device+ \* reference. This may also release the reference to the master device.+ \*/+void tpm\_devs\_remove(struct tpm\_chip \*chip)+{+ cdev\_device\_del(&chip->cdevs, &chip->devs);+ put\_device(&chip->devs);+}++/\*+ \* Add a device file to expose TPM spaces. Also take a reference to the+ \* main device.+ \*/+int tpm\_devs\_add(struct tpm\_chip \*chip)+{+ int rc;++ device\_initialize(&chip->devs);+ chip->devs.parent = chip->dev.parent;+ chip->devs.class = tpmrm\_class;++ /\*+ \* Get extra reference on main device to hold on behalf of devs.+ \* This holds the chip structure while cdevs is in use. The+ \* corresponding put is in the tpm\_devs\_release.+ \*/+ get\_device(&chip->dev);+ chip->devs.release = tpm\_devs\_release;+ chip->devs.devt = MKDEV(MAJOR(tpm\_devt), chip->dev\_num + TPM\_NUM\_DEVICES);+ cdev\_init(&chip->cdevs, &tpmrm\_fops);+ chip->cdevs.owner = THIS\_MODULE;++ rc = dev\_set\_name(&chip->devs, "tpmrm%d", chip->dev\_num);+ if (rc)+ goto err\_put\_devs;++ rc = cdev\_device\_add(&chip->cdevs, &chip->devs);+ if (rc) {+ dev\_err(&chip->devs,+ "unable to cdev\_device\_add() %s, major %d, minor %d, err=%d\n",+ dev\_name(&chip->devs), MAJOR(chip->devs.devt),+ MINOR(chip->devs.devt), rc);+ goto err\_put\_devs;+ }++ return 0;++err\_put\_devs:+ put\_device(&chip->devs);++ return rc;+}diff --git a/drivers/char/tpm/xen-tpmfront.c b/drivers/char/tpm/xen-tpmfront.cindex da5b30771418f3..f53e0cf1ec7e9d 100644--- a/[drivers/char/tpm/xen-tpmfront.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/tpm/xen-tpmfront.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[drivers/char/tpm/xen-tpmfront.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/tpm/xen-tpmfront.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -126,16 +126,16 @@ static void vtpm\_cancel(struct tpm\_chip \*chip) notify\_remote\_via\_evtchn(priv->evtchn); } -static unsigned int shr\_data\_offset(struct vtpm\_shared\_page \*shr)+static size\_t shr\_data\_offset(struct vtpm\_shared\_page \*shr) {- return sizeof(\*shr) + sizeof(u32) \* shr->nr\_extra\_pages;+ return struct\_size(shr, extra\_pages, shr->nr\_extra\_pages); }  static int vtpm\_send(struct tpm\_chip \*chip, u8 \*buf, size\_t count) { struct tpm\_private \*priv = dev\_get\_drvdata(&chip->dev); struct vtpm\_shared\_page \*shr = priv->shr;- unsigned int offset = shr\_data\_offset(shr);+ size\_t offset = shr\_data\_offset(shr);  u32 ordinal; unsigned long duration;@@ -177,7 +177,7 @@ static int vtpm\_recv(struct tpm\_chip \*chip, u8 \*buf, size\_t count) { struct tpm\_private \*priv = dev\_get\_drvdata(&chip->dev); struct vtpm\_shared\_page \*shr = priv->shr;- unsigned int offset = shr\_data\_offset(shr);+ size\_t offset = shr\_data\_offset(shr); size\_t length = shr->length;  if (shr->state == VTPM\_STATE\_IDLE)diff --git a/drivers/firmware/efi/mokvar-table.c b/drivers/firmware/efi/mokvar-table.cindex 38722d2009e206..5ed0602c2f75f0 100644--- a/[drivers/firmware/efi/mokvar-table.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/firmware/efi/mokvar-table.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[drivers/firmware/efi/mokvar-table.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/firmware/efi/mokvar-table.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -359,4 +359,4 @@ static int \_\_init efi\_mokvar\_sysfs\_init(void) } return err; }-device\_initcall(efi\_mokvar\_sysfs\_init);+fs\_initcall(efi\_mokvar\_sysfs\_init);diff --git a/include/crypto/asym\_tpm\_subtype.h b/include/crypto/asym\_tpm\_subtype.hdeleted file mode 100644index 48198c36d6b9bd..00000000000000--- a/[include/crypto/asym\_tpm\_subtype.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/crypto/asym_tpm_subtype.h?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ /dev/null@@ -1,19 +0,0 @@-// SPDX-License-Identifier: GPL-2.0-#ifndef \_LINUX\_ASYM\_TPM\_SUBTYPE\_H-#define \_LINUX\_ASYM\_TPM\_SUBTYPE\_H--#include <linux/keyctl.h>--struct tpm\_key {- void \*blob;- u32 blob\_len;- uint16\_t key\_len; /\* Size in bits of the key \*/- const void \*pub\_key; /\* pointer inside blob to the public key bytes \*/- uint16\_t pub\_key\_len; /\* length of the public key \*/-};--struct tpm\_key \*tpm\_key\_create(const void \*blob, uint32\_t blob\_len);--extern struct asymmetric\_key\_subtype asym\_tpm\_subtype;--#endif /\* \_LINUX\_ASYM\_TPM\_SUBTYPE\_H \*/diff --git a/include/keys/system\_keyring.h b/include/keys/system\_keyring.hindex 6acd3cf13a18c7..2419a735420fb8 100644--- a/[include/keys/system\_keyring.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/keys/system_keyring.h?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[include/keys/system\_keyring.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/keys/system_keyring.h?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -38,6 +38,20 @@ extern int restrict\_link\_by\_builtin\_and\_secondary\_trusted( #define restrict\_link\_by\_builtin\_and\_secondary\_trusted restrict\_link\_by\_builtin\_trusted #endif +#ifdef CONFIG\_INTEGRITY\_MACHINE\_KEYRING+extern int restrict\_link\_by\_builtin\_secondary\_and\_machine(+ struct key \*dest\_keyring,+ const struct key\_type \*type,+ const union key\_payload \*payload,+ struct key \*restrict\_key);+extern void \_\_init set\_machine\_trusted\_keys(struct key \*keyring);+#else+#define restrict\_link\_by\_builtin\_secondary\_and\_machine restrict\_link\_by\_builtin\_trusted+static inline void \_\_init set\_machine\_trusted\_keys(struct key \*keyring)+{+}+#endif+ extern struct pkcs7\_message \*pkcs7; #ifdef CONFIG\_SYSTEM\_BLACKLIST\_KEYRING extern int mark\_hash\_blacklisted(const char \*hash);diff --git a/security/integrity/Kconfig b/security/integrity/Kconfigindex 71f0177e8716ee..599429f99f99fd 100644--- a/[security/integrity/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/Kconfig?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[security/integrity/Kconfig](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/Kconfig?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -62,6 +62,19 @@ config INTEGRITY\_PLATFORM\_KEYRING provided by the platform for verifying the kexec'ed kerned image and, possibly, the initramfs signature. +config INTEGRITY\_MACHINE\_KEYRING+ bool "Provide a keyring to which Machine Owner Keys may be added"+ depends on SECONDARY\_TRUSTED\_KEYRING+ depends on INTEGRITY\_ASYMMETRIC\_KEYS+ depends on SYSTEM\_BLACKLIST\_KEYRING+ depends on LOAD\_UEFI\_KEYS+ depends on !IMA\_KEYRINGS\_PERMIT\_SIGNED\_BY\_BUILTIN\_OR\_SECONDARY+ help+ If set, provide a keyring to which Machine Owner Keys (MOK) may+ be added. This keyring shall contain just MOK keys. Unlike keys+ in the platform keyring, keys contained in the .machine keyring will+ be trusted within the kernel.+ config LOAD\_UEFI\_KEYS depends on INTEGRITY\_PLATFORM\_KEYRING depends on EFIdiff --git a/security/integrity/Makefile b/security/integrity/Makefileindex 7ee39d66cf166c..d0ffe37dc1d646 100644--- a/[security/integrity/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/Makefile?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[security/integrity/Makefile](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/Makefile?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -10,6 +10,7 @@ integrity-$(CONFIG\_INTEGRITY\_AUDIT) += integrity\_audit.o integrity-$(CONFIG\_INTEGRITY\_SIGNATURE) += digsig.o integrity-$(CONFIG\_INTEGRITY\_ASYMMETRIC\_KEYS) += digsig\_asymmetric.o integrity-$(CONFIG\_INTEGRITY\_PLATFORM\_KEYRING) += platform\_certs/platform\_keyring.o+integrity-$(CONFIG\_INTEGRITY\_MACHINE\_KEYRING) += platform\_certs/machine\_keyring.o integrity-$(CONFIG\_LOAD\_UEFI\_KEYS) += platform\_certs/efi\_parser.o \ platform\_certs/load\_uefi.o \ platform\_certs/keyring\_handler.odiff --git a/security/integrity/digsig.c b/security/integrity/digsig.cindex 3b06a01bd0fdd5..c8c8a4a4e7a00c 100644--- a/[security/integrity/digsig.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/digsig.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[security/integrity/digsig.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/digsig.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -30,6 +30,7 @@ static const char \* const keyring\_name[INTEGRITY\_KEYRING\_MAX] = { ".ima", #endif ".platform",+ ".machine", };  #ifdef CONFIG\_IMA\_KEYRINGS\_PERMIT\_SIGNED\_BY\_BUILTIN\_OR\_SECONDARY@@ -111,6 +112,8 @@ static int \_\_init \_\_integrity\_init\_keyring(const unsigned int id, } else { if (id == INTEGRITY\_KEYRING\_PLATFORM) set\_platform\_trusted\_keys(keyring[id]);+ if (id == INTEGRITY\_KEYRING\_MACHINE && trust\_moklist())+ set\_machine\_trusted\_keys(keyring[id]); if (id == INTEGRITY\_KEYRING\_IMA) load\_module\_cert(keyring[id]); }@@ -126,7 +129,8 @@ int \_\_init integrity\_init\_keyring(const unsigned int id) perm = (KEY\_POS\_ALL & ~KEY\_POS\_SETATTR) | KEY\_USR\_VIEW | KEY\_USR\_READ | KEY\_USR\_SEARCH; - if (id == INTEGRITY\_KEYRING\_PLATFORM) {+ if (id == INTEGRITY\_KEYRING\_PLATFORM ||+ id == INTEGRITY\_KEYRING\_MACHINE) { restriction = NULL; goto out; }@@ -139,7 +143,14 @@ int \_\_init integrity\_init\_keyring(const unsigned int id) return -ENOMEM;  restriction->check = restrict\_link\_to\_ima;- perm |= KEY\_USR\_WRITE;++ /\*+ \* MOK keys can only be added through a read-only runtime services+ \* UEFI variable during boot. No additional keys shall be allowed to+ \* load into the machine keyring following init from userspace.+ \*/+ if (id != INTEGRITY\_KEYRING\_MACHINE)+ perm |= KEY\_USR\_WRITE;  out: return \_\_integrity\_init\_keyring(id, perm, restriction);diff --git a/security/integrity/integrity.h b/security/integrity/integrity.hindex 547425c20e1172..2e214c76115869 100644--- a/[security/integrity/integrity.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/integrity.h?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[security/integrity/integrity.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/integrity.h?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -151,7 +151,8 @@ int integrity\_kernel\_read(struct file \*file, loff\_t offset, #define INTEGRITY\_KEYRING\_EVM 0 #define INTEGRITY\_KEYRING\_IMA 1 #define INTEGRITY\_KEYRING\_PLATFORM 2-#define INTEGRITY\_KEYRING\_MAX 3+#define INTEGRITY\_KEYRING\_MACHINE 3+#define INTEGRITY\_KEYRING\_MAX 4  extern struct dentry \*integrity\_dir; @@ -283,3 +284,17 @@ static inline void \_\_init add\_to\_platform\_keyring(const char \*source, { } #endif++#ifdef CONFIG\_INTEGRITY\_MACHINE\_KEYRING+void \_\_init add\_to\_machine\_keyring(const char \*source, const void \*data, size\_t len);+bool \_\_init trust\_moklist(void);+#else+static inline void \_\_init add\_to\_machine\_keyring(const char \*source,+ const void \*data, size\_t len)+{+}+static inline bool \_\_init trust\_moklist(void)+{+ return false;+}+#endifdiff --git a/security/integrity/platform\_certs/keyring\_handler.c b/security/integrity/platform\_certs/keyring\_handler.cindex 5604bd57c99077..1db4d3b4356dc4 100644--- a/[security/integrity/platform\_certs/keyring\_handler.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/platform_certs/keyring_handler.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[security/integrity/platform\_certs/keyring\_handler.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/platform_certs/keyring_handler.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -9,6 +9,7 @@ #include <keys/asymmetric-type.h> #include <keys/system\_keyring.h> #include "../integrity.h"+#include "keyring\_handler.h"  static efi\_guid\_t efi\_cert\_x509\_guid \_\_initdata = EFI\_CERT\_X509\_GUID; static efi\_guid\_t efi\_cert\_x509\_sha256\_guid \_\_initdata =@@ -66,7 +67,7 @@ static \_\_init void uefi\_revocation\_list\_x509(const char \*source,  /\* \* Return the appropriate handler for particular signature list types found in- \* the UEFI db and MokListRT tables.+ \* the UEFI db tables. \*/ \_\_init efi\_element\_handler\_t get\_handler\_for\_db(const efi\_guid\_t \*sig\_type) {@@ -77,6 +78,21 @@ \_\_init efi\_element\_handler\_t get\_handler\_for\_db(const efi\_guid\_t \*sig\_type)  /\* \* Return the appropriate handler for particular signature list types found in+ \* the MokListRT tables.+ \*/+\_\_init efi\_element\_handler\_t get\_handler\_for\_mok(const efi\_guid\_t \*sig\_type)+{+ if (efi\_guidcmp(\*sig\_type, efi\_cert\_x509\_guid) == 0) {+ if (IS\_ENABLED(CONFIG\_INTEGRITY\_MACHINE\_KEYRING) && trust\_moklist())+ return add\_to\_machine\_keyring;+ else+ return add\_to\_platform\_keyring;+ }+ return 0;+}++/\*+ \* Return the appropriate handler for particular signature list types found in \* the UEFI dbx and MokListXRT tables. \*/ \_\_init efi\_element\_handler\_t get\_handler\_for\_dbx(const efi\_guid\_t \*sig\_type)diff --git a/security/integrity/platform\_certs/keyring\_handler.h b/security/integrity/platform\_certs/keyring\_handler.hindex 2462bfa08fe341..284558f30411eb 100644--- a/[security/integrity/platform\_certs/keyring\_handler.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/platform_certs/keyring_handler.h?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[security/integrity/platform\_certs/keyring\_handler.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/platform_certs/keyring_handler.h?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -25,6 +25,11 @@ void blacklist\_binary(const char \*source, const void \*data, size\_t len); efi\_element\_handler\_t get\_handler\_for\_db(const efi\_guid\_t \*sig\_type);  /\*+ \* Return the handler for particular signature list types found in the mok.+ \*/+efi\_element\_handler\_t get\_handler\_for\_mok(const efi\_guid\_t \*sig\_type);++/\* \* Return the handler for particular signature list types found in the dbx. \*/ efi\_element\_handler\_t get\_handler\_for\_dbx(const efi\_guid\_t \*sig\_type);diff --git a/security/integrity/platform\_certs/load\_uefi.c b/security/integrity/platform\_certs/load\_uefi.cindex 08b6d12f99b4fd..5f45c3c07dbd48 100644--- a/[security/integrity/platform\_certs/load\_uefi.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/platform_certs/load_uefi.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[security/integrity/platform\_certs/load\_uefi.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/platform_certs/load_uefi.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -95,7 +95,7 @@ static int \_\_init load\_moklist\_certs(void) rc = parse\_efi\_signature\_list("UEFI:MokListRT (MOKvar table)", mokvar\_entry->data, mokvar\_entry->data\_size,- get\_handler\_for\_db);+ get\_handler\_for\_mok); /\* All done if that worked. \*/ if (!rc) return rc;@@ -110,7 +110,7 @@ static int \_\_init load\_moklist\_certs(void) mok = get\_cert\_list(L"MokListRT", &mok\_var, &moksize, &status); if (mok) { rc = parse\_efi\_signature\_list("UEFI:MokListRT",- mok, moksize, get\_handler\_for\_db);+ mok, moksize, get\_handler\_for\_mok); kfree(mok); if (rc) pr\_err("Couldn't parse MokListRT signatures: %d\n", rc);diff --git a/security/integrity/platform\_certs/machine\_keyring.c b/security/integrity/platform\_certs/machine\_keyring.cnew file mode 100644index 00000000000000..7aaed7950b6e36--- /dev/null+++ b/[security/integrity/platform\_certs/machine\_keyring.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/integrity/platform_certs/machine_keyring.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -0,0 +1,77 @@+// SPDX-License-Identifier: GPL-2.0+/\*+ \* Machine keyring routines.+ \*+ \* Copyright (c) 2021, Oracle and/or its affiliates.+ \*/++#include <linux/efi.h>+#include "../integrity.h"++static bool trust\_mok;++static \_\_init int machine\_keyring\_init(void)+{+ int rc;++ rc = integrity\_init\_keyring(INTEGRITY\_KEYRING\_MACHINE);+ if (rc)+ return rc;++ pr\_notice("Machine keyring initialized\n");+ return 0;+}+device\_initcall(machine\_keyring\_init);++void \_\_init add\_to\_machine\_keyring(const char \*source, const void \*data, size\_t len)+{+ key\_perm\_t perm;+ int rc;++ perm = (KEY\_POS\_ALL & ~KEY\_POS\_SETATTR) | KEY\_USR\_VIEW;+ rc = integrity\_load\_cert(INTEGRITY\_KEYRING\_MACHINE, source, data, len, perm);++ /\*+ \* Some MOKList keys may not pass the machine keyring restrictions.+ \* If the restriction check does not pass and the platform keyring+ \* is configured, try to add it into that keyring instead.+ \*/+ if (rc && IS\_ENABLED(CONFIG\_INTEGRITY\_PLATFORM\_KEYRING))+ rc = integrity\_load\_cert(INTEGRITY\_KEYRING\_PLATFORM, source,+ data, len, perm);++ if (rc)+ pr\_info("Error adding keys to machine keyring %s\n", source);+}++/\*+ \* Try to load the MokListTrustedRT MOK variable to see if we should trust+ \* the MOK keys within the kernel. It is not an error if this variable+ \* does not exist. If it does not exist, MOK keys should not be trusted+ \* within the machine keyring.+ \*/+static \_\_init bool uefi\_check\_trust\_mok\_keys(void)+{+ struct efi\_mokvar\_table\_entry \*mokvar\_entry;++ mokvar\_entry = efi\_mokvar\_entry\_find("MokListTrustedRT");++ if (mokvar\_entry)+ return true;++ return false;+}++bool \_\_init trust\_moklist(void)+{+ static bool initialized;++ if (!initialized) {+ initialized = true;++ if (uefi\_check\_trust\_mok\_keys())+ trust\_mok = true;+ }++ return trust\_mok;+}diff --git a/security/keys/keyctl\_pkey.c b/security/keys/keyctl\_pkey.cindex 5de0d599a2748f..97bc27bbf07977 100644--- a/[security/keys/keyctl\_pkey.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/keys/keyctl_pkey.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[security/keys/keyctl\_pkey.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/keys/keyctl_pkey.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -135,15 +135,23 @@ static int keyctl\_pkey\_params\_get\_2(const struct keyctl\_pkey\_params \_\_user \*\_par  switch (op) { case KEYCTL\_PKEY\_ENCRYPT:+ if (uparams.in\_len > info.max\_dec\_size ||+ uparams.out\_len > info.max\_enc\_size)+ return -EINVAL;+ break; case KEYCTL\_PKEY\_DECRYPT: if (uparams.in\_len > info.max\_enc\_size || uparams.out\_len > info.max\_dec\_size) return -EINVAL; break; case KEYCTL\_PKEY\_SIGN:+ if (uparams.in\_len > info.max\_data\_size ||+ uparams.out\_len > info.max\_sig\_size)+ return -EINVAL;+ break; case KEYCTL\_PKEY\_VERIFY:- if (uparams.in\_len > info.max\_sig\_size ||- uparams.out\_len > info.max\_data\_size)+ if (uparams.in\_len > info.max\_data\_size ||+ uparams.in2\_len > info.max\_sig\_size) return -EINVAL; break; default:@@ -151,7 +159,7 @@ static int keyctl\_pkey\_params\_get\_2(const struct keyctl\_pkey\_params \_\_user \*\_par }  params->in\_len = uparams.in\_len;- params->out\_len = uparams.out\_len;+ params->out\_len = uparams.out\_len; /\* Note: same as in2\_len \*/ return 0; } diff --git a/security/keys/trusted-keys/trusted\_core.c b/security/keys/trusted-keys/trusted\_core.cindex d5c891d8d35348..9b9d3ef79cbe35 100644--- a/[security/keys/trusted-keys/trusted\_core.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/keys/trusted-keys/trusted_core.c?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[security/keys/trusted-keys/trusted\_core.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/security/keys/trusted-keys/trusted_core.c?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -27,10 +27,10 @@ module\_param\_named(source, trusted\_key\_source, charp, 0); MODULE\_PARM\_DESC(source, "Select trusted keys source (tpm or tee)");  static const struct trusted\_key\_source trusted\_key\_sources[] = {-#if defined(CONFIG\_TCG\_TPM)+#if IS\_REACHABLE(CONFIG\_TCG\_TPM) { "tpm", &trusted\_key\_tpm\_ops }, #endif-#if defined(CONFIG\_TEE)+#if IS\_REACHABLE(CONFIG\_TEE) { "tee", &trusted\_key\_tee\_ops }, #endif };@@ -351,7 +351,7 @@ static int \_\_init init\_trusted(void)  static void \_\_exit cleanup\_trusted(void) {- static\_call(trusted\_key\_exit)();+ static\_call\_cond(trusted\_key\_exit)(); }  late\_initcall(init\_trusted);diff --git a/tools/testing/selftests/tpm2/tpm2.py b/tools/testing/selftests/tpm2/tpm2.pyindex f34486cd7342d5..057a4f49c79d96 100644--- a/[tools/testing/selftests/tpm2/tpm2.py](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/tpm2/tpm2.py?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[tools/testing/selftests/tpm2/tpm2.py](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/tpm2/tpm2.py?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -56,6 +56,7 @@ TSS2\_RESMGR\_TPM\_RC\_LAYER = (11 << TSS2\_RC\_LAYER\_SHIFT)  TPM2\_CAP\_HANDLES = 0x00000001 TPM2\_CAP\_COMMANDS = 0x00000002+TPM2\_CAP\_PCRS = 0x00000005 TPM2\_CAP\_TPM\_PROPERTIES = 0x00000006  TPM2\_PT\_FIXED = 0x100@@ -712,3 +713,33 @@ class Client: pt += 1  return handles++ def get\_cap\_pcrs(self):+ pcr\_banks = {}++ fmt = '>HII III'++ cmd = struct.pack(fmt,+ TPM2\_ST\_NO\_SESSIONS,+ struct.calcsize(fmt),+ TPM2\_CC\_GET\_CAPABILITY,+ TPM2\_CAP\_PCRS, 0, 1)+ rsp = self.send\_cmd(cmd)[10:]+ \_, \_, cnt = struct.unpack('>BII', rsp[:9])+ rsp = rsp[9:]++ # items are TPMS\_PCR\_SELECTION's+ for i in range(0, cnt):+ hash, sizeOfSelect = struct.unpack('>HB', rsp[:3])+ rsp = rsp[3:]++ pcrSelect = 0+ if sizeOfSelect > 0:+ pcrSelect, = struct.unpack('%ds' % sizeOfSelect,+ rsp[:sizeOfSelect])+ rsp = rsp[sizeOfSelect:]+ pcrSelect = int.from\_bytes(pcrSelect, byteorder='big')++ pcr\_banks[hash] = pcrSelect++ return pcr\_banksdiff --git a/tools/testing/selftests/tpm2/tpm2\_tests.py b/tools/testing/selftests/tpm2/tpm2\_tests.pyindex 9d764306887b70..ffe98b5c8d22f3 100644--- a/[tools/testing/selftests/tpm2/tpm2\_tests.py](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/tpm2/tpm2_tests.py?id=f443e374ae131c168a065ea1748feac6b2e76613)+++ b/[tools/testing/selftests/tpm2/tpm2\_tests.py](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/tpm2/tpm2_tests.py?id=9d8e7007dc7c4d7c8366739bbcd3f5e51dcd470f)@@ -27,7 +27,17 @@ class SmokeTest(unittest.TestCase): result = self.client.unseal(self.root\_key, blob, auth, None) self.assertEqual(data, result) + def determine\_bank\_alg(self, mask):+ pcr\_banks = self.client.get\_cap\_pcrs()+ for bank\_alg, pcrSelection in pcr\_banks.items():+ if pcrSelection & mask == mask:+ return bank\_alg+ return None+ def test\_seal\_with\_policy(self):+ bank\_alg = self.determine\_bank\_alg(1 << 16)+ self.assertIsNotNone(bank\_alg)+ handle = self.client.start\_auth\_session(tpm2.TPM2\_SE\_TRIAL)  data = ('X' \* 64).encode()@@ -35,7 +45,7 @@ class SmokeTest(unittest.TestCase): pcrs = [16]  try:- self.client.policy\_pcr(handle, pcrs)+ self.client.policy\_pcr(handle, pcrs, bank\_alg=bank\_alg) self.client.policy\_password(handle)  policy\_dig = self.client.get\_policy\_digest(handle)@@ -47,7 +57,7 @@ class SmokeTest(unittest.TestCase): handle = self.client.start\_auth\_session(tpm2.TPM2\_SE\_POLICY)  try:- self.client.policy\_pcr(handle, pcrs)+ self.client.policy\_pcr(handle, pcrs, bank\_alg=bank\_alg) self.client.policy\_password(handle)  result = self.client.unseal(self.root\_key, blob, auth, handle)@@ -72,6 +82,9 @@ class SmokeTest(unittest.TestCase): self.assertEqual(rc, tpm2.TPM2\_RC\_AUTH\_FAIL)  def test\_unseal\_with\_wrong\_policy(self):+ bank\_alg = self.determine\_bank\_alg(1 << 16 | 1 << 1)+ self.assertIsNotNone(bank\_alg)+ handle = self.client.start\_auth\_session(tpm2.TPM2\_SE\_TRIAL)  data = ('X' \* 64).encode()@@ -79,7 +92,7 @@ class SmokeTest(unittest.TestCase): pcrs = [16]  try:- self.client.policy\_pcr(handle, pcrs)+ self.client.policy\_pcr(handle, pcrs, bank\_alg=bank\_alg) self.client.policy\_password(handle)  policy\_dig = self.client.get\_policy\_digest(handle)@@ -91,13 +104,13 @@ class SmokeTest(unittest.TestCase): # Extend first a PCR that is not part of the policy and try to unseal. # This should succeed. - ds = tpm2.get\_digest\_size(tpm2.TPM2\_ALG\_SHA1)- self.client.extend\_pcr(1, ('X' \* ds).encode())+ ds = tpm2.get\_digest\_size(bank\_alg)+ self.client.extend\_pcr(1, ('X' \* ds).encode(), bank\_alg=bank\_alg)  handle = self.client.start\_auth\_session(tpm2.TPM2\_SE\_POLICY)  try:- self.client.policy\_pcr(handle, pcrs)+ self.client.policy\_pcr(handle, pcrs, bank\_alg=bank\_alg) self.client.policy\_password(handle)  result = self.client.unseal(self.root\_key, blob, auth, handle)@@ -109,14 +122,14 @@ class SmokeTest(unittest.TestCase):  # Then, extend a PCR that is part of the policy and try to unseal. # This should fail.- self.client.extend\_pcr(16, ('X' \* ds).encode())+ self.client.extend\_pcr(16, ('X' \* ds).encode(), bank\_alg=bank\_alg)  handle = self.client.start\_auth\_session(tpm2.TPM2\_SE\_POLICY)  rc = 0  try:- self.client.policy\_pcr(handle, pcrs)+ self.client.policy\_pcr(handle, pcrs, bank\_alg=bank\_alg) self.client.policy\_password(handle)  result = self.client.unseal(self.root\_key, blob, auth, handle)@@ -302,3 +315,19 @@ class AsyncTest(unittest.TestCase): log.debug("Calling get\_cap in a NON\_BLOCKING mode") async\_client.get\_cap(tpm2.TPM2\_CAP\_HANDLES, tpm2.HR\_LOADED\_SESSION) async\_client.close()++ def test\_flush\_invalid\_context(self):+ log = logging.getLogger(\_\_name\_\_)+ log.debug(sys.\_getframe().f\_code.co\_name)++ async\_client = tpm2.Client(tpm2.Client.FLAG\_SPACE | tpm2.Client.FLAG\_NONBLOCK)+ log.debug("Calling flush\_context passing in an invalid handle ")+ handle = 0x80123456+ rc = 0+ try:+ async\_client.flush\_context(handle)+ except OSError as e:+ rc = e.errno++ self.assertEqual(rc, 22)+ async\_client.close() |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 23:13:33 +0000


