=== Content from github.com_8cf67736_20250115_100613.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fopen-policy-agent%2Fopa%2Fblob%2F598176de326025451025225aca53e85708d5f1db%2Fast%2Fcompile.go)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fopen-policy-agent%2Fopa%2Fblob%2F598176de326025451025225aca53e85708d5f1db%2Fast%2Fcompile.go)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=open-policy-agent%2Fopa)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[open-policy-agent](/open-policy-agent)
/
**[opa](/open-policy-agent/opa)**
Public

* [Notifications](/login?return_to=%2Fopen-policy-agent%2Fopa) You must be signed in to change notification settings
* [Fork
  1.4k](/login?return_to=%2Fopen-policy-agent%2Fopa)
* [Star
   9.9k](/login?return_to=%2Fopen-policy-agent%2Fopa)

* [Code](/open-policy-agent/opa)
* [Issues
  384](/open-policy-agent/opa/issues)
* [Pull requests
  3](/open-policy-agent/opa/pulls)
* [Actions](/open-policy-agent/opa/actions)
* [Projects
  2](/open-policy-agent/opa/projects)
* [Wiki](/open-policy-agent/opa/wiki)
* [Security](/open-policy-agent/opa/security)
* [Insights](/open-policy-agent/opa/pulse)

Additional navigation options

* [Code](/open-policy-agent/opa)
* [Issues](/open-policy-agent/opa/issues)
* [Pull requests](/open-policy-agent/opa/pulls)
* [Actions](/open-policy-agent/opa/actions)
* [Projects](/open-policy-agent/opa/projects)
* [Wiki](/open-policy-agent/opa/wiki)
* [Security](/open-policy-agent/opa/security)
* [Insights](/open-policy-agent/opa/pulse)

## Files

 598176d
## Breadcrumbs

1. [opa](/open-policy-agent/opa/tree/598176de326025451025225aca53e85708d5f1db)
2. /[ast](/open-policy-agent/opa/tree/598176de326025451025225aca53e85708d5f1db/ast)
/
# compile.go

Copy path Blame  Blame
## Latest commit

## History

[History](/open-policy-agent/opa/commits/598176de326025451025225aca53e85708d5f1db/ast/compile.go)4732 lines (4131 loc) · 128 KB 598176d
## Breadcrumbs

1. [opa](/open-policy-agent/opa/tree/598176de326025451025225aca53e85708d5f1db)
2. /[ast](/open-policy-agent/opa/tree/598176de326025451025225aca53e85708d5f1db/ast)
/
# compile.go

Top
## File metadata and controls

* Code
* Blame

4732 lines (4131 loc) · 128 KB[Raw](https://github.com/open-policy-agent/opa/raw/598176de326025451025225aca53e85708d5f1db/ast/compile.go)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000// Copyright 2016 The OPA Authors. All rights reserved.// Use of this source code is governed by an Apache2// license that can be found in the LICENSE file.
package ast
import ( "fmt" "io" "sort" "strconv" "strings"
 "github.com/open-policy-agent/opa/internal/debug" "github.com/open-policy-agent/opa/internal/gojsonschema" "github.com/open-policy-agent/opa/metrics" "github.com/open-policy-agent/opa/types" "github.com/open-policy-agent/opa/util")
// CompileErrorLimitDefault is the default number errors a compiler will allow before// exiting.const CompileErrorLimitDefault = 10
var errLimitReached = NewError(CompileErr, nil, "error limit reached")
// Compiler contains the state of a compilation process.type Compiler struct {
 // Errors contains errors that occurred during the compilation process. // If there are one or more errors, the compilation process is considered // "failed". Errors Errors
 // Modules contains the compiled modules. The compiled modules are the // output of the compilation process. If the compilation process failed, // there is no guarantee about the state of the modules. Modules map[string]\*Module
 // ModuleTree organizes the modules into a tree where each node is keyed by // an element in the module's package path. E.g., given modules containing // the following package directives: "a", "a.b", "a.c", and "a.b", the // resulting module tree would be: // // root // | // +--- data (no modules) // | // +--- a (1 module) // | // +--- b (2 modules) // | // +--- c (1 module) // ModuleTree \*ModuleTreeNode
 // RuleTree organizes rules into a tree where each node is keyed by an // element in the rule's path. The rule path is the concatenation of the // containing package and the stringified rule name. E.g., given the // following module: // // package ex // p[1] { true } // p[2] { true } // q = true // // root // | // +--- data (no rules) // | // +--- ex (no rules) // | // +--- p (2 rules) // | // +--- q (1 rule) RuleTree \*TreeNode
 // Graph contains dependencies between rules. An edge (u,v) is added to the // graph if rule 'u' refers to the virtual document defined by 'v'. Graph \*Graph
 // TypeEnv holds type information for values inferred by the compiler. TypeEnv \*TypeEnv
 // RewrittenVars is a mapping of variables that have been rewritten // with the key being the generated name and value being the original. RewrittenVars map[Var]Var
 localvargen \*localVarGenerator moduleLoader ModuleLoader ruleIndices \*util.HashMap stages []struct { name string metricName string f func() } maxErrs int sorted []string // list of sorted module names pathExists func([]string) (bool, error) after map[string][]CompilerStageDefinition metrics metrics.Metrics capabilities \*Capabilities // user-supplied capabilities builtins map[string]\*Builtin // universe of built-in functions customBuiltins map[string]\*Builtin // user-supplied custom built-in functions (deprecated: use capabilities) unsafeBuiltinsMap map[string]struct{} // user-supplied set of unsafe built-ins functions to block (deprecated: use capabilities) deprecatedBuiltinsMap map[string]struct{} // set of deprecated, but not removed, built-in functions enablePrintStatements bool // indicates if print statements should be elided (default) comprehensionIndices map[\*Term]\*ComprehensionIndex // comprehension key index initialized bool // indicates if init() has been called debug debug.Debug // emits debug information produced during compilation schemaSet \*SchemaSet // user-supplied schemas for input and data documents inputType types.Type // global input type retrieved from schema set annotationSet \*AnnotationSet // hierarchical set of annotations strict bool // enforce strict compilation checks}
// CompilerStage defines the interface for stages in the compiler.type CompilerStage func(\*Compiler) \*Error
// CompilerStageDefinition defines a compiler stagetype CompilerStageDefinition struct { Name string MetricName string Stage CompilerStage}
// RulesOptions defines the options for retrieving rules by Ref from the// compiler.type RulesOptions struct { // IncludeHiddenModules determines if the result contains hidden modules, // currently only the "system" namespace, i.e. "data.system.\*". IncludeHiddenModules bool}
// QueryContext contains contextual information for running an ad-hoc query.//// Ad-hoc queries can be run in the context of a package and imports may be// included to provide concise access to data.type QueryContext struct { Package \*Package Imports []\*Import}
// NewQueryContext returns a new QueryContext object.func NewQueryContext() \*QueryContext { return &QueryContext{}}
// WithPackage sets the pkg on qc.func (qc \*QueryContext) WithPackage(pkg \*Package) \*QueryContext { if qc == nil { qc = NewQueryContext() } qc.Package = pkg return qc}
// WithImports sets the imports on qc.func (qc \*QueryContext) WithImports(imports []\*Import) \*QueryContext { if qc == nil { qc = NewQueryContext() } qc.Imports = imports return qc}
// Copy returns a deep copy of qc.func (qc \*QueryContext) Copy() \*QueryContext { if qc == nil { return nil } cpy := \*qc if cpy.Package != nil { cpy.Package = qc.Package.Copy() } cpy.Imports = make([]\*Import, len(qc.Imports)) for i := range qc.Imports { cpy.Imports[i] = qc.Imports[i].Copy() } return &cpy}
// QueryCompiler defines the interface for compiling ad-hoc queries.type QueryCompiler interface {
 // Compile should be called to compile ad-hoc queries. The return value is // the compiled version of the query. Compile(q Body) (Body, error)
 // TypeEnv returns the type environment built after running type checking // on the query. TypeEnv() \*TypeEnv
 // WithContext sets the QueryContext on the QueryCompiler. Subsequent calls // to Compile will take the QueryContext into account. WithContext(qctx \*QueryContext) QueryCompiler
 // WithEnablePrintStatements enables print statements in queries compiled // with the QueryCompiler. WithEnablePrintStatements(yes bool) QueryCompiler
 // WithUnsafeBuiltins sets the built-in functions to treat as unsafe and not // allow inside of queries. By default the query compiler inherits the // compiler's unsafe built-in functions. This function allows callers to // override that set. If an empty (non-nil) map is provided, all built-ins // are allowed. WithUnsafeBuiltins(unsafe map[string]struct{}) QueryCompiler
 // WithStageAfter registers a stage to run during query compilation after // the named stage. WithStageAfter(after string, stage QueryCompilerStageDefinition) QueryCompiler
 // RewrittenVars maps generated vars in the compiled query to vars from the // parsed query. For example, given the query "input := 1" the rewritten // query would be "\_\_local0\_\_ = 1". The mapping would then be {\_\_local0\_\_: input}. RewrittenVars() map[Var]Var
 // ComprehensionIndex returns an index data structure for the given comprehension // term. If no index is found, returns nil. ComprehensionIndex(term \*Term) \*ComprehensionIndex}
// QueryCompilerStage defines the interface for stages in the query compiler.type QueryCompilerStage func(QueryCompiler, Body) (Body, error)
// QueryCompilerStageDefinition defines a QueryCompiler stagetype QueryCompilerStageDefinition struct { Name string MetricName string Stage QueryCompilerStage}
// NewCompiler returns a new empty compiler.func NewCompiler() \*Compiler {
 c := &Compiler{ Modules: map[string]\*Module{}, RewrittenVars: map[Var]Var{}, ruleIndices: util.NewHashMap(func(a, b util.T) bool { r1, r2 := a.(Ref), b.(Ref) return r1.Equal(r2) }, func(x util.T) int { return x.(Ref).Hash() }), maxErrs: CompileErrorLimitDefault, after: map[string][]CompilerStageDefinition{}, unsafeBuiltinsMap: map[string]struct{}{}, deprecatedBuiltinsMap: map[string]struct{}{}, comprehensionIndices: map[\*Term]\*ComprehensionIndex{}, debug: debug.Discard(), }
 c.ModuleTree = NewModuleTree(nil) c.RuleTree = NewRuleTree(c.ModuleTree)
 c.stages = []struct { name string metricName string f func() }{ {"CheckDuplicateImports", "compile\_stage\_check\_duplicate\_imports", c.checkDuplicateImports}, {"CheckKeywordOverrides", "compile\_stage\_check\_keyword\_overrides", c.checkKeywordOverrides}, // Reference resolution should run first as it may be used to lazily // load additional modules. If any stages run before resolution, they // need to be re-run after resolution. {"ResolveRefs", "compile\_stage\_resolve\_refs", c.resolveAllRefs}, {"SetModuleTree", "compile\_stage\_set\_module\_tree", c.setModuleTree}, {"SetRuleTree", "compile\_stage\_set\_rule\_tree", c.setRuleTree}, // The local variable generator must be initialized after references are // resolved and the dynamic module loader has run but before subsequent // stages that need to generate variables. {"InitLocalVarGen", "compile\_stage\_init\_local\_var\_gen", c.initLocalVarGen}, {"RewriteLocalVars", "compile\_stage\_rewrite\_local\_vars", c.rewriteLocalVars}, {"CheckVoidCalls", "compile\_stage\_check\_void\_calls", c.checkVoidCalls}, {"RewritePrintCalls", "compile\_stage\_rewrite\_print\_calls", c.rewritePrintCalls}, {"RewriteExprTerms", "compile\_stage\_rewrite\_expr\_terms", c.rewriteExprTerms}, {"SetGraph", "compile\_stage\_set\_graph", c.setGraph}, {"RewriteComprehensionTerms", "compile\_stage\_rewrite\_comprehension\_terms", c.rewriteComprehensionTerms}, {"RewriteRefsInHead", "compile\_stage\_rewrite\_refs\_in\_head", c.rewriteRefsInHead}, {"RewriteWithValues", "compile\_stage\_rewrite\_with\_values", c.rewriteWithModifiers}, {"CheckRuleConflicts", "compile\_stage\_check\_rule\_conflicts", c.checkRuleConflicts}, {"CheckUndefinedFuncs", "compile\_stage\_check\_undefined\_funcs", c.checkUndefinedFuncs}, {"CheckSafetyRuleHeads", "compile\_stage\_check\_safety\_rule\_heads", c.checkSafetyRuleHeads}, {"CheckSafetyRuleBodies", "compile\_stage\_check\_safety\_rule\_bodies", c.checkSafetyRuleBodies}, {"RewriteEquals", "compile\_stage\_rewrite\_equals", c.rewriteEquals}, {"RewriteDynamicTerms", "compile\_stage\_rewrite\_dynamic\_terms", c.rewriteDynamicTerms}, {"CheckRecursion", "compile\_stage\_check\_recursion", c.checkRecursion}, {"SetAnnotationSet", "compile\_stage\_set\_annotationset", c.setAnnotationSet}, {"CheckTypes", "compile\_stage\_check\_types", c.checkTypes}, // must be run after CheckRecursion {"CheckUnsafeBuiltins", "compile\_state\_check\_unsafe\_builtins", c.checkUnsafeBuiltins}, {"CheckDeprecatedBuiltins", "compile\_state\_check\_deprecated\_builtins", c.checkDeprecatedBuiltins}, {"BuildRuleIndices", "compile\_stage\_rebuild\_indices", c.buildRuleIndices}, {"BuildComprehensionIndices", "compile\_stage\_rebuild\_comprehension\_indices", c.buildComprehensionIndices}, }
 return c}
// SetErrorLimit sets the number of errors the compiler can encounter before it// quits. Zero or a negative number indicates no limit.func (c \*Compiler) SetErrorLimit(limit int) \*Compiler { c.maxErrs = limit return c}
// WithEnablePrintStatements enables print statements inside of modules compiled// by the compiler. If print statements are not enabled, calls to print() are// erased at compile-time.func (c \*Compiler) WithEnablePrintStatements(yes bool) \*Compiler { c.enablePrintStatements = yes return c}
// WithPathConflictsCheck enables base-virtual document conflict// detection. The compiler will check that rules don't overlap with// paths that exist as determined by the provided callable.func (c \*Compiler) WithPathConflictsCheck(fn func([]string) (bool, error)) \*Compiler { c.pathExists = fn return c}
// WithStageAfter registers a stage to run during compilation after// the named stage.func (c \*Compiler) WithStageAfter(after string, stage CompilerStageDefinition) \*Compiler { c.after[after] = append(c.after[after], stage) return c}
// WithMetrics will set a metrics.Metrics and be used for profiling// the Compiler instance.func (c \*Compiler) WithMetrics(metrics metrics.Metrics) \*Compiler { c.metrics = metrics return c}
// WithCapabilities sets capabilities to enable during compilation. Capabilities allow the caller// to specify the set of built-in functions available to the policy. In the future, capabilities// may be able to restrict access to other language features. Capabilities allow callers to check// if policies are compatible with a particular version of OPA. If policies are a compiled for a// specific version of OPA, there is no guarantee that \_this\_ version of OPA can evaluate them// successfully.func (c \*Compiler) WithCapabilities(capabilities \*Capabilities) \*Compiler { c.capabilities = capabilities return c}
// Capabilities returns the capabilities enabled during compilation.func (c \*Compiler) Capabilities() \*Capabilities { return c.capabilities}
// WithDebug sets where debug messages are written to. Passing `nil` has no// effect.func (c \*Compiler) WithDebug(sink io.Writer) \*Compiler { if sink != nil { c.debug = debug.New(sink) } return c}
// WithBuiltins is deprecated. Use WithCapabilities instead.func (c \*Compiler) WithBuiltins(builtins map[string]\*Builtin) \*Compiler { c.customBuiltins = make(map[string]\*Builtin) for k, v := range builtins { c.customBuiltins[k] = v } return c}
// WithUnsafeBuiltins is deprecated. Use WithCapabilities instead.func (c \*Compiler) WithUnsafeBuiltins(unsafeBuiltins map[string]struct{}) \*Compiler { for name := range unsafeBuiltins { c.unsafeBuiltinsMap[name] = struct{}{} } return c}
// WithStrict enables strict mode in the compiler.func (c \*Compiler) WithStrict(strict bool) \*Compiler { c.strict = strict return c}
// QueryCompiler returns a new QueryCompiler object.func (c \*Compiler) QueryCompiler() QueryCompiler { c.init() return newQueryCompiler(c)}
// Compile runs the compilation process on the input modules. The compiled// version of the modules and associated data structures are stored on the// compiler. If the compilation process fails for any reason, the compiler will// contain a slice of errors.func (c \*Compiler) Compile(modules map[string]\*Module) {
 c.init()
 c.Modules = make(map[string]\*Module, len(modules))
 for k, v := range modules { c.Modules[k] = v.Copy() c.sorted = append(c.sorted, k) }
 sort.Strings(c.sorted)
 c.compile()}
// WithSchemas sets a schemaSet to the compilerfunc (c \*Compiler) WithSchemas(schemas \*SchemaSet) \*Compiler { c.schemaSet = schemas return c}
// Failed returns true if a compilation error has been encountered.func (c \*Compiler) Failed() bool { return len(c.Errors) > 0}
// ComprehensionIndex returns a data structure specifying how to index comprehension// results so that callers do not have to recompute the comprehension more than once.// If no index is found, returns nil.func (c \*Compiler) ComprehensionIndex(term \*Term) \*ComprehensionIndex { return c.comprehensionIndices[term]}
// GetArity returns the number of args a function referred to by ref takes. If// ref refers to built-in function, the built-in declaration is consulted,// otherwise, the ref is used to perform a ruleset lookup.func (c \*Compiler) GetArity(ref Ref) int { if bi := c.builtins[ref.String()]; bi != nil { return len(bi.Decl.Args()) } rules := c.GetRulesExact(ref) if len(rules) == 0 { return -1 } return len(rules[0].Head.Args)}
// GetRulesExact returns a slice of rules referred to by the reference.//// E.g., given the following module://// package a.b.c//// p[k] = v { ... } # rule1// p[k1] = v1 { ... } # rule2//// The following calls yield the rules on the right.//// GetRulesExact("data.a.b.c.p") => [rule1, rule2]// GetRulesExact("data.a.b.c.p.x") => nil// GetRulesExact("data.a.b.c") => nilfunc (c \*Compiler) GetRulesExact(ref Ref) (rules []\*Rule) { node := c.RuleTree
 for \_, x := range ref { if node = node.Child(x.Value); node == nil { return nil } }
 return extractRules(node.Values)}
// GetRulesForVirtualDocument returns a slice of rules that produce the virtual// document referred to by the reference.//// E.g., given the following module://// package a.b.c//// p[k] = v { ... } # rule1// p[k1] = v1 { ... } # rule2//// The following calls yield the rules on the right.//// GetRulesForVirtualDocument("data.a.b.c.p") => [rule1, rule2]// GetRulesForVirtualDocument("data.a.b.c.p.x") => [rule1, rule2]// GetRulesForVirtualDocument("data.a.b.c") => nilfunc (c \*Compiler) GetRulesForVirtualDocument(ref Ref) (rules []\*Rule) {
 node := c.RuleTree
 for \_, x := range ref { if node = node.Child(x.Value); node == nil { return nil } if len(node.Values) > 0 { return extractRules(node.Values) } }
 return extractRules(node.Values)}
// GetRulesWithPrefix returns a slice of rules that share the prefix ref.//// E.g., given the following module://// package a.b.c//// p[x] = y { ... } # rule1// p[k] = v { ... } # rule2// q { ... } # rule3//// The following calls yield the rules on the right.//// GetRulesWithPrefix("data.a.b.c.p") => [rule1, rule2]// GetRulesWithPrefix("data.a.b.c.p.a") => nil// GetRulesWithPrefix("data.a.b.c") => [rule1, rule2, rule3]func (c \*Compiler) GetRulesWithPrefix(ref Ref) (rules []\*Rule) {
 node := c.RuleTree
 for \_, x := range ref { if node = node.Child(x.Value); node == nil { return nil } }
 var acc func(node \*TreeNode)
 acc = func(node \*TreeNode) { rules = append(rules, extractRules(node.Values)...) for \_, child := range node.Children { if child.Hide { continue } acc(child) } }
 acc(node)
 return rules}
func extractRules(s []util.T) (rules []\*Rule) { for \_, r := range s { rules = append(rules, r.(\*Rule)) } return rules}
// GetRules returns a slice of rules that are referred to by ref.//// E.g., given the following module://// package a.b.c//// p[x] = y { q[x] = y; ... } # rule1// q[x] = y { ... } # rule2//// The following calls yield the rules on the right.//// GetRules("data.a.b.c.p") => [rule1]// GetRules("data.a.b.c.p.x") => [rule1]// GetRules("data.a.b.c.q") => [rule2]// GetRules("data.a.b.c") => [rule1, rule2]// GetRules("data.a.b.d") => nilfunc (c \*Compiler) GetRules(ref Ref) (rules []\*Rule) {
 set := map[\*Rule]struct{}{}
 for \_, rule := range c.GetRulesForVirtualDocument(ref) { set[rule] = struct{}{} }
 for \_, rule := range c.GetRulesWithPrefix(ref) { set[rule] = struct{}{} }
 for rule := range set { rules = append(rules, rule) }
 return rules}
// GetRulesDynamic returns a slice of rules that could be referred to by a ref.//// Deprecated: use GetRulesDynamicWithOptsfunc (c \*Compiler) GetRulesDynamic(ref Ref) []\*Rule { return c.GetRulesDynamicWithOpts(ref, RulesOptions{})}
// GetRulesDynamicWithOpts returns a slice of rules that could be referred to by// a ref.// When parts of the ref are statically known, we use that information to narrow// down which rules the ref could refer to, but in the most general case this// will be an over-approximation.//// E.g., given the following modules://// package a.b.c//// r1 = 1 # rule1//// and://// package a.d.c//// r2 = 2 # rule2//// The following calls yield the rules on the right.//// GetRulesDynamicWithOpts("data.a[x].c[y]", opts) => [rule1, rule2]// GetRulesDynamicWithOpts("data.a[x].c.r2", opts) => [rule2]// GetRulesDynamicWithOpts("data.a.b[x][y]", opts) => [rule1]//// Using the RulesOptions parameter, the inclusion of hidden modules can be// controlled://// With//// package system.main//// r3 = 3 # rule3//// We'd get this result://// GetRulesDynamicWithOpts("data[x]", RulesOptions{IncludeHiddenModules: true}) => [rule1, rule2, rule3]//// Without the options, it would be excluded.func (c \*Compiler) GetRulesDynamicWithOpts(ref Ref, opts RulesOptions) []\*Rule { node := c.RuleTree
 set := map[\*Rule]struct{}{} var walk func(node \*TreeNode, i int) walk = func(node \*TreeNode, i int) { if i >= len(ref) { // We've reached the end of the reference and want to collect everything // under this "prefix". node.DepthFirst(func(descendant \*TreeNode) bool { insertRules(set, descendant.Values) if opts.IncludeHiddenModules { return false } return descendant.Hide }) } else if i == 0 || IsConstant(ref[i].Value) { // The head of the ref is always grounded. In case another part of the // ref is also grounded, we can lookup the exact child. If it's not found // we can immediately return... if child := node.Child(ref[i].Value); child == nil { return } else if len(child.Values) > 0 { // If there are any rules at this position, it's what the ref would // refer to. We can just append those and stop here. insertRules(set, child.Values) } else { // Otherwise, we continue using the child node. walk(child, i+1) } } else { // This part of the ref is a dynamic term. We can't know what it refers // to and will just need to try all of the children. for \_, child := range node.Children { if child.Hide && !opts.IncludeHiddenModules { continue } insertRules(set, child.Values) walk(child, i+1) } } }
 walk(node, 0) rules := make([]\*Rule, 0, len(set)) for rule := range set { rules = append(rules, rule) } return rules}
// Utility: add all rule values to the set.func insertRules(set map[\*Rule]struct{}, rules []util.T) { for \_, rule := range rules { set[rule.(\*Rule)] = struct{}{} }}
// RuleIndex returns a RuleIndex built for the rule set referred to by path.// The path must refer to the rule set exactly, i.e., given a rule set at path// data.a.b.c.p, refs data.a.b.c.p.x and data.a.b.c would not return a// RuleIndex built for the rule.func (c \*Compiler) RuleIndex(path Ref) RuleIndex { r, ok := c.ruleIndices.Get(path) if !ok { return nil } return r.(RuleIndex)}
// PassesTypeCheck determines whether the given body passes type checkingfunc (c \*Compiler) PassesTypeCheck(body Body) bool { checker := newTypeChecker().WithSchemaSet(c.schemaSet).WithInputType(c.inputType) env := c.TypeEnv \_, errs := checker.CheckBody(env, body) return len(errs) == 0}
// ModuleLoader defines the interface that callers can implement to enable lazy// loading of modules during compilation.type ModuleLoader func(resolved map[string]\*Module) (parsed map[string]\*Module, err error)
// WithModuleLoader sets f as the ModuleLoader on the compiler.//// The compiler will invoke the ModuleLoader after resolving all references in// the current set of input modules. The ModuleLoader can return a new// collection of parsed modules that are to be included in the compilation// process. This process will repeat until the ModuleLoader returns an empty// collection or an error. If an error is returned, compilation will stop// immediately.func (c \*Compiler) WithModuleLoader(f ModuleLoader) \*Compiler { c.moduleLoader = f return c}
func (c \*Compiler) counterAdd(name string, n uint64) { if c.metrics == nil { return } c.metrics.Counter(name).Add(n)}
func (c \*Compiler) buildRuleIndices() {
 c.RuleTree.DepthFirst(func(node \*TreeNode) bool { if len(node.Values) == 0 { return false } index := newBaseDocEqIndex(func(ref Ref) bool { return isVirtual(c.RuleTree, ref.GroundPrefix()) }) if rules := extractRules(node.Values); index.Build(rules) { c.ruleIndices.Put(rules[0].Path(), index) } return false })
}
func (c \*Compiler) buildComprehensionIndices() { for \_, name := range c.sorted { WalkRules(c.Modules[name], func(r \*Rule) bool { candidates := r.Head.Args.Vars() candidates.Update(ReservedVars) n := buildComprehensionIndices(c.debug, c.GetArity, candidates, c.RewrittenVars, r.Body, c.comprehensionIndices) c.counterAdd(compileStageComprehensionIndexBuild, n) return false }) }}
// checkRecursion ensures that there are no recursive definitions, i.e., there are// no cycles in the Graph.func (c \*Compiler) checkRecursion() { eq := func(a, b util.T) bool { return a.(\*Rule) == b.(\*Rule) }
 c.RuleTree.DepthFirst(func(node \*TreeNode) bool { for \_, rule := range node.Values { for node := rule.(\*Rule); node != nil; node = node.Else { c.checkSelfPath(node.Loc(), eq, node, node) } } return false })}
func (c \*Compiler) checkSelfPath(loc \*Location, eq func(a, b util.T) bool, a, b util.T) { tr := NewGraphTraversal(c.Graph) if p := util.DFSPath(tr, eq, a, b); len(p) > 0 { n := []string{} for \_, x := range p { n = append(n, astNodeToString(x)) } c.err(NewError(RecursionErr, loc, "rule %v is recursive: %v", astNodeToString(a), strings.Join(n, " -> "))) }}
func astNodeToString(x interface{}) string { switch x := x.(type) { case \*Rule: return string(x.Head.Name) default: panic("not reached") }}
// checkRuleConflicts ensures that rules definitions are not in conflict.func (c \*Compiler) checkRuleConflicts() { c.RuleTree.DepthFirst(func(node \*TreeNode) bool { if len(node.Values) == 0 { return false }
 kinds := map[DocKind]struct{}{} defaultRules := 0 arities := map[int]struct{}{} declared := false
 for \_, rule := range node.Values { r := rule.(\*Rule) kinds[r.Head.DocKind()] = struct{}{} arities[len(r.Head.Args)] = struct{}{} if r.Head.Assign { declared = true } if r.Default { defaultRules++ } }
 name := Var(node.Key.(String))
 if declared && len(node.Values) > 1 { c.err(NewError(TypeErr, node.Values[0].(\*Rule).Loc(), "rule named %v redeclared at %v", name, node.Values[1].(\*Rule).Loc())) } else if len(kinds) > 1 || len(arities) > 1 { c.err(NewError(TypeErr, node.Values[0].(\*Rule).Loc(), "conflicting rules named %v found", name)) } else if defaultRules > 1 { c.err(NewError(TypeErr, node.Values[0].(\*Rule).Loc(), "multiple default rules named %s found", name)) }
 return false })
 if c.pathExists != nil { for \_, err := range CheckPathConflicts(c, c.pathExists) { c.err(err) } }
 c.ModuleTree.DepthFirst(func(node \*ModuleTreeNode) bool { for \_, mod := range node.Modules { for \_, rule := range mod.Rules { if childNode, ok := node.Children[String(rule.Head.Name)]; ok { for \_, childMod := range childNode.Modules { msg := fmt.Sprintf("%v conflicts with rule defined at %v", childMod.Package, rule.Loc()) c.err(NewError(TypeErr, mod.Package.Loc(), msg)) } } } } return false })}
func (c \*Compiler) checkUndefinedFuncs() { for \_, name := range c.sorted { m := c.Modules[name] for \_, err := range checkUndefinedFuncs(c.TypeEnv, m, c.GetArity, c.RewrittenVars) { c.err(err) } }}
func checkUndefinedFuncs(env \*TypeEnv, x interface{}, arity func(Ref) int, rwVars map[Var]Var) Errors {
 var errs Errors
 WalkExprs(x, func(expr \*Expr) bool { if !expr.IsCall() { return false } ref := expr.Operator() if arity := arity(ref); arity >= 0 { operands := len(expr.Operands()) if expr.Generated { // an output var was added if !expr.IsEquality() && operands != arity+1 { ref = rewriteVarsInRef(rwVars)(ref) errs = append(errs, arityMismatchError(env, ref, expr, arity, operands-1)) return true } } else { // either output var or not if operands != arity && operands != arity+1 { ref = rewriteVarsInRef(rwVars)(ref) errs = append(errs, arityMismatchError(env, ref, expr, arity, operands)) return true } } return false } ref = rewriteVarsInRef(rwVars)(ref) errs = append(errs, NewError(TypeErr, expr.Loc(), "undefined function %v", ref)) return true })
 return errs}
func arityMismatchError(env \*TypeEnv, f Ref, expr \*Expr, exp, act int) \*Error { if want, ok := env.Get(f).(\*types.Function); ok { // generate richer error for built-in functions have := make([]types.Type, len(expr.Operands())) for i, op := range expr.Operands() { have[i] = env.Get(op) } return newArgError(expr.Loc(), f, "arity mismatch", have, want.FuncArgs()) } if act != 1 { return NewError(TypeErr, expr.Loc(), "function %v has arity %d, got %d arguments", f, exp, act) } return NewError(TypeErr, expr.Loc(), "function %v has arity %d, got %d argument", f, exp, act)}
// checkSafetyRuleBodies ensures that variables appearing in negated expressions or non-target// positions of built-in expressions will be bound when evaluating the rule from left// to right, re-ordering as necessary.func (c \*Compiler) checkSafetyRuleBodies() { for \_, name := range c.sorted { m := c.Modules[name] WalkRules(m, func(r \*Rule) bool { safe := ReservedVars.Copy() safe.Update(r.Head.Args.Vars()) r.Body = c.checkBodySafety(safe, r.Body) return false }) }}
func (c \*Compiler) checkBodySafety(safe VarSet, b Body) Body { reordered, unsafe := reorderBodyForSafety(c.builtins, c.GetArity, safe, b) if errs := safetyErrorSlice(unsafe, c.RewrittenVars); len(errs) > 0 { for \_, err := range errs { c.err(err) } return b } return reordered}
// SafetyCheckVisitorParams defines the AST visitor parameters to use for collecting// variables during the safety check. This has to be exported because it's relied on// by the copy propagation implementation in topdown.var SafetyCheckVisitorParams = VarVisitorParams{ SkipRefCallHead: true, SkipClosures: true,}
// checkSafetyRuleHeads ensures that variables appearing in the head of a// rule also appear in the body.func (c \*Compiler) checkSafetyRuleHeads() {
 for \_, name := range c.sorted { m := c.Modules[name] WalkRules(m, func(r \*Rule) bool { safe := r.Body.Vars(SafetyCheckVisitorParams) safe.Update(r.Head.Args.Vars()) unsafe := r.Head.Vars().Diff(safe) for v := range unsafe { if w, ok := c.RewrittenVars[v]; ok { v = w } if !v.IsGenerated() { c.err(NewError(UnsafeVarErr, r.Loc(), "var %v is unsafe", v)) } } return false }) }}
func compileSchema(goSchema interface{}, allowNet []string) (\*gojsonschema.Schema, error) { gojsonschema.SetAllowNet(allowNet)
 var refLoader gojsonschema.JSONLoader sl := gojsonschema.NewSchemaLoader()
 if goSchema != nil { refLoader = gojsonschema.NewGoLoader(goSchema) } else { return nil, fmt.Errorf("no schema as input to compile") } schemasCompiled, err := sl.Compile(refLoader) if err != nil { return nil, fmt.Errorf("unable to compile the schema: %w", err) } return schemasCompiled, nil}
func mergeSchemas(schemas ...\*gojsonschema.SubSchema) (\*gojsonschema.SubSchema, error) { if len(schemas) == 0 { return nil, nil } var result = schemas[0]
 for i := range schemas { if len(schemas[i].PropertiesChildren) > 0 { if !schemas[i].Types.Contains("object") { if err := schemas[i].Types.Add("object"); err != nil { return nil, fmt.Errorf("unable to set the type in schemas") } } } else if len(schemas[i].ItemsChildren) > 0 { if !schemas[i].Types.Contains("array") {[View remainder of file in raw view](https://github.com/open-policy-agent/opa/raw/598176de326025451025225aca53e85708d5f1db/ast/compile.go)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


