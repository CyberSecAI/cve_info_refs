=== Content from github.com_ea6e37f4_20250115_090806.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fblob%2Fffa202a17ab7a4a10182b746d230ea66f021fe16%2Ftensorflow%2Fcore%2Fgrappler%2Fcosts%2Fop_level_cost_estimator.cc)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fblob%2Fffa202a17ab7a4a10182b746d230ea66f021fe16%2Ftensorflow%2Fcore%2Fgrappler%2Fcosts%2Fop_level_cost_estimator.cc)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=tensorflow%2Ftensorflow)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[tensorflow](/tensorflow)
/
**[tensorflow](/tensorflow/tensorflow)**
Public

* [Notifications](/login?return_to=%2Ftensorflow%2Ftensorflow) You must be signed in to change notification settings
* [Fork
  74.4k](/login?return_to=%2Ftensorflow%2Ftensorflow)
* [Star
   187k](/login?return_to=%2Ftensorflow%2Ftensorflow)

* [Code](/tensorflow/tensorflow)
* [Issues
  826](/tensorflow/tensorflow/issues)
* [Pull requests
  5k+](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects
  2](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

Additional navigation options

* [Code](/tensorflow/tensorflow)
* [Issues](/tensorflow/tensorflow/issues)
* [Pull requests](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

## Files

 ffa202a
## Breadcrumbs

1. [tensorflow](/tensorflow/tensorflow/tree/ffa202a17ab7a4a10182b746d230ea66f021fe16)
2. /[tensorflow](/tensorflow/tensorflow/tree/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow)
3. /[core](/tensorflow/tensorflow/tree/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow/core)
4. /[grappler](/tensorflow/tensorflow/tree/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow/core/grappler)
5. /[costs](/tensorflow/tensorflow/tree/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow/core/grappler/costs)
/
# op\_level\_cost\_estimator.cc

Copy path Blame  Blame
## Latest commit

## History

[History](/tensorflow/tensorflow/commits/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow/core/grappler/costs/op_level_cost_estimator.cc)2692 lines (2437 loc) · 110 KB ffa202a
## Breadcrumbs

1. [tensorflow](/tensorflow/tensorflow/tree/ffa202a17ab7a4a10182b746d230ea66f021fe16)
2. /[tensorflow](/tensorflow/tensorflow/tree/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow)
3. /[core](/tensorflow/tensorflow/tree/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow/core)
4. /[grappler](/tensorflow/tensorflow/tree/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow/core/grappler)
5. /[costs](/tensorflow/tensorflow/tree/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow/core/grappler/costs)
/
# op\_level\_cost\_estimator.cc

Top
## File metadata and controls

* Code
* Blame

2692 lines (2437 loc) · 110 KB[Raw](https://github.com/tensorflow/tensorflow/raw/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow/core/grappler/costs/op_level_cost_estimator.cc)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000
/\* Copyright 2017 The TensorFlow Authors. All Rights Reserved.
Licensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.==============================================================================\*/
#include "tensorflow/core/grappler/costs/op\_level\_cost\_estimator.h"
#include "absl/strings/match.h"#include "third\_party/eigen3/Eigen/Core"#include "tensorflow/core/framework/attr\_value.pb.h"#include "tensorflow/core/framework/attr\_value\_util.h"#include "tensorflow/core/framework/tensor.pb.h"#include "tensorflow/core/framework/tensor\_shape.pb.h"#include "tensorflow/core/framework/types.h"#include "tensorflow/core/grappler/clusters/utils.h"#include "tensorflow/core/grappler/costs/op\_context.h"#include "tensorflow/core/grappler/costs/utils.h"#include "tensorflow/core/platform/errors.h"
namespace tensorflow {namespace grappler {
// TODO(dyoon): update op to Predict method map for TF ops with V2 or V3 suffix.constexpr int kOpsPerMac = 2;constexpr char kGuaranteeConst[] = "GuaranteeConst";constexpr char kAddN[] = "AddN";constexpr char kBitCast[] = "BitCast";constexpr char kConcatV2[] = "ConcatV2";constexpr char kConv2d[] = "Conv2D";constexpr char kConv2dBackpropFilter[] = "Conv2DBackpropFilter";constexpr char kConv2dBackpropInput[] = "Conv2DBackpropInput";constexpr char kFusedConv2dBiasActivation[] = "FusedConv2DBiasActivation";constexpr char kDataFormatVecPermute[] = "DataFormatVecPermute";constexpr char kDepthToSpace[] = "DepthToSpace";constexpr char kDepthwiseConv2dNative[] = "DepthwiseConv2dNative";constexpr char kDepthwiseConv2dNativeBackpropFilter[] = "DepthwiseConv2dNativeBackpropFilter";constexpr char kDepthwiseConv2dNativeBackpropInput[] = "DepthwiseConv2dNativeBackpropInput";constexpr char kMatMul[] = "MatMul";constexpr char kXlaEinsum[] = "XlaEinsum";constexpr char kEinsum[] = "Einsum";constexpr char kExpandDims[] = "ExpandDims";constexpr char kFill[] = "Fill";constexpr char kSparseMatMul[] = "SparseMatMul";constexpr char kSparseTensorDenseMatMul[] = "SparseTensorDenseMatMul";constexpr char kPlaceholder[] = "Placeholder";constexpr char kIdentity[] = "Identity";constexpr char kIdentityN[] = "IdentityN";constexpr char kRefIdentity[] = "RefIdentity";constexpr char kNoOp[] = "NoOp";constexpr char kReshape[] = "Reshape";constexpr char kSplit[] = "Split";constexpr char kSqueeze[] = "Squeeze";constexpr char kRecv[] = "\_Recv";constexpr char kSend[] = "\_Send";constexpr char kBatchMatMul[] = "BatchMatMul";constexpr char kBatchMatMulV2[] = "BatchMatMulV2";constexpr char kOneHot[] = "OneHot";constexpr char kPack[] = "Pack";constexpr char kRank[] = "Rank";constexpr char kRange[] = "Range";constexpr char kShape[] = "Shape";constexpr char kShapeN[] = "ShapeN";constexpr char kSize[] = "Size";constexpr char kStopGradient[] = "StopGradient";constexpr char kPreventGradient[] = "PreventGradient";constexpr char kGather[] = "Gather";constexpr char kGatherNd[] = "GatherNd";constexpr char kGatherV2[] = "GatherV2";constexpr char kScatterAdd[] = "ScatterAdd";constexpr char kScatterDiv[] = "ScatterDiv";constexpr char kScatterMax[] = "ScatterMax";constexpr char kScatterMin[] = "ScatterMin";constexpr char kScatterMul[] = "ScatterMul";constexpr char kScatterSub[] = "ScatterSub";constexpr char kScatterUpdate[] = "ScatterUpdate";constexpr char kSlice[] = "Slice";constexpr char kStridedSlice[] = "StridedSlice";constexpr char kSpaceToDepth[] = "SpaceToDepth";constexpr char kTranspose[] = "Transpose";constexpr char kTile[] = "Tile";constexpr char kMaxPool[] = "MaxPool";constexpr char kMaxPoolGrad[] = "MaxPoolGrad";constexpr char kAvgPool[] = "AvgPool";constexpr char kAvgPoolGrad[] = "AvgPoolGrad";constexpr char kFusedBatchNorm[] = "FusedBatchNorm";constexpr char kFusedBatchNormGrad[] = "FusedBatchNormGrad";constexpr char kQuantizedMatMul[] = "QuantizedMatMul";constexpr char kQuantizedMatMulV2[] = "QuantizedMatMulV2";constexpr char kUnpack[] = "Unpack";constexpr char kSoftmax[] = "Softmax";constexpr char kResizeBilinear[] = "ResizeBilinear";constexpr char kCropAndResize[] = "CropAndResize";// Dynamic control flow ops.constexpr char kSwitch[] = "Switch";constexpr char kMerge[] = "Merge";constexpr char kEnter[] = "Enter";constexpr char kExit[] = "Exit";constexpr char kNextIteration[] = "NextIteration";// Persistent ops.constexpr char kConst[] = "Const";constexpr char kVariable[] = "Variable";constexpr char kVariableV2[] = "VariableV2";constexpr char kAutoReloadVariable[] = "AutoReloadVariable";constexpr char kVarHandleOp[] = "VarHandleOp";constexpr char kVarHandlesOp[] = "\_VarHandlesOp";constexpr char kReadVariableOp[] = "ReadVariableOp";constexpr char kReadVariablesOp[] = "\_ReadVariablesOp";constexpr char kAssignVariableOp[] = "AssignVariableOp";constexpr char kAssignAddVariableOp[] = "AssignAddVariableOp";constexpr char kAssignSubVariableOp[] = "AssignSubVariableOp";
static const Costs::Duration kMinComputeTime(1);static const int64\_t kMinComputeOp = 1;
namespace {
std::string GetDataFormat(const OpInfo& op\_info) { std::string data\_format = "NHWC"; // Default format. if (op\_info.attr().find("data\_format") != op\_info.attr().end()) { data\_format = op\_info.attr().at("data\_format").s(); } return data\_format;}
std::string GetFilterFormat(const OpInfo& op\_info) { std::string filter\_format = "HWIO"; // Default format. if (op\_info.attr().find("filter\_format") != op\_info.attr().end()) { filter\_format = op\_info.attr().at("filter\_format").s(); } return filter\_format;}
Padding GetPadding(const OpInfo& op\_info) { if (op\_info.attr().find("padding") != op\_info.attr().end() && op\_info.attr().at("padding").s() == "VALID") { return Padding::VALID; } return Padding::SAME; // Default padding.}
bool IsTraining(const OpInfo& op\_info) { if (op\_info.attr().find("is\_training") != op\_info.attr().end() && op\_info.attr().at("is\_training").b()) { return true; } return false;}
// TODO(dyoon): support non-4D tensors in the cost functions of convolution// related ops (Conv, Pool, BatchNorm, and their backprops) and the related// helper functions.std::vector<int64\_t> GetStrides(const OpInfo& op\_info) { if (op\_info.attr().find("strides") != op\_info.attr().end()) { const auto strides = op\_info.attr().at("strides").list().i(); DCHECK(strides.size() == 4) << "Attr strides is not a length-4 vector: " << op\_info.DebugString(); if (strides.size() != 4) return {1, 1, 1, 1}; return {strides[0], strides[1], strides[2], strides[3]}; } return {1, 1, 1, 1};}
std::vector<int64\_t> GetKernelSize(const OpInfo& op\_info) { if (op\_info.attr().find("ksize") != op\_info.attr().end()) { const auto ksize = op\_info.attr().at("ksize").list().i(); DCHECK(ksize.size() == 4) << "Attr ksize is not a length-4 vector: " << op\_info.DebugString(); if (ksize.size() != 4) return {1, 1, 1, 1}; return {ksize[0], ksize[1], ksize[2], ksize[3]}; } // Note that FusedBatchNorm doesn't have ksize attr, but GetKernelSize returns // {1, 1, 1, 1} in that case. return {1, 1, 1, 1};}
int64\_t GetOutputSize(const int64\_t input, const int64\_t filter, const int64\_t stride, const Padding& padding) { // Logic for calculating output shape is from GetWindowedOutputSizeVerbose() // function in third\_party/tensorflow/core/framework/common\_shape\_fns.cc. if (padding == Padding::VALID) { return (input - filter + stride) / stride; } else { // SAME. return (input + stride - 1) / stride; }}
// Return the output element count of a multi-input element-wise op considering// broadcasting.int64\_t CwiseOutputElementCount(const OpInfo& op\_info) { int max\_rank = 1; for (const OpInfo::TensorProperties& input\_properties : op\_info.inputs()) { max\_rank = std::max(max\_rank, input\_properties.shape().dim\_size()); }
 TensorShapeProto output\_shape; output\_shape.mutable\_dim()->Reserve(max\_rank); for (int i = 0; i < max\_rank; ++i) { output\_shape.add\_dim(); }
 // Expand the shape of the output to follow the numpy-style broadcast rule // which matches each input starting with the trailing dimensions and working // its way forward. To do this, iterate through each input shape's dimensions // in reverse order, and potentially increase the corresponding output // dimension. for (const OpInfo::TensorProperties& input\_properties : op\_info.inputs()) { const TensorShapeProto& input\_shape = input\_properties.shape(); for (int i = input\_shape.dim\_size() - 1; i >= 0; --i) { int output\_shape\_dim\_index = i + output\_shape.dim\_size() - input\_shape.dim\_size(); output\_shape.mutable\_dim(output\_shape\_dim\_index) ->set\_size(std::max(output\_shape.dim(output\_shape\_dim\_index).size(), input\_shape.dim(i).size())); } }
 int64\_t count = 1; for (int i = 0; i < output\_shape.dim\_size(); i++) { count \*= output\_shape.dim(i).size(); } return count;}
// Helper function for determining whether there are repeated indices in the// input Einsum equation.bool CheckRepeatedDimensions(const absl::string\_view dim\_str) { int str\_size = dim\_str.size(); for (int idx = 0; idx < str\_size - 1; idx++) { if (dim\_str.find(dim\_str[idx], idx + 1) != std::string::npos) { return true; } } return false;}
// Auxiliary function for determining whether OpLevelCostEstimator is compatible// with a given Einsum.bool IsEinsumCorrectlyFormed(const OpContext& einsum\_context) { const auto& op\_info = einsum\_context.op\_info;
 auto it = op\_info.attr().find("equation"); if (it == op\_info.attr().end()) return false; const absl::string\_view equation = it->second.s(); std::vector<std::string> equation\_split = absl::StrSplit(equation, "->");
 if (equation\_split.empty()) { LOG(WARNING) << "Einsum with malformed equation"; return false; } std::vector<absl::string\_view> input\_split = absl::StrSplit(equation\_split[0], ',');
 // The current model covers Einsum operations with two operands and a RHS if (op\_info.inputs\_size() != 2 || equation\_split.size() != 2) { VLOG(1) << "Missing accurate estimator for op: " << op\_info.op(); return false; } const auto& a\_input = op\_info.inputs(0); const auto& b\_input = op\_info.inputs(1); absl::string\_view rhs\_str = equation\_split[1]; absl::string\_view a\_input\_str = input\_split[0]; absl::string\_view b\_input\_str = input\_split[1];
 // Ellipsis are not currently supported if (absl::StrContains(a\_input\_str, "...") || absl::StrContains(b\_input\_str, "...")) { VLOG(1) << "Missing accurate estimator for op: " << op\_info.op() << ", ellipsis not supported"; return false; }
 constexpr int kMatrixRank = 2;
 bool a\_input\_shape\_unknown = false; bool b\_input\_shape\_unknown = false;
 TensorShapeProto a\_input\_shape = MaybeGetMinimumShape( a\_input.shape(), std::max(kMatrixRank, a\_input.shape().dim\_size()), &a\_input\_shape\_unknown); TensorShapeProto b\_input\_shape = MaybeGetMinimumShape( b\_input.shape(), std::max(kMatrixRank, b\_input.shape().dim\_size()), &b\_input\_shape\_unknown);
 if (a\_input\_str.size() != static\_cast<size\_t>(a\_input\_shape.dim\_size()) || b\_input\_str.size() != static\_cast<size\_t>(b\_input\_shape.dim\_size())) { VLOG(1) << "Missing accurate estimator for op: " << op\_info.op() << ", equation subscripts don't match tensor rank."; return false; }
 // Subscripts where axis appears more than once for a single input are not yet // supported if (CheckRepeatedDimensions(a\_input\_str) || CheckRepeatedDimensions(b\_input\_str) || CheckRepeatedDimensions(rhs\_str)) { VLOG(1) << "Missing accurate estimator for op: " << op\_info.op() << ", Subscripts where axis appears more than once for a single " "input are not yet supported"; return false; }
 return true;}
} // namespace
// Return a minimum shape if the shape is unknown. If known, return the original// shape.TensorShapeProto MaybeGetMinimumShape(const TensorShapeProto& original\_shape, int rank, bool\* found\_unknown\_shapes) { auto shape = original\_shape; bool is\_scalar = !shape.unknown\_rank() && shape.dim\_size() == 0;
 if (shape.unknown\_rank() || (!is\_scalar && shape.dim\_size() < rank)) { \*found\_unknown\_shapes = true; VLOG(2) << "Use minimum shape because the rank is unknown."; // The size of each dimension is at least 1, if unknown. for (int i = shape.dim\_size(); i < rank; i++) { shape.add\_dim()->set\_size(1); } } else if (is\_scalar) { for (int i = 0; i < rank; i++) { shape.add\_dim()->set\_size(1); } } else if (shape.dim\_size() > rank) { \*found\_unknown\_shapes = true; shape.clear\_dim(); for (int i = 0; i < rank; i++) { shape.add\_dim()->set\_size(original\_shape.dim(i).size()); } } else { for (int i = 0; i < shape.dim\_size(); i++) { if (shape.dim(i).size() < 0) { \*found\_unknown\_shapes = true; VLOG(2) << "Use minimum dim size 1 because the shape is unknown."; // The size of each dimension is at least 1, if unknown. shape.mutable\_dim(i)->set\_size(1); } } } return shape;}
OpLevelCostEstimator::OpLevelCostEstimator() { // Syntactic sugar to build and return a lambda that takes an OpInfo and // returns a cost. typedef Status (OpLevelCostEstimator::\*CostImpl)(const OpContext& op\_context, NodeCosts\*) const; auto wrap = [this](CostImpl impl) -> std::function<Status(const OpContext&, NodeCosts\*)> { return [this, impl](const OpContext& op\_context, NodeCosts\* node\_costs) { return (this->\*impl)(op\_context, node\_costs); }; };
 device\_cost\_impl\_.emplace(kConv2d, wrap(&OpLevelCostEstimator::PredictConv2D)); device\_cost\_impl\_.emplace( kConv2dBackpropFilter, wrap(&OpLevelCostEstimator::PredictConv2DBackpropFilter)); device\_cost\_impl\_.emplace( kConv2dBackpropInput, wrap(&OpLevelCostEstimator::PredictConv2DBackpropInput)); device\_cost\_impl\_.emplace( kFusedConv2dBiasActivation, wrap(&OpLevelCostEstimator::PredictFusedConv2DBiasActivation)); // reuse Conv2D for DepthwiseConv2dNative because the calculation is the // same although the actual meaning of the parameters are different. See // comments in PredictConv2D and related functions device\_cost\_impl\_.emplace(kDepthwiseConv2dNative, wrap(&OpLevelCostEstimator::PredictConv2D)); device\_cost\_impl\_.emplace( kDepthwiseConv2dNativeBackpropFilter, wrap(&OpLevelCostEstimator::PredictConv2DBackpropFilter)); device\_cost\_impl\_.emplace( kDepthwiseConv2dNativeBackpropInput, wrap(&OpLevelCostEstimator::PredictConv2DBackpropInput)); device\_cost\_impl\_.emplace(kMatMul, wrap(&OpLevelCostEstimator::PredictMatMul)); device\_cost\_impl\_.emplace(kSparseMatMul, wrap(&OpLevelCostEstimator::PredictMatMul)); device\_cost\_impl\_.emplace( kSparseTensorDenseMatMul, wrap(&OpLevelCostEstimator::PredictSparseTensorDenseMatMul)); device\_cost\_impl\_.emplace(kBatchMatMul, wrap(&OpLevelCostEstimator::PredictBatchMatMul)); device\_cost\_impl\_.emplace(kBatchMatMulV2, wrap(&OpLevelCostEstimator::PredictBatchMatMul)); device\_cost\_impl\_.emplace(kQuantizedMatMul, wrap(&OpLevelCostEstimator::PredictMatMul)); device\_cost\_impl\_.emplace(kQuantizedMatMulV2, wrap(&OpLevelCostEstimator::PredictMatMul)); device\_cost\_impl\_.emplace(kXlaEinsum, wrap(&OpLevelCostEstimator::PredictEinsum)); device\_cost\_impl\_.emplace(kEinsum, wrap(&OpLevelCostEstimator::PredictEinsum));
 device\_cost\_impl\_.emplace(kNoOp, wrap(&OpLevelCostEstimator::PredictNoOp)); device\_cost\_impl\_.emplace(kGuaranteeConst, wrap(&OpLevelCostEstimator::PredictNoOp));
 device\_cost\_impl\_.emplace(kGather, wrap(&OpLevelCostEstimator::PredictGatherOrSlice)); device\_cost\_impl\_.emplace(kGatherNd, wrap(&OpLevelCostEstimator::PredictGatherOrSlice)); device\_cost\_impl\_.emplace(kGatherV2, wrap(&OpLevelCostEstimator::PredictGatherOrSlice)); device\_cost\_impl\_.emplace(kScatterAdd, wrap(&OpLevelCostEstimator::PredictScatter)); device\_cost\_impl\_.emplace(kScatterDiv, wrap(&OpLevelCostEstimator::PredictScatter)); device\_cost\_impl\_.emplace(kScatterMax, wrap(&OpLevelCostEstimator::PredictScatter)); device\_cost\_impl\_.emplace(kScatterMin, wrap(&OpLevelCostEstimator::PredictScatter)); device\_cost\_impl\_.emplace(kScatterMul, wrap(&OpLevelCostEstimator::PredictScatter)); device\_cost\_impl\_.emplace(kScatterSub, wrap(&OpLevelCostEstimator::PredictScatter)); device\_cost\_impl\_.emplace(kScatterUpdate, wrap(&OpLevelCostEstimator::PredictScatter));
 device\_cost\_impl\_.emplace(kSlice, wrap(&OpLevelCostEstimator::PredictGatherOrSlice)); device\_cost\_impl\_.emplace(kStridedSlice, wrap(&OpLevelCostEstimator::PredictGatherOrSlice));
 device\_cost\_impl\_.emplace(kPlaceholder, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kIdentity, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kIdentityN, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kRefIdentity, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kStopGradient, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kPreventGradient, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kReshape, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kRecv, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kSend, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kSwitch, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kMerge, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kEnter, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kExit, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kNextIteration, wrap(&OpLevelCostEstimator::PredictIdentity)); device\_cost\_impl\_.emplace(kBitCast, wrap(&OpLevelCostEstimator::PredictIdentity));
 device\_cost\_impl\_.emplace(kConcatV2, wrap(&OpLevelCostEstimator::PredictPureMemoryOp)); device\_cost\_impl\_.emplace(kDataFormatVecPermute, wrap(&OpLevelCostEstimator::PredictPureMemoryOp)); device\_cost\_impl\_.emplace(kDepthToSpace, wrap(&OpLevelCostEstimator::PredictPureMemoryOp)); device\_cost\_impl\_.emplace(kExpandDims, wrap(&OpLevelCostEstimator::PredictPureMemoryOp)); device\_cost\_impl\_.emplace(kFill, wrap(&OpLevelCostEstimator::PredictPureMemoryOp)); device\_cost\_impl\_.emplace(kOneHot, wrap(&OpLevelCostEstimator::PredictPureMemoryOp)); device\_cost\_impl\_.emplace(kPack, wrap(&OpLevelCostEstimator::PredictPureMemoryOp)); device\_cost\_impl\_.emplace(kRange, wrap(&OpLevelCostEstimator::PredictPureMemoryOp)); device\_cost\_impl\_.emplace(kSpaceToDepth, wrap(&OpLevelCostEstimator::PredictPureMemoryOp)); device\_cost\_impl\_.emplace(kSplit, wrap(&OpLevelCostEstimator::PredictPureMemoryOp)); device\_cost\_impl\_.emplace(kSqueeze, wrap(&OpLevelCostEstimator::PredictPureMemoryOp)); device\_cost\_impl\_.emplace(kTranspose, wrap(&OpLevelCostEstimator::PredictPureMemoryOp)); device\_cost\_impl\_.emplace(kTile, wrap(&OpLevelCostEstimator::PredictPureMemoryOp)); device\_cost\_impl\_.emplace(kUnpack, wrap(&OpLevelCostEstimator::PredictPureMemoryOp));
 device\_cost\_impl\_.emplace(kRank, wrap(&OpLevelCostEstimator::PredictMetadata)); device\_cost\_impl\_.emplace(kShape, wrap(&OpLevelCostEstimator::PredictMetadata)); device\_cost\_impl\_.emplace(kShapeN, wrap(&OpLevelCostEstimator::PredictMetadata)); device\_cost\_impl\_.emplace(kSize, wrap(&OpLevelCostEstimator::PredictMetadata)); device\_cost\_impl\_.emplace(kMaxPool, wrap(&OpLevelCostEstimator::PredictMaxPool)); device\_cost\_impl\_.emplace(kMaxPoolGrad, wrap(&OpLevelCostEstimator::PredictMaxPoolGrad)); device\_cost\_impl\_.emplace(kAvgPool, wrap(&OpLevelCostEstimator::PredictAvgPool)); device\_cost\_impl\_.emplace(kAvgPoolGrad, wrap(&OpLevelCostEstimator::PredictAvgPoolGrad)); device\_cost\_impl\_.emplace(kFusedBatchNorm, wrap(&OpLevelCostEstimator::PredictFusedBatchNorm)); device\_cost\_impl\_.emplace( kFusedBatchNormGrad, wrap(&OpLevelCostEstimator::PredictFusedBatchNormGrad)); device\_cost\_impl\_.emplace(kSoftmax, wrap(&OpLevelCostEstimator::PredictSoftmax)); device\_cost\_impl\_.emplace(kResizeBilinear, wrap(&OpLevelCostEstimator::PredictResizeBilinear)); device\_cost\_impl\_.emplace(kCropAndResize, wrap(&OpLevelCostEstimator::PredictCropAndResize)); device\_cost\_impl\_.emplace( kAssignVariableOp, wrap(&OpLevelCostEstimator::PredictAssignVariableOps)); device\_cost\_impl\_.emplace( kAssignAddVariableOp, wrap(&OpLevelCostEstimator::PredictAssignVariableOps)); device\_cost\_impl\_.emplace( kAssignSubVariableOp, wrap(&OpLevelCostEstimator::PredictAssignVariableOps)); device\_cost\_impl\_.emplace(kAddN, wrap(&OpLevelCostEstimator::PredictNaryOp));
 persistent\_ops\_ = { kConst, kVariable, kVariableV2, kAutoReloadVariable, kVarHandleOp, kReadVariableOp, kVarHandlesOp, kReadVariablesOp};
#define EIGEN\_COST(X) Eigen::internal::functor\_traits<Eigen::internal::X>::Cost
 // Quantize = apply min and max bounds, multiply by scale factor and round. const int quantize\_v2\_cost = EIGEN\_COST(scalar\_product\_op<float>) + EIGEN\_COST(scalar\_max\_op<float>) + EIGEN\_COST(scalar\_min\_op<float>) + EIGEN\_COST(scalar\_round\_op<float>); const int quantize\_and\_dequantize\_v2\_cost = quantize\_v2\_cost + EIGEN\_COST(scalar\_product\_op<float>);
 // Unary ops alphabetically sorted elementwise\_ops\_.emplace("Acos", EIGEN\_COST(scalar\_acos\_op<float>)); elementwise\_ops\_.emplace("All", EIGEN\_COST(scalar\_boolean\_and\_op)); elementwise\_ops\_.emplace("ArgMax", EIGEN\_COST(scalar\_max\_op<float>)); elementwise\_ops\_.emplace("Asin", EIGEN\_COST(scalar\_asin\_op<float>)); elementwise\_ops\_.emplace("Atan", EIGEN\_COST(scalar\_atan\_op<float>)); elementwise\_ops\_.emplace("Atan2", EIGEN\_COST(scalar\_quotient\_op<float>) + EIGEN\_COST(scalar\_atan\_op<float>)); // For now, we use Eigen cost model for float to int16 cast as an example // case; Eigen cost model is zero when src and dst types are identical, // and it uses AddCost (1) when different. We may implement a separate // cost functions for cast ops, using the actual input and output types. elementwise\_ops\_.emplace( "Cast", Eigen::internal::functor\_traits< Eigen::internal::scalar\_cast\_op<float, int16>>::Cost); elementwise\_ops\_.emplace("Ceil", EIGEN\_COST(scalar\_ceil\_op<float>)); elementwise\_ops\_.emplace("Cos", EIGEN\_COST(scalar\_cos\_op<float>)); elementwise\_ops\_.emplace("Dequantize", EIGEN\_COST(scalar\_product\_op<float>)); elementwise\_ops\_.emplace("Erf", 1); elementwise\_ops\_.emplace("Erfc", 1); elementwise\_ops\_.emplace("Exp", EIGEN\_COST(scalar\_exp\_op<float>)); elementwise\_ops\_.emplace("Expm1", EIGEN\_COST(scalar\_expm1\_op<float>)); elementwise\_ops\_.emplace("Floor", EIGEN\_COST(scalar\_floor\_op<float>)); elementwise\_ops\_.emplace("Inv", EIGEN\_COST(scalar\_inverse\_op<float>)); elementwise\_ops\_.emplace("InvGrad", 1); elementwise\_ops\_.emplace("Lgamma", 1); elementwise\_ops\_.emplace("Log", EIGEN\_COST(scalar\_log\_op<float>)); elementwise\_ops\_.emplace("Log1p", EIGEN\_COST(scalar\_log1p\_op<float>)); elementwise\_ops\_.emplace("Max", EIGEN\_COST(scalar\_max\_op<float>)); elementwise\_ops\_.emplace("Min", EIGEN\_COST(scalar\_min\_op<float>)); elementwise\_ops\_.emplace("Neg", EIGEN\_COST(scalar\_opposite\_op<float>)); elementwise\_ops\_.emplace("Prod", EIGEN\_COST(scalar\_product\_op<float>)); elementwise\_ops\_.emplace("QuantizeAndDequantizeV2", quantize\_and\_dequantize\_v2\_cost); elementwise\_ops\_.emplace("QuantizeAndDequantizeV4", quantize\_and\_dequantize\_v2\_cost); elementwise\_ops\_.emplace("QuantizedSigmoid", EIGEN\_COST(scalar\_logistic\_op<float>)); elementwise\_ops\_.emplace("QuantizeV2", quantize\_v2\_cost); elementwise\_ops\_.emplace("Reciprocal", EIGEN\_COST(scalar\_inverse\_op<float>)); elementwise\_ops\_.emplace("Relu", EIGEN\_COST(scalar\_max\_op<float>)); elementwise\_ops\_.emplace("Relu6", EIGEN\_COST(scalar\_max\_op<float>)); elementwise\_ops\_.emplace("Rint", 1); elementwise\_ops\_.emplace("Round", EIGEN\_COST(scalar\_round\_op<float>)); elementwise\_ops\_.emplace("Rsqrt", EIGEN\_COST(scalar\_rsqrt\_op<float>)); elementwise\_ops\_.emplace("Sigmoid", EIGEN\_COST(scalar\_logistic\_op<float>)); elementwise\_ops\_.emplace("Sign", EIGEN\_COST(scalar\_sign\_op<float>)); elementwise\_ops\_.emplace("Sin", EIGEN\_COST(scalar\_sin\_op<float>)); elementwise\_ops\_.emplace("Sqrt", EIGEN\_COST(scalar\_sqrt\_op<float>)); elementwise\_ops\_.emplace("Square", EIGEN\_COST(scalar\_square\_op<float>)); elementwise\_ops\_.emplace("Sum", EIGEN\_COST(scalar\_sum\_op<float>)); elementwise\_ops\_.emplace("Tan", EIGEN\_COST(scalar\_tan\_op<float>)); elementwise\_ops\_.emplace("Tanh", EIGEN\_COST(scalar\_tanh\_op<float>)); elementwise\_ops\_.emplace("TopKV2", EIGEN\_COST(scalar\_max\_op<float>)); // Binary ops alphabetically sorted elementwise\_ops\_.emplace("Add", EIGEN\_COST(scalar\_sum\_op<float>)); elementwise\_ops\_.emplace("AddV2", EIGEN\_COST(scalar\_sum\_op<float>)); elementwise\_ops\_.emplace("ApproximateEqual", 1); elementwise\_ops\_.emplace("BiasAdd", EIGEN\_COST(scalar\_sum\_op<float>)); elementwise\_ops\_.emplace("QuantizedBiasAdd", EIGEN\_COST(scalar\_sum\_op<float>)); elementwise\_ops\_.emplace("Div", EIGEN\_COST(scalar\_quotient\_op<float>)); elementwise\_ops\_.emplace("Equal", 1); elementwise\_ops\_.emplace("FloorDiv", EIGEN\_COST(scalar\_quotient\_op<float>)); elementwise\_ops\_.emplace("FloorMod", EIGEN\_COST(scalar\_mod\_op<float>)); elementwise\_ops\_.emplace("Greater", 1); elementwise\_ops\_.emplace("GreaterEqual", 1); elementwise\_ops\_.emplace("Less", 1); elementwise\_ops\_.emplace("LessEqual", 1); elementwise\_ops\_.emplace("LogicalAnd", EIGEN\_COST(scalar\_boolean\_and\_op)); elementwise\_ops\_.emplace("LogicalNot", 1); elementwise\_ops\_.emplace("LogicalOr", EIGEN\_COST(scalar\_boolean\_or\_op)); elementwise\_ops\_.emplace("Maximum", EIGEN\_COST(scalar\_max\_op<float>)); elementwise\_ops\_.emplace("Minimum", EIGEN\_COST(scalar\_min\_op<float>)); elementwise\_ops\_.emplace("Mod", EIGEN\_COST(scalar\_mod\_op<float>)); elementwise\_ops\_.emplace("Mul", EIGEN\_COST(scalar\_product\_op<float>)); elementwise\_ops\_.emplace("NotEqual", 1); elementwise\_ops\_.emplace("QuantizedAdd", EIGEN\_COST(scalar\_sum\_op<float>)); elementwise\_ops\_.emplace("QuantizedMul", EIGEN\_COST(scalar\_product\_op<float>)); elementwise\_ops\_.emplace("RealDiv", EIGEN\_COST(scalar\_quotient\_op<float>)); elementwise\_ops\_.emplace("ReluGrad", EIGEN\_COST(scalar\_max\_op<float>)); elementwise\_ops\_.emplace("Select", EIGEN\_COST(scalar\_boolean\_or\_op)); elementwise\_ops\_.emplace("SelectV2", EIGEN\_COST(scalar\_boolean\_or\_op)); elementwise\_ops\_.emplace("SquaredDifference", EIGEN\_COST(scalar\_square\_op<float>) + EIGEN\_COST(scalar\_difference\_op<float>)); elementwise\_ops\_.emplace("Sub", EIGEN\_COST(scalar\_difference\_op<float>)); elementwise\_ops\_.emplace("TruncateDiv", EIGEN\_COST(scalar\_quotient\_op<float>)); elementwise\_ops\_.emplace("TruncateMod", EIGEN\_COST(scalar\_mod\_op<float>)); elementwise\_ops\_.emplace("Where", 1);
#undef EIGEN\_COST
 // By default, use sum of memory\_time and compute\_time for execution\_time. compute\_memory\_overlap\_ = false;}
Costs OpLevelCostEstimator::PredictCosts(const OpContext& op\_context) const { Costs costs; NodeCosts node\_costs; if (PredictNodeCosts(op\_context, &node\_costs).ok()) { if (node\_costs.has\_costs) { return node\_costs.costs; } // Convert NodeCosts to Costs. if (node\_costs.minimum\_cost\_op) { // Override to minimum cost; Note that some ops with minimum cost may have // non-typical device (e.g., channel for \_Send), which may fail with // GetDeviceInfo(), called from PredictOpCountBasedCost(). Make sure we // directly set minimum values to Costs here, not calling // PredictOpCountBasedCost(). costs.compute\_time = kMinComputeTime; costs.execution\_time = kMinComputeTime; costs.memory\_time = 0; costs.intermediate\_memory\_time = 0; costs.intermediate\_memory\_read\_time = 0; costs.intermediate\_memory\_write\_time = 0; } else { // Convert NodeCosts to Costs. costs = PredictOpCountBasedCost( node\_costs.num\_compute\_ops, node\_costs.num\_total\_read\_bytes(), node\_costs.num\_total\_write\_bytes(), op\_context.op\_info); } VLOG(1) << "Operation " << op\_context.op\_info.op() << " takes " << costs.execution\_time.count() << " ns."; // Copy additional stats from NodeCosts to Costs. costs.max\_memory = node\_costs.max\_memory; costs.persistent\_memory = node\_costs.persistent\_memory; costs.temporary\_memory = node\_costs.temporary\_memory; costs.inaccurate = node\_costs.inaccurate; costs.num\_ops\_with\_unknown\_shapes = node\_costs.num\_nodes\_with\_unknown\_shapes; costs.num\_ops\_total = node\_costs.num\_nodes; return costs; } // Errors during node cost estimate. LOG(WARNING) << "Error in PredictCost() for the op: " << op\_context.op\_info.ShortDebugString(); costs = Costs::ZeroCosts(/\*inaccurate=\*/true); costs.num\_ops\_with\_unknown\_shapes = node\_costs.num\_nodes\_with\_unknown\_shapes; return costs;}
Status OpLevelCostEstimator::PredictNodeCosts(const OpContext& op\_context, NodeCosts\* node\_costs) const { const auto& op\_info = op\_context.op\_info; auto it = device\_cost\_impl\_.find(op\_info.op()); if (it != device\_cost\_impl\_.end()) { std::function<Status(const OpContext&, NodeCosts\*)> estimator = it->second; return estimator(op\_context, node\_costs); }
 if (persistent\_ops\_.find(op\_info.op()) != persistent\_ops\_.end()) { return PredictVariable(op\_context, node\_costs); }
 if (elementwise\_ops\_.find(op\_info.op()) != elementwise\_ops\_.end()) { return PredictCwiseOp(op\_context, node\_costs); }
 VLOG(1) << "Missing accurate estimator for op: " << op\_info.op();
 node\_costs->num\_nodes\_with\_unknown\_op\_type = 1; return PredictCostOfAnUnknownOp(op\_context, node\_costs);}
// This method assumes a typical system composed of CPUs and GPUs, connected// through PCIe. To define device info more precisely, override this method.DeviceInfo OpLevelCostEstimator::GetDeviceInfo( const DeviceProperties& device) const { double gflops = -1; double gb\_per\_sec = -1;
 if (device.type() == "CPU") { // Check if vector instructions are available, and refine performance // prediction based on this. // Frequencies are stored in MHz in the DeviceProperties. gflops = device.num\_cores() \* device.frequency() \* 1e-3; if (gb\_per\_sec < 0) { if (device.bandwidth() > 0) { gb\_per\_sec = device.bandwidth() / 1e6; } else { gb\_per\_sec = 32; } } } else if (device.type() == "GPU") { const auto& device\_env = device.environment(); auto it = device\_env.find("architecture"); if (it != device\_env.end()) { const std::string architecture = device\_env.at("architecture"); int cores\_per\_multiprocessor; if (architecture < "3") { // Fermi cores\_per\_multiprocessor = 32; } else if (architecture < "4") { // Kepler cores\_per\_multiprocessor = 192; } else if (architecture < "6") { // Maxwell cores\_per\_multiprocessor = 128; } else { // Pascal (compute capability version 6) and Volta (compute capability // version 7) cores\_per\_multiprocessor = 64; } gflops = device.num\_cores() \* device.frequency() \* 1e-3 \* cores\_per\_multiprocessor \* kOpsPerMac; if (device.bandwidth() > 0) { gb\_per\_sec = device.bandwidth() / 1e6; } else { gb\_per\_sec = 100; } } else { // Architecture is not available (ex: pluggable device), return default // value. gflops = 100; // Dummy value; gb\_per\_sec = 12; // default PCIe x16 gen3. } } else { LOG\_EVERY\_N(WARNING, 1000) << "Unknown device type: " << device.type() << ", assuming PCIe between CPU and GPU."; gflops = 1; // Dummy value; data transfer ops would not have compute ops. gb\_per\_sec = 12; // default PCIe x16 gen3. } VLOG(1) << "Device: " << device.type() << " gflops: " << gflops << " gb\_per\_sec: " << gb\_per\_sec;
 return DeviceInfo(gflops, gb\_per\_sec);}
Status OpLevelCostEstimator::PredictCwiseOp(const OpContext& op\_context, NodeCosts\* node\_costs) const { const auto& op\_info = op\_context.op\_info; bool found\_unknown\_shapes = false; // For element-wise operations, op count is the element count of any input. We // use the count for the largest input here to be more robust in case that the // shape is unknown or partially known for other input. int64\_t op\_count = CalculateLargestInputCount(op\_info, &found\_unknown\_shapes); // If output shape is available, try to use the element count calculated from // that. if (op\_info.outputs\_size() > 0) { op\_count = std::max( op\_count, CalculateTensorElementCount(op\_info.outputs(0), &found\_unknown\_shapes)); } // Calculate the output shape possibly resulting from broadcasting. if (op\_info.inputs\_size() >= 2) { op\_count = std::max(op\_count, CwiseOutputElementCount(op\_info)); }
 int op\_cost = 1; auto it = elementwise\_ops\_.find(op\_info.op()); if (it != elementwise\_ops\_.end()) { op\_cost = it->second; } else { return errors::InvalidArgument("Not a cwise op: ", op\_info.op()); }
 return PredictDefaultNodeCosts(op\_count \* op\_cost, op\_context, &found\_unknown\_shapes, node\_costs);}
Status OpLevelCostEstimator::PredictCostOfAnUnknownOp( const OpContext& op\_context, NodeCosts\* node\_costs) const { // Don't assume the operation is cwise, return cost based on input/output size // and admit that it is inaccurate... bool found\_unknown\_shapes = false; node\_costs->inaccurate = true; return PredictDefaultNodeCosts(0, op\_context, &found\_unknown\_shapes, node\_costs);}
Costs OpLevelCostEstimator::PredictOpCountBasedCost( double operations, const OpInfo& op\_info) const { bool unknown\_shapes = false; const double input\_size = CalculateInputSize(op\_info, &unknown\_shapes); const double output\_size = CalculateOutputSize(op\_info, &unknown\_shapes); Costs costs = PredictOpCountBasedCost(operations, input\_size, output\_size, op\_info); costs.inaccurate = unknown\_shapes; costs.num\_ops\_with\_unknown\_shapes = unknown\_shapes; costs.max\_memory = output\_size; return costs;}
Costs OpLevelCostEstimator::PredictOpCountBasedCost( double operations, double input\_io\_bytes, double output\_io\_bytes, const OpInfo& op\_info) const { double total\_io\_bytes = input\_io\_bytes + output\_io\_bytes; const DeviceInfo device\_info = GetDeviceInfo(op\_info.device()); if (device\_info.gigaops <= 0 || device\_info.gb\_per\_sec <= 0 || device\_info.intermediate\_read\_gb\_per\_sec <= 0 || device\_info.intermediate\_write\_gb\_per\_sec <= 0) { VLOG(1) << "BAD DEVICE. Op:" << op\_info.op() << " device type:" << op\_info.device().type() << " device model:" << op\_info.device().model(); }
 Costs::NanoSeconds compute\_cost(std::ceil(operations / device\_info.gigaops)); VLOG(1) << "Op:" << op\_info.op() << " GOps:" << operations / 1e9 << " Compute Time (ns):" << compute\_cost.count();
 Costs::NanoSeconds memory\_cost( std::ceil(total\_io\_bytes / device\_info.gb\_per\_sec)); VLOG(1) << "Op:" << op\_info.op() << " Size (KB):" << (total\_io\_bytes) / 1e3 << " Memory Time (ns):" << memory\_cost.count();
 // Check if bytes > 0. If it's not and the bandwidth is set to infinity // then the result would be undefined. double intermediate\_read\_time = (input\_io\_bytes > 0) ? std::ceil(input\_io\_bytes / device\_info.intermediate\_read\_gb\_per\_sec) : 0;
 double intermediate\_write\_time = (output\_io\_bytes > 0) ? std::ceil(output\_io\_bytes / device\_info.intermediate\_write\_gb\_per\_sec) : 0;
 Costs::NanoSeconds intermediate\_memory\_cost = compute\_memory\_overlap\_ ? std::max(intermediate\_read\_time, intermediate\_write\_time) : (intermediate\_read\_time + intermediate\_write\_time); VLOG(1) << "Op:" << op\_info.op() << " Size (KB):" << (total\_io\_bytes) / 1e3 << " Intermediate Memory Time (ns):" << intermediate\_memory\_cost.count();
 Costs costs = Costs::ZeroCosts(); costs.compute\_time = compute\_cost; costs.memory\_time = memory\_cost; costs.intermediate\_memory\_time = intermediate\_memory\_cost; costs.intermediate\_memory\_read\_time = Costs::NanoSeconds(intermediate\_read\_time); costs.intermediate\_memory\_write\_time = Costs::NanoSeconds(intermediate\_write\_time); CombineCostsAndUpdateExecutionTime(compute\_memory\_overlap\_, &costs); return costs;}
int64\_t OpLevelCostEstimator::CountConv2DOperations( const OpInfo& op\_info, bool\* found\_unknown\_shapes) { return CountConv2DOperations(op\_info, nullptr, found\_unknown\_shapes);}
// Helper to translate the positional arguments into named fields./\* static \*/OpLevelCostEstimator::ConvolutionDimensionsOpLevelCostEstimator::ConvolutionDimensionsFromInputs( const TensorShapeProto& original\_image\_shape, const TensorShapeProto& original\_filter\_shape, const OpInfo& op\_info, bool\* found\_unknown\_shapes) { VLOG(2) << "op features: " << op\_info.DebugString(); VLOG(2) << "Original image shape: " << original\_image\_shape.DebugString(); VLOG(2) << "Original filter shape: " << original\_filter\_shape.DebugString();
 int x\_index, y\_index, major\_channel\_index, minor\_channel\_index = -1; const std::string& data\_format = GetDataFormat(op\_info); if (data\_format == "NCHW") { major\_channel\_index = 1; y\_index = 2; x\_index = 3; } else if (data\_format == "NCHW\_VECT\_C") { // Use NCHW\_VECT\_C minor\_channel\_index = 1; y\_index = 2; x\_index = 3; major\_channel\_index = 4; } else { // Use NHWC. y\_index = 1; x\_index = 2; major\_channel\_index = 3; } const std::string& filter\_format = GetFilterFormat(op\_info); int filter\_x\_index, filter\_y\_index, in\_major\_channel\_index, out\_channel\_index, in\_minor\_channel\_index = -1; if (filter\_format == "HWIO") { filter\_y\_index = 0; filter\_x\_index = 1; in\_major\_channel\_index = 2; out\_channel\_index = 3; } else if (filter\_format == "OIHW\_VECT\_I") { out\_channel\_index = 0; in\_minor\_channel\_index = 1; filter\_y\_index = 2; filter\_x\_index = 3; in\_major\_channel\_index = 4; } else { // Use OIHW out\_channel\_index = 0; in\_major\_channel\_index = 1; filter\_y\_index = 2; filter\_x\_index = 3; }
 auto image\_shape = MaybeGetMinimumShape(original\_image\_shape, minor\_channel\_index >= 0 ? 5 : 4, found\_unknown\_shapes); auto filter\_shape = MaybeGetMinimumShape(original\_filter\_shape, in\_minor\_channel\_index >= 0 ? 5 : 4, found\_unknown\_shapes); VLOG(2) << "Image shape: " << image\_shape.DebugString(); VLOG(2) << "Filter shape: " << filter\_shape.DebugString();
 int64\_t batch = image\_shape.dim(0).size(); int64\_t ix = image\_shape.dim(x\_index).size(); int64\_t iy = image\_shape.dim(y\_index).size(); int64\_t iz = minor\_channel\_index >= 0 ? image\_shape.dim(minor\_channel\_index).size() \* image\_shape.dim(major\_channel\_index).size() : image\_shape.dim(major\_channel\_index).size(); int64\_t kx = filter\_shape.dim(filter\_x\_index).size(); int64\_t ky = filter\_shape.dim(filter\_y\_index).size(); int64\_t kz = in\_minor\_channel\_index >= 0 ? filter\_shape.dim(in\_major\_channel\_index).size() \* filter\_shape.dim(in\_minor\_channel\_index).size() : filter\_shape.dim(in\_major\_channel\_index).size(); std::vector<int64\_t> strides = GetStrides(op\_info); const auto padding = GetPadding(op\_info); int64\_t sx = strides[x\_index]; int64\_t sy = strides[y\_index]; int64\_t ox = GetOutputSize(ix, kx, sx, padding); int64\_t oy = GetOutputSize(iy, ky, sy, padding); int64\_t oz = filter\_shape.dim(out\_channel\_index).size(); // Only check equality when both sizes are known (in other words, when // neither is set to a minimum dimension size of 1). if (iz != 1 && kz != 1) { DCHECK\_EQ(iz % kz, 0) << "Input channel " << iz << " is not a multiple of filter channel " << kz << "."; if (iz % kz) { \*found\_unknown\_shapes = true; } } else { iz = kz = std::max<int64\_t>(iz, kz); } OpLevelCostEstimator::ConvolutionDimensions conv\_dims = { batch, ix, iy, iz, kx, ky, kz, oz, ox, oy, sx, sy, padding};
 VLOG(1) << "Batch Size:" << batch; VLOG(1) << "Image Dims:" << ix << "," << iy; VLOG(1) << "Input Depth:" << iz; VLOG(1) << "Kernel Dims:" << kx << "," << ky; VLOG(1) << "Kernel Depth:" << kz; VLOG(1) << "Output Dims:" << ox << "," << oy; VLOG(1) << "Output Depth:" << oz; VLOG(1) << "Strides:" << sx << "," << sy;[View remainder of file in raw view](https://github.com/tensorflow/tensorflow/raw/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow/core/grappler/costs/op_level_cost_estimator.cc)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_2b4f1c54_20250115_090810.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fsecurity%2Fadvisories%2FGHSA-v3f7-j968-4h5f)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fsecurity%2Fadvisories%2FGHSA-v3f7-j968-4h5f)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=tensorflow%2Ftensorflow)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[tensorflow](/tensorflow)
/
**[tensorflow](/tensorflow/tensorflow)**
Public

* [Notifications](/login?return_to=%2Ftensorflow%2Ftensorflow) You must be signed in to change notification settings
* [Fork
  74.4k](/login?return_to=%2Ftensorflow%2Ftensorflow)
* [Star
   187k](/login?return_to=%2Ftensorflow%2Ftensorflow)

* [Code](/tensorflow/tensorflow)
* [Issues
  826](/tensorflow/tensorflow/issues)
* [Pull requests
  5k+](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects
  2](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

Additional navigation options

* [Code](/tensorflow/tensorflow)
* [Issues](/tensorflow/tensorflow/issues)
* [Pull requests](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

# Floating point division by 0 when executing convolution operators

Low

[mihaimaruseac](/mihaimaruseac)
published
GHSA-v3f7-j968-4h5f
Feb 2, 2022

## Package

pip

tensorflow, tensorflow-cpu, tensorflow-gpu
([pip](/advisories?query=ecosystem%3Apip))

## Affected versions

< 2.8.0

## Patched versions

2.5.3, 2.6.3, 2.7.1

## Description

### Impact

The [estimator for the cost of some convolution operations](https://github.com/tensorflow/tensorflow/blob/ffa202a17ab7a4a10182b746d230ea66f021fe16/tensorflow/core/grappler/costs/op_level_cost_estimator.cc#L189-L198) can be made to execute a division by 0:

```
import tensorflow as tf

@tf.function
def test():
  y=tf.raw_ops.AvgPoolGrad(
    orig_input_shape=[1,1,1,1],
    grad=[[[[1.0],[1.0],[1.0]]],[[[2.0],[2.0],[2.0]]],[[[3.0],[3.0],[3.0]]]],
    ksize=[1,1,1,1],
    strides=[1,1,1,0],
    padding='VALID',
    data_format='NCHW')
  return y

test()
```

The function fails to check that the stride argument is stricly positive:

```
int64_t GetOutputSize(const int64_t input, const int64_t filter,
                      const int64_t stride, const Padding& padding) {
  // Logic for calculating output shape is from GetWindowedOutputSizeVerbose()
  // function in third_party/tensorflow/core/framework/common_shape_fns.cc.
  if (padding == Padding::VALID) {
    return (input - filter + stride) / stride;
  } else {  // SAME.
    return (input + stride - 1) / stride;
  }
}
```

Hence, the fix is to add a check for the stride argument to ensure it is valid.

### Patches

We have patched the issue in GitHub commit [3218043d6d3a019756607643cf65574fbfef5d7a](https://github.com/tensorflow/tensorflow/commit/3218043d6d3a019756607643cf65574fbfef5d7a).

The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.

### For more information

Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.

### Attribution

This vulnerability has been reported by Yu Tian of Qihoo 360 AIVul Team.

### Severity

Low

### CVE ID

CVE-2022-21725

### Weaknesses

No CWEs

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_6b7447d8_20250115_090808.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fcommit%2F3218043d6d3a019756607643cf65574fbfef5d7a)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fcommit%2F3218043d6d3a019756607643cf65574fbfef5d7a)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=tensorflow%2Ftensorflow)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[tensorflow](/tensorflow)
/
**[tensorflow](/tensorflow/tensorflow)**
Public

* [Notifications](/login?return_to=%2Ftensorflow%2Ftensorflow) You must be signed in to change notification settings
* [Fork
  74.4k](/login?return_to=%2Ftensorflow%2Ftensorflow)
* [Star
   187k](/login?return_to=%2Ftensorflow%2Ftensorflow)

* [Code](/tensorflow/tensorflow)
* [Issues
  826](/tensorflow/tensorflow/issues)
* [Pull requests
  5k+](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects
  2](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

Additional navigation options

* [Code](/tensorflow/tensorflow)
* [Issues](/tensorflow/tensorflow/issues)
* [Pull requests](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

## Commit

[Permalink](/tensorflow/tensorflow/commit/3218043d6d3a019756607643cf65574fbfef5d7a)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

Internal change

[Browse files](/tensorflow/tensorflow/tree/3218043d6d3a019756607643cf65574fbfef5d7a)
Browse the repository at this point in the history

```
PiperOrigin-RevId: 411896058
Change-Id: Ia031058247e3cf382957a6662d3f9e1cbb481ca2
```

* Loading branch information

[![@ishark](https://avatars.githubusercontent.com/u/723624?s=40&v=4)](/ishark) [![@tensorflower-gardener](https://avatars.githubusercontent.com/u/17151892?s=40&v=4)](/tensorflower-gardener)

[ishark](/tensorflow/tensorflow/commits?author=ishark "View all commits by ishark")
authored and
[tensorflower-gardener](/tensorflow/tensorflow/commits?author=tensorflower-gardener "View all commits by tensorflower-gardener")
committed
Nov 23, 2021

1 parent
[05e7d51](/tensorflow/tensorflow/commit/05e7d510f6859d32f22c1f0a0c1e8ca8c826c058)

commit 3218043

 Show file tree

 Hide file tree

Showing
**4 changed files**
with
**83 additions**
and
**17 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

* tensorflow/core/grappler/costs

  + tensorflow/core/grappler/costs/BUILD
    [BUILD](#diff-403342f93283f451fa5850a239bd34689ee07b15e67a23c7db8c200987cb9de8)
  + tensorflow/core/grappler/costs/op\_level\_cost\_estimator.cc
    [op\_level\_cost\_estimator.cc](#diff-1d83005a694aeb7181d668b0efaa5ac21f227b5a1b0928e686c134fc9218193f)
  + tensorflow/core/grappler/costs/op\_level\_cost\_estimator.h
    [op\_level\_cost\_estimator.h](#diff-200660cf790210be2eb4fa016c87cc3a582874c6c06e35775d231157d21bc0f3)
  + tensorflow/core/grappler/costs/op\_level\_cost\_estimator\_test.cc
    [op\_level\_cost\_estimator\_test.cc](#diff-c9f08c364f5c3c10b0bbf4d26c4108c246e4a1e6dd8bd9358cd90277a65525c5)

## There are no files selected for viewing

1 change: 1 addition & 0 deletions

1
[tensorflow/core/grappler/costs/BUILD](#diff-403342f93283f451fa5850a239bd34689ee07b15e67a23c7db8c200987cb9de8 "tensorflow/core/grappler/costs/BUILD")

Show comments

[View file](/tensorflow/tensorflow/blob/3218043d6d3a019756607643cf65574fbfef5d7a/tensorflow/core/grappler/costs/BUILD)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -355,6 +355,7 @@ tf\_cc\_test( |
|  |  | "//tensorflow/core:protos\_all\_cc", |
|  |  | "//tensorflow/core:test", |
|  |  | "//tensorflow/core:test\_main", |
|  |  | "//tensorflow/core/platform:status\_matchers", |
|  |  | ], |
|  |  | ) |
|  |  |  |
| Expand Down | |  |

37 changes: 24 additions & 13 deletions

37
[tensorflow/core/grappler/costs/op\_level\_cost\_estimator.cc](#diff-1d83005a694aeb7181d668b0efaa5ac21f227b5a1b0928e686c134fc9218193f "tensorflow/core/grappler/costs/op_level_cost_estimator.cc")

Show comments

[View file](/tensorflow/tensorflow/blob/3218043d6d3a019756607643cf65574fbfef5d7a/tensorflow/core/grappler/costs/op_level_cost_estimator.cc)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -2153,7 +2153,7 @@ OpInfo::TensorProperties OpLevelCostEstimator::DescribeTensor( |
|  |  | } |
|  |  |  |
|  |  | /\* static \*/ |
|  |  | OpLevelCostEstimator::ConvolutionDimensions |
|  |  | StatusOr<OpLevelCostEstimator::ConvolutionDimensions> |
|  |  | OpLevelCostEstimator::OpDimensionsFromInputs( |
|  |  | const TensorShapeProto& original\_image\_shape, const OpInfo& op\_info, |
|  |  | bool\* found\_unknown\_shapes) { |
| Expand Down  Expand Up | | @@ -2190,6 +2190,11 @@ OpLevelCostEstimator::OpDimensionsFromInputs( |
|  |  | std::vector<int64\_t> strides = GetStrides(op\_info); |
|  |  | int64\_t sx = strides[x\_index]; |
|  |  | int64\_t sy = strides[y\_index]; |
|  |  | if (sx == 0 || sy == 0) { |
|  |  | return errors::InvalidArgument( |
|  |  | "Stride must be > 0 for Height and Width, but got (", sy, ", ", sx, |
|  |  | ")"); |
|  |  | } |
|  |  | const auto padding = GetPadding(op\_info); |
|  |  |  |
|  |  | int64\_t ox = GetOutputSize(ix, kx, sx, padding); |
| Expand All | | @@ -2206,8 +2211,9 @@ Status OpLevelCostEstimator::PredictMaxPool(const OpContext& op\_context, |
|  |  | bool found\_unknown\_shapes = false; |
|  |  | const auto& op\_info = op\_context.op\_info; |
|  |  | // x: op\_info.inputs(0) |
|  |  | ConvolutionDimensions dims = OpDimensionsFromInputs( |
|  |  | op\_info.inputs(0).shape(), op\_info, &found\_unknown\_shapes); |
|  |  | TF\_ASSIGN\_OR\_RETURN(ConvolutionDimensions dims, |
|  |  | OpDimensionsFromInputs(op\_info.inputs(0).shape(), op\_info, |
|  |  | &found\_unknown\_shapes)); |
|  |  | // kx \* ky - 1 comparisons per output (kx \* xy > 1) |
|  |  | // or 1 copy per output (kx \* k1 = 1). |
|  |  | int per\_output\_ops = dims.kx \* dims.ky == 1 ? 1 : dims.kx \* dims.ky - 1; |
| Expand Down  Expand Up | | @@ -2248,8 +2254,9 @@ Status OpLevelCostEstimator::PredictMaxPoolGrad(const OpContext& op\_context, |
|  |  | op\_info.ShortDebugString()); |
|  |  | } |
|  |  |  |
|  |  | ConvolutionDimensions dims = OpDimensionsFromInputs( |
|  |  | op\_info.inputs(0).shape(), op\_info, &found\_unknown\_shapes); |
|  |  | TF\_ASSIGN\_OR\_RETURN(ConvolutionDimensions dims, |
|  |  | OpDimensionsFromInputs(op\_info.inputs(0).shape(), op\_info, |
|  |  | &found\_unknown\_shapes)); |
|  |  |  |
|  |  | int64\_t ops = 0; |
|  |  | if (dims.kx == 1 && dims.ky == 1) { |
| Expand Down  Expand Up | | @@ -2324,8 +2331,9 @@ Status OpLevelCostEstimator::PredictAvgPool(const OpContext& op\_context, |
|  |  | bool found\_unknown\_shapes = false; |
|  |  | const auto& op\_info = op\_context.op\_info; |
|  |  | // x: op\_info.inputs(0) |
|  |  | ConvolutionDimensions dims = OpDimensionsFromInputs( |
|  |  | op\_info.inputs(0).shape(), op\_info, &found\_unknown\_shapes); |
|  |  | TF\_ASSIGN\_OR\_RETURN(ConvolutionDimensions dims, |
|  |  | OpDimensionsFromInputs(op\_info.inputs(0).shape(), op\_info, |
|  |  | &found\_unknown\_shapes)); |
|  |  |  |
|  |  | // kx \* ky - 1 additions and 1 multiplication per output. |
|  |  | int64\_t ops = dims.batch \* dims.ox \* dims.oy \* dims.oz \* dims.kx \* dims.ky; |
| Expand Down  Expand Up | | @@ -2382,8 +2390,9 @@ Status OpLevelCostEstimator::PredictAvgPoolGrad(const OpContext& op\_context, |
|  |  | found\_unknown\_shapes = true; |
|  |  | } |
|  |  |  |
|  |  | ConvolutionDimensions dims = |
|  |  | OpDimensionsFromInputs(x\_shape, op\_info, &found\_unknown\_shapes); |
|  |  | TF\_ASSIGN\_OR\_RETURN( |
|  |  | ConvolutionDimensions dims, |
|  |  | OpDimensionsFromInputs(x\_shape, op\_info, &found\_unknown\_shapes)); |
|  |  |  |
|  |  | int64\_t ops = 0; |
|  |  | if (dims.kx <= dims.sx && dims.ky <= dims.sy) { |
| Expand All | | @@ -2409,8 +2418,9 @@ Status OpLevelCostEstimator::PredictFusedBatchNorm( |
|  |  | // offset: op\_info.inputs(2) |
|  |  | // mean: op\_info.inputs(3) --> only for inference |
|  |  | // variance: op\_info.inputs(4) --> only for inference |
|  |  | ConvolutionDimensions dims = OpDimensionsFromInputs( |
|  |  | op\_info.inputs(0).shape(), op\_info, &found\_unknown\_shapes); |
|  |  | TF\_ASSIGN\_OR\_RETURN(ConvolutionDimensions dims, |
|  |  | OpDimensionsFromInputs(op\_info.inputs(0).shape(), op\_info, |
|  |  | &found\_unknown\_shapes)); |
|  |  | const bool is\_training = IsTraining(op\_info); |
|  |  |  |
|  |  | int64\_t ops = 0; |
| Expand Down  Expand Up | | @@ -2459,8 +2469,9 @@ Status OpLevelCostEstimator::PredictFusedBatchNormGrad( |
|  |  | // scale: op\_info.inputs(2) |
|  |  | // mean: op\_info.inputs(3) |
|  |  | // variance or inverse of variance: op\_info.inputs(4) |
|  |  | ConvolutionDimensions dims = OpDimensionsFromInputs( |
|  |  | op\_info.inputs(1).shape(), op\_info, &found\_unknown\_shapes); |
|  |  | TF\_ASSIGN\_OR\_RETURN(ConvolutionDimensions dims, |
|  |  | OpDimensionsFromInputs(op\_info.inputs(1).shape(), op\_info, |
|  |  | &found\_unknown\_shapes)); |
|  |  |  |
|  |  | int64\_t ops = 0; |
|  |  | const auto rsqrt\_cost = Eigen::internal::functor\_traits< |
| Expand Down | |  |

2 changes: 1 addition & 1 deletion

2
[tensorflow/core/grappler/costs/op\_level\_cost\_estimator.h](#diff-200660cf790210be2eb4fa016c87cc3a582874c6c06e35775d231157d21bc0f3 "tensorflow/core/grappler/costs/op_level_cost_estimator.h")

Show comments

[View file](/tensorflow/tensorflow/blob/3218043d6d3a019756607643cf65574fbfef5d7a/tensorflow/core/grappler/costs/op_level_cost_estimator.h)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -290,7 +290,7 @@ class OpLevelCostEstimator { |
|  |  | bool\* found\_unknown\_shapes); |
|  |  |  |
|  |  | // For Pooling, FusedBatchNorm, and their grad ops. |
|  |  | static ConvolutionDimensions OpDimensionsFromInputs( |
|  |  | static StatusOr<ConvolutionDimensions> OpDimensionsFromInputs( |
|  |  | const TensorShapeProto& original\_image\_shape, const OpInfo& op\_info, |
|  |  | bool\* found\_unknown\_shapes); |
|  |  |  |
| Expand Down | |  |

60 changes: 57 additions & 3 deletions

60
[tensorflow/core/grappler/costs/op\_level\_cost\_estimator\_test.cc](#diff-c9f08c364f5c3c10b0bbf4d26c4108c246e4a1e6dd8bd9358cd90277a65525c5 "tensorflow/core/grappler/costs/op_level_cost_estimator_test.cc")

Show comments

[View file](/tensorflow/tensorflow/blob/3218043d6d3a019756607643cf65574fbfef5d7a/tensorflow/core/grappler/costs/op_level_cost_estimator_test.cc)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -24,6 +24,7 @@ limitations under the License. |
|  |  | #include "tensorflow/core/framework/tensor\_shape.h" |
|  |  | #include "tensorflow/core/framework/tensor\_shape.pb.h" |
|  |  | #include "tensorflow/core/framework/types.h" |
|  |  | #include "tensorflow/core/platform/status\_matchers.h" |
|  |  | #include "tensorflow/core/platform/test.h" |
|  |  | #include "tensorflow/core/protobuf/device\_properties.pb.h" |
|  |  |  |
| Expand Down  Expand Up | | @@ -558,9 +559,10 @@ class OpLevelCostEstimatorTest : public ::testing::Test { |
|  |  | } |
|  |  |  |
|  |  | bool found\_unknown\_shapes; |
|  |  | auto dims = OpLevelCostEstimator::OpDimensionsFromInputs( |
|  |  | op\_context.op\_info.inputs(0).shape(), op\_context.op\_info, |
|  |  | &found\_unknown\_shapes); |
|  |  | TF\_ASSERT\_OK\_AND\_ASSIGN( |
|  |  | auto dims, OpLevelCostEstimator::OpDimensionsFromInputs( |
|  |  | op\_context.op\_info.inputs(0).shape(), op\_context.op\_info, |
|  |  | &found\_unknown\_shapes)); |
|  |  | Padding padding\_enum; |
|  |  | if (padding == "VALID") { |
|  |  | padding\_enum = Padding::VALID; |
| Expand All | | @@ -581,6 +583,38 @@ class OpLevelCostEstimatorTest : public ::testing::Test { |
|  |  | EXPECT\_EQ(padding\_enum, dims.padding); |
|  |  | } |
|  |  |  |
|  |  | StatusOr<OpLevelCostEstimator::ConvolutionDimensions> |
|  |  | CallOpDimensionsFromInputs(const int n, const int h, const int w, const int c, |
|  |  | const int kx, const int ky, const int sx, |
|  |  | const int sy, const string& data\_format, |
|  |  | const string& padding) { |
|  |  | OpContext op\_context; |
|  |  |  |
|  |  | const std::vector<int> x = {n, h, w, c}; |
|  |  | const std::vector<int> ksize = {1, kx, ky, 1}; |
|  |  | std::vector<int> strides; |
|  |  | if (data\_format == "NHWC") { |
|  |  | strides = {1, sy, sx, 1}; |
|  |  | } else { |
|  |  | strides = {1, 1, sy, sx}; |
|  |  | } |
|  |  |  |
|  |  | auto& op\_info = op\_context.op\_info; |
|  |  | SetCpuDevice(&op\_info); |
|  |  | op\_info.set\_op("MaxPool"); |
|  |  |  |
|  |  | DescribeTensor4D(x[0], x[1], x[2], x[3], op\_info.add\_inputs()); |
|  |  | auto\* attr = op\_info.mutable\_attr(); |
|  |  | SetAttrValue(data\_format, &(\*attr)["data\_format"]); |
|  |  | SetAttrValue(padding, &(\*attr)["padding"]); |
|  |  | SetAttrValue(strides, &(\*attr)["strides"]); |
|  |  | SetAttrValue(ksize, &(\*attr)["ksize"]); |
|  |  | bool found\_unknown\_shapes; |
|  |  | return OpLevelCostEstimator::OpDimensionsFromInputs( |
|  |  | op\_context.op\_info.inputs(0).shape(), op\_context.op\_info, |
|  |  | &found\_unknown\_shapes); |
|  |  | } |
|  |  |  |
|  |  | OpLevelCostEstimator estimator\_; |
|  |  | }; |
|  |  |  |
| Expand Down  Expand Up | | @@ -1383,6 +1417,26 @@ TEST\_F(OpLevelCostEstimatorTest, OpDimensionsFromInputs) { |
|  |  | } |
|  |  | } |
|  |  |  |
|  |  | TEST\_F(OpLevelCostEstimatorTest, OpDimensionsFromInputsError) { |
|  |  | std::vector<string> paddings = {"VALID", "SAME"}; |
|  |  | std::vector<string> formats = {"NHWC", "NCHW"}; |
|  |  | for (const auto& p : paddings) { |
|  |  | for (const auto& f : formats) { |
|  |  | // n, h, w, c, kx, ky, sx, sy, data\_format, padding. |
|  |  | ASSERT\_THAT( |
|  |  | CallOpDimensionsFromInputs(10, 14, 14, 3840, 3, 3, 0, 2, f, p), |
|  |  | testing::StatusIs( |
|  |  | error::INVALID\_ARGUMENT, |
|  |  | "Stride must be > 0 for Height and Width, but got (2, 0)")); |
|  |  | ASSERT\_THAT( |
|  |  | CallOpDimensionsFromInputs(10, 14, 14, 3840, 3, 3, 2, 0, f, p), |
|  |  | testing::StatusIs( |
|  |  | error::INVALID\_ARGUMENT, |
|  |  | "Stride must be > 0 for Height and Width, but got (0, 2)")); |
|  |  | } |
|  |  | } |
|  |  | } |
|  |  |  |
|  |  | TEST\_F(OpLevelCostEstimatorTest, PredictMaxPool) { |
|  |  | auto predict\_max\_pool = [this](const int n, const int in, const int c, |
|  |  | const int k, const int s, |
| Expand Down | |  |

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `3218043`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fcommit%2F3218043d6d3a019756607643cf65574fbfef5d7a) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


