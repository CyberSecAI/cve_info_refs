=== Content from codereview.qt-project.org_005706b0_20250114_231032.html ===




=== Content from download.qt.io_1f4d41ad_20250114_231033.html ===
diff --git a/src/corelib/io/qlockfile\_win.cpp b/src/corelib/io/qlockfile\_win.cpp
index a20a274870..30ef0625db 100644
--- a/src/corelib/io/qlockfile\_win.cpp
+++ b/src/corelib/io/qlockfile\_win.cpp
@@ -48,6 +48,8 @@
#include "QtCore/qdebug.h"
#include "QtCore/qthread.h"
+#include "private/qsystemlibrary\_p.h"
+
QT\_BEGIN\_NAMESPACE
static inline bool fileExists(const wchar\_t \*fileName)
@@ -150,7 +152,7 @@ QString QLockFilePrivate::processNameByPid(qint64 pid)
#if !defined(Q\_OS\_WINRT)
typedef DWORD (WINAPI \*GetModuleFileNameExFunc)(HANDLE, HMODULE, LPTSTR, DWORD);
- HMODULE hPsapi = LoadLibraryA("psapi");
+ HMODULE hPsapi = QSystemLibrary::load(L"psapi");
if (!hPsapi)
return QString();
GetModuleFileNameExFunc qGetModuleFileNameEx = reinterpret\_cast(
diff --git a/src/network/kernel/qauthenticator.cpp b/src/network/kernel/qauthenticator.cpp
index 4e84c0954b..a2f1133bc0 100644
--- a/src/network/kernel/qauthenticator.cpp
+++ b/src/network/kernel/qauthenticator.cpp
@@ -50,6 +50,7 @@
#include
#include
#include
+#include "private/qsystemlibrary\_p.h"
#ifdef Q\_OS\_WIN
#include
@@ -1563,7 +1564,7 @@ static bool q\_SSPI\_library\_load()
// Initialize security interface
if (pSecurityFunctionTable == nullptr) {
- securityDLLHandle = LoadLibrary(L"secur32.dll");
+ securityDLLHandle = QSystemLibrary::load(L"secur32");
if (securityDLLHandle != nullptr) {
INIT\_SECURITY\_INTERFACE pInitSecurityInterface =
reinterpret\_cast(
diff --git a/src/plugins/platforms/windows/qwindowsglcontext.cpp b/src/plugins/platforms/windows/qwindowsglcontext.cpp
index 65b3e7f430..ff04fbbf98 100644
--- a/src/plugins/platforms/windows/qwindowsglcontext.cpp
+++ b/src/plugins/platforms/windows/qwindowsglcontext.cpp
@@ -48,6 +48,7 @@
#include
#include
+#include
#include
#include
@@ -162,19 +163,25 @@ QFunctionPointer QWindowsOpengl32DLL::resolve(const char \*name)
bool QWindowsOpengl32DLL::init(bool softwareRendering)
{
- const QByteArray opengl32 = QByteArrayLiteral("opengl32.dll");
- const QByteArray swopengl = QByteArrayLiteral("opengl32sw.dll");
+ const QByteArray opengl32 = QByteArrayLiteral("opengl32");
+ const QByteArray swopengl = QByteArrayLiteral("opengl32sw");
+ bool useSystemLib = false;
QByteArray openglDll = qgetenv("QT\_OPENGL\_DLL");
- if (openglDll.isEmpty())
+ if (openglDll.isEmpty()) {
openglDll = softwareRendering ? swopengl : opengl32;
+ useSystemLib = !softwareRendering;
+ }
openglDll = openglDll.toLower();
m\_nonOpengl32 = openglDll != opengl32;
qCDebug(lcQpaGl) << "Qt: Using WGL and OpenGL from" << openglDll;
- m\_lib = ::LoadLibraryA(openglDll.constData());
+ if (useSystemLib)
+ m\_lib = QSystemLibrary::load((wchar\_t\*)(QString::fromLatin1(openglDll).utf16()));
+ else
+ m\_lib = LoadLibraryA(openglDll.constData());
if (!m\_lib) {
qErrnoWarning(::GetLastError(), "Failed to load %s", openglDll.constData());
return false;
@@ -184,7 +191,7 @@ bool QWindowsOpengl32DLL::init(bool softwareRendering)
// Load opengl32.dll always. GDI functions like ChoosePixelFormat do
// GetModuleHandle for opengl32.dll and behave differently (and call back into
// opengl32) when the module is present. This is fine for dummy contexts and windows.
- ::LoadLibraryA("opengl32.dll");
+ QSystemLibrary::load(L"opengl32");
}
wglCreateContext = reinterpret\_cast(resolve("wglCreateContext"));
diff --git a/src/plugins/platforms/windows/qwindowsopengltester.cpp b/src/plugins/platforms/windows/qwindowsopengltester.cpp
index 49da6ee3e3..d78a18b35d 100644
--- a/src/plugins/platforms/windows/qwindowsopengltester.cpp
+++ b/src/plugins/platforms/windows/qwindowsopengltester.cpp
@@ -49,6 +49,7 @@
#include
#include
#include
+#include
#ifndef QT\_NO\_OPENGL
#include
@@ -396,7 +397,7 @@ bool QWindowsOpenGLTester::testDesktopGL()
// Test #1: Load opengl32.dll and try to resolve an OpenGL 2 function.
// This will typically fail on systems that do not have a real OpenGL driver.
- lib = LoadLibraryA("opengl32.dll");
+ lib = QSystemLibrary::load(L"opengl32");
if (lib) {
CreateContext = reinterpret\_cast(
reinterpret\_cast(::GetProcAddress(lib, "wglCreateContext")));


=== Content from codereview.qt-project.org_7923accd_20250114_231032.html ===




=== Content from codereview.qt-project.org_ce69d1ed_20250114_231032.html ===



