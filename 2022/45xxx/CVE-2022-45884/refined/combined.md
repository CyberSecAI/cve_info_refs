=== Content from lore.kernel.org_3d1f90fb_20250114_200004.html ===

```
[linux-media.vger.kernel.org archive mirror](../?t=20221115131937)
 [help](../_/text/help/) / [color](../_/text/color/) / [mirror](../_/text/mirror/) / [Atom feed](../new.atom)
```
```
From: imv4bel@gmail.com
To: mchehab@kernel.org
Cc: Hyunwoo Kim <imv4bel@gmail.com>,
	kernel@tuxforce.de, [linux-media@vger.kernel.org](../../linux-media/?t=20221115131937),
	[linux-usb@vger.kernel.org](../../linux-usb/?t=20221115131937), cai.huoqing@linux.dev, tiwai@suse.de
Subject: [[PATCH 0/4] Fix multiple race condition vulnerabilities in dvb-core and device driver](#r)
Date: Tue, 15 Nov 2022 05:18:18 -0800	[[thread overview]](#r)
Message-ID: <20221115131822.6640-1-imv4bel@gmail.com> (<raw>)

From: Hyunwoo Kim <imv4bel@gmail.com>

Dear,

This patch set is a security patch for various race condition vulnerabilities that occur
in 'dvb-core' and 'ttusb_dec', a dvb-based device driver.

# 1. media: dvb-core: Fix use-after-free due to race condition occurring in dvb_frontend
This is a security patch for a race condition that occurs in the dvb_frontend system of dvb-core.

The race condition that occurs here will occur with _any_ device driver using dvb_frontend.

The race conditions that occur in dvb_frontend are as follows
(Description is based on drivers/media/usb/as102/as102_drv.c using dvb_frontend):
```
                cpu0                                                cpu1
       1. open()
          dvb_frontend_open()
          dvb_frontend_get()    // kref : 3

                                                             2. as102_usb_disconnect()
                                                                as102_dvb_unregister()
                                                                dvb_unregister_frontend()
                                                                    dvb_frontend_put()    // kref : 2
                                                                dvb_frontend_detach()
                                                                    dvb_frontend_put()    // kref : 1
       3. close()
          __fput()
          dvb_frontend_release()
          dvb_frontend_put()    // kref : 0
          dvb_frontend_free()
          __dvb_frontend_free()
          dvb_free_device()
          kfree (dvbdev->fops);
          ...
          fops_put(file->f_op);    // UAF!!
```
UAF occurs in the following order: '.probe -> open() -> .disconnect -> close()'.

The root cause of this is that wake_up() for dvbdev->wait_queue is implemented in the
dvb_frontend_release() function, but wait_event() is not implemented in the dvb_frontend_stop() function.

The KASAN log caused by this is as follows:
```
[   60.754938] ==================================================================
[   60.754942] BUG: KASAN: use-after-free in __fput+0xa55/0xaf0
[   60.754945] Read of size 8 at addr ffff888134ddf000 by task as102_test/2139

[   60.754949] CPU: 3 PID: 2139 Comm: as102_test Not tainted 6.1.0-rc2+ #16
[   60.754951] Hardware name: Gigabyte Technology Co., Ltd. B460MDS3H/B460M DS3H, BIOS F3 05/27/2020
[   60.754953] Call Trace:
[   60.754954]  <TASK>
[   60.754956]  dump_stack_lvl+0x49/0x63
[   60.754958]  print_report+0x177/0x46e
[   60.754962]  ? kasan_complete_mode_report_info+0x7c/0x210
[   60.754965]  ? __fput+0xa55/0xaf0
[   60.754970]  kasan_report+0xb0/0x140
[   60.754976]  ? __fput+0xa55/0xaf0
[   60.754979]  __asan_report_load8_noabort+0x14/0x20
[   60.754982]  __fput+0xa55/0xaf0
[   60.754985]  ____fput+0xe/0x20
[   60.754987]  task_work_run+0x153/0x240
[   60.754991]  ? task_work_cancel+0x20/0x20
[   60.754994]  ? fput+0xab/0x140
[   60.754997]  exit_to_user_mode_prepare+0x18f/0x1a0
[   60.754999]  syscall_exit_to_user_mode+0x26/0x50
[   60.755003]  do_syscall_64+0x69/0x90
[   60.755005]  ? do_syscall_64+0x69/0x90
[   60.755008]  ? debug_smp_processor_id+0x17/0x20
[   60.755010]  ? fpregs_assert_state_consistent+0x52/0xc0
[   60.755013]  ? exit_to_user_mode_prepare+0x49/0x1a0
[   60.755015]  ? irqentry_exit_to_user_mode+0x9/0x20
[   60.755018]  ? irqentry_exit+0x3b/0x50
[   60.755021]  ? sysvec_apic_timer_interrupt+0x57/0xc0
[   60.755024]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
[   60.755027] RIP: 0033:0x4537eb
[   60.755029] Code: 03 00 00 00 0f 05 48 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 c3 a8 02 00 8b 7c 24 0c 41 89 c0 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 35 44 89 c7 89 44 24 0c e8 11 a9 02 00 8b 44
[   60.755031] RSP: 002b:00007ff8c1c001a0 EFLAGS: 00000293 ORIG_RAX: 0000000000000003
[   60.755034] RAX: 0000000000000000 RBX: 00007ff8c1c00640 RCX: 00000000004537eb
[   60.755036] RDX: 0000000000000000 RSI: 00007ff8bc000b70 RDI: 0000000000000003
[   60.755038] RBP: 00007ff8c1c001d0 R08: 0000000000000000 R09: 0000000000000000
[   60.755040] R10: 000000000000000a R11: 0000000000000293 R12: 00007ff8c1c00640
[   60.755042] R13: 0000000000000000 R14: 000000000041b290 R15: 00007ff8c1400000
[   60.755044]  </TASK>

[   60.755047] Allocated by task 2114:
[   60.755049]  kasan_save_stack+0x26/0x50
[   60.755052]  kasan_set_track+0x25/0x40
[   60.755054]  kasan_save_alloc_info+0x1e/0x30
[   60.755056]  __kasan_kmalloc+0xb4/0xc0
[   60.755058]  __kmalloc_node_track_caller+0x66/0x160
[   60.755061]  kmemdup+0x23/0x50
[   60.755063]  dvb_register_device+0x1cd/0x15c0 [dvb_core]
[   60.755070]  dvb_register_frontend+0x3cb/0x630 [dvb_core]
[   60.755078]  as102_dvb_register+0x335/0x4d0 [dvb_as102]
[   60.755083]  as102_usb_probe.cold+0x680/0x6eb [dvb_as102]
[   60.755087]  usb_probe_interface+0x266/0x740
[   60.755089]  really_probe+0x1fa/0xa80
[   60.755092]  __driver_probe_device+0x2cb/0x490
[   60.755094]  driver_probe_device+0x4e/0x140
[   60.755096]  __driver_attach+0x1a3/0x520
[   60.755098]  bus_for_each_dev+0x11e/0x1c0
[   60.755100]  driver_attach+0x3d/0x60
[   60.755102]  bus_add_driver+0x449/0x5a0
[   60.755103]  driver_register+0x219/0x390
[   60.755105]  usb_register_driver+0x228/0x400
[   60.755107]  0xffffffffc04c8023
[   60.755110]  do_one_initcall+0x97/0x310
[   60.755113]  do_init_module+0x19a/0x630
[   60.755115]  load_module+0x6ca4/0x7d90
[   60.755117]  __do_sys_finit_module+0x134/0x1d0
[   60.755119]  __x64_sys_finit_module+0x72/0xb0
[   60.755121]  do_syscall_64+0x59/0x90
[   60.755123]  entry_SYSCALL_64_after_hwframe+0x63/0xcd

[   60.755126] Freed by task 2139:
[   60.755128]  kasan_save_stack+0x26/0x50
[   60.755130]  kasan_set_track+0x25/0x40
[   60.755132]  kasan_save_free_info+0x2e/0x50
[   60.755134]  ____kasan_slab_free+0x174/0x1e0
[   60.755136]  __kasan_slab_free+0x12/0x20
[   60.755138]  slab_free_freelist_hook+0xd0/0x1a0
[   60.755140]  __kmem_cache_free+0x193/0x2c0
[   60.755143]  kfree+0x79/0x120
[   60.755145]  dvb_free_device+0x38/0x60 [dvb_core]
[   60.755151]  dvb_frontend_put.cold+0xa6/0x15a [dvb_core]
[   60.755160]  dvb_frontend_release.cold+0xc7/0xf6 [dvb_core]
[   60.755167]  __fput+0x2ce/0xaf0
[   60.755169]  ____fput+0xe/0x20
[   60.755171]  task_work_run+0x153/0x240
[   60.755173]  exit_to_user_mode_prepare+0x18f/0x1a0
[   60.755175]  syscall_exit_to_user_mode+0x26/0x50
[   60.755177]  do_syscall_64+0x69/0x90
[   60.755179]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
```

Also, UAF can occur for driver-specfic structures (such as 'struct XXX_dev'):
```
                cpu0                                                cpu1
       1. open()
          dvb_frontend_open()
                                                             2. as102_usb_disconnect()
                                                                kref_put(&as102_dev->kref, as102_usb_release);    // kref : 0
                                                                as102_usb_release()
                                                                kfree(as102_dev);
       3. close()
          dvb_frontend_release()
          mutex_lock(&fe->dvb->mdev_lock);    // UAF
```

The KASAN log caused by this is as follows:
```
[   82.144178] ==================================================================
[   82.144182] BUG: KASAN: use-after-free in mutex_lock+0x81/0xe0
[   82.144189] Write of size 8 at addr ffff888121b6a168 by task as102_test/2356

[   82.144193] CPU: 12 PID: 2356 Comm: as102_test Not tainted 6.1.0-rc2+ #16
[   82.144196] Hardware name: Gigabyte Technology Co., Ltd. B460MDS3H/B460M DS3H, BIOS F3 05/27/2020
[   82.144198] Call Trace:
[   82.144200]  <TASK>
[   82.144201]  dump_stack_lvl+0x49/0x63
[   82.144205]  print_report+0x177/0x46e
[   82.144208]  ? kasan_complete_mode_report_info+0x7c/0x210
[   82.144212]  ? mutex_lock+0x81/0xe0
[   82.144215]  kasan_report+0xb0/0x140
[   82.144218]  ? mutex_lock+0x81/0xe0
[   82.144222]  kasan_check_range+0x3a/0x1d0
[   82.144224]  __kasan_check_write+0x14/0x20
[   82.144226]  mutex_lock+0x81/0xe0
[   82.144229]  ? __mutex_lock_slowpath+0x20/0x20
[   82.144234]  dvb_frontend_release.cold+0x178/0x4d2 [dvb_core]
[   82.144246]  __fput+0x2ce/0xaf0
[   82.144250]  ____fput+0xe/0x20
[   82.144253]  task_work_run+0x153/0x240
[   82.144257]  ? task_work_cancel+0x20/0x20
[   82.144260]  ? fput+0xab/0x140
[   82.144263]  exit_to_user_mode_prepare+0x18f/0x1a0
[   82.144266]  syscall_exit_to_user_mode+0x26/0x50
[   82.144270]  do_syscall_64+0x69/0x90
[   82.144273]  ? debug_smp_processor_id+0x17/0x20
[   82.144275]  ? fpregs_assert_state_consistent+0x52/0xc0
[   82.144279]  ? exit_to_user_mode_prepare+0x49/0x1a0
[   82.144281]  ? irqentry_exit_to_user_mode+0x9/0x20
[   82.144284]  ? irqentry_exit+0x3b/0x50
[   82.144287]  ? sysvec_apic_timer_interrupt+0x57/0xc0
[   82.144290]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
[   82.144293] RIP: 0033:0x4537eb
[   82.144296] Code: 03 00 00 00 0f 05 48 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 c3 a8 02 00 8b 7c 24 0c 41 89 c0 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 35 44 89 c7 89 44 24 0c e8 11 a9 02 00 8b 44
[   82.144298] RSP: 002b:00007fc7600001a0 EFLAGS: 00000293 ORIG_RAX: 0000000000000003
[   82.144302] RAX: 0000000000000000 RBX: 00007fc760000640 RCX: 00000000004537eb
[   82.144304] RDX: 0000000000000000 RSI: 00007fc758000b70 RDI: 0000000000000003
[   82.144306] RBP: 00007fc7600001d0 R08: 0000000000000000 R09: 0000000000000000
[   82.144308] R10: 000000000000000a R11: 0000000000000293 R12: 00007fc760000640
[   82.144310] R13: 0000000000000000 R14: 000000000041b290 R15: 00007fc75f800000
[   82.144313]  </TASK>

[   82.144315] Allocated by task 2225:
[   82.144317]  kasan_save_stack+0x26/0x50
[   82.144320]  kasan_set_track+0x25/0x40
[   82.144322]  kasan_save_alloc_info+0x1e/0x30
[   82.144325]  __kasan_kmalloc+0xb4/0xc0
[   82.144327]  kmalloc_trace+0x4a/0xb0
[   82.144329]  as102_usb_probe.cold+0x58/0x6eb [dvb_as102]
[   82.144335]  usb_probe_interface+0x266/0x740
[   82.144338]  really_probe+0x1fa/0xa80
[   82.144341]  __driver_probe_device+0x2cb/0x490
[   82.144343]  driver_probe_device+0x4e/0x140
[   82.144345]  __driver_attach+0x1a3/0x520
[   82.144347]  bus_for_each_dev+0x11e/0x1c0
[   82.144348]  driver_attach+0x3d/0x60
[   82.144350]  bus_add_driver+0x449/0x5a0
[   82.144352]  driver_register+0x219/0x390
[   82.144354]  usb_register_driver+0x228/0x400
[   82.144356]  0xffffffffc0655023
[   82.144358]  do_one_initcall+0x97/0x310
[   82.144361]  do_init_module+0x19a/0x630
[   82.144363]  load_module+0x6ca4/0x7d90
[   82.144365]  __do_sys_finit_module+0x134/0x1d0
[   82.144367]  __x64_sys_finit_module+0x72/0xb0
[   82.144369]  do_syscall_64+0x59/0x90
[   82.144371]  entry_SYSCALL_64_after_hwframe+0x63/0xcd

[   82.144374] Freed by task 158:
[   82.144376]  kasan_save_stack+0x26/0x50
[   82.144378]  kasan_set_track+0x25/0x40
[   82.144380]  kasan_save_free_info+0x2e/0x50
[   82.144382]  ____kasan_slab_free+0x174/0x1e0
[   82.144384]  __kasan_slab_free+0x12/0x20
[   82.144386]  slab_free_freelist_hook+0xd0/0x1a0
[   82.144388]  __kmem_cache_free+0x193/0x2c0
[   82.144391]  kfree+0x79/0x120
[   82.144393]  as102_usb_release+0x5d/0x75 [dvb_as102]
[   82.144397]  as102_usb_disconnect+0x125/0x176 [dvb_as102]
[   82.144400]  usb_unbind_interface+0x187/0x7c0
[   82.144402]  device_remove+0x117/0x170
[   82.144404]  device_release_driver_internal+0x418/0x660
[   82.144407]  device_release_driver+0x12/0x20
[   82.144409]  bus_remove_device+0x28f/0x540
[   82.144410]  device_del+0x501/0xc30
[   82.144413]  usb_disable_device+0x2a5/0x660
[   82.144415]  usb_disconnect.cold+0x1f9/0x620
[   82.144417]  hub_event+0x16d3/0x3d20
[   82.144420]  process_one_work+0x778/0x11c0
[   82.144422]  worker_thread+0x544/0x1180
[   82.144424]  kthread+0x280/0x320
[   82.144426]  ret_from_fork+0x1f/0x30
```

# 2. media: dvb-core: Fix use-after-free due to race condition occurring in dvb_net
This is a security patch for a race condition that occurs in the dvb_net system of dvb-core.

The race condition that occurs here will occur with _any_ device driver using dvb_net.

The race condition that occurs in dvb_net is:
```
                cpu0                                                          cpu1
       1. .disconnect()
          dvb_net_release()
          dvbnet->exit = 1;
          if (dvbnet->dvbdev->users < 1)  // improper reference counting
                                                                       2. open()
                                                                          dvb_device_open()
                                                                          down_read(&minor_rwsem);
                                                                          dvb_generic_open()
                                                                          dvbdev->users--;	// race condition
                                                                          up_read(&minor_rwsem);
       3. dvb_unregister_device()
          dvb_remove_device()
          down_write(&minor_rwsem);
          dvb_minors[dvbdev->minor] = NULL;
          up_write(&minor_rwsem);
          dvb_free_device()
          kfree (dvbdev->fops);
                                                                       4. close(fd)
                                                                          __x64_sys_close()
                                                                          close_fd()
                                                                          filp_close()
                                                                          retval = filp->f_op->flush(filp, id);    // UAF
```
After the 'if (dvbnet->dvbdev->users < 1)' conditional of dvb_net_release() passes,
'dvbdev->users--;' of dvb_generic_open() is executed, improper reference counting occurs.

The root cause of this is that you use the dvb_device_open() function,
which does not implement a conditional statement that checks 'dvbnet->exit'.

The KASAN log caused by this is as follows:
```
[  952.372616] ==================================================================
[  952.372639] BUG: KASAN: use-after-free in filp_close+0x119/0x140
[  952.372667] Read of size 8 at addr ffff888118abec78 by task dvb_net_test/2522

[  952.372690] CPU: 3 PID: 2522 Comm: dvb_net_test Not tainted 6.1.0-rc2+ #16
[  952.372707] Hardware name: Gigabyte Technology Co., Ltd. B460MDS3H/B460M DS3H, BIOS F3 05/27/2020
[  952.372718] Call Trace:
[  952.372727]  <TASK>
[  952.372736]  dump_stack_lvl+0x49/0x63
[  952.372754]  print_report+0x177/0x46e
[  952.372775]  ? kasan_complete_mode_report_info+0x7c/0x210
[  952.372791]  ? filp_close+0x119/0x140
[  952.372810]  kasan_report+0xb0/0x140
[  952.372830]  ? filp_close+0x119/0x140
[  952.372850]  __asan_report_load8_noabort+0x14/0x20
[  952.372865]  filp_close+0x119/0x140
[  952.372883]  close_fd+0x75/0x90
[  952.372897]  __x64_sys_close+0x30/0x80
[  952.372915]  do_syscall_64+0x59/0x90
[  952.372930]  ? fpregs_assert_state_consistent+0x52/0xc0
[  952.372950]  ? exit_to_user_mode_prepare+0x49/0x1a0
[  952.372965]  ? syscall_exit_to_user_mode+0x26/0x50
[  952.372984]  ? do_syscall_64+0x69/0x90
[  952.373000]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
[  952.373016] RIP: 0033:0x4537eb
[  952.373031] Code: 03 00 00 00 0f 05 48 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 c3 a8 02 00 8b 7c 24 0c 41 89 c0 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 35 44 89 c7 89 44 24 0c e8 11 a9 02 00 8b 44
[  952.373046] RSP: 002b:00007f98078001a0 EFLAGS: 00000293 ORIG_RAX: 0000000000000003
[  952.373066] RAX: ffffffffffffffda RBX: 00007f9807800640 RCX: 00000000004537eb
[  952.373078] RDX: 0000000000000000 RSI: 00007f9800000b70 RDI: 0000000000000003
[  952.373089] RBP: 00007f98078001d0 R08: 0000000000000000 R09: 0000000000000000
[  952.373100] R10: 00007f9807800180 R11: 0000000000000293 R12: 00007f9807800640
[  952.373111] R13: 0000000000000000 R14: 000000000041b290 R15: 00007f9807000000
[  952.373130]  </TASK>

[  952.373145] Allocated by task 592:
[  952.373155]  kasan_save_stack+0x26/0x50
[  952.373171]  kasan_set_track+0x25/0x40
[  952.373185]  kasan_save_alloc_info+0x1e/0x30
[  952.373195]  __kasan_kmalloc+0xb4/0xc0
[  952.373212]  __kmalloc_node_track_caller+0x66/0x160
[  952.373233]  kmemdup+0x23/0x50
[  952.373250]  dvb_register_device+0x1cd/0x15c0 [dvb_core]
[  952.373301]  dvb_net_init+0xc7/0x100 [dvb_core]
[  952.373348]  ttusb_dec_probe.cold+0x14de/0x1f1e [ttusb_dec]
[  952.373373]  usb_probe_interface+0x266/0x740
[  952.373388]  really_probe+0x1fa/0xa80
[  952.373400]  __driver_probe_device+0x2cb/0x490
[  952.373412]  driver_probe_device+0x4e/0x140
[  952.373424]  __device_attach_driver+0x197/0x2b0
[  952.373437]  bus_for_each_drv+0x129/0x1c0
[  952.373447]  __device_attach+0x2ad/0x4f0
[  952.373459]  device_initial_probe+0x13/0x20
[  952.373470]  bus_probe_device+0x198/0x240
[  952.373481]  device_add+0xa1b/0x1cc0
[  952.373491]  usb_set_configuration+0x9ca/0x17f0
[  952.373502]  usb_generic_driver_probe+0x86/0xb0
[  952.373513]  usb_probe_device+0xa7/0x260
[  952.373524]  really_probe+0x1fa/0xa80
[  952.373535]  __driver_probe_device+0x2cb/0x490
[  952.373547]  driver_probe_device+0x4e/0x140
[  952.373558]  __device_attach_driver+0x197/0x2b0
[  952.373570]  bus_for_each_drv+0x129/0x1c0
[  952.373580]  __device_attach+0x2ad/0x4f0
[  952.373591]  device_initial_probe+0x13/0x20
[  952.373603]  bus_probe_device+0x198/0x240
[  952.373614]  device_add+0xa1b/0x1cc0
[  952.373623]  usb_new_device.cold+0x462/0xc46
[  952.373637]  hub_event+0x1d23/0x3d20
[  952.373652]  process_one_work+0x778/0x11c0
[  952.373664]  worker_thread+0x544/0x1180
[  952.373676]  kthread+0x280/0x320
[  952.373686]  ret_from_fork+0x1f/0x30

[  952.373707] Freed by task 592:
[  952.373717]  kasan_save_stack+0x26/0x50
[  952.373731]  kasan_set_track+0x25/0x40
[  952.373744]  kasan_save_free_info+0x2e/0x50
[  952.373754]  ____kasan_slab_free+0x174/0x1e0
[  952.373767]  __kasan_slab_free+0x12/0x20
[  952.373780]  slab_free_freelist_hook+0xd0/0x1a0
[  952.373793]  __kmem_cache_free+0x193/0x2c0
[  952.373805]  kfree+0x79/0x120
[  952.373817]  dvb_free_device.part.0+0x33/0x70 [dvb_core]
[  952.373858]  dvb_unregister_device+0x40/0x54 [dvb_core]
[  952.373905]  dvb_net_release+0x264/0x316 [dvb_core]
[  952.373952]  ttusb_dec_disconnect+0x391/0x4e1 [ttusb_dec]
[  952.373973]  usb_unbind_interface+0x187/0x7c0
[  952.373986]  device_remove+0x117/0x170
[  952.373997]  device_release_driver_internal+0x418/0x660
[  952.374010]  device_release_driver+0x12/0x20
[  952.374022]  bus_remove_device+0x28f/0x540
[  952.374032]  device_del+0x501/0xc30
[  952.374047]  usb_disable_device+0x2a5/0x660
[  952.374058]  usb_disconnect.cold+0x1f9/0x620
[  952.374070]  hub_event+0x16d3/0x3d20
[  952.374084]  process_one_work+0x778/0x11c0
[  952.374096]  worker_thread+0x544/0x1180
[  952.374107]  kthread+0x280/0x320
[  952.374117]  ret_from_fork+0x1f/0x30
```

# 3. media: dvb-core: Fix use-after-free due to race condition occurring in dvb_register_device()
This is a security patch for a race condition that occurs in the dvb_register_device() function.

This race condition can occur _anywhere_ the dvb_register_device() function is called:
dvb_demux, dvb_dvr, dvb_frontend, dvb_net, etc.

The race condition flow is as follows (dvb_net is used as an example):
``````
                cpu0                                                cpu1
       1. open()
          dvb_device_open()

       2. close()
          __fput()
          dvb_net_close()
                                                             3. .disconnect()
                                                                dvb_net_release()
                                                                dvb_unregister_device()
                                                                dvb_free_device()
                                                                kfree (dvbdev->fops);
       4. ...
          fops_put(file->f_op);    // UAF!!
```
UAF occurs in '.probe -> open() -> close() -> .disconnect' flow.

The root cause of this is that fops used as an argument of replace_fops() in dvb_device_open()
are kfree()d in the .disconnect flow.
It's not common for fops used in replace_fops() to be dynamically allocated and kfree()d like this.

The KASAN log caused by this is as follows:
```
[   67.857811] ==================================================================
[   67.857830] BUG: KASAN: use-after-free in __fput+0xa55/0xaf0
[   67.857855] Read of size 8 at addr ffff88810f7dfc00 by task dvb_net_fput/2152

[   67.857879] CPU: 15 PID: 2152 Comm: dvb_net_fput Not tainted 6.1.0-rc2+ #17
[   67.857896] Hardware name: Gigabyte Technology Co., Ltd. B460MDS3H/B460M DS3H, BIOS F3 05/27/2020
[   67.857907] Call Trace:
[   67.857917]  <TASK>
[   67.857928]  dump_stack_lvl+0x49/0x63
[   67.857947]  print_report+0x177/0x46e
[   67.857967]  ? kasan_complete_mode_report_info+0x7c/0x210
[   67.857984]  ? __fput+0xa55/0xaf0
[   67.858001]  kasan_report+0xb0/0x140
[   67.858021]  ? __fput+0xa55/0xaf0
[   67.858039]  __asan_report_load8_noabort+0x14/0x20
[   67.858053]  __fput+0xa55/0xaf0
[   67.858072]  ____fput+0xe/0x20
[   67.858087]  task_work_run+0x153/0x240
[   67.858108]  ? task_work_cancel+0x20/0x20
[   67.858127]  ? fput+0xab/0x140
[   67.858144]  exit_to_user_mode_prepare+0x18f/0x1a0
[   67.858160]  syscall_exit_to_user_mode+0x26/0x50
[   67.858179]  do_syscall_64+0x69/0x90
[   67.858194]  ? exit_to_user_mode_prepare+0x49/0x1a0
[   67.858208]  ? irqentry_exit_to_user_mode+0x9/0x20
[   67.858226]  ? irqentry_exit+0x3b/0x50
[   67.858243]  ? exc_page_fault+0x72/0xf0
[   67.858262]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
[   67.858278] RIP: 0033:0x4537eb
[   67.858294] Code: 03 00 00 00 0f 05 48 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 c3 a8 02 00 8b 7c 24 0c 41 89 c0 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 35 44 89 c7 89 44 24 0c e8 11 a9 02 00 8b 44
[   67.858309] RSP: 002b:00007f607be001a0 EFLAGS: 00000293 ORIG_RAX: 0000000000000003
[   67.858330] RAX: 0000000000000000 RBX: 00007f607be00640 RCX: 00000000004537eb
[   67.858343] RDX: 0000000000000000 RSI: 00007f6074000b70 RDI: 0000000000000003
[   67.858353] RBP: 00007f607be001d0 R08: 0000000000000000 R09: 0000000000000000
[   67.858364] R10: 00007f607be00180 R11: 0000000000000293 R12: 00007f607be00640
[   67.858375] R13: 0000000000000000 R14: 000000000041b2a0 R15: 00007f607b600000
[   67.858392]  </TASK>

[   67.858407] Allocated by task 2125:
[   67.858417]  kasan_save_stack+0x26/0x50
[   67.858433]  kasan_set_track+0x25/0x40
[   67.858447]  kasan_save_alloc_info+0x1e/0x30
[   67.858456]  __kasan_kmalloc+0xb4/0xc0
[   67.858469]  __kmalloc_node_track_caller+0x66/0x160
[   67.858483]  kmemdup+0x23/0x50
[   67.858495]  dvb_register_device+0x1cd/0x15c0 [dvb_core]
[   67.858543]  dvb_net_init+0xe1/0x120 [dvb_core]
[   67.858591]  ttusb_dec_probe.cold+0x14de/0x1f1e [ttusb_dec]
[   67.858615]  usb_probe_interface+0x266/0x740
[   67.858629]  really_probe+0x1fa/0xa80
[   67.858642]  __driver_probe_device+0x2cb/0x490
[   67.858654]  driver_probe_device+0x4e/0x140
[   67.858666]  __driver_attach+0x1a3/0x520
[   67.858677]  bus_for_each_dev+0x11e/0x1c0
[   67.858688]  driver_attach+0x3d/0x60
[   67.858699]  bus_add_driver+0x449/0x5a0
[   67.858710]  driver_register+0x219/0x390
[   67.858722]  usb_register_driver+0x228/0x400
[   67.858733]  0xffffffffc0506023
[   67.858744]  do_one_initcall+0x97/0x310
[   67.858758]  do_init_module+0x19a/0x630
[   67.858770]  load_module+0x6ca4/0x7d90
[   67.858781]  __do_sys_finit_module+0x134/0x1d0
[   67.858792]  __x64_sys_finit_module+0x72/0xb0
[   67.858803]  do_syscall_64+0x59/0x90
[   67.858815]  entry_SYSCALL_64_after_hwframe+0x63/0xcd

[   67.858834] Freed by task 666:
[   67.858843]  kasan_save_stack+0x26/0x50
[   67.858857]  kasan_set_track+0x25/0x40
[   67.858870]  kasan_save_free_info+0x2e/0x50
[   67.858880]  ____kasan_slab_free+0x174/0x1e0
[   67.858893]  __kasan_slab_free+0x12/0x20
[   67.858907]  slab_free_freelist_hook+0xd0/0x1a0
[   67.858919]  __kmem_cache_free+0x193/0x2c0
[   67.858932]  kfree+0x79/0x120
[   67.858944]  dvb_free_device.part.0+0x33/0x70 [dvb_core]
[   67.858984]  dvb_unregister_device+0x40/0x54 [dvb_core]
[   67.859032]  dvb_net_release+0x267/0x319 [dvb_core]
[   67.859080]  ttusb_dec_disconnect+0x391/0x4e1 [ttusb_dec]
[   67.859102]  usb_unbind_interface+0x187/0x7c0
[   67.859115]  device_remove+0x117/0x170
[   67.859126]  device_release_driver_internal+0x418/0x660
[   67.859139]  device_release_driver+0x12/0x20
[   67.859150]  bus_remove_device+0x28f/0x540
[   67.859161]  device_del+0x501/0xc30
[   67.859176]  usb_disable_device+0x2a5/0x660
[   67.859187]  usb_disconnect.cold+0x1f9/0x620
[   67.859200]  hub_event+0x16d3/0x3d20
[   67.859215]  process_one_work+0x778/0x11c0
[   67.859228]  worker_thread+0x544/0x1180
[   67.859239]  kthread+0x280/0x320
[   67.859249]  ret_from_fork+0x1f/0x30
```

# 4. media: ttusb-dec: Fix memory leak in ttusb_dec_exit_dvb()
This is a patch for a memory leak that occurs in the ttusb_dec_exit_dvb() function.

Because ttusb_dec_exit_dvb() does not call dvb_frontend_detach(),
several fe related structures are not kfree()d.

Users can trigger a memory leak just by repeating connecting and disconnecting
the ttusb_dec device.

Finally, most of these patches are similar to this one, the security patch for
CVE-2022-41218 that I reported:
[https://lore.kernel.org/linux-media/20221031100245.23702-1-tiwai@suse.de/](https://lore.kernel.org/linux-media/20221031100245.23702-1-tiwai%40suse.de/)

Regards,
Hyunwoo Kim

Hyunwoo Kim (4):
  media: dvb-core: Fix use-after-free due to race condition occurring in
    dvb_frontend
  media: dvb-core: Fix use-after-free due to race condition occurring in
    dvb_net
  media: dvb-core: Fix use-after-free due to race condition occurring in
    dvb_register_device()
  media: ttusb-dec: Fix memory leak in ttusb_dec_exit_dvb()

 drivers/media/dvb-core/dvb_frontend.c   | 39 ++++++++++--
 drivers/media/dvb-core/dvb_net.c        | 37 ++++++++++-
 drivers/media/dvb-core/dvbdev.c         | 83 ++++++++++++++++++-------
 drivers/media/usb/ttusb-dec/ttusb_dec.c |  3 +-
 include/media/dvb_frontend.h            |  6 +-
 include/media/dvb_net.h                 |  4 ++
 include/media/dvbdev.h                  | 15 +++++
 7 files changed, 155 insertions(+), 32 deletions(-)

--
2.25.1

```

---

```
[next](../20221115131822.6640-2-imv4bel%40gmail.com/)             [reply](#R)other threads:[[~2022-11-15 13:19 UTC](../?t=20221115131937)|[newest](../)]

Thread overview: 6+ messages / expand[[flat](T/#u)|[nested](t/#u)]  [mbox.gz](t.mbox.gz)  [Atom feed](t.atom)  [top](#b)
2022-11-15 13:18 [imv4bel [this message]](#t)
2022-11-15 13:18 ` [[PATCH 1/4] media: dvb-core: Fix use-after-free due to race condition occurring in dvb_frontend](../20221115131822.6640-2-imv4bel%40gmail.com/) imv4bel
2022-11-15 13:18 ` [[PATCH 2/4] media: dvb-core: Fix use-after-free due to race condition occurring in dvb_net](../20221115131822.6640-3-imv4bel%40gmail.com/) imv4bel
2022-11-15 13:18 ` [[PATCH 3/4] media: dvb-core: Fix use-after-free due to race condition occurring in dvb_register_device()](../20221115131822.6640-4-imv4bel%40gmail.com/) imv4bel
2022-11-17  4:16   ` [Dan Carpenter](../202211161100.BsMHAcor-lkp%40intel.com/)
2022-11-15 13:18 ` [[PATCH 4/4] media: ttusb-dec: Fix memory leak in ttusb_dec_exit_dvb()](../20221115131822.6640-5-imv4bel%40gmail.com/) imv4bel

```

---

```
Reply instructions:

You may reply publicly to [this message](#t) via plain-text email
using any one of the following methods:

* Save the following mbox file, import it into your mail client,
  and reply-to-all from there: [mbox](raw)

  Avoid top-posting and favor interleaved quoting:
  <https://en.wikipedia.org/wiki/Posting_style#Interleaved_style>

* Reply using the --to, --cc, and --in-reply-to
  switches of git-send-email(1):

  git send-email \
    --in-reply-to=20221115131822.6640-1-imv4bel@gmail.com \
    --to=imv4bel@gmail.com \
    --cc=cai.huoqing@linux.dev \
    --cc=kernel@tuxforce.de \
    --cc=linux-media@vger.kernel.org \
    --cc=linux-usb@vger.kernel.org \
    --cc=mchehab@kernel.org \
    --cc=tiwai@suse.de \
    /path/to/YOUR_REPLY

  <https://kernel.org/pub/software/scm/git/docs/git-send-email.html>

* If your mail client supports setting the In-Reply-To header
  via mailto: links, try the mailto: link

```
Be sure your reply has a **Subject:** header at the top and a blank line
before the message body.

---

```
This is a public inbox, see [mirroring instructions](../_/text/mirror/)
for how to clone and mirror all data and code used for this inbox;
as well as URLs for NNTP newsgroup(s).
```


=== Content from lore.kernel.org_27d83476_20250114_200006.html ===

```
[linux-media.vger.kernel.org archive mirror](../?t=20221115131943)
 [help](../_/text/help/) / [color](../_/text/color/) / [mirror](../_/text/mirror/) / [Atom feed](../new.atom)
```
```
From: imv4bel@gmail.com
To: mchehab@kernel.org
Cc: Hyunwoo Kim <imv4bel@gmail.com>,
	kernel@tuxforce.de, [linux-media@vger.kernel.org](../../linux-media/?t=20221115131943),
	[linux-usb@vger.kernel.org](../../linux-usb/?t=20221115131943), cai.huoqing@linux.dev, tiwai@suse.de
Subject: [[PATCH 3/4] media: dvb-core: Fix use-after-free due to race condition occurring in dvb_register_device()](#r)
Date: Tue, 15 Nov 2022 05:18:21 -0800	[[thread overview]](#r)
Message-ID: <20221115131822.6640-4-imv4bel@gmail.com> (<raw>)
In-Reply-To: <[20221115131822.6640-1-imv4bel@gmail.com](../20221115131822.6640-1-imv4bel%40gmail.com/)>

From: Hyunwoo Kim <imv4bel@gmail.com>

dvb_register_device() dynamically allocates fops with kmemdup()
to set the fops->owner.
And these fops are registered in 'file->f_ops' using replace_fops()
in the dvb_device_open() process, and kfree()d in dvb_free_device().

However, it is not common to use dynamically allocated fops instead
of 'static const' fops as an argument of replace_fops(),
and UAF may occur.
These UAFs can occur on any dvb type using dvb_register_device(),
such as dvb_dvr, dvb_demux, dvb_frontend, dvb_net, etc.

So, instead of kfree() the fops dynamically allocated in
dvb_register_device() in dvb_free_device() called during the
.disconnect() process, kfree() it collectively in exit_dvbdev()
called when the dvbdev.c module is removed.

Signed-off-by: Hyunwoo Kim <imv4bel@gmail.com>
---
 [drivers/media/dvb-core/dvbdev.c](#Z31drivers:media:dvb-core:dvbdev.c) | 83 ++++++++++++++++++++++++---------
 [include/media/dvbdev.h](#Z31include:media:dvbdev.h)          | 15 ++++++
 2 files [changed](#related), 77 insertions(+), 21 deletions(-)

[diff](#iZ31drivers:media:dvb-core:dvbdev.c) --git a/drivers/media/dvb-core/dvbdev.c b/drivers/media/dvb-core/dvbdev.c
index 675d877a67b2..424cf92c068e 100644
--- a/drivers/media/dvb-core/dvbdev.c
+++ b/drivers/media/dvb-core/dvbdev.c
@@ -27,6 +27,7 @@
 #include <media/tuner.h>

 static DEFINE_MUTEX(dvbdev_mutex);
+static LIST_HEAD(dvbdevfops_list);
 static int dvbdev_debug;

 module_param(dvbdev_debug, int, 0644);
@@ -448,14 +449,15 @@ int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
 			enum dvb_device_type type, int demux_sink_pads)
 {
 	struct dvb_device *dvbdev;
-	struct file_operations *dvbdevfops;
+	struct file_operations *dvbdevfops = NULL;
+	struct dvbdevfops_node *node, *new_node;
 	struct device *clsdev;
 	int minor;
 	int id, ret;

 	mutex_lock(&dvbdev_register_lock);

-	if ((id = dvbdev_get_free_id (adap, type)) < 0){
+	if ((id = dvbdev_get_free_id (adap, type)) < 0) {
 		mutex_unlock(&dvbdev_register_lock);
 		*pdvbdev = NULL;
 		pr_err("%s: couldn't find free device id\n", __func__);
@@ -463,18 +465,45 @@ int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
 	}

 	*pdvbdev = dvbdev = kzalloc(sizeof(*dvbdev), GFP_KERNEL);
-
 	if (!dvbdev){
 		mutex_unlock(&dvbdev_register_lock);
 		return -ENOMEM;
 	}

-	dvbdevfops = kmemdup(template->fops, sizeof(*dvbdevfops), GFP_KERNEL);
+	/*
+	 * When a device of the same type is probe()d more than once,
+	 * the first allocated fops are used. This prevents memory leaks
+	 * that can occur when the same device is probe()d repeatedly.
+	 */
+	list_for_each_entry(node, &dvbdevfops_list, list_head) {
+		if (node->fops->owner == adap->module &&
+				node->type == type &&
+				node->template == template) {
+			dvbdevfops = node->fops;
+			break;
+		}
+	}

-	if (!dvbdevfops){
-		kfree (dvbdev);
-		mutex_unlock(&dvbdev_register_lock);
-		return -ENOMEM;
+	if (dvbdevfops == NULL) {
+		dvbdevfops = kmemdup(template->fops, sizeof(*dvbdevfops), GFP_KERNEL);
+		if (!dvbdevfops) {
+			kfree(dvbdev);
+			mutex_unlock(&dvbdev_register_lock);
+			return -ENOMEM;
+		}
+
+		new_node = kzalloc(sizeof(struct dvbdevfops_node), GFP_KERNEL);
+		if (!new_node) {
+			kfree(dvbdevfops);
+			kfree(dvbdev);
+			mutex_unlock(&dvbdev_register_lock);
+			return -ENOMEM;
+		}
+
+		new_node->fops = dvbdevfops;
+		new_node->type = type;
+		new_node->template = template;
+		list_add_tail (&new_node->list_head, &dvbdevfops_list);
 	}

 	memcpy(dvbdev, template, sizeof(struct dvb_device));
@@ -484,20 +513,20 @@ int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
 	dvbdev->priv = priv;
 	dvbdev->fops = dvbdevfops;
 	init_waitqueue_head (&dvbdev->wait_queue);
-
 	dvbdevfops->owner = adap->module;
-
 	list_add_tail (&dvbdev->list_head, &adap->device_list);
-
 	down_write(&minor_rwsem);
 #ifdef CONFIG_DVB_DYNAMIC_MINORS
 	for (minor = 0; minor < MAX_DVB_MINORS; minor++)
 		if (dvb_minors[minor] == NULL)
 			break;
-
 	if (minor == MAX_DVB_MINORS) {
+		if (new_node) {
+			list_del (&new_node->list_head);
+			kfree(dvbdevfops);
+			kfree(new_node);
+		}
 		list_del (&dvbdev->list_head);
-		kfree(dvbdevfops);
 		kfree(dvbdev);
 		up_write(&minor_rwsem);
 		mutex_unlock(&dvbdev_register_lock);
@@ -506,41 +535,46 @@ int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
 #else
 	minor = nums2minor(adap->num, type, id);
 #endif
-
 	dvbdev->minor = minor;
 	dvb_minors[minor] = dvbdev;
 	up_write(&minor_rwsem);
-
 	ret = dvb_register_media_device(dvbdev, type, minor, demux_sink_pads);
 	if (ret) {
 		pr_err("%s: dvb_register_media_device failed to create the mediagraph\n",
 		      __func__);
-
+		if (new_node) {
+			list_del (&new_node->list_head);
+			kfree(dvbdevfops);
+			kfree(new_node);
+		}
 		dvb_media_device_free(dvbdev);
 		list_del (&dvbdev->list_head);
-		kfree(dvbdevfops);
 		kfree(dvbdev);
 		mutex_unlock(&dvbdev_register_lock);
 		return ret;
 	}

-	mutex_unlock(&dvbdev_register_lock);
-
 	clsdev = device_create(dvb_class, adap->device,
 			       MKDEV(DVB_MAJOR, minor),
 			       dvbdev, "dvb%d.%s%d", adap->num, dnames[type], id);
 	if (IS_ERR(clsdev)) {
 		pr_err("%s: failed to create device dvb%d.%s%d (%ld)\n",
 		       __func__, adap->num, dnames[type], id, PTR_ERR(clsdev));
+		if (new_node) {
+			list_del (&new_node->list_head);
+			kfree(dvbdevfops);
+			kfree(new_node);
+		}
 		dvb_media_device_free(dvbdev);
 		list_del (&dvbdev->list_head);
-		kfree(dvbdevfops);
 		kfree(dvbdev);
 		return PTR_ERR(clsdev);
 	}
+
 	dprintk("DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n",
 		adap->num, dnames[type], id, minor, minor);

+	mutex_unlock(&dvbdev_register_lock);
 	return 0;
 }
 EXPORT_SYMBOL(dvb_register_device);
@@ -569,7 +603,6 @@ void dvb_free_device(struct dvb_device *dvbdev)
 	if (!dvbdev)
 		return;

-	kfree (dvbdev->fops);
 	kfree (dvbdev);
 }
 EXPORT_SYMBOL(dvb_free_device);
@@ -1061,9 +1094,17 @@ static int __init init_dvbdev(void)

 static void __exit exit_dvbdev(void)
 {
+	struct dvbdevfops_node *node, *next;
+
 	class_destroy(dvb_class);
 	cdev_del(&dvb_device_cdev);
 	unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
+
+	list_for_each_entry_safe(node, next, &dvbdevfops_list, list_head) {
+		list_del (&node->list_head);
+		kfree(node->fops);
+		kfree(node);
+	}
 }

 subsys_initcall(init_dvbdev);
[diff](#iZ31include:media:dvbdev.h) --git a/include/media/dvbdev.h b/include/media/dvbdev.h
index 2f6b0861322a..1e5413303705 100644
--- a/include/media/dvbdev.h
+++ b/include/media/dvbdev.h
@@ -187,6 +187,21 @@ struct dvb_device {
 	void *priv;
 };

+/**
+ * struct dvbdevfops_node - fops nodes registered in dvbdevfops_list
+ *
+ * @fops:		Dynamically allocated fops for ->owner registration
+ * @type:		type of dvb_device
+ * @template:		dvb_device used for registration
+ * @list_head:		list_head for dvbdevfops_list
+ */
+struct dvbdevfops_node {
+	struct file_operations *fops;
+	enum dvb_device_type type;
+	const struct dvb_device *template;
+	struct list_head list_head;
+};
+
 /**
  * dvb_register_adapter - Registers a new DVB adapter
  *
--
2.25.1

```

---

```
[next](../202211161100.BsMHAcor-lkp%40intel.com/) [prev](../20221115131822.6640-3-imv4bel%40gmail.com/) [parent](../20221115131822.6640-1-imv4bel%40gmail.com/) [reply](#R)	other threads:[[~2022-11-15 13:19 UTC](../?t=20221115131943)|[newest](../)]

Thread overview: 6+ messages / expand[[flat](T/#u)|[nested](t/#u)]  [mbox.gz](t.mbox.gz)  [Atom feed](t.atom)  [top](#b)
2022-11-15 13:18 [[PATCH 0/4] Fix multiple race condition vulnerabilities in dvb-core and device driver](../20221115131822.6640-1-imv4bel%40gmail.com/) imv4bel
2022-11-15 13:18 ` [[PATCH 1/4] media: dvb-core: Fix use-after-free due to race condition occurring in dvb_frontend](../20221115131822.6640-2-imv4bel%40gmail.com/) imv4bel
2022-11-15 13:18 ` [[PATCH 2/4] media: dvb-core: Fix use-after-free due to race condition occurring in dvb_net](../20221115131822.6640-3-imv4bel%40gmail.com/) imv4bel
2022-11-15 13:18 ` [imv4bel [this message]](#t)
2022-11-17  4:16   ` [[PATCH 3/4] media: dvb-core: Fix use-after-free due to race condition occurring in dvb_register_device()](../202211161100.BsMHAcor-lkp%40intel.com/) Dan Carpenter
2022-11-15 13:18 ` [[PATCH 4/4] media: ttusb-dec: Fix memory leak in ttusb_dec_exit_dvb()](../20221115131822.6640-5-imv4bel%40gmail.com/) imv4bel

```
```
find likely ancestor, descendant, or conflicting patches for [this message](#t):
( dfblob:675d877a67b dfblob:424cf92c068 dfblob:2f6b0861322
dfblob:1e541330370 )
 OR (
bs:"[PATCH 3/4] media: dvb-core: Fix use-after-free due to race condition occurring in dvb_register_device()" )
	([help](../_/text/help/#search))
```

---

```
Reply instructions:

You may reply publicly to [this message](#t) via plain-text email
using any one of the following methods:

* Save the following mbox file, import it into your mail client,
  and reply-to-all from there: [mbox](raw)

  Avoid top-posting and favor interleaved quoting:
  <https://en.wikipedia.org/wiki/Posting_style#Interleaved_style>

* Reply using the --to, --cc, and --in-reply-to
  switches of git-send-email(1):

  git send-email \
    --in-reply-to=20221115131822.6640-4-imv4bel@gmail.com \
    --to=imv4bel@gmail.com \
    --cc=cai.huoqing@linux.dev \
    --cc=kernel@tuxforce.de \
    --cc=linux-media@vger.kernel.org \
    --cc=linux-usb@vger.kernel.org \
    --cc=mchehab@kernel.org \
    --cc=tiwai@suse.de \
    /path/to/YOUR_REPLY

  <https://kernel.org/pub/software/scm/git/docs/git-send-email.html>

* If your mail client supports setting the In-Reply-To header
  via mailto: links, try the mailto: link

```
Be sure your reply has a **Subject:** header at the top and a blank line
before the message body.

---

```
This is a public inbox, see [mirroring instructions](../_/text/mirror/)
for how to clone and mirror all data and code used for this inbox;
as well as URLs for NNTP newsgroup(s).
```


=== Content from git.kernel.org_c128ebbe_20250114_200003.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=627bb528b086b4136315c25d6a447a98ea9448d3)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=627bb528b086b4136315c25d6a447a98ea9448d3)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=627bb528b086b4136315c25d6a447a98ea9448d3)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=627bb528b086b4136315c25d6a447a98ea9448d3)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Hyunwoo Kim <imv4bel@gmail.com> | 2022-11-17 04:59:24 +0000 |
| --- | --- | --- |
| committer | Mauro Carvalho Chehab <mchehab@kernel.org> | 2023-05-14 06:30:58 +0100 |
| commit | [627bb528b086b4136315c25d6a447a98ea9448d3](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=627bb528b086b4136315c25d6a447a98ea9448d3) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=627bb528b086b4136315c25d6a447a98ea9448d3)) | |
| tree | [47b999d037e43720c4cf1bfed135c88f118e393f](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=627bb528b086b4136315c25d6a447a98ea9448d3) | |
| parent | [4172385b0c9ac366dcab78eda48c26814b87ed1a](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4172385b0c9ac366dcab78eda48c26814b87ed1a) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=627bb528b086b4136315c25d6a447a98ea9448d3&id2=4172385b0c9ac366dcab78eda48c26814b87ed1a)) | |
| download | [linux-627bb528b086b4136315c25d6a447a98ea9448d3.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-627bb528b086b4136315c25d6a447a98ea9448d3.tar.gz) | |

media: dvb-core: Fix use-after-free due to race at dvb\_register\_device()dvb\_register\_device() dynamically allocates fops with kmemdup()
to set the fops->owner.
And these fops are registered in 'file->f\_ops' using replace\_fops()
in the dvb\_device\_open() process, and kfree()d in dvb\_free\_device().
However, it is not common to use dynamically allocated fops instead
of 'static const' fops as an argument of replace\_fops(),
and UAF may occur.
These UAFs can occur on any dvb type using dvb\_register\_device(),
such as dvb\_dvr, dvb\_demux, dvb\_frontend, dvb\_net, etc.
So, instead of kfree() the fops dynamically allocated in
dvb\_register\_device() in dvb\_free\_device() called during the
.disconnect() process, kfree() it collectively in exit\_dvbdev()
called when the dvbdev.c module is removed.
Link: [https://lore.kernel.org/linux-media/20221117045925.14297-4-imv4bel@gmail.com](https://lore.kernel.org/linux-media/20221117045925.14297-4-imv4bel%40gmail.com)
Signed-off-by: Hyunwoo Kim <imv4bel@gmail.com>
Reported-by: kernel test robot <lkp@intel.com>
Reported-by: Dan Carpenter <error27@gmail.com>
Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=627bb528b086b4136315c25d6a447a98ea9448d3)

| -rw-r--r-- | [drivers/media/dvb-core/dvbdev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/media/dvb-core/dvbdev.c?id=627bb528b086b4136315c25d6a447a98ea9448d3) | 84 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [include/media/dvbdev.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/media/dvbdev.h?id=627bb528b086b4136315c25d6a447a98ea9448d3) | 15 | |  |  |  | | --- | --- | --- | |

2 files changed, 78 insertions, 21 deletions

| diff --git a/drivers/media/dvb-core/dvbdev.c b/drivers/media/dvb-core/dvbdev.cindex e9b3ce09e534c1..a4b05e366cccde 100644--- a/[drivers/media/dvb-core/dvbdev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/media/dvb-core/dvbdev.c?id=4172385b0c9ac366dcab78eda48c26814b87ed1a)+++ b/[drivers/media/dvb-core/dvbdev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/media/dvb-core/dvbdev.c?id=627bb528b086b4136315c25d6a447a98ea9448d3)@@ -27,6 +27,7 @@ #include <media/tuner.h>  static DEFINE\_MUTEX(dvbdev\_mutex);+static LIST\_HEAD(dvbdevfops\_list); static int dvbdev\_debug;  module\_param(dvbdev\_debug, int, 0644);@@ -453,14 +454,15 @@ int dvb\_register\_device(struct dvb\_adapter \*adap, struct dvb\_device \*\*pdvbdev, enum dvb\_device\_type type, int demux\_sink\_pads) { struct dvb\_device \*dvbdev;- struct file\_operations \*dvbdevfops;+ struct file\_operations \*dvbdevfops = NULL;+ struct dvbdevfops\_node \*node = NULL, \*new\_node = NULL; struct device \*clsdev; int minor; int id, ret;  mutex\_lock(&dvbdev\_register\_lock); - if ((id = dvbdev\_get\_free\_id (adap, type)) < 0){+ if ((id = dvbdev\_get\_free\_id (adap, type)) < 0) { mutex\_unlock(&dvbdev\_register\_lock); \*pdvbdev = NULL; pr\_err("%s: couldn't find free device id\n", \_\_func\_\_);@@ -468,18 +470,45 @@ int dvb\_register\_device(struct dvb\_adapter \*adap, struct dvb\_device \*\*pdvbdev, }  \*pdvbdev = dvbdev = kzalloc(sizeof(\*dvbdev), GFP\_KERNEL);- if (!dvbdev){ mutex\_unlock(&dvbdev\_register\_lock); return -ENOMEM; } - dvbdevfops = kmemdup(template->fops, sizeof(\*dvbdevfops), GFP\_KERNEL);+ /\*+ \* When a device of the same type is probe()d more than once,+ \* the first allocated fops are used. This prevents memory leaks+ \* that can occur when the same device is probe()d repeatedly.+ \*/+ list\_for\_each\_entry(node, &dvbdevfops\_list, list\_head) {+ if (node->fops->owner == adap->module &&+ node->type == type &&+ node->template == template) {+ dvbdevfops = node->fops;+ break;+ }+ } - if (!dvbdevfops){- kfree (dvbdev);- mutex\_unlock(&dvbdev\_register\_lock);- return -ENOMEM;+ if (dvbdevfops == NULL) {+ dvbdevfops = kmemdup(template->fops, sizeof(\*dvbdevfops), GFP\_KERNEL);+ if (!dvbdevfops) {+ kfree(dvbdev);+ mutex\_unlock(&dvbdev\_register\_lock);+ return -ENOMEM;+ }++ new\_node = kzalloc(sizeof(struct dvbdevfops\_node), GFP\_KERNEL);+ if (!new\_node) {+ kfree(dvbdevfops);+ kfree(dvbdev);+ mutex\_unlock(&dvbdev\_register\_lock);+ return -ENOMEM;+ }++ new\_node->fops = dvbdevfops;+ new\_node->type = type;+ new\_node->template = template;+ list\_add\_tail (&new\_node->list\_head, &dvbdevfops\_list); }  memcpy(dvbdev, template, sizeof(struct dvb\_device));@@ -490,20 +519,20 @@ int dvb\_register\_device(struct dvb\_adapter \*adap, struct dvb\_device \*\*pdvbdev, dvbdev->priv = priv; dvbdev->fops = dvbdevfops; init\_waitqueue\_head (&dvbdev->wait\_queue);- dvbdevfops->owner = adap->module;- list\_add\_tail (&dvbdev->list\_head, &adap->device\_list);- down\_write(&minor\_rwsem); #ifdef CONFIG\_DVB\_DYNAMIC\_MINORS for (minor = 0; minor < MAX\_DVB\_MINORS; minor++) if (dvb\_minors[minor] == NULL) break;- if (minor == MAX\_DVB\_MINORS) {+ if (new\_node) {+ list\_del (&new\_node->list\_head);+ kfree(dvbdevfops);+ kfree(new\_node);+ } list\_del (&dvbdev->list\_head);- kfree(dvbdevfops); kfree(dvbdev); up\_write(&minor\_rwsem); mutex\_unlock(&dvbdev\_register\_lock);@@ -512,41 +541,47 @@ int dvb\_register\_device(struct dvb\_adapter \*adap, struct dvb\_device \*\*pdvbdev, #else minor = nums2minor(adap->num, type, id); #endif- dvbdev->minor = minor; dvb\_minors[minor] = dvb\_device\_get(dvbdev); up\_write(&minor\_rwsem);- ret = dvb\_register\_media\_device(dvbdev, type, minor, demux\_sink\_pads); if (ret) { pr\_err("%s: dvb\_register\_media\_device failed to create the mediagraph\n", \_\_func\_\_);-+ if (new\_node) {+ list\_del (&new\_node->list\_head);+ kfree(dvbdevfops);+ kfree(new\_node);+ } dvb\_media\_device\_free(dvbdev); list\_del (&dvbdev->list\_head);- kfree(dvbdevfops); kfree(dvbdev); mutex\_unlock(&dvbdev\_register\_lock); return ret; } - mutex\_unlock(&dvbdev\_register\_lock);- clsdev = device\_create(dvb\_class, adap->device, MKDEV(DVB\_MAJOR, minor), dvbdev, "dvb%d.%s%d", adap->num, dnames[type], id); if (IS\_ERR(clsdev)) { pr\_err("%s: failed to create device dvb%d.%s%d (%ld)\n", \_\_func\_\_, adap->num, dnames[type], id, PTR\_ERR(clsdev));+ if (new\_node) {+ list\_del (&new\_node->list\_head);+ kfree(dvbdevfops);+ kfree(new\_node);+ } dvb\_media\_device\_free(dvbdev); list\_del (&dvbdev->list\_head);- kfree(dvbdevfops); kfree(dvbdev);+ mutex\_unlock(&dvbdev\_register\_lock); return PTR\_ERR(clsdev); }+ dprintk("DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n", adap->num, dnames[type], id, minor, minor); + mutex\_unlock(&dvbdev\_register\_lock); return 0; } EXPORT\_SYMBOL(dvb\_register\_device);@@ -575,7 +610,6 @@ static void dvb\_free\_device(struct kref \*ref) { struct dvb\_device \*dvbdev = container\_of(ref, struct dvb\_device, ref); - kfree (dvbdev->fops); kfree (dvbdev); } @@ -1081,9 +1115,17 @@ error:  static void \_\_exit exit\_dvbdev(void) {+ struct dvbdevfops\_node \*node, \*next;+ class\_destroy(dvb\_class); cdev\_del(&dvb\_device\_cdev); unregister\_chrdev\_region(MKDEV(DVB\_MAJOR, 0), MAX\_DVB\_MINORS);++ list\_for\_each\_entry\_safe(node, next, &dvbdevfops\_list, list\_head) {+ list\_del (&node->list\_head);+ kfree(node->fops);+ kfree(node);+ } }  subsys\_initcall(init\_dvbdev);diff --git a/include/media/dvbdev.h b/include/media/dvbdev.hindex 29d25c8a6f13fa..8958e5e2fc5b77 100644--- a/[include/media/dvbdev.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/media/dvbdev.h?id=4172385b0c9ac366dcab78eda48c26814b87ed1a)+++ b/[include/media/dvbdev.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/media/dvbdev.h?id=627bb528b086b4136315c25d6a447a98ea9448d3)@@ -194,6 +194,21 @@ struct dvb\_device { };  /\*\*+ \* struct dvbdevfops\_node - fops nodes registered in dvbdevfops\_list+ \*+ \* @fops: Dynamically allocated fops for ->owner registration+ \* @type: type of dvb\_device+ \* @template: dvb\_device used for registration+ \* @list\_head: list\_head for dvbdevfops\_list+ \*/+struct dvbdevfops\_node {+ struct file\_operations \*fops;+ enum dvb\_device\_type type;+ const struct dvb\_device \*template;+ struct list\_head list\_head;+};++/\*\* \* dvb\_device\_get - Increase dvb\_device reference \* \* @dvbdev: pointer to struct dvb\_device |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 19:58:40 +0000



=== Content from security.netapp.com_de1a25df_20250114_200008.html ===

[Skip to main content](#n-main-content)

* [NetApp.com](https://www.netapp.com/)
* [Support](https://mysupport.netapp.com)
* [Community](https://community.netapp.com)
* [Training](https://www.netapp.com/support-and-training/netapp-learning-services/)

* [Contact Us](https://www.netapp.com/company/contact-us/)

English
æ¥æ¬èª

[netapp-mark

NetApp

## Product Security](https://security.netapp.com)

Search

Search

* Search

Search

Search

* [Home](https://security.netapp.com/en)
* [Advisories](https://security.netapp.com/advisory/)
* [Bulletins](https://security.netapp.com/bulletins/)
* [Contact](https://security.netapp.com/contact/)
* [Policy](https://security.netapp.com/policy/)
* [Resources](https://security.netapp.com/resources/)
* [Certifications](https://security.netapp.com/certs/)

* [Home](https://security.netapp.com/en)
* [Advisory](https://security.netapp.com/advisory)
* [November 2022 Linux Kernel 6.0.9 Vulnerabilities in NetApp Products](https://security.netapp.com/advisory/ntap-20230113-0006)

## November 2022 Linux Kernel 6.0.9 Vulnerabilities in NetApp Products

circle-check-alt

This advisory should be considered the single source of current, up-to-date, authorized and accurate information from NetApp regarding Full Support products and versions.

close ×

#### Subscribe to NTAP-20230113-0006 updates

Email

Yes, please send me emails when NetApp Security Advisories are posted or updated.

 By filling and submitting this form, I understand and agree with the [NetApp privacy policy](https://www.netapp.com/company/legal/privacy-policy/ "Privacy Policy") and understand that I can unsubscribe from NetApp Security Advisory communications at any time.

Subscribe

#### Subscribe to NTAP-20230113-0006 advisory updates

OTP

Confirm

ionicons-v5-e

Confirmed your subscription to advisory alerts

close ×

#### Unsubscribe from NTAP-20230113-0006 advisory updates

Email

Unsubscribe

#### Unsubscribe from NTAP-20230113-0006 advisory updates

Email

Confirm

ionicons-v5-e

Unsubscribed successfully from advisory alerts

Subscribe to receive email updates

**Advisory ID:** NTAP-20230113-0006
**Version:**
2.0

**Last updated:**
02/16/2023

**Status:**
Final.

**CVEs:** CVE-2022-45884, CVE-2022-45885, CVE-2022-45886, CVE-2022-45887, CVE-2022-45888

Overview
#### Summary

Multiple NetApp products incorporate Linux Kernel. Linux Kernel versions through 6.0.9 are susceptible to vulnerabilities which when successfully exploited could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS).

#### Impact

Successful exploitation of these vulnerabilities could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS).

#### Vulnerability Scoring Details

| **CVE** | **Score** | **Vector** |
| --- | --- | --- |
| [CVE-2022-45884](https://nvd.nist.gov/vuln/detail/CVE-2022-45884) | 7.0 (HIGH) | CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H |
| [CVE-2022-45885](https://nvd.nist.gov/vuln/detail/CVE-2022-45885) | 7.0 (HIGH) | CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H |
| [CVE-2022-45886](https://nvd.nist.gov/vuln/detail/CVE-2022-45886) | 7.0 (HIGH) | CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H |
| [CVE-2022-45887](https://nvd.nist.gov/vuln/detail/CVE-2022-45887) | 4.7 (MEDIUM) | CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H |
| [CVE-2022-45888](https://nvd.nist.gov/vuln/detail/CVE-2022-45888) | 6.4 (MEDIUM) | CVSS:3.1/AV:P/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H |

#### Exploitation and Public Announcements

NetApp is aware of public discussion of this vulnerability.

#### References

* [https://lore.kernel.org/linux-media/20221115131822.6640-1-imv4bel@gmail.com/](https://lore.kernel.org/linux-media/20221115131822.6640-1-imv4bel%40gmail.com/)
* [https://lore.kernel.org/linux-media/20221115131822.6640-2-imv4bel@gmail.com/](https://lore.kernel.org/linux-media/20221115131822.6640-2-imv4bel%40gmail.com/)
* [https://lore.kernel.org/linux-media/20221115131822.6640-3-imv4bel@gmail.com/](https://lore.kernel.org/linux-media/20221115131822.6640-3-imv4bel%40gmail.com/)
* [https://lore.kernel.org/linux-media/20221115131822.6640-4-imv4bel@gmail.com/](https://lore.kernel.org/linux-media/20221115131822.6640-4-imv4bel%40gmail.com/)
* [https://lore.kernel.org/linux-media/20221115131822.6640-5-imv4bel@gmail.com/](https://lore.kernel.org/linux-media/20221115131822.6640-5-imv4bel%40gmail.com/)
* [https://lore.kernel.org/all/20221022175404.GA375335@ubuntu/](https://lore.kernel.org/all/20221022175404.GA375335%40ubuntu/)

Affected Products
#### Affected Products

* NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H410S
* NetApp HCI Baseboard Management Controller (BMC) - H410C

#### Products Not Affected

* AFF Baseboard Management Controller (BMC) - A700s
* ATTO FibreBridge - 7500N
* ATTO FibreBridge - 7600N
* Active IQ Unified Manager for Linux
* Active IQ Unified Manager for Microsoft Windows
* Active IQ Unified Manager for VMware vSphere
* Active IQ mobile app
* Astra Control Center
* Astra Control Center - Cloud Insights Telegraf Agent
* Astra Control Center - NetApp Kubernetes Monitoring Operator
* Astra Trident
* Astra Trident Autosupport
* BlueXP Classification
* Brocade Fabric Operating System Firmware
* Brocade SAN Navigator (SANnav)
* Cloud Insights Acquisition Unit
* Cloud Insights Storage Workload Security Agent
* Cloud Insights Telegraf Agent
* Cloud Volumes ONTAP Mediator
* E-Series BIOS
* E-Series SANtricity OS Controller Software 11.x
* E-Series SANtricity Unified Manager and Web Services Proxy
* Element .NET SDK
* Element HealthTools
* Element JAVA SDK
* Element Plug-in for vCenter Server
* Element Powershell Tools
* Element Python SDK
* FAS/AFF BIOS - 8300/8700/A400/C400
* FAS/AFF BIOS - A250/500f/C250
* FAS/AFF BIOS - A300/8200/A200/2650/2620/C190/A220/2720/2750/A150
* FAS/AFF BIOS - A320
* FAS/AFF BIOS - A700/9000
* FAS/AFF BIOS - A700s
* FAS/AFF BIOS - A800/C800
* FAS/AFF BIOS - A900/9500
* FAS/AFF Baseboard Management Controller (BMC) - 8300/8700/A400/C400
* FAS/AFF Baseboard Management Controller (BMC) - A250/500f/C250
* FAS/AFF Baseboard Management Controller (BMC) - A900/9500
* FAS/AFF Baseboard Management Controller (BMC) - C190/A150/A220/FAS2720/FAS2750
* FAS/AFF Service Processor - 2554/2552/2520
* FAS/AFF Service Processor - 8080/8060/8040/8020
* FAS/AFF Service Processor - A300/8200/A200/2650/2620
* FAS/AFF Service Processor - A700/9000
* Global File Cache
* Host Utilities - SAN for Linux
* Host Utilities - SAN for Windows
* IOM6 SAS Disk Shelf Firmware
* Management Services for Element Software and NetApp HCI
* MetroCluster Tiebreaker for clustered Data ONTAP
* Multipath I/O (SANtricity DSM for Windows MPIO)
* NetApp BlueXP
* NetApp Converged Systems Advisor Agent
* NetApp E-Series Host Collection
* NetApp E-Series SANtricity Collection
* NetApp HCI Baseboard Management Controller (BMC) - H610C
* NetApp HCI Baseboard Management Controller (BMC) - H610S
* NetApp HCI Baseboard Management Controller (BMC) - H615C
* NetApp HCI Compute Node (Bootstrap OS)
* NetApp HCI Compute Node BIOS
* NetApp HCI Storage Node BIOS
* NetApp Kubernetes Monitoring Operator
* NetApp Manageability SDK
* NetApp NFS Plug-in for VMware VAAI
* NetApp ONTAP PowerShell Toolkit (PSTK)
* NetApp SolidFire & HCI Management Node
* NetApp SolidFire & HCI Storage Node (Element Software)
* NetApp SolidFire Plug-in for vRealize Orchestrator (SolidFire vRO)
* NetApp XCP NFS
* NetApp XCP SMB
* ONTAP 9 (formerly Clustered Data ONTAP)
* ONTAP Antivirus Connector
* ONTAP Mediator
* ONTAP Select Deploy administration utility
* ONTAP tools for VMware vSphere 9
* OnCommand Insight
* OnCommand Workflow Automation
* SANtricity Storage Plugin for vCenter
* SRA Plugin for Linux
* SRA Plugin for Windows
* Single Mailbox Recovery
* Snap Creator Framework
* SnapCenter
* SnapCenter Plug-in for VMware vSphere/BlueXP backup and Recovery for Virtual Machine
* SnapManager for Hyper-V
* SolidFire Storage Replication Adapter
* StorageGRID (formerly StorageGRID Webscale)
* StorageGRID BIOS SG1000/SG100
* StorageGRID BIOS SG5660/SG5612/SG5760/SG5712
* StorageGRID BIOS SG6060/SGF6024/SGF6112
* StorageGRID Baseboard Management Controller (BMC)
* System Manager 9.x

Remediation
#### Software Versions and Fixes

NetApp's currently available patches are listed below.

| **Product** | **First Fixed in Release** |
| --- | --- |
| **NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H410S** | NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H410S has no plans to address this vulnerability. See the [EOA announcement](https://mysupport.netapp.com/info/communications/ECMLP2876227.html) for more information. |
| **NetApp HCI Baseboard Management Controller (BMC) - H410C** | NetApp HCI Baseboard Management Controller (BMC) - H410C has no plans to address this vulnerability. See the [EOA announcement](https://mysupport.netapp.com/info/communications/ECMLP2876227.html) for more information. |

#### Workarounds

None at this time.

#### Obtaining Software Fixes

Software fixes will be made available through the NetApp Support website in the Software Download section.

<https://mysupport.netapp.com/site/downloads/>

Customers who do not have access to the Support website should contact Technical Support at the number below to obtain the patches.

#### Contact Information

Check <http://mysupport.netapp.com> for further
updates.

**Technical Support**

Revision History
#### Status of This Notice

**Final.**

This advisory should be considered the single source of current, up-to-date, authorized and accurate information from NetApp regarding Full Support products and versions.

This advisory is posted at the following link:

<https://security.netapp.com/advisory/NTAP-20230113-0006>
#### Revision History

| **Revision #** | **Date** | **Comments** |
| --- | --- | --- |
| 1.0 | 20230113 | Initial Public Release |
| 2.0 | 20230216 | NetApp HCI Baseboard Management Controller (BMC) - H610S, NetApp HCI Baseboard Management Controller (BMC) - H610C and NetApp HCI Baseboard Management Controller (BMC) - H615C moved to Products Not Affected, Final status |

This document is provided solely for informational purposes. All information is based upon NetAppâs current knowledge and understanding of the hardware and software products tested by NetApp, and the methodology and assumptions used by NetApp. NetApp is not responsible for any errors or omissions that may be contained herein, and no warranty, representation, or other legal commitment or obligation is being provided by NetApp. Â© 2025 NetApp, Inc. All rights reserved. No portions of this document may be reproduced without prior written consent of NetApp, Inc.

 ©  NetApp

Have feedback for our website?
[Let us know](https://www.netapp.com/forms/site-feedback/)


