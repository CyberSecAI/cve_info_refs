=== Content from github.com_ed31a901_20250114_193520.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fblob%2F274df9b02330b790aa8de1cee164b70f72b9b244%2Ftensorflow%2Fcore%2Fgraph%2Fgraph.cc)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fblob%2F274df9b02330b790aa8de1cee164b70f72b9b244%2Ftensorflow%2Fcore%2Fgraph%2Fgraph.cc)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=tensorflow%2Ftensorflow)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[tensorflow](/tensorflow)
/
**[tensorflow](/tensorflow/tensorflow)**
Public

* [Notifications](/login?return_to=%2Ftensorflow%2Ftensorflow) You must be signed in to change notification settings
* [Fork
  74.4k](/login?return_to=%2Ftensorflow%2Ftensorflow)
* [Star
   187k](/login?return_to=%2Ftensorflow%2Ftensorflow)

* [Code](/tensorflow/tensorflow)
* [Issues
  827](/tensorflow/tensorflow/issues)
* [Pull requests
  5k+](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects
  2](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

Additional navigation options

* [Code](/tensorflow/tensorflow)
* [Issues](/tensorflow/tensorflow/issues)
* [Pull requests](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

## Files

 274df9b
## Breadcrumbs

1. [tensorflow](/tensorflow/tensorflow/tree/274df9b02330b790aa8de1cee164b70f72b9b244)
2. /[tensorflow](/tensorflow/tensorflow/tree/274df9b02330b790aa8de1cee164b70f72b9b244/tensorflow)
3. /[core](/tensorflow/tensorflow/tree/274df9b02330b790aa8de1cee164b70f72b9b244/tensorflow/core)
4. /[graph](/tensorflow/tensorflow/tree/274df9b02330b790aa8de1cee164b70f72b9b244/tensorflow/core/graph)
/
# graph.cc

Copy path Blame  Blame
## Latest commit

## History

[History](/tensorflow/tensorflow/commits/274df9b02330b790aa8de1cee164b70f72b9b244/tensorflow/core/graph/graph.cc)1009 lines (888 loc) · 33.3 KB 274df9b
## Breadcrumbs

1. [tensorflow](/tensorflow/tensorflow/tree/274df9b02330b790aa8de1cee164b70f72b9b244)
2. /[tensorflow](/tensorflow/tensorflow/tree/274df9b02330b790aa8de1cee164b70f72b9b244/tensorflow)
3. /[core](/tensorflow/tensorflow/tree/274df9b02330b790aa8de1cee164b70f72b9b244/tensorflow/core)
4. /[graph](/tensorflow/tensorflow/tree/274df9b02330b790aa8de1cee164b70f72b9b244/tensorflow/core/graph)
/
# graph.cc

Top
## File metadata and controls

* Code
* Blame

1009 lines (888 loc) · 33.3 KB[Raw](https://github.com/tensorflow/tensorflow/raw/274df9b02330b790aa8de1cee164b70f72b9b244/tensorflow/core/graph/graph.cc)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* Copyright 2015 The TensorFlow Authors. All Rights Reserved.
Licensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.==============================================================================\*/
#include "tensorflow/core/graph/graph.h"
#include <memory>#include <vector>
#include "absl/container/flat\_hash\_map.h"#include "tensorflow/core/framework/full\_type.pb.h"#include "tensorflow/core/framework/graph.pb.h"#include "tensorflow/core/framework/node\_def.pb.h"#include "tensorflow/core/framework/node\_properties.h"#include "tensorflow/core/framework/op\_def\_builder.h"#include "tensorflow/core/framework/op\_kernel.h"#include "tensorflow/core/framework/versions.pb.h"#include "tensorflow/core/graph/graph\_node\_util.h"#include "tensorflow/core/graph/while\_context.h"#include "tensorflow/core/lib/core/errors.h"#include "tensorflow/core/lib/gtl/map\_util.h"#include "tensorflow/core/lib/hash/hash.h"#include "tensorflow/core/lib/strings/strcat.h"#include "tensorflow/core/lib/strings/stringprintf.h"#include "tensorflow/core/platform/errors.h"#include "tensorflow/core/platform/logging.h"#include "tensorflow/core/public/version.h"
namespace tensorflow {
const int Graph::kControlSlot = -1;
// NodeNode::NodeClass Node::GetNodeClassForOp(const std::string& ts) { static const absl::flat\_hash\_map<std::string, Node::NodeClass>\* kNodeClassTable =#define REF\_CLASS(key, value) \ {key, value}, { "Ref" key, value } new absl::flat\_hash\_map<std::string, Node::NodeClass>({ // Keep in same order as NodeClass values REF\_CLASS("Switch", NC\_SWITCH), REF\_CLASS("\_SwitchN", NC\_SWITCH), REF\_CLASS("Merge", NC\_MERGE), REF\_CLASS("Enter", NC\_ENTER), REF\_CLASS("Exit", NC\_EXIT), REF\_CLASS("NextIteration", NC\_NEXT\_ITERATION), {"LoopCond", NC\_LOOP\_COND}, {"ControlTrigger", NC\_CONTROL\_TRIGGER}, {"\_Send", NC\_SEND}, {"\_HostSend", NC\_HOST\_SEND}, {"\_Recv", NC\_RECV}, {"\_HostRecv", NC\_HOST\_RECV}, {"Const", NC\_CONSTANT}, {"HostConst", NC\_CONSTANT}, {"Variable", NC\_VARIABLE}, {"VariableV2", NC\_VARIABLE}, REF\_CLASS("Identity", NC\_IDENTITY), {"GetSessionHandle", NC\_GET\_SESSION\_HANDLE}, {"GetSessionHandleV2", NC\_GET\_SESSION\_HANDLE}, {"GetSessionTensor", NC\_GET\_SESSION\_TENSOR}, {"DeleteSessionTensor", NC\_DELETE\_SESSION\_TENSOR}, {"Size", NC\_METADATA}, {"Shape", NC\_METADATA}, {"Rank", NC\_METADATA}, {"\_ScopedAllocator", NC\_SCOPED\_ALLOCATOR}, {"CollectiveReduce", NC\_COLLECTIVE}, {"CollectiveBcastSend", NC\_COLLECTIVE}, {"CollectiveBcastRecv", NC\_COLLECTIVE}, {"CollectiveGather", NC\_COLLECTIVE}, {"FakeParam", NC\_FAKE\_PARAM}, {"PartitionedCall", NC\_PARTITIONED\_CALL}, {"StatefulPartitionedCall", NC\_PARTITIONED\_CALL}, {"SymbolicGradient", NC\_SYMBOLIC\_GRADIENT}, {"If", NC\_IF}, {"StatelessIf", NC\_IF}, {"While", NC\_WHILE}, {"StatelessWhile", NC\_WHILE}, {"Case", NC\_CASE}, {"StatelessCase", NC\_CASE}, // Not using the constants defined in FunctionLibraryDefinition // for the // 4 ops below because android inference library does not link // tf.function related files. {"\_Arg", NC\_ARG}, {"\_DeviceArg", NC\_ARG}, {"\_Retval", NC\_RETVAL}, {"\_DeviceRetval", NC\_RETVAL}, {"\_XlaMerge", NC\_MERGE}, });#undef REF\_CLASS
 auto it = kNodeClassTable->find(ts); if (it != kNodeClassTable->end()) { return it->second; } else { return NC\_OTHER; }}
std::string Node::DebugString() const { std::string ret = strings::StrCat("{name:'", name(), "' id:", id\_); if (IsSource()) { strings::StrAppend(&ret, " source}"); } else if (IsSink()) { strings::StrAppend(&ret, " sink}"); } else { strings::StrAppend(&ret, " op device:", "{requested: '", requested\_device(), "', assigned: '", assigned\_device\_name(), "'}", " def:{", SummarizeNode(\*this), "}}"); } return ret;}
Node::Node() : id\_(-1), cost\_id\_(-1), class\_(NC\_UNINITIALIZED), props\_(nullptr), assigned\_device\_name\_index\_(0), while\_ctx\_(nullptr) {}
void Node::Initialize(int id, int cost\_id, std::shared\_ptr<NodeProperties> props, Node::NodeClass node\_class) { DCHECK\_EQ(id\_, -1); DCHECK(in\_edges\_.empty()); DCHECK(out\_edges\_.empty()); id\_ = id; cost\_id\_ = cost\_id;
 props\_ = std::move(props); class\_ = node\_class;}
void Node::Clear() { in\_edges\_.clear(); out\_edges\_.clear(); id\_ = -1; cost\_id\_ = -1; class\_ = NC\_UNINITIALIZED; props\_.reset(); assigned\_device\_name\_index\_ = 0;}
void Node::UpdateProperties() { DataTypeVector inputs; DataTypeVector outputs; Status status = InOutTypesForNode(props\_->node\_def, \*(props\_->op\_def), &inputs, &outputs); if (!status.ok()) { LOG(ERROR) << "Failed at updating node: " << status; return; } if (props\_->input\_types != inputs || props\_->output\_types != outputs) { if (TF\_PREDICT\_TRUE(props\_.use\_count() == 1)) { props\_->input\_types = inputs; props\_->input\_types\_slice = props\_->input\_types; props\_->output\_types = outputs; props\_->output\_types\_slice = props\_->output\_types; } else { props\_ = std::make\_shared<NodeProperties>( props\_->op\_def, std::move(props\_->node\_def), inputs, outputs); } }}
void Node::ClearTypeInfo() { if (props\_->node\_def.has\_experimental\_type()) { MaybeCopyOnWrite(); props\_->node\_def.clear\_experimental\_type(); }}
void Node::RunForwardTypeInference() { VLOG(4) << "Forward type inference: " << props\_->node\_def.DebugString();
 if (props\_->fwd\_type\_fn == nullptr) { return; }
 std::vector<Node\*> input\_nodes(props\_->input\_types.size(), nullptr); std::vector<int> input\_idx(props\_->input\_types.size(), 0); for (const auto& edge : in\_edges\_) { if (edge->IsControlEdge()) { continue; } DCHECK(edge->dst\_input() < input\_nodes.size()) << DebugString(); int i = edge->dst\_input(); input\_nodes.at(i) = edge->src(); input\_idx.at(i) = edge->src\_output(); }
 // Note: technically, we could use a very generic type when some of the inputs // are unknown. But there is an expectation that a node will have complete // inputs soon, so updating intermediate types is largely unnecessary.
 for (const auto\* node : input\_nodes) { if (node == nullptr) { // Incomplete inputs, bail. ClearTypeInfo(); return; } }
 static FullTypeDef\* no\_type = new FullTypeDef();
 std::vector<std::reference\_wrapper<const FullTypeDef>> input\_types; for (int i = 0; i < input\_nodes.size(); i++) { const auto\* node = input\_nodes[i]; if (node->def().has\_experimental\_type()) { const auto& node\_t = node->def().experimental\_type(); if (node\_t.type\_id() != TFT\_UNSET) { int ix = input\_idx[i]; DCHECK(ix < node\_t.args\_size()) << "input " << i << " should have an output " << ix << " but instead only has " << node\_t.args\_size() << " outputs: " << node\_t.DebugString(); input\_types.emplace\_back(node\_t.args(ix)); } else { input\_types.emplace\_back(\*no\_type); } } else { // Incomplete inputs, bail. ClearTypeInfo(); return; } }
 const auto infer\_type = props\_->fwd\_type\_fn(input\_types); const FullTypeDef infer\_typedef = infer\_type.ValueOrDie(); if (infer\_typedef.type\_id() != TFT\_UNSET) { MaybeCopyOnWrite(); \*(props\_->node\_def.mutable\_experimental\_type()) = infer\_typedef; }}
const std::string& Node::name() const { return props\_->node\_def.name(); }const std::string& Node::type\_string() const { return props\_->node\_def.op(); }const NodeDef& Node::def() const { return props\_->node\_def; }const OpDef& Node::op\_def() const { return \*props\_->op\_def; }
NodeDef\* Node::mutable\_def() { return &props\_->node\_def; }
int32 Node::num\_inputs() const { return props\_->input\_types.size(); }DataType Node::input\_type(int32\_t i) const { return props\_->input\_types[i]; }const DataTypeVector& Node::input\_types() const { return props\_->input\_types; }
int32 Node::num\_outputs() const { return props\_->output\_types.size(); }DataType Node::output\_type(int32\_t o) const { return props\_->output\_types[o]; }const DataTypeVector& Node::output\_types() const { return props\_->output\_types;}
AttrSlice Node::attrs() const { return AttrSlice(def()); }
const protobuf::RepeatedPtrField<std::string>& Node::requested\_inputs() const { return def().input();}
const std::string& Node::requested\_device() const { return def().device(); }
gtl::iterator\_range<NeighborIter> Node::out\_nodes() const { return gtl::make\_range(NeighborIter(out\_edges\_.begin(), false), NeighborIter(out\_edges\_.end(), false));}
gtl::iterator\_range<NeighborIter> Node::in\_nodes() const { return gtl::make\_range(NeighborIter(in\_edges\_.begin(), true), NeighborIter(in\_edges\_.end(), true));}
void Node::MaybeCopyOnWrite() { // TODO(mdan): As nodes become more dynamic, this may not be worth the cost. // NodeProperties may be shared between Nodes. Make a copy if so. if (!props\_.unique()) { props\_ = std::make\_shared<NodeProperties>(\*props\_); }}
AttrValue\* Node::AddAttrHelper(const std::string& name) { MaybeCopyOnWrite(); return &((\*props\_->node\_def.mutable\_attr())[name]);}
void Node::ClearAttr(const std::string& name) { MaybeCopyOnWrite(); (\*props\_->node\_def.mutable\_attr()).erase(name);}
void Node::set\_name(std::string name) { MaybeCopyOnWrite(); props\_->node\_def.set\_name(std::move(name));}
void Node::set\_requested\_device(const std::string& device) { MaybeCopyOnWrite(); props\_->node\_def.set\_device(device);}
void Node::set\_original\_node\_names(const std::vector<std::string>& names) { MaybeCopyOnWrite(); props\_->node\_def.mutable\_experimental\_debug\_info() ->clear\_original\_node\_names(); if (!names.empty()) { \*props\_->node\_def.mutable\_experimental\_debug\_info() ->mutable\_original\_node\_names() = {names.begin(), names.end()}; }}
void Node::set\_original\_func\_names(const std::vector<std::string>& names) { MaybeCopyOnWrite(); props\_->node\_def.mutable\_experimental\_debug\_info() ->clear\_original\_func\_names(); if (!names.empty()) { \*props\_->node\_def.mutable\_experimental\_debug\_info() ->mutable\_original\_func\_names() = {names.begin(), names.end()}; }}
Status Node::input\_edge(int idx, const Edge\*\* e) const { if (idx < 0 || idx >= num\_inputs()) { return errors::InvalidArgument("Invalid input\_edge index: ", idx, ", Node ", name(), " only has ", num\_inputs(), " inputs."); }
 // This does a linear search over the edges. In the common case, // the number of elements is small enough that this search isn't // expensive. Should it become a bottleneck, one can make an // optimization where, if the number of edges is small, we use // linear iteration, and if the number of edges is large, we perform // an indexing step during construction that keeps an array of Edges // indexed by pointer. This would keep the size of each Node small // in the common case but make this function faster when the number // of edges is large. for (const Edge\* edge : in\_edges()) { if (edge->dst\_input() == idx) { \*e = edge; return Status::OK(); } }
 return errors::NotFound("Could not find input edge ", idx, " for ", name());}
// Returns a vector of the non-control input edges to a node, indexed by ID.Status Node::input\_edges(std::vector<const Edge\*>\* input\_edges) const { input\_edges->clear(); input\_edges->resize(num\_inputs(), nullptr);
 for (const Edge\* edge : in\_edges()) { if (edge->IsControlEdge()) continue; if (edge->dst\_input() < 0 || edge->dst\_input() >= num\_inputs()) { return errors::Internal("Invalid edge input number ", edge->dst\_input()); } if ((\*input\_edges)[edge->dst\_input()] != nullptr) { return errors::Internal("Duplicate edge input number: ", edge->dst\_input()); } (\*input\_edges)[edge->dst\_input()] = edge; }
 for (int i = 0; i < num\_inputs(); ++i) { if ((\*input\_edges)[i] == nullptr) { return errors::InvalidArgument("Missing edge input number: ", i); } } return Status::OK();}
Status Node::input\_node(int idx, Node\*\* n) const { const Edge\* e; TF\_RETURN\_IF\_ERROR(input\_edge(idx, &e)); if (e == nullptr) { \*n = nullptr; } else { \*n = e->src(); } return Status::OK();}
Status Node::input\_node(int idx, const Node\*\* const\_n) const { Node\* n; TF\_RETURN\_IF\_ERROR(input\_node(idx, &n)); \*const\_n = n; return Status::OK();}
Status Node::input\_tensor(int idx, OutputTensor\* t) const { const Edge\* e; TF\_RETURN\_IF\_ERROR(input\_edge(idx, &e)); DCHECK(e != nullptr); \*t = OutputTensor(e->src(), e->src\_output()); return Status::OK();}
// NodeDebugInfo
NodeDebugInfo::NodeDebugInfo(const Node& n) : NodeDebugInfo(n.def()) {}NodeDebugInfo::NodeDebugInfo(const NodeDef& ndef) : NodeDebugInfo(ndef.name(), ndef.has\_experimental\_debug\_info(), ndef.experimental\_debug\_info()) {}NodeDebugInfo::NodeDebugInfo( StringPiece node\_name, bool has\_experimental\_debug\_info, const NodeDef\_ExperimentalDebugInfo& experimental\_debug\_info) : name(node\_name) { if (has\_experimental\_debug\_info) { const auto& node\_names = experimental\_debug\_info.original\_node\_names(); original\_node\_names.assign(node\_names.begin(), node\_names.end()); const auto& func\_names = experimental\_debug\_info.original\_func\_names(); original\_func\_names.assign(func\_names.begin(), func\_names.end()); }}// InputTensor
bool InputTensor::operator==(const InputTensor& other) const { return node == other.node && index == other.index;}
uint64 InputTensor::Hash::operator()(InputTensor const& s) const { return Hash64Combine(std::hash<const Node\*>()(s.node), std::hash<int>()(s.index));}
// OutputTensor
bool OutputTensor::operator==(const OutputTensor& other) const { return node == other.node && index == other.index;}
uint64 OutputTensor::Hash::operator()(OutputTensor const& s) const { return Hash64Combine(std::hash<const Node\*>()(s.node), std::hash<int>()(s.index));}
// Graph
Graph::Graph(const OpRegistryInterface\* ops) : ops\_(ops, FunctionDefLibrary()), versions\_(new VersionDef), arena\_(8 << 10 /\* 8kB \*/) { versions\_->set\_producer(TF\_GRAPH\_DEF\_VERSION); versions\_->set\_min\_consumer(TF\_GRAPH\_DEF\_VERSION\_MIN\_CONSUMER);
 // Initialize the name interning table for assigned\_device\_name. device\_names\_.push\_back(""); DCHECK\_EQ(0, InternDeviceName(""));
 // Source and sink have no endpoints, just control edges. NodeDef def; def.set\_name("\_SOURCE"); def.set\_op("NoOp"); Status status; Node\* source = AddNode(def, &status); TF\_CHECK\_OK(status); CHECK\_EQ(source->id(), kSourceId);
 def.set\_name("\_SINK"); Node\* sink = AddNode(def, &status); TF\_CHECK\_OK(status); CHECK\_EQ(sink->id(), kSinkId);
 AddControlEdge(source, sink);}
Graph::Graph(const FunctionLibraryDefinition& flib\_def) : Graph(flib\_def.default\_registry()) { // Need a new-enough consumer to support the functions we add to the graph. if (flib\_def.num\_functions() > 0 && versions\_->min\_consumer() < 12) { versions\_->set\_min\_consumer(12); } Status s = ops\_.AddLibrary(flib\_def); CHECK(s.ok()) << s.error\_message();}
Graph::~Graph() { // Manually call the destructors for all the Nodes we constructed using // placement new. for (Node\* node : nodes\_) { if (node != nullptr) { node->~Node(); } } for (Node\* node : free\_nodes\_) { node->~Node(); } // Edges have no destructor, and we arena-allocated them, so no need to // destroy them.}
std::unique\_ptr<Graph> Graph::Clone() { std::unique\_ptr<Graph> new\_graph(new Graph(flib\_def())); new\_graph->Copy(\*this); return new\_graph;}
const VersionDef& Graph::versions() const { return \*versions\_; }void Graph::set\_versions(const VersionDef& versions) { \*versions\_ = versions; }
void Graph::Copy(const Graph& src) { SetConstructionContext(src.GetConstructionContextInternal()); for (Node\* n : nodes()) { CHECK(n->IsSource() || n->IsSink()) << "\*dest must be empty"; }
 // Copy GraphDef versions set\_versions(src.versions());
 // Copy the nodes. // "Node in src" -> "Node in \*dest" gtl::FlatMap<const Node\*, Node\*> node\_map; node\_map.reserve(src.num\_nodes()); node\_map[src.source\_node()] = source\_node(); node\_map[src.sink\_node()] = sink\_node(); for (Node\* n : src.op\_nodes()) { auto copy = CopyNode(n); copy->in\_edges\_.reserve(n->in\_edges().size()); copy->out\_edges\_.reserve(n->out\_edges().size()); node\_map[n] = copy; }
 // Copy the edges edges\_.reserve(src.num\_edges()); for (const Edge\* e : src.edges()) { Node\* src\_copy = node\_map[e->src()]; Node\* dst\_copy = node\_map[e->dst()]; AddEdge(src\_copy, e->src\_output(), dst\_copy, e->dst\_input()); }}
Node\* Graph::AddNode(NodeDef node\_def, Status\* status) { const OpRegistrationData\* op\_reg\_data; status->Update(ops\_.LookUp(node\_def.op(), &op\_reg\_data)); if (!status->ok()) return nullptr;
 DataTypeVector inputs; DataTypeVector outputs; status->Update( InOutTypesForNode(node\_def, op\_reg\_data->op\_def, &inputs, &outputs)); if (!status->ok()) { \*status = AttachDef(\*status, node\_def); return nullptr; }
 Node::NodeClass node\_class = op\_reg\_data->is\_function\_op ? Node::NC\_FUNCTION\_OP : Node::GetNodeClassForOp(node\_def.op());
 if (op\_reg\_data->type\_ctor != nullptr) { VLOG(3) << "AddNode: found type constructor for " << node\_def.name(); const auto ctor\_type = full\_type::SpecializeType(AttrSlice(node\_def), op\_reg\_data->op\_def); const FullTypeDef ctor\_typedef = ctor\_type.ValueOrDie(); if (ctor\_typedef.type\_id() != TFT\_UNSET) { \*(node\_def.mutable\_experimental\_type()) = ctor\_typedef; } } else { VLOG(3) << "AddNode: no type constructor for " << node\_def.name(); }
 Node\* node = AllocateNode(std::make\_shared<NodeProperties>( &op\_reg\_data->op\_def, std::move(node\_def), inputs, outputs, op\_reg\_data->fwd\_type\_fn), nullptr, node\_class); return node;}
Node\* Graph::CopyNode(const Node\* node) { DCHECK(!node->IsSource()); DCHECK(!node->IsSink()); Node\* copy = AllocateNode(node->props\_, node, node->class\_); copy->set\_assigned\_device\_name(node->assigned\_device\_name());
 // Since the OpDef of a function may be owned by the Graph that owns 'node', // relookup the OpDef in the target graph. If it differs, then clone the // node properties with the updated OpDef. const OpDef\* op\_def; TF\_CHECK\_OK(ops\_.LookUpOpDef(node->type\_string(), &op\_def)); if (op\_def != node->props\_->op\_def) { copy->MaybeCopyOnWrite(); copy->props\_->op\_def = op\_def; } copy->SetStackTrace(node->GetStackTrace());
 return copy;}
void Graph::RemoveNode(Node\* node) { TF\_DCHECK\_OK(IsValidNode(node)) << node->DebugString(); DCHECK(!node->IsSource()); DCHECK(!node->IsSink());
 // Remove any edges involving this node. for (const Edge\* e : node->in\_edges\_) { CHECK\_EQ(e->src\_->out\_edges\_.erase(e), size\_t{1}); edges\_[e->id\_] = nullptr; RecycleEdge(e); --num\_edges\_; } node->in\_edges\_.clear(); for (const Edge\* e : node->out\_edges\_) { CHECK\_EQ(e->dst\_->in\_edges\_.erase(e), size\_t{1}); edges\_[e->id\_] = nullptr; RecycleEdge(e); --num\_edges\_; } node->out\_edges\_.clear(); ReleaseNode(node);}
const Edge\* Graph::AddEdge(Node\* source, int x, Node\* dest, int y) { TF\_DCHECK\_OK(IsValidNode(source)) << source->DebugString(); TF\_DCHECK\_OK(IsValidNode(dest)) << dest->DebugString();
 // source/sink must only be linked via control slots, and // control slots must only be linked to control slots. if (source == source\_node() || dest == sink\_node() || x == kControlSlot || y == kControlSlot) { DCHECK\_EQ(x, kControlSlot) << source->DebugString(); DCHECK\_EQ(y, kControlSlot) << dest->DebugString(); }
 Edge\* e = nullptr; if (free\_edges\_.empty()) { e = new (arena\_.Alloc(sizeof(Edge))) Edge; // placement new } else { e = free\_edges\_.back(); free\_edges\_.pop\_back(); } e->id\_ = edges\_.size(); e->src\_ = source; e->dst\_ = dest; e->src\_output\_ = x; e->dst\_input\_ = y; CHECK(source->out\_edges\_.insert(e).second); CHECK(dest->in\_edges\_.insert(e).second); edges\_.push\_back(e); ++num\_edges\_;
 if (!e->IsControlEdge()) { if (dest->in\_edges\_.size() >= dest->props\_->input\_types.size()) { // Note: this only produces consistent results at graph construction, // and only when all incoming edges are up-to-date. // If the graph is subsequently modified, or if the node is added before // any of its upstream nodes, this type information would change as well. // In general, graph transformations should run shole-graph type inference // when done, and should not rely on types being fully up to date // after each AddNode. // TODO(mdan): Should we even run type inference here any more? dest->RunForwardTypeInference(); } }
 return e;}
void Graph::RemoveEdge(const Edge\* e) { TF\_DCHECK\_OK(IsValidNode(e->src\_)) << e->src\_->DebugString(); TF\_DCHECK\_OK(IsValidNode(e->dst\_)) << e->dst\_->DebugString(); CHECK\_EQ(e->src\_->out\_edges\_.erase(e), size\_t{1}); CHECK\_EQ(e->dst\_->in\_edges\_.erase(e), size\_t{1}); CHECK\_EQ(e, edges\_[e->id\_]); CHECK\_GT(num\_edges\_, 0);
 edges\_[e->id\_] = nullptr; RecycleEdge(e); --num\_edges\_;
 if (!e->IsControlEdge()) { // This may clear the node type if enough edges are removed. e->dst\_->RunForwardTypeInference(); }}
void Graph::RecycleEdge(const Edge\* e) { free\_edges\_.push\_back(const\_cast<Edge\*>(e));}
const Edge\* Graph::AddControlEdge(Node\* source, Node\* dest, bool allow\_duplicates) { if (!allow\_duplicates) { for (const Edge\* edge : dest->in\_edges()) { if (edge->IsControlEdge() && edge->src() == source) { // The requested edge already exists. return nullptr; } } } // Modify dest's NodeDef if necessary. if (!source->IsSource() && !dest->IsSink() && !allow\_duplicates) { // Check if this input is already in dest's NodeDef. const std::string new\_input = strings::StrCat("^", source->name()); bool input\_exists = false; for (const std::string& input : dest->props\_->node\_def.input()) { if (input == new\_input) { input\_exists = true; break; } } if (!input\_exists) { dest->MaybeCopyOnWrite(); dest->props\_->node\_def.add\_input(new\_input); } } return AddEdge(source, kControlSlot, dest, kControlSlot);}
void Graph::RemoveControlEdge(const Edge\* e) { if (!e->src\_->IsSource() && !e->dst\_->IsSink()) { e->dst\_->MaybeCopyOnWrite(); std::string e\_src\_name = strings::StrCat("^", e->src\_->name()); auto\* inputs = e->dst\_->props\_->node\_def.mutable\_input(); for (auto it = inputs->begin(); it != inputs->end(); ++it) { if (\*it == e\_src\_name) { inputs->erase(it); break; } } } RemoveEdge(e);}
namespace {const Edge\* FindEdge(const Node\* dst, int index) { for (const Edge\* e : dst->in\_edges()) { if (e->dst\_input() == index) return e; } return nullptr;}} // namespace
Status Graph::UpdateEdge(Node\* new\_src, int new\_src\_index, Node\* dst, int dst\_index) { TF\_RETURN\_IF\_ERROR(IsValidOutputTensor(new\_src, new\_src\_index)); TF\_RETURN\_IF\_ERROR(IsValidInputTensor(dst, dst\_index)); const Edge\* e = FindEdge(dst, dst\_index); if (e == nullptr) { return errors::InvalidArgument("Couldn't find edge to ", FormatNodeForError(\*dst)); } RemoveEdge(e); AddEdge(new\_src, new\_src\_index, dst, dst\_index); dst->MaybeCopyOnWrite(); (\*dst->props\_->node\_def.mutable\_input())[dst\_index] = strings::StrCat(new\_src->name(), ":", new\_src\_index); return Status::OK();}
Status Graph::AddWhileInputHack(Node\* new\_src, int new\_src\_index, Node\* dst) { if (!dst->IsWhileNode()) { return errors::Internal( "dst argument to AddWhileEdgeHack should be a While op, got: ", dst->DebugString()); } TF\_RETURN\_IF\_ERROR(IsValidOutputTensor(new\_src, new\_src\_index)); // Find the current number of data inputs. We'll add the new edge to the next // missing data input. int dst\_index = 0; for (const Edge\* edge : dst->in\_edges()) { if (edge->IsControlEdge()) continue; ++dst\_index; } TF\_RETURN\_IF\_ERROR(IsValidInputTensor(dst, dst\_index)); AddEdge(new\_src, new\_src\_index, dst, dst\_index); dst->MaybeCopyOnWrite(); dst->props\_->node\_def.add\_input( strings::StrCat(new\_src->name(), ":", new\_src\_index)); return Status::OK();}
Status Graph::AddFunctionLibrary(const FunctionDefLibrary& fdef\_lib) { // Need a new-enough consumer to support the functions we add to the graph. if (fdef\_lib.function\_size() > 0 && versions\_->min\_consumer() < 12) { versions\_->set\_min\_consumer(12); } return ops\_.AddLibrary(fdef\_lib);}
namespace {
void AddInput(NodeDef\* dst, StringPiece src\_name, int src\_slot) { if (src\_slot == Graph::kControlSlot) { dst->add\_input(strings::StrCat("^", src\_name)); } else if (src\_slot == 0) { dst->add\_input(src\_name.data(), src\_name.size()); } else { dst->add\_input(strings::StrCat(src\_name, ":", src\_slot)); }}
} // namespace
void Graph::ToGraphDef(GraphDef\* graph\_def) const { ToGraphDefSubRange(graph\_def, 0);}
GraphDef Graph::ToGraphDefDebug() const { GraphDef ret; ToGraphDef(&ret); return ret;}
void Graph::ToGraphDefSubRange(GraphDef\* graph\_def, int from\_node\_id) const { graph\_def->Clear(); \*graph\_def->mutable\_versions() = versions(); \*graph\_def->mutable\_library() = ops\_.ToProto();
 graph\_def->mutable\_node()->Reserve(std::max(1, num\_nodes() - from\_node\_id));
 std::vector<const Edge\*> inputs; // Construct this outside the loop for speed. for (auto id = from\_node\_id; id < num\_node\_ids(); ++id) { const Node\* node = FindNodeId(id); if (node == nullptr || !node->IsOp()) continue; NodeDef\* node\_def = graph\_def->add\_node(); \*node\_def = node->def();
 // Use the node's assigned device, if any, instead of the device requested // in the NodeDef. if (!node->assigned\_device\_name().empty()) { node\_def->set\_device(node->assigned\_device\_name()); }
 // Get the inputs for this Node. We make sure control inputs are // after data inputs, as required by GraphDef. inputs.clear(); inputs.resize(node->num\_inputs(), nullptr); for (const Edge\* edge : node->in\_edges()) { if (edge->IsControlEdge()) { inputs.push\_back(edge); } else { DCHECK(edge->dst\_input() < inputs.size()) << "Edge " << edge->DebugString() << " is overflowing the expected number of inputs (" << node->num\_inputs() << ") for node " << node->DebugString(); CHECK(inputs[edge->dst\_input()] == nullptr) << "Edge " << edge->src()->name() << "->" << edge->dst()->name() << " conflicts with pre-existing input edge " << inputs[edge->dst\_input()]->src()->name() << "->" << inputs[edge->dst\_input()]->dst()->name();
 inputs[edge->dst\_input()] = edge; } } // Sort the control inputs for more predictable serialization. std::sort(inputs.begin() + node->num\_inputs(), inputs.end(), [](const Edge\* a, const Edge\* b) -> bool { return a->src()->name() < b->src()->name(); }); node\_def->clear\_input(); node\_def->mutable\_input()->Reserve(inputs.size());
 for (size\_t i = 0; i < inputs.size(); ++i) { const Edge\* edge = inputs[i]; if (edge == nullptr) { if (i < node->requested\_inputs().size()) { node\_def->add\_input(node->requested\_inputs()[i]); } else { node\_def->add\_input(""); } } else { const Node\* src = edge->src(); if (!src->IsOp()) continue; AddInput(node\_def, src->name(), edge->src\_output()); } } }}
std::string Graph::NewName(StringPiece prefix) { return strings::StrCat(prefix, "/\_", name\_counter\_++);}
Status Graph::IsValidNode(const Node\* node) const { if (node == nullptr) { return errors::InvalidArgument("Node is null"); } const int id = node->id(); if (id < 0) { return errors::InvalidArgument("node id ", id, " is less than zero"); } if (static\_cast<size\_t>(id) >= nodes\_.size()) { return errors::InvalidArgument( "node id ", id, " is >= than number of nodes in graph ", nodes\_.size()); } if (nodes\_[id] != node) { return errors::InvalidArgument("Node with id ", id, " is different from the passed in node. " "Does it belong to a different graph?"); } return Status::OK();}
Status Graph::IsValidOutputTensor(const Node\* node, int idx) const { TF\_RETURN\_IF\_ERROR(IsValidNode(node)); if (idx >= node->num\_outputs() || idx < 0) { return errors::OutOfRange("Node '", node->name(), "' (type: '", node->op\_def().name(), "', num of outputs: ", node->num\_outputs(), ") does not have ", "output ", idx); } return Status::OK();}
Status Graph::IsValidInputTensor(const Node\* node, int idx) const { TF\_RETURN\_IF\_ERROR(IsValidNode(node)); if (idx >= node->num\_inputs() || idx < 0) { return errors::OutOfRange("Node '", node->name(), "' (type: '", node->op\_def().name(), "', num of inputs: ", node->num\_inputs(), ") does not have ", "input ", idx); } return Status::OK();}
Node\* Graph::AllocateNode(std::shared\_ptr<NodeProperties> props, const Node\* cost\_node, Node::NodeClass node\_class) { Node\* node = nullptr; if (free\_nodes\_.empty()) { node = new (arena\_.Alloc(sizeof(Node))) Node; // placement new } else { node = free\_nodes\_.back(); free\_nodes\_.pop\_back(); } node->graph\_ = this; const int id = nodes\_.size(); int cost\_id = cost\_node ? cost\_node->cost\_id() : id; node->Initialize(id, cost\_id, std::move(props), node\_class); nodes\_.push\_back(node); ++num\_nodes\_; return node;}
void Graph::ReleaseNode(Node\* node) { TF\_DCHECK\_OK(IsValidNode(node)) << node->DebugString(); nodes\_[node->id()] = nullptr; free\_nodes\_.push\_back(node); --num\_nodes\_; node->Clear();}
// Ensures that 'device\_name' is present in the device name table, and returns// the index of that device name. The index is stable, and can be used in// calls to Node::set\_assigned\_device\_name\_index().int Graph::InternDeviceName(const std::string& device\_name) { // Special case, very common. Also, this allows us to use a single map // lookup below, instead of two. The 'if (index\_cell > 0)' test below // relies on this check. if (device\_name.empty()) { return 0; }
 int& index\_cell = device\_names\_map\_[device\_name]; if (index\_cell > 0) { return index\_cell; }
 const int index = device\_names\_map\_.size(); index\_cell = index; device\_names\_.push\_back(device\_name); return index;}
Status Graph::AddWhileContext(StringPiece frame\_name, std::vector<Node\*> enter\_nodes, std::vector<Node\*> exit\_nodes, OutputTensor cond\_output, std::vector<OutputTensor> body\_inputs, std::vector<OutputTensor> body\_outputs, WhileContext\*\* result) { auto pair = while\_ctxs\_.insert(std::pair<std::string, WhileContext>( std::string(frame\_name), WhileContext(frame\_name, std::move(enter\_nodes), std::move(exit\_nodes), cond\_output, std::move(body\_inputs), std::move(body\_outputs)))); if (!pair.second) { \*result = nullptr; return errors::InvalidArgument("WhileContext with frame name '", frame\_name, "' already exists"); } \*result = &pair.first->second; return Status::OK();}
std::unordered\_map<std::string, Node\*> Graph::BuildNodeNameIndex() const { std::unordered\_map<std::string, Node\*> result; for (Node\* n : nodes()) { result[n->name()] = n; }[View remainder of file in raw view](https://github.com/tensorflow/tensorflow/raw/274df9b02330b790aa8de1cee164b70f72b9b244/tensorflow/core/graph/graph.cc)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_e02f7c85_20250114_193522.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fsecurity%2Fadvisories%2FGHSA-pqrv-8r2f-7278)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fsecurity%2Fadvisories%2FGHSA-pqrv-8r2f-7278)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=tensorflow%2Ftensorflow)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[tensorflow](/tensorflow)
/
**[tensorflow](/tensorflow/tensorflow)**
Public

* [Notifications](/login?return_to=%2Ftensorflow%2Ftensorflow) You must be signed in to change notification settings
* [Fork
  74.4k](/login?return_to=%2Ftensorflow%2Ftensorflow)
* [Star
   187k](/login?return_to=%2Ftensorflow%2Ftensorflow)

* [Code](/tensorflow/tensorflow)
* [Issues
  827](/tensorflow/tensorflow/issues)
* [Pull requests
  5k+](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects
  2](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

Additional navigation options

* [Code](/tensorflow/tensorflow)
* [Issues](/tensorflow/tensorflow/issues)
* [Pull requests](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

# Crash due to erroneous `StatusOr`

Moderate

[mihaimaruseac](/mihaimaruseac)
published
GHSA-pqrv-8r2f-7278
Feb 2, 2022

## Package

No package listed

## Affected versions

>= 2.7.0, < 2.8.0

## Patched versions

2.7.1

## Description

### Impact

A `GraphDef` from a TensorFlow `SavedModel` can be maliciously altered to cause a TensorFlow process to crash due to encountering [a `StatusOr` value that is an error and forcibly extracting the value from it](https://github.com/tensorflow/tensorflow/blob/274df9b02330b790aa8de1cee164b70f72b9b244/tensorflow/core/graph/graph.cc#L560-L567):

```
  if (op_reg_data->type_ctor != nullptr) {
    VLOG(3) << "AddNode: found type constructor for " << node_def.name();
    const auto ctor_type =
        full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);
    const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();
    if (ctor_typedef.type_id() != TFT_UNSET) {
      *(node_def.mutable_experimental_type()) = ctor_typedef;
    }
  }
```

If `ctor_type` is an error status, `ValueOrDie` results in a crash.

### Patches

We have patched the issue in GitHub commit [955059813cc325dc1db5e2daa6221271406d4439](https://github.com/tensorflow/tensorflow/commit/955059813cc325dc1db5e2daa6221271406d4439).

We have patched the issue in multiple GitHub commits and these will be included in TensorFlow 2.8.0 and TensorFlow 2.7.1, as both are affected.

### For more information

Please consult [our security guide](https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.

### Severity

Moderate

### CVE ID

CVE-2022-23590

### Weaknesses

No CWEs

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_03dbd30e_20250114_193521.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fcommit%2F955059813cc325dc1db5e2daa6221271406d4439)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fcommit%2F955059813cc325dc1db5e2daa6221271406d4439)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=tensorflow%2Ftensorflow)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[tensorflow](/tensorflow)
/
**[tensorflow](/tensorflow/tensorflow)**
Public

* [Notifications](/login?return_to=%2Ftensorflow%2Ftensorflow) You must be signed in to change notification settings
* [Fork
  74.4k](/login?return_to=%2Ftensorflow%2Ftensorflow)
* [Star
   187k](/login?return_to=%2Ftensorflow%2Ftensorflow)

* [Code](/tensorflow/tensorflow)
* [Issues
  827](/tensorflow/tensorflow/issues)
* [Pull requests
  5k+](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects
  2](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

Additional navigation options

* [Code](/tensorflow/tensorflow)
* [Issues](/tensorflow/tensorflow/issues)
* [Pull requests](/tensorflow/tensorflow/pulls)
* [Actions](/tensorflow/tensorflow/actions)
* [Projects](/tensorflow/tensorflow/projects)
* [Security](/tensorflow/tensorflow/security)
* [Insights](/tensorflow/tensorflow/pulse)

## Commit

[Permalink](/tensorflow/tensorflow/commit/955059813cc325dc1db5e2daa6221271406d4439)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

Check for type inference error on node construction.

[Browse files](/tensorflow/tensorflow/tree/955059813cc325dc1db5e2daa6221271406d4439)
Browse the repository at this point in the history

```
PiperOrigin-RevId: 409415804
Change-Id: Ieb6e020906b96f522bf8e2fa103715ddbbdc434a
```

* Loading branch information

[![@tensorflower-gardener](https://avatars.githubusercontent.com/u/17151892?s=40&v=4)](/tensorflower-gardener)

Dan Moldovan
authored and
[tensorflower-gardener](/tensorflow/tensorflow/commits?author=tensorflower-gardener "View all commits by tensorflower-gardener")
committed
Nov 12, 2021

1 parent
[3d89911](/tensorflow/tensorflow/commit/3d89911481ba6ebe8c88c1c0b595412121e6c645)

commit 9550598

Showing
**1 changed file**
with
**5 additions**
and
**0 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

## There are no files selected for viewing

5 changes: 5 additions & 0 deletions

5
[tensorflow/core/graph/graph.cc](#diff-aaa2b0be601f53326f36894b5ea9a48c01ff0cfcb979995a4772192060f910df "tensorflow/core/graph/graph.cc")

Show comments

[View file](/tensorflow/tensorflow/blob/955059813cc325dc1db5e2daa6221271406d4439/tensorflow/core/graph/graph.cc)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -561,6 +561,11 @@ Node\* Graph::AddNode(NodeDef node\_def, Status\* status) { |
|  |  | VLOG(3) << "AddNode: found type constructor for " << node\_def.name(); |
|  |  | const auto ctor\_type = |
|  |  | full\_type::SpecializeType(AttrSlice(node\_def), op\_reg\_data->op\_def); |
|  |  | if (!ctor\_type.ok()) { |
|  |  | \*status = errors::InvalidArgument("type error: ", |
|  |  | ctor\_type.status().ToString()); |
|  |  | return nullptr; |
|  |  | } |
|  |  | const FullTypeDef ctor\_typedef = ctor\_type.ValueOrDie(); |
|  |  | if (ctor\_typedef.type\_id() != TFT\_UNSET) { |
|  |  | \*(node\_def.mutable\_experimental\_type()) = ctor\_typedef; |
| Expand Down | |  |

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `9550598`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftensorflow%2Ftensorflow%2Fcommit%2F955059813cc325dc1db5e2daa6221271406d4439) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


