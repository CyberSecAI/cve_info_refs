```
{
  "CVE-2022-42703": {
    "description": "The provided text details an exploit for CVE-2022-42703, a use-after-free vulnerability in the Linux kernel's memory management subsystem affecting struct anon_vma. The vulnerability is triggered when folio->mapping points to a freed anon_vma object. Repeated accesses to the freed object via madvise(..., MADV_PAGEOUT) call can lead to memory corruption via down_read_trylock(). The exploit strategy involves reclaiming the freed anon_vma with attacker-controlled memory using pipe buffers and then overwriting saved registers on the interrupt stack to achieve kernel code execution.",
    "vulnerability_details": {
      "root_cause": "A use-after-free vulnerability occurs when folio->mapping points to a freed anon_vma object. Specifically, the kernel's MM subsystem incorrectly handles the reuse of anon_vma structures, leading to a dangling pointer.",
      "weaknesses": [
        "Use-after-free on struct anon_vma",
        "Insufficient access control in folio_lock_anon_vma_read()",
        "Unprotected down_read_trylock() call on attacker-controlled pointer"
      ],
      "impact": "An attacker can achieve arbitrary kernel memory read/write which can result in kernel code execution leading to full system compromise.",
      "attack_vectors": "The vulnerability is triggered by calling madvise(..., MADV_PAGEOUT) which repeatedly accesses the freed anon_vma object, causing a use-after-free. The arbitrary write primitive is then used to overwrite saved register on an exception stack. A prefetch side-channel is used to bypass KASLR.",
      "attacker_capabilities": "An attacker needs local code execution capabilities to trigger the use-after-free, reclaim freed memory with controlled content, set hardware breakpoints and finally to leverage the arbitrary write primitive. An attacker also needs to bypass KASLR."
    },
    "additional_information": "The provided content includes detailed steps of the exploit, including: \n1. Reclaiming freed anon_vma memory with controlled content using pipe buffers.\n2. Corrupting saved registers (specifically rcx) on the DB exception stack by using the arbitrary write primitive within down_read_trylock().\n3. Leaking KASLR slide using a prefetch side-channel attack.\n4. Creating a stack overflow condition by exploiting copy_from_user.\nThe content also highlights a weakness in KASLR as well as CPU entry area randomization mitigation, making it vulnerable to a local attacker."
  }
}
```