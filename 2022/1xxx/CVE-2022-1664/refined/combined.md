=== Content from lists.debian.org_0dc05656_20250114_192353.html ===


---

[[Date Prev](msg00114.html)][[Date Next](msg00116.html)]
[[Thread Prev](msg00114.html)][[Thread Next](msg00116.html)]
[[Date Index](maillist.html#00115)]
[[Thread Index](threads.html#00115)]

# [SECURITY] [DSA 5147-1] dpkg security update

---

* *To*: debian-security-announce@lists.debian.org
* *Subject*: [SECURITY] [DSA 5147-1] dpkg security update
* *From*: Salvatore Bonaccorso <carnil@debian.org>
* *Date*: Wed, 25 May 2022 15:31:54 +0000
* *Message-id*: <[[ðŸ”Ž]](/msgid-search/E1ntszK-0003ng-Lk%40seger.debian.org)Â [E1ntszK-0003ng-Lk@seger.debian.org](msg00115.html)>
* *Reply-to*: debian-security-announce-request@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

- -------------------------------------------------------------------------
Debian Security Advisory DSA-5147-1                   security@debian.org
<https://www.debian.org/security/>                     Salvatore Bonaccorso
May 25, 2022                          <https://www.debian.org/security/faq>
- -------------------------------------------------------------------------

Package        : dpkg
CVE ID         : CVE-2022-1664

Max Justicz reported a directory traversal vulnerability in
Dpkg::Source::Archive in dpkg, the Debian package management system.
This affects extracting untrusted source packages in the v2 and v3
source package formats that include a debian.tar.

For the oldstable distribution (buster), this problem has been fixed
in version 1.19.8.

For the stable distribution (bullseye), this problem has been fixed in
version 1.20.10.

We recommend that you upgrade your dpkg packages.

For the detailed security status of dpkg please refer to its security
tracker page at:
<https://security-tracker.debian.org/tracker/dpkg>

Further information about Debian Security Advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://www.debian.org/security/>

Mailing list: debian-security-announce@lists.debian.org
-----BEGIN PGP SIGNATURE-----

iQKTBAEBCgB9FiEERkRAmAjBceBVMd3uBUy48xNDz0QFAmKOS75fFIAAAAAALgAo
aXNzdWVyLWZwckBub3RhdGlvbnMub3BlbnBncC5maWZ0aGhvcnNlbWFuLm5ldDQ2
NDQ0MDk4MDhDMTcxRTA1NTMxRERFRTA1NENCOEYzMTM0M0NGNDQACgkQBUy48xND
z0SQiw//emxzoeBb84SW7etFMi/UQJZSPSg9sEcbD3IKAUU4DbZsz1rnPiydijHw
X7eYWx3SoCx4wItsLT5n9eMFCGoyMp0zPebv8T7ipr/0dhe+R5MNKkKqmvBZOO10
MP9o3rm2VA0wUSHeNNhFlQHf/4cFWYXSeQGdq5/iemZcYY+/nEt56EX9iEoQX5dq
AQ3eQ90nczZrOY3JSVtiJmv7btq19EcVDF54iqzKVdKis34305J77i+ZMVyYhMId
cuWsv6ZgvdjfqLb8hYVE4IlXJZHATx5NKzAx1g5ZkeC/rbZCTLoEoBi+VV7caRxB
7ailjM5E5Qcd8f/nIQDq9ZkPKF8kKc5FlFW+K7FKO2YbVhcwqAodFosphRMc9G7j
p98aTDjp7WC9if5QwgdiSdt3h2/hFRfRZd6otlk8ub8i/OT5pbvCBrCWPS8Q8Hr5
pLQ0SgUnyANBPhJiByg4Km+Rl/nzI0VbZqxb19zQeMJK+SJoEgYrhhzoR32ZCLs0
cqf5xnlaiXWwi2I7mTJP7RwWTnESXFBMW0IjhDW2UDqK26jSgjWjFPBb+4JKRk+M
vkhVbxCoZo5wh5LoOQAD5u34ggsZliid6cs7nNWXg3Wvw1kxh+WTnReVnlD4tcV7
jWlMgVOgCucWXGYXauB1b2nUTAXq5f/gjaCOF/yTi0jVuqgW9tI=
=zSO4
-----END PGP SIGNATURE-----

```

---



=== Content from git.dpkg.org_fd6d4dc3_20250114_192350.html ===


| [cgit logo](/cgit/) | [index](/cgit/) : [dpkg/dpkg.git](/cgit/dpkg/dpkg.git/) | 1.13.x 1.14.x 1.15.x 1.16.x 1.17.x 1.18.x 1.19.x 1.20.x 1.21.x bookworm bullseye buster etch jessie lenny main sid squeeze squeeze-backports stretch wheezy |
| --- | --- | --- |
| Debian package management system | [Dpkg Team](https://wiki.debian.org/Teams/Dpkg) |

| [summary](/cgit/dpkg/dpkg.git/)[refs](/cgit/dpkg/dpkg.git/refs/?id=58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5)[log](/cgit/dpkg/dpkg.git/log/)[tree](/cgit/dpkg/dpkg.git/tree/?id=58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5)[commit](/cgit/dpkg/dpkg.git/commit/?id=58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5)[diff](/cgit/dpkg/dpkg.git/diff/?id=58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Guillem Jover <guillem@debian.org> | 2022-05-03 02:09:32 +0200 |
| --- | --- | --- |
| committer | Guillem Jover <guillem@debian.org> | 2022-05-24 12:50:23 +0200 |
| commit | [58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5](/cgit/dpkg/dpkg.git/commit/?id=58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5) ([patch](/cgit/dpkg/dpkg.git/patch/?id=58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5)) | |
| tree | [da2e59bc9c19d42a0230871157963f795a5075c5](/cgit/dpkg/dpkg.git/tree/?id=58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5) | |
| parent | [708898e44763a0d33556b47a03c839c0ee3f3701](/cgit/dpkg/dpkg.git/commit/?id=708898e44763a0d33556b47a03c839c0ee3f3701) ([diff](/cgit/dpkg/dpkg.git/diff/?id=58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5&id2=708898e44763a0d33556b47a03c839c0ee3f3701)) | |

Dpkg::Source::Archive: Prevent directory traversal for in-place extractsFor untrusted v2 and v3 source package formats that include a debian.tar
archive, when we are extracting it, we do that as an in-place extraction,
which can lead to directory traversal situations on specially crafted
orig.tar and debian.tar tarballs.
GNU tar replaces entries on the filesystem by the entries present on
the tarball, but it will follow symlinks when the symlink pathname
itself is not present as an actual directory on the tarball.
This means we can create an orig.tar where there's a symlink pointing
out of the source tree root directory, and then a debian.tar that
contains an entry within that symlink as if it was a directory, without
a directory entry for the symlink pathname itself, which will be
extracted following the symlink outside the source tree root.
This is currently noted as expected in GNU tar documentation. But even
if there was a new extraction mode avoiding this problem we'd need such
new version. Using perl's Archive::Tar would solve the problem, but
switching to such different pure perl implementation, could cause
compatibility or performance issues.
What we do is when we are requested to perform an in-place extract, we
instead still use a temporary directory, then walk that directory and
remove any matching entry in the destination directory, replicating what
GNU tar would do, but in addition avoiding the directory traversal issue
for symlinks. Which should work with any tar implementation and be safe.
Reported-by: Max Justicz <max@justi.cz>
Stable-Candidates: 1.18.x 1.19.x 1.20.x
Fixes: commit 0c0057a27fecccab77d2b3cffa9a7d172846f0b4 (1.14.17)
Fixes: CVE-2022-1664
(cherry picked from commit 7a6c03cb34d4a09f35df2f10779cbf1b70a5200b)
[Diffstat](/cgit/dpkg/dpkg.git/diff/?id=58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5)

| -rw-r--r-- | [scripts/Dpkg/Source/Archive.pm](/cgit/dpkg/dpkg.git/diff/scripts/Dpkg/Source/Archive.pm?id=58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5) | 122 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [scripts/t/Dpkg\_Source\_Archive.t](/cgit/dpkg/dpkg.git/diff/scripts/t/Dpkg_Source_Archive.t?id=58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5) | 110 | |  |  |  | | --- | --- | --- | |

2 files changed, 204 insertions, 28 deletions

| diff --git a/scripts/Dpkg/Source/Archive.pm b/scripts/Dpkg/Source/Archive.pmindex 33c181b20..2ddd04af8 100644--- a/[scripts/Dpkg/Source/Archive.pm](/cgit/dpkg/dpkg.git/tree/scripts/Dpkg/Source/Archive.pm?id=708898e44763a0d33556b47a03c839c0ee3f3701)+++ b/[scripts/Dpkg/Source/Archive.pm](/cgit/dpkg/dpkg.git/tree/scripts/Dpkg/Source/Archive.pm?id=58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5)@@ -21,9 +21,11 @@ use warnings; our $VERSION = '0.01';  use Carp;+use Errno qw(ENOENT); use File::Temp qw(tempdir); use File::Basename qw(basename); use File::Spec;+use File::Find; use Cwd;  use Dpkg ();@@ -110,19 +112,13 @@ sub extract { my %spawn\_opts = (wait\_child => 1);  # Prepare destination- my $tmp;- if ($opts{in\_place}) {- $spawn\_opts{chdir} = $dest;- $tmp = $dest; # So that fixperms call works- } else {- my $template = basename($self->get\_filename()) . '.tmp-extract.XXXXX';- unless (-e $dest) {- # Kludge so that realpath works- mkdir($dest) or syserr(g\_('cannot create directory %s'), $dest);- }- $tmp = tempdir($template, DIR => Cwd::realpath("$dest/.."), CLEANUP => 1);- $spawn\_opts{chdir} = $tmp;+ my $template = basename($self->get\_filename()) . '.tmp-extract.XXXXX';+ unless (-e $dest) {+ # Kludge so that realpath works+ mkdir($dest) or syserr(g\_('cannot create directory %s'), $dest); }+ my $tmp = tempdir($template, DIR => Cwd::realpath("$dest/.."), CLEANUP => 1);+ $spawn\_opts{chdir} = $tmp;  # Prepare stuff that handles the input of tar $self->ensure\_open('r', delete\_sig => [ 'PIPE' ]);@@ -145,22 +141,94 @@ sub extract { # have to be calculated using mount options and other madness. fixperms($tmp) unless $opts{no\_fixperms}; - # Stop here if we extracted in-place as there's nothing to move around- return if $opts{in\_place};-- # Rename extracted directory- opendir(my $dir\_dh, $tmp) or syserr(g\_('cannot opendir %s'), $tmp);- my @entries = grep { $\_ ne '.' && $\_ ne '..' } readdir($dir\_dh);- closedir($dir\_dh);- my $done = 0;- erasedir($dest);- if (scalar(@entries) == 1 && ! -l "$tmp/$entries[0]" && -d \_) {- rename("$tmp/$entries[0]", $dest)- or syserr(g\_('unable to rename %s to %s'),- "$tmp/$entries[0]", $dest);+ # If we are extracting "in-place" do not remove the destination directory.+ if ($opts{in\_place}) {+ my $canon\_basedir = Cwd::realpath($dest);+ # On Solaris /dev/null points to /devices/pseudo/mm@0:null.+ my $canon\_devnull = Cwd::realpath('/dev/null');+ my $check\_symlink = sub {+ my $pathname = shift;+ my $canon\_pathname = Cwd::realpath($pathname);+ if (not defined $canon\_pathname) {+ return if $! == ENOENT;++ syserr(g\_("pathname '%s' cannot be canonicalized"), $pathname);+ }+ return if $canon\_pathname eq $canon\_devnull;+ return if $canon\_pathname eq $canon\_basedir;+ return if $canon\_pathname =~ m{^\Q$canon\_basedir/\E};+ warning(g\_("pathname '%s' points outside source root (to '%s')"),+ $pathname, $canon\_pathname);+ };++ my $move\_in\_place = sub {+ my $relpath = File::Spec->abs2rel($File::Find::name, $tmp);+ my $destpath = File::Spec->catfile($dest, $relpath);++ my ($mode, $atime, $mtime);+ lstat $File::Find::name+ or syserr(g\_('cannot get source pathname %s metadata'), $File::Find::name);+ ((undef) x 2, $mode, (undef) x 5, $atime, $mtime) = lstat \_;+ my $src\_is\_dir = -d \_;++ my $dest\_exists = 1;+ if (not lstat $destpath) {+ if ($! == ENOENT) {+ $dest\_exists = 0;+ } else {+ syserr(g\_('cannot get target pathname %s metadata'), $destpath);+ }+ }+ my $dest\_is\_dir = -d \_;+ if ($dest\_exists) {+ if ($dest\_is\_dir && $src\_is\_dir) {+ # Refresh the destination directory attributes with the+ # ones from the tarball.+ chmod $mode, $destpath+ or syserr(g\_('cannot change directory %s mode'), $File::Find::name);+ utime $atime, $mtime, $destpath+ or syserr(g\_('cannot change directory %s times'), $File::Find::name);++ # We should do nothing, and just walk further tree.+ return;+ } elsif ($dest\_is\_dir) {+ rmdir $destpath+ or syserr(g\_('cannot remove destination directory %s'), $destpath);+ } else {+ $check\_symlink->($destpath);+ unlink $destpath+ or syserr(g\_('cannot remove destination file %s'), $destpath);+ }+ }+ # If we are moving a directory, we do not need to walk it.+ if ($src\_is\_dir) {+ $File::Find::prune = 1;+ }+ rename $File::Find::name, $destpath+ or syserr(g\_('cannot move %s to %s'), $File::Find::name, $destpath);+ };++ find({+ wanted => $move\_in\_place,+ no\_chdir => 1,+ dangling\_symlinks => 0,+ }, $tmp); } else {- rename($tmp, $dest)- or syserr(g\_('unable to rename %s to %s'), $tmp, $dest);+ # Rename extracted directory+ opendir(my $dir\_dh, $tmp) or syserr(g\_('cannot opendir %s'), $tmp);+ my @entries = grep { $\_ ne '.' && $\_ ne '..' } readdir($dir\_dh);+ closedir($dir\_dh);++ erasedir($dest);++ if (scalar(@entries) == 1 && ! -l "$tmp/$entries[0]" && -d \_) {+ rename("$tmp/$entries[0]", $dest)+ or syserr(g\_('unable to rename %s to %s'),+ "$tmp/$entries[0]", $dest);+ } else {+ rename($tmp, $dest)+ or syserr(g\_('unable to rename %s to %s'), $tmp, $dest);+ } } erasedir($tmp); }diff --git a/scripts/t/Dpkg\_Source\_Archive.t b/scripts/t/Dpkg\_Source\_Archive.tindex 7b70da68e..504fbe1d4 100644--- a/[scripts/t/Dpkg\_Source\_Archive.t](/cgit/dpkg/dpkg.git/tree/scripts/t/Dpkg_Source_Archive.t?id=708898e44763a0d33556b47a03c839c0ee3f3701)+++ b/[scripts/t/Dpkg\_Source\_Archive.t](/cgit/dpkg/dpkg.git/tree/scripts/t/Dpkg_Source_Archive.t?id=58814cacee39c4ce9e2cd0e3a3b9b57ad437eff5)@@ -16,12 +16,120 @@ use strict; use warnings; -use Test::More tests => 1;+use Test::More tests => 4;+use Test::Dpkg qw(:paths);++use File::Spec;+use File::Path qw(make\_path rmtree);  BEGIN { use\_ok('Dpkg::Source::Archive'); } +use Dpkg;++my $tmpdir = test\_get\_temp\_path();++rmtree($tmpdir);++sub test\_touch+{+ my ($name, $data) = @\_;++ open my $fh, '>', $name+ or die "cannot touch file $name\n";+ print { $fh } $data if $data;+ close $fh;+}++sub test\_path\_escape+{+ my $name = shift;++ my $treedir = File::Spec->rel2abs("$tmpdir/$name-tree");+ my $overdir = File::Spec->rel2abs("$tmpdir/$name-overlay");+ my $outdir = "$tmpdir/$name-out";+ my $expdir = "$tmpdir/$name-exp";++ # This is the base directory, where we are going to be extracting stuff+ # into, which include traps.+ make\_path("$treedir/subdir-a");+ test\_touch("$treedir/subdir-a/file-a");+ test\_touch("$treedir/subdir-a/file-pre-a");+ make\_path("$treedir/subdir-b");+ test\_touch("$treedir/subdir-b/file-b");+ test\_touch("$treedir/subdir-b/file-pre-b");+ symlink File::Spec->abs2rel($outdir, $treedir), "$treedir/symlink-escape";+ symlink File::Spec->abs2rel("$outdir/nonexistent", $treedir), "$treedir/symlink-nonexistent";+ symlink "$treedir/file", "$treedir/symlink-within";+ test\_touch("$treedir/supposed-dir");++ # This is the overlay directory, which we'll pack and extract over the+ # base directory.+ make\_path($overdir);+ make\_path("$overdir/subdir-a/aa");+ test\_touch("$overdir/subdir-a/aa/file-aa", 'aa');+ test\_touch("$overdir/subdir-a/file-a", 'a');+ make\_path("$overdir/subdir-b/bb");+ test\_touch("$overdir/subdir-b/bb/file-bb", 'bb');+ test\_touch("$overdir/subdir-b/file-b", 'b');+ make\_path("$overdir/symlink-escape");+ test\_touch("$overdir/symlink-escape/escaped-file", 'escaped');+ test\_touch("$overdir/symlink-nonexistent", 'nonexistent');+ make\_path("$overdir/symlink-within");+ make\_path("$overdir/supposed-dir");+ test\_touch("$overdir/supposed-dir/supposed-file", 'something');++ # Generate overlay tar.+ system($Dpkg::PROGTAR, '-cf', "$overdir.tar", '-C', $overdir, qw(+ subdir-a subdir-b+ symlink-escape/escaped-file symlink-nonexistent symlink-within+ supposed-dir+ )) == 0+ or die "cannot create overlay tar archive\n";++ # This is the expected directory, which we'll be comparing against.+ make\_path($expdir);+ system('cp', '-a', $overdir, $expdir) == 0+ or die "cannot copy overlay hierarchy into expected directory\n";++ # Store the expected and out reference directories into a tar to compare+ # its structure against the result reference.+ system($Dpkg::PROGTAR, '-cf', "$expdir.tar", '-C', $overdir, qw(+ subdir-a subdir-b+ symlink-escape/escaped-file symlink-nonexistent symlink-within+ supposed-dir+ ), '-C', $treedir, qw(+ subdir-a/file-pre-a+ subdir-b/file-pre-b+ )) == 0+ or die "cannot create expected tar archive\n";++ # This directory is supposed to remain empty, anything inside implies a+ # directory traversal.+ make\_path($outdir);++ my $warnseen;+ local $SIG{\_\_WARN\_\_} = sub { $warnseen = $\_[0] };++ # Perform the extraction.+ my $tar = Dpkg::Source::Archive->new(filename => "$overdir.tar");+ $tar->extract($treedir, in\_place => 1);++ # Store the result into a tar to compare its structure against a reference.+ system($Dpkg::PROGTAR, '-cf', "$treedir.tar", '-C', $treedir, '.');++ # Check results+ ok(length $warnseen && $warnseen =~ m/points outside source root/,+ 'expected warning seen');+ ok(system($Dpkg::PROGTAR, '--compare', '-f', "$expdir.tar", '-C', $treedir) == 0,+ 'expected directory matches');+ ok(! -e "$outdir/escaped-file",+ 'expected output directory is empty, directory traversal');+}++test\_path\_escape('in-place');+ # TODO: Add actual test cases.  1; |
| --- |

generated by [cgit v1.2.3](https://git.zx2c4.com/cgit/about/) ([git 2.39.1](https://git-scm.com/)) at 2025-01-14 19:23:50 +0000



=== Content from security.netapp.com_5c29570f_20250114_192354.html ===

[Skip to main content](#n-main-content)

* [NetApp.com](https://www.netapp.com/)
* [Support](https://mysupport.netapp.com)
* [Community](https://community.netapp.com)
* [Training](https://www.netapp.com/support-and-training/netapp-learning-services/)

* [Contact Us](https://www.netapp.com/company/contact-us/)

English
Ã¦Â—Â¥Ã¦ÂœÂ¬Ã¨ÂªÂž

[netapp-mark

NetApp

## Product Security](https://security.netapp.com)

Search

Search

* Search

Search

Search

* [Home](https://security.netapp.com/en)
* [Advisories](https://security.netapp.com/advisory/)
* [Bulletins](https://security.netapp.com/bulletins/)
* [Contact](https://security.netapp.com/contact/)
* [Policy](https://security.netapp.com/policy/)
* [Resources](https://security.netapp.com/resources/)
* [Certifications](https://security.netapp.com/certs/)

* [Home](https://security.netapp.com/en)
* [Advisory](https://security.netapp.com/advisory)
* [CVE-2022-1664 Dpkg Vulnerability in NetApp Products](https://security.netapp.com/advisory/ntap-20221007-0002)

## CVE-2022-1664 Dpkg Vulnerability in NetApp Products

circle-check-alt

This advisory should be considered the single source of current, up-to-date, authorized and accurate information from NetApp regarding Full Support products and versions.

close Ã—

#### Subscribe to NTAP-20221007-0002 updates

Email

Yes, please send me emails when NetApp Security Advisories are posted or updated.

 By filling and submitting this form, I understand and agree with the [NetApp privacy policy](https://www.netapp.com/company/legal/privacy-policy/ "Privacy Policy") and understand that I can unsubscribe from NetApp Security Advisory communications at any time.

Subscribe

#### Subscribe to NTAP-20221007-0002 advisory updates

OTP

Confirm

ionicons-v5-e

Confirmed your subscription to advisory alerts

close Ã—

#### Unsubscribe from NTAP-20221007-0002 advisory updates

Email

Unsubscribe

#### Unsubscribe from NTAP-20221007-0002 advisory updates

Email

Confirm

ionicons-v5-e

Unsubscribed successfully from advisory alerts

Subscribe to receive email updates

**Advisory ID:** NTAP-20221007-0002
**Version:**
2.0

**Last updated:**
03/07/2024

**Status:**
Final.

**CVEs:** CVE-2022-1664

Overview
#### Summary

Multiple NetApp products incorporate the Debian package management system (dpkg). Dpkg versions prior to 1.21.8, 1.20.10, 1.19.8, and 1.18.26 are susceptible to a vulnerability which when successfully exploited could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS).

#### Impact

Successful exploitation of this vulnerability could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS).

#### Vulnerability Scoring Details

| **CVE** | **Score** | **Vector** |
| --- | --- | --- |
| [CVE-2022-1664](https://nvd.nist.gov/vuln/detail/CVE-2022-1664) | 9.8 (CRITICAL) | CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H |

#### Exploitation and Public Announcements

NetApp is aware of public discussion of this vulnerability.

#### References

* <https://lists.debian.org/debian-lts-announce/2022/05/msg00033.html>
* <https://lists.debian.org/debian-security-announce/2022/msg00115.html>

Affected Products
#### Affected Products

* ONTAP Select Deploy administration utility

#### Products Not Affected

* AFF Baseboard Management Controller (BMC) - A700s
* ATTO FibreBridge - 7500N
* ATTO FibreBridge - 7600N
* Active IQ Unified Manager for Linux
* Active IQ Unified Manager for Microsoft Windows
* Active IQ Unified Manager for VMware vSphere
* Active IQ mobile app
* Astra Control Center
* Astra Control Center - Cloud Insights Telegraf Agent
* Astra Control Center - NetApp Kubernetes Monitoring Operator
* Astra Trident
* Astra Trident Autosupport
* BlueXP Classification
* Brocade Fabric Operating System Firmware
* Brocade SAN Navigator (SANnav)
* Cloud Insights Acquisition Unit
* Cloud Insights Storage Workload Security Agent
* Cloud Insights Telegraf Agent
* Cloud Volumes ONTAP Mediator
* E-Series BIOS
* E-Series SANtricity OS Controller Software 11.x
* E-Series SANtricity Unified Manager and Web Services Proxy
* Element .NET SDK
* Element HealthTools
* Element JAVA SDK
* Element Plug-in for vCenter Server
* Element Powershell Tools
* Element Python SDK
* FAS/AFF BIOS - 8300/8700/A400/C400
* FAS/AFF Baseboard Management Controller (BMC) - 8300/8700/A400/C400
* FAS/AFF Baseboard Management Controller (BMC) - A250/500f/C250
* FAS/AFF Baseboard Management Controller (BMC) - A900/9500
* FAS/AFF Baseboard Management Controller (BMC) - C190/A150/A220/FAS2720/FAS2750
* Global File Cache
* Host Utilities - SAN for Linux
* Host Utilities - SAN for Windows
* IOM6 SAS Disk Shelf Firmware
* Management Services for Element Software and NetApp HCI
* MetroCluster Tiebreaker for clustered Data ONTAP
* Multipath I/O (SANtricity DSM for Windows MPIO)
* NetApp BlueXP
* NetApp Converged Systems Advisor Agent
* NetApp E-Series Host Collection
* NetApp E-Series SANtricity Collection
* NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H410S
* NetApp HCI Baseboard Management Controller (BMC) - H410C
* NetApp HCI Baseboard Management Controller (BMC) - H610C
* NetApp HCI Baseboard Management Controller (BMC) - H610S
* NetApp HCI Baseboard Management Controller (BMC) - H615C
* NetApp HCI Compute Node (Bootstrap OS)
* NetApp HCI Compute Node BIOS
* NetApp HCI Storage Node BIOS
* NetApp Kubernetes Monitoring Operator
* NetApp Manageability SDK
* NetApp NFS Plug-in for VMware VAAI
* NetApp ONTAP PowerShell Toolkit (PSTK)
* NetApp SolidFire & HCI Management Node
* NetApp SolidFire & HCI Storage Node (Element Software)
* NetApp SolidFire Plug-in for vRealize Orchestrator (SolidFire vRO)
* NetApp XCP NFS
* NetApp XCP SMB
* ONTAP 9 (formerly Clustered Data ONTAP)
* ONTAP Antivirus Connector
* ONTAP Mediator
* ONTAP tools for VMware vSphere 9
* OnCommand Insight
* OnCommand Workflow Automation
* SANtricity Storage Plugin for vCenter
* SRA Plugin for Linux
* SRA Plugin for Windows
* Single Mailbox Recovery
* Snap Creator Framework
* SnapCenter
* SnapCenter Plug-in for VMware vSphere/BlueXP backup and Recovery for Virtual Machine
* SnapManager for Hyper-V
* SolidFire Storage Replication Adapter
* StorageGRID (formerly StorageGRID Webscale)
* StorageGRID BIOS SG1000/SG100
* StorageGRID BIOS SG5660/SG5612/SG5760/SG5712
* StorageGRID BIOS SG6060/SGF6024/SGF6112
* StorageGRID Baseboard Management Controller (BMC)
* System Manager 9.x

Remediation
#### Software Versions and Fixes

NetApp's currently available patches are listed below.

| **Product** | **First Fixed in Release** |
| --- | --- |
| **ONTAP Select Deploy administration utility** | <https://mysupport.netapp.com/site/products/all/details/ontapselect-deploy/downloads-tab/download/62910/9.14.1> |

#### Workarounds

None at this time.

#### Obtaining Software Fixes

Software fixes will be made available through the NetApp Support website in the Software Download section.

<https://mysupport.netapp.com/site/downloads/>

Customers who do not have access to the Support website should contact Technical Support at the number below to obtain the patches.

#### Contact Information

Check <http://mysupport.netapp.com> for further
updates.

**Technical Support**

Revision History
#### Status of This Notice

**Final.**

This advisory should be considered the single source of current, up-to-date, authorized and accurate information from NetApp regarding Full Support products and versions.

This advisory is posted at the following link:

<https://security.netapp.com/advisory/NTAP-20221007-0002>
#### Revision History

| **Revision #** | **Date** | **Comments** |
| --- | --- | --- |
| 1.0 | 20221007 | Initial Public Release |
| 2.0 | 20240307 | ONTAP Select Deploy administration utility added to Software Versions and Fixes, Final status |

This document is provided solely for informational purposes. All information is based upon NetAppÃ¢Â€Â™s current knowledge and understanding of the hardware and software products tested by NetApp, and the methodology and assumptions used by NetApp. NetApp is not responsible for any errors or omissions that may be contained herein, and no warranty, representation, or other legal commitment or obligation is being provided by NetApp. Ã‚Â© 2025 NetApp, Inc. All rights reserved. No portions of this document may be reproduced without prior written consent of NetApp, Inc.

 Â©  NetApp

Have feedback for our website?
[Let us know](https://www.netapp.com/forms/site-feedback/)



=== Content from lists.debian.org_e06ca593_20250114_192353.html ===


---

[[Date Prev](msg00032.html)][[Date Next](msg00034.html)]
[[Thread Prev](msg00032.html)][[Thread Next](msg00034.html)]
[[Date Index](maillist.html#00033)]
[[Thread Index](threads.html#00033)]

# [SECURITY] [DLA 3022-1] dpkg security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 3022-1] dpkg security update
* *From*: Salvatore Bonaccorso <carnil@debian.org>
* *Date*: Wed, 25 May 2022 15:46:54 +0000
* *Message-id*: <[[ðŸ”Ž]](/msgid-search/E1nttDq-0008Ow-KK%40seger.debian.org)Â [E1nttDq-0008Ow-KK@seger.debian.org](msg00033.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

- -------------------------------------------------------------------------
Debian LTS Advisory DLA-3022-1                debian-lts@lists.debian.org
<https://www.debian.org/lts/security/>                 Salvatore Bonaccorso
May 25, 2022                                  <https://wiki.debian.org/LTS>
- -------------------------------------------------------------------------

Package        : dpkg
Version        : 1.18.26
CVE ID         : CVE-2022-1664

Max Justicz reported a directory traversal vulnerability in
Dpkg::Source::Archive in dpkg, the Debian package management system.
This affects extracting untrusted source packages in the v2 and v3
source package formats that include a debian.tar.

For Debian 9 stretch, this problem has been fixed in version
1.18.26.

We recommend that you upgrade your dpkg packages.

For the detailed security status of dpkg please refer to its security
tracker page at:
<https://security-tracker.debian.org/tracker/dpkg>

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>
-----BEGIN PGP SIGNATURE-----

iQKTBAEBCgB9FiEERkRAmAjBceBVMd3uBUy48xNDz0QFAmKOTlZfFIAAAAAALgAo
aXNzdWVyLWZwckBub3RhdGlvbnMub3BlbnBncC5maWZ0aGhvcnNlbWFuLm5ldDQ2
NDQ0MDk4MDhDMTcxRTA1NTMxRERFRTA1NENCOEYzMTM0M0NGNDQACgkQBUy48xND
z0RTPg//XGA+5fKdTCNBYP3+vUl2Uzab8R6GOZlRjljfX4htFwLzHGVe/v/6dy6P
4lYHGFeRV8PrWhpU7lwnDC6dIu9jDyuGXFh8hwa1SZUH1/ZtrjTozLdIc1WVj2OO
QZu4O9nAuWkUhWbd6D8+wegHML2A2Ywx1SpcWrFhe3Z2eg9WIQ0YvLx/tw7Kn+wX
u4UlEKw9ZvkH/SMZJ7TaImQsHh19Ba9O4JxlVeOw0bzYLjmQZpv0epRUEnwFy+Lm
q/APvG8F4FaK1tqvIOa4UzjdBAwOsNnmuNfk3AMybg1gie/HYP30RvnAcD7yAL+G
8RBNJ+wnPEs7ubz/5sYRn8sj35nIEjyXKodI7h1hqps4N7DRG3Dkz79wGDMdLfHk
8LnN67+LMFTwM52XJuKVewQMqgCYqq9mNgKptsUU1K9sRYfowt78Fegvkq9JObZ3
dekTgoZbd7KlyGlDY7U0PruUmUT6c9zi/rLKzLDOV5JwblggLPUW5GZ3WgqIxVf6
YVmd8cil2bNA7xNTlCM8DBuWYaNpiTiT7XE2rOlaHDj0xz2plwYrUJvPOoTIwvVx
JEY6IrV0DFfzzCCCjbepI33qxs7ifjTFoIABBOenVuXZ4RM4Dvi3ZdXNhkAojPOJ
QG01IGekLxt8F4RAGVi1fCM5NEf6vGNXG2WufZg9B6cnxywUsG8=
=QcTv
-----END PGP SIGNATURE-----

```

---



=== Content from git.dpkg.org_1934e1bd_20250114_192350.html ===


| [cgit logo](/cgit/) | [index](/cgit/) : [dpkg/dpkg.git](/cgit/dpkg/dpkg.git/) | 1.13.x 1.14.x 1.15.x 1.16.x 1.17.x 1.18.x 1.19.x 1.20.x 1.21.x bookworm bullseye buster etch jessie lenny main sid squeeze squeeze-backports stretch wheezy |
| --- | --- | --- |
| Debian package management system | [Dpkg Team](https://wiki.debian.org/Teams/Dpkg) |

| [summary](/cgit/dpkg/dpkg.git/)[refs](/cgit/dpkg/dpkg.git/refs/?id=1f23dddc17f69c9598477098c7fb9936e15fa495)[log](/cgit/dpkg/dpkg.git/log/)[tree](/cgit/dpkg/dpkg.git/tree/?id=1f23dddc17f69c9598477098c7fb9936e15fa495)[commit](/cgit/dpkg/dpkg.git/commit/?id=1f23dddc17f69c9598477098c7fb9936e15fa495)[diff](/cgit/dpkg/dpkg.git/diff/?id=1f23dddc17f69c9598477098c7fb9936e15fa495) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Guillem Jover <guillem@debian.org> | 2022-05-03 02:09:32 +0200 |
| --- | --- | --- |
| committer | Guillem Jover <guillem@debian.org> | 2022-05-24 12:50:54 +0200 |
| commit | [1f23dddc17f69c9598477098c7fb9936e15fa495](/cgit/dpkg/dpkg.git/commit/?id=1f23dddc17f69c9598477098c7fb9936e15fa495) ([patch](/cgit/dpkg/dpkg.git/patch/?id=1f23dddc17f69c9598477098c7fb9936e15fa495)) | |
| tree | [d171e53366a7643da44bb16f1be77b0f80998ea8](/cgit/dpkg/dpkg.git/tree/?id=1f23dddc17f69c9598477098c7fb9936e15fa495) | |
| parent | [9994817895fe72ea068c1bdf078e71515dde66fe](/cgit/dpkg/dpkg.git/commit/?id=9994817895fe72ea068c1bdf078e71515dde66fe) ([diff](/cgit/dpkg/dpkg.git/diff/?id=1f23dddc17f69c9598477098c7fb9936e15fa495&id2=9994817895fe72ea068c1bdf078e71515dde66fe)) | |

Dpkg::Source::Archive: Prevent directory traversal for in-place extractsFor untrusted v2 and v3 source package formats that include a debian.tar
archive, when we are extracting it, we do that as an in-place extraction,
which can lead to directory traversal situations on specially crafted
orig.tar and debian.tar tarballs.
GNU tar replaces entries on the filesystem by the entries present on
the tarball, but it will follow symlinks when the symlink pathname
itself is not present as an actual directory on the tarball.
This means we can create an orig.tar where there's a symlink pointing
out of the source tree root directory, and then a debian.tar that
contains an entry within that symlink as if it was a directory, without
a directory entry for the symlink pathname itself, which will be
extracted following the symlink outside the source tree root.
This is currently noted as expected in GNU tar documentation. But even
if there was a new extraction mode avoiding this problem we'd need such
new version. Using perl's Archive::Tar would solve the problem, but
switching to such different pure perl implementation, could cause
compatibility or performance issues.
What we do is when we are requested to perform an in-place extract, we
instead still use a temporary directory, then walk that directory and
remove any matching entry in the destination directory, replicating what
GNU tar would do, but in addition avoiding the directory traversal issue
for symlinks. Which should work with any tar implementation and be safe.
Reported-by: Max Justicz <max@justi.cz>
Stable-Candidates: 1.18.x 1.19.x 1.20.x
Fixes: commit 0c0057a27fecccab77d2b3cffa9a7d172846f0b4 (1.14.17)
Fixes: CVE-2022-1664
(cherry picked from commit 7a6c03cb34d4a09f35df2f10779cbf1b70a5200b)
[Diffstat](/cgit/dpkg/dpkg.git/diff/?id=1f23dddc17f69c9598477098c7fb9936e15fa495)

| -rw-r--r-- | [scripts/Dpkg/Source/Archive.pm](/cgit/dpkg/dpkg.git/diff/scripts/Dpkg/Source/Archive.pm?id=1f23dddc17f69c9598477098c7fb9936e15fa495) | 122 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [scripts/t/Dpkg\_Source\_Archive.t](/cgit/dpkg/dpkg.git/diff/scripts/t/Dpkg_Source_Archive.t?id=1f23dddc17f69c9598477098c7fb9936e15fa495) | 110 | |  |  |  | | --- | --- | --- | |

2 files changed, 204 insertions, 28 deletions

| diff --git a/scripts/Dpkg/Source/Archive.pm b/scripts/Dpkg/Source/Archive.pmindex 33c181b20..2ddd04af8 100644--- a/[scripts/Dpkg/Source/Archive.pm](/cgit/dpkg/dpkg.git/tree/scripts/Dpkg/Source/Archive.pm?id=9994817895fe72ea068c1bdf078e71515dde66fe)+++ b/[scripts/Dpkg/Source/Archive.pm](/cgit/dpkg/dpkg.git/tree/scripts/Dpkg/Source/Archive.pm?id=1f23dddc17f69c9598477098c7fb9936e15fa495)@@ -21,9 +21,11 @@ use warnings; our $VERSION = '0.01';  use Carp;+use Errno qw(ENOENT); use File::Temp qw(tempdir); use File::Basename qw(basename); use File::Spec;+use File::Find; use Cwd;  use Dpkg ();@@ -110,19 +112,13 @@ sub extract { my %spawn\_opts = (wait\_child => 1);  # Prepare destination- my $tmp;- if ($opts{in\_place}) {- $spawn\_opts{chdir} = $dest;- $tmp = $dest; # So that fixperms call works- } else {- my $template = basename($self->get\_filename()) . '.tmp-extract.XXXXX';- unless (-e $dest) {- # Kludge so that realpath works- mkdir($dest) or syserr(g\_('cannot create directory %s'), $dest);- }- $tmp = tempdir($template, DIR => Cwd::realpath("$dest/.."), CLEANUP => 1);- $spawn\_opts{chdir} = $tmp;+ my $template = basename($self->get\_filename()) . '.tmp-extract.XXXXX';+ unless (-e $dest) {+ # Kludge so that realpath works+ mkdir($dest) or syserr(g\_('cannot create directory %s'), $dest); }+ my $tmp = tempdir($template, DIR => Cwd::realpath("$dest/.."), CLEANUP => 1);+ $spawn\_opts{chdir} = $tmp;  # Prepare stuff that handles the input of tar $self->ensure\_open('r', delete\_sig => [ 'PIPE' ]);@@ -145,22 +141,94 @@ sub extract { # have to be calculated using mount options and other madness. fixperms($tmp) unless $opts{no\_fixperms}; - # Stop here if we extracted in-place as there's nothing to move around- return if $opts{in\_place};-- # Rename extracted directory- opendir(my $dir\_dh, $tmp) or syserr(g\_('cannot opendir %s'), $tmp);- my @entries = grep { $\_ ne '.' && $\_ ne '..' } readdir($dir\_dh);- closedir($dir\_dh);- my $done = 0;- erasedir($dest);- if (scalar(@entries) == 1 && ! -l "$tmp/$entries[0]" && -d \_) {- rename("$tmp/$entries[0]", $dest)- or syserr(g\_('unable to rename %s to %s'),- "$tmp/$entries[0]", $dest);+ # If we are extracting "in-place" do not remove the destination directory.+ if ($opts{in\_place}) {+ my $canon\_basedir = Cwd::realpath($dest);+ # On Solaris /dev/null points to /devices/pseudo/mm@0:null.+ my $canon\_devnull = Cwd::realpath('/dev/null');+ my $check\_symlink = sub {+ my $pathname = shift;+ my $canon\_pathname = Cwd::realpath($pathname);+ if (not defined $canon\_pathname) {+ return if $! == ENOENT;++ syserr(g\_("pathname '%s' cannot be canonicalized"), $pathname);+ }+ return if $canon\_pathname eq $canon\_devnull;+ return if $canon\_pathname eq $canon\_basedir;+ return if $canon\_pathname =~ m{^\Q$canon\_basedir/\E};+ warning(g\_("pathname '%s' points outside source root (to '%s')"),+ $pathname, $canon\_pathname);+ };++ my $move\_in\_place = sub {+ my $relpath = File::Spec->abs2rel($File::Find::name, $tmp);+ my $destpath = File::Spec->catfile($dest, $relpath);++ my ($mode, $atime, $mtime);+ lstat $File::Find::name+ or syserr(g\_('cannot get source pathname %s metadata'), $File::Find::name);+ ((undef) x 2, $mode, (undef) x 5, $atime, $mtime) = lstat \_;+ my $src\_is\_dir = -d \_;++ my $dest\_exists = 1;+ if (not lstat $destpath) {+ if ($! == ENOENT) {+ $dest\_exists = 0;+ } else {+ syserr(g\_('cannot get target pathname %s metadata'), $destpath);+ }+ }+ my $dest\_is\_dir = -d \_;+ if ($dest\_exists) {+ if ($dest\_is\_dir && $src\_is\_dir) {+ # Refresh the destination directory attributes with the+ # ones from the tarball.+ chmod $mode, $destpath+ or syserr(g\_('cannot change directory %s mode'), $File::Find::name);+ utime $atime, $mtime, $destpath+ or syserr(g\_('cannot change directory %s times'), $File::Find::name);++ # We should do nothing, and just walk further tree.+ return;+ } elsif ($dest\_is\_dir) {+ rmdir $destpath+ or syserr(g\_('cannot remove destination directory %s'), $destpath);+ } else {+ $check\_symlink->($destpath);+ unlink $destpath+ or syserr(g\_('cannot remove destination file %s'), $destpath);+ }+ }+ # If we are moving a directory, we do not need to walk it.+ if ($src\_is\_dir) {+ $File::Find::prune = 1;+ }+ rename $File::Find::name, $destpath+ or syserr(g\_('cannot move %s to %s'), $File::Find::name, $destpath);+ };++ find({+ wanted => $move\_in\_place,+ no\_chdir => 1,+ dangling\_symlinks => 0,+ }, $tmp); } else {- rename($tmp, $dest)- or syserr(g\_('unable to rename %s to %s'), $tmp, $dest);+ # Rename extracted directory+ opendir(my $dir\_dh, $tmp) or syserr(g\_('cannot opendir %s'), $tmp);+ my @entries = grep { $\_ ne '.' && $\_ ne '..' } readdir($dir\_dh);+ closedir($dir\_dh);++ erasedir($dest);++ if (scalar(@entries) == 1 && ! -l "$tmp/$entries[0]" && -d \_) {+ rename("$tmp/$entries[0]", $dest)+ or syserr(g\_('unable to rename %s to %s'),+ "$tmp/$entries[0]", $dest);+ } else {+ rename($tmp, $dest)+ or syserr(g\_('unable to rename %s to %s'), $tmp, $dest);+ } } erasedir($tmp); }diff --git a/scripts/t/Dpkg\_Source\_Archive.t b/scripts/t/Dpkg\_Source\_Archive.tindex 7b70da68e..504fbe1d4 100644--- a/[scripts/t/Dpkg\_Source\_Archive.t](/cgit/dpkg/dpkg.git/tree/scripts/t/Dpkg_Source_Archive.t?id=9994817895fe72ea068c1bdf078e71515dde66fe)+++ b/[scripts/t/Dpkg\_Source\_Archive.t](/cgit/dpkg/dpkg.git/tree/scripts/t/Dpkg_Source_Archive.t?id=1f23dddc17f69c9598477098c7fb9936e15fa495)@@ -16,12 +16,120 @@ use strict; use warnings; -use Test::More tests => 1;+use Test::More tests => 4;+use Test::Dpkg qw(:paths);++use File::Spec;+use File::Path qw(make\_path rmtree);  BEGIN { use\_ok('Dpkg::Source::Archive'); } +use Dpkg;++my $tmpdir = test\_get\_temp\_path();++rmtree($tmpdir);++sub test\_touch+{+ my ($name, $data) = @\_;++ open my $fh, '>', $name+ or die "cannot touch file $name\n";+ print { $fh } $data if $data;+ close $fh;+}++sub test\_path\_escape+{+ my $name = shift;++ my $treedir = File::Spec->rel2abs("$tmpdir/$name-tree");+ my $overdir = File::Spec->rel2abs("$tmpdir/$name-overlay");+ my $outdir = "$tmpdir/$name-out";+ my $expdir = "$tmpdir/$name-exp";++ # This is the base directory, where we are going to be extracting stuff+ # into, which include traps.+ make\_path("$treedir/subdir-a");+ test\_touch("$treedir/subdir-a/file-a");+ test\_touch("$treedir/subdir-a/file-pre-a");+ make\_path("$treedir/subdir-b");+ test\_touch("$treedir/subdir-b/file-b");+ test\_touch("$treedir/subdir-b/file-pre-b");+ symlink File::Spec->abs2rel($outdir, $treedir), "$treedir/symlink-escape";+ symlink File::Spec->abs2rel("$outdir/nonexistent", $treedir), "$treedir/symlink-nonexistent";+ symlink "$treedir/file", "$treedir/symlink-within";+ test\_touch("$treedir/supposed-dir");++ # This is the overlay directory, which we'll pack and extract over the+ # base directory.+ make\_path($overdir);+ make\_path("$overdir/subdir-a/aa");+ test\_touch("$overdir/subdir-a/aa/file-aa", 'aa');+ test\_touch("$overdir/subdir-a/file-a", 'a');+ make\_path("$overdir/subdir-b/bb");+ test\_touch("$overdir/subdir-b/bb/file-bb", 'bb');+ test\_touch("$overdir/subdir-b/file-b", 'b');+ make\_path("$overdir/symlink-escape");+ test\_touch("$overdir/symlink-escape/escaped-file", 'escaped');+ test\_touch("$overdir/symlink-nonexistent", 'nonexistent');+ make\_path("$overdir/symlink-within");+ make\_path("$overdir/supposed-dir");+ test\_touch("$overdir/supposed-dir/supposed-file", 'something');++ # Generate overlay tar.+ system($Dpkg::PROGTAR, '-cf', "$overdir.tar", '-C', $overdir, qw(+ subdir-a subdir-b+ symlink-escape/escaped-file symlink-nonexistent symlink-within+ supposed-dir+ )) == 0+ or die "cannot create overlay tar archive\n";++ # This is the expected directory, which we'll be comparing against.+ make\_path($expdir);+ system('cp', '-a', $overdir, $expdir) == 0+ or die "cannot copy overlay hierarchy into expected directory\n";++ # Store the expected and out reference directories into a tar to compare+ # its structure against the result reference.+ system($Dpkg::PROGTAR, '-cf', "$expdir.tar", '-C', $overdir, qw(+ subdir-a subdir-b+ symlink-escape/escaped-file symlink-nonexistent symlink-within+ supposed-dir+ ), '-C', $treedir, qw(+ subdir-a/file-pre-a+ subdir-b/file-pre-b+ )) == 0+ or die "cannot create expected tar archive\n";++ # This directory is supposed to remain empty, anything inside implies a+ # directory traversal.+ make\_path($outdir);++ my $warnseen;+ local $SIG{\_\_WARN\_\_} = sub { $warnseen = $\_[0] };++ # Perform the extraction.+ my $tar = Dpkg::Source::Archive->new(filename => "$overdir.tar");+ $tar->extract($treedir, in\_place => 1);++ # Store the result into a tar to compare its structure against a reference.+ system($Dpkg::PROGTAR, '-cf', "$treedir.tar", '-C', $treedir, '.');++ # Check results+ ok(length $warnseen && $warnseen =~ m/points outside source root/,+ 'expected warning seen');+ ok(system($Dpkg::PROGTAR, '--compare', '-f', "$expdir.tar", '-C', $treedir) == 0,+ 'expected directory matches');+ ok(! -e "$outdir/escaped-file",+ 'expected output directory is empty, directory traversal');+}++test\_path\_escape('in-place');+ # TODO: Add actual test cases.  1; |
| --- |

generated by [cgit v1.2.3](https://git.zx2c4.com/cgit/about/) ([git 2.39.1](https://git-scm.com/)) at 2025-01-14 19:23:49 +0000



=== Content from git.dpkg.org_b7d99454_20250114_192351.html ===


| [cgit logo](/cgit/) | [index](/cgit/) : [dpkg/dpkg.git](/cgit/dpkg/dpkg.git/) | 1.13.x 1.14.x 1.15.x 1.16.x 1.17.x 1.18.x 1.19.x 1.20.x 1.21.x bookworm bullseye buster etch jessie lenny main sid squeeze squeeze-backports stretch wheezy |
| --- | --- | --- |
| Debian package management system | [Dpkg Team](https://wiki.debian.org/Teams/Dpkg) |

| [summary](/cgit/dpkg/dpkg.git/)[refs](/cgit/dpkg/dpkg.git/refs/?id=7a6c03cb34d4a09f35df2f10779cbf1b70a5200b)[log](/cgit/dpkg/dpkg.git/log/)[tree](/cgit/dpkg/dpkg.git/tree/?id=7a6c03cb34d4a09f35df2f10779cbf1b70a5200b)[commit](/cgit/dpkg/dpkg.git/commit/?id=7a6c03cb34d4a09f35df2f10779cbf1b70a5200b)[diff](/cgit/dpkg/dpkg.git/diff/?id=7a6c03cb34d4a09f35df2f10779cbf1b70a5200b) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Guillem Jover <guillem@debian.org> | 2022-05-03 02:09:32 +0200 |
| --- | --- | --- |
| committer | Guillem Jover <guillem@debian.org> | 2022-05-24 12:49:03 +0200 |
| commit | [7a6c03cb34d4a09f35df2f10779cbf1b70a5200b](/cgit/dpkg/dpkg.git/commit/?id=7a6c03cb34d4a09f35df2f10779cbf1b70a5200b) ([patch](/cgit/dpkg/dpkg.git/patch/?id=7a6c03cb34d4a09f35df2f10779cbf1b70a5200b)) | |
| tree | [fe0aa961bae8e1c07e87ad97b623416eb88d5397](/cgit/dpkg/dpkg.git/tree/?id=7a6c03cb34d4a09f35df2f10779cbf1b70a5200b) | |
| parent | [b794831e0f4cf8b90ac3aef6463cf3b10377b0ee](/cgit/dpkg/dpkg.git/commit/?id=b794831e0f4cf8b90ac3aef6463cf3b10377b0ee) ([diff](/cgit/dpkg/dpkg.git/diff/?id=7a6c03cb34d4a09f35df2f10779cbf1b70a5200b&id2=b794831e0f4cf8b90ac3aef6463cf3b10377b0ee)) | |

Dpkg::Source::Archive: Prevent directory traversal for in-place extractsFor untrusted v2 and v3 source package formats that include a debian.tar
archive, when we are extracting it, we do that as an in-place extraction,
which can lead to directory traversal situations on specially crafted
orig.tar and debian.tar tarballs.
GNU tar replaces entries on the filesystem by the entries present on
the tarball, but it will follow symlinks when the symlink pathname
itself is not present as an actual directory on the tarball.
This means we can create an orig.tar where there's a symlink pointing
out of the source tree root directory, and then a debian.tar that
contains an entry within that symlink as if it was a directory, without
a directory entry for the symlink pathname itself, which will be
extracted following the symlink outside the source tree root.
This is currently noted as expected in GNU tar documentation. But even
if there was a new extraction mode avoiding this problem we'd need such
new version. Using perl's Archive::Tar would solve the problem, but
switching to such different pure perl implementation, could cause
compatibility or performance issues.
What we do is when we are requested to perform an in-place extract, we
instead still use a temporary directory, then walk that directory and
remove any matching entry in the destination directory, replicating what
GNU tar would do, but in addition avoiding the directory traversal issue
for symlinks. Which should work with any tar implementation and be safe.
Reported-by: Max Justicz <max@justi.cz>
Stable-Candidates: 1.18.x 1.19.x 1.20.x
Fixes: commit 0c0057a27fecccab77d2b3cffa9a7d172846f0b4 (1.14.17)
Fixes: CVE-2022-1664
[Diffstat](/cgit/dpkg/dpkg.git/diff/?id=7a6c03cb34d4a09f35df2f10779cbf1b70a5200b)

| -rw-r--r-- | [scripts/Dpkg/Source/Archive.pm](/cgit/dpkg/dpkg.git/diff/scripts/Dpkg/Source/Archive.pm?id=7a6c03cb34d4a09f35df2f10779cbf1b70a5200b) | 122 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [scripts/t/Dpkg\_Source\_Archive.t](/cgit/dpkg/dpkg.git/diff/scripts/t/Dpkg_Source_Archive.t?id=7a6c03cb34d4a09f35df2f10779cbf1b70a5200b) | 110 | |  |  |  | | --- | --- | --- | |

2 files changed, 204 insertions, 28 deletions

| diff --git a/scripts/Dpkg/Source/Archive.pm b/scripts/Dpkg/Source/Archive.pmindex 33c181b20..2ddd04af8 100644--- a/[scripts/Dpkg/Source/Archive.pm](/cgit/dpkg/dpkg.git/tree/scripts/Dpkg/Source/Archive.pm?id=b794831e0f4cf8b90ac3aef6463cf3b10377b0ee)+++ b/[scripts/Dpkg/Source/Archive.pm](/cgit/dpkg/dpkg.git/tree/scripts/Dpkg/Source/Archive.pm?id=7a6c03cb34d4a09f35df2f10779cbf1b70a5200b)@@ -21,9 +21,11 @@ use warnings; our $VERSION = '0.01';  use Carp;+use Errno qw(ENOENT); use File::Temp qw(tempdir); use File::Basename qw(basename); use File::Spec;+use File::Find; use Cwd;  use Dpkg ();@@ -110,19 +112,13 @@ sub extract { my %spawn\_opts = (wait\_child => 1);  # Prepare destination- my $tmp;- if ($opts{in\_place}) {- $spawn\_opts{chdir} = $dest;- $tmp = $dest; # So that fixperms call works- } else {- my $template = basename($self->get\_filename()) . '.tmp-extract.XXXXX';- unless (-e $dest) {- # Kludge so that realpath works- mkdir($dest) or syserr(g\_('cannot create directory %s'), $dest);- }- $tmp = tempdir($template, DIR => Cwd::realpath("$dest/.."), CLEANUP => 1);- $spawn\_opts{chdir} = $tmp;+ my $template = basename($self->get\_filename()) . '.tmp-extract.XXXXX';+ unless (-e $dest) {+ # Kludge so that realpath works+ mkdir($dest) or syserr(g\_('cannot create directory %s'), $dest); }+ my $tmp = tempdir($template, DIR => Cwd::realpath("$dest/.."), CLEANUP => 1);+ $spawn\_opts{chdir} = $tmp;  # Prepare stuff that handles the input of tar $self->ensure\_open('r', delete\_sig => [ 'PIPE' ]);@@ -145,22 +141,94 @@ sub extract { # have to be calculated using mount options and other madness. fixperms($tmp) unless $opts{no\_fixperms}; - # Stop here if we extracted in-place as there's nothing to move around- return if $opts{in\_place};-- # Rename extracted directory- opendir(my $dir\_dh, $tmp) or syserr(g\_('cannot opendir %s'), $tmp);- my @entries = grep { $\_ ne '.' && $\_ ne '..' } readdir($dir\_dh);- closedir($dir\_dh);- my $done = 0;- erasedir($dest);- if (scalar(@entries) == 1 && ! -l "$tmp/$entries[0]" && -d \_) {- rename("$tmp/$entries[0]", $dest)- or syserr(g\_('unable to rename %s to %s'),- "$tmp/$entries[0]", $dest);+ # If we are extracting "in-place" do not remove the destination directory.+ if ($opts{in\_place}) {+ my $canon\_basedir = Cwd::realpath($dest);+ # On Solaris /dev/null points to /devices/pseudo/mm@0:null.+ my $canon\_devnull = Cwd::realpath('/dev/null');+ my $check\_symlink = sub {+ my $pathname = shift;+ my $canon\_pathname = Cwd::realpath($pathname);+ if (not defined $canon\_pathname) {+ return if $! == ENOENT;++ syserr(g\_("pathname '%s' cannot be canonicalized"), $pathname);+ }+ return if $canon\_pathname eq $canon\_devnull;+ return if $canon\_pathname eq $canon\_basedir;+ return if $canon\_pathname =~ m{^\Q$canon\_basedir/\E};+ warning(g\_("pathname '%s' points outside source root (to '%s')"),+ $pathname, $canon\_pathname);+ };++ my $move\_in\_place = sub {+ my $relpath = File::Spec->abs2rel($File::Find::name, $tmp);+ my $destpath = File::Spec->catfile($dest, $relpath);++ my ($mode, $atime, $mtime);+ lstat $File::Find::name+ or syserr(g\_('cannot get source pathname %s metadata'), $File::Find::name);+ ((undef) x 2, $mode, (undef) x 5, $atime, $mtime) = lstat \_;+ my $src\_is\_dir = -d \_;++ my $dest\_exists = 1;+ if (not lstat $destpath) {+ if ($! == ENOENT) {+ $dest\_exists = 0;+ } else {+ syserr(g\_('cannot get target pathname %s metadata'), $destpath);+ }+ }+ my $dest\_is\_dir = -d \_;+ if ($dest\_exists) {+ if ($dest\_is\_dir && $src\_is\_dir) {+ # Refresh the destination directory attributes with the+ # ones from the tarball.+ chmod $mode, $destpath+ or syserr(g\_('cannot change directory %s mode'), $File::Find::name);+ utime $atime, $mtime, $destpath+ or syserr(g\_('cannot change directory %s times'), $File::Find::name);++ # We should do nothing, and just walk further tree.+ return;+ } elsif ($dest\_is\_dir) {+ rmdir $destpath+ or syserr(g\_('cannot remove destination directory %s'), $destpath);+ } else {+ $check\_symlink->($destpath);+ unlink $destpath+ or syserr(g\_('cannot remove destination file %s'), $destpath);+ }+ }+ # If we are moving a directory, we do not need to walk it.+ if ($src\_is\_dir) {+ $File::Find::prune = 1;+ }+ rename $File::Find::name, $destpath+ or syserr(g\_('cannot move %s to %s'), $File::Find::name, $destpath);+ };++ find({+ wanted => $move\_in\_place,+ no\_chdir => 1,+ dangling\_symlinks => 0,+ }, $tmp); } else {- rename($tmp, $dest)- or syserr(g\_('unable to rename %s to %s'), $tmp, $dest);+ # Rename extracted directory+ opendir(my $dir\_dh, $tmp) or syserr(g\_('cannot opendir %s'), $tmp);+ my @entries = grep { $\_ ne '.' && $\_ ne '..' } readdir($dir\_dh);+ closedir($dir\_dh);++ erasedir($dest);++ if (scalar(@entries) == 1 && ! -l "$tmp/$entries[0]" && -d \_) {+ rename("$tmp/$entries[0]", $dest)+ or syserr(g\_('unable to rename %s to %s'),+ "$tmp/$entries[0]", $dest);+ } else {+ rename($tmp, $dest)+ or syserr(g\_('unable to rename %s to %s'), $tmp, $dest);+ } } erasedir($tmp); }diff --git a/scripts/t/Dpkg\_Source\_Archive.t b/scripts/t/Dpkg\_Source\_Archive.tindex 7b70da68e..504fbe1d4 100644--- a/[scripts/t/Dpkg\_Source\_Archive.t](/cgit/dpkg/dpkg.git/tree/scripts/t/Dpkg_Source_Archive.t?id=b794831e0f4cf8b90ac3aef6463cf3b10377b0ee)+++ b/[scripts/t/Dpkg\_Source\_Archive.t](/cgit/dpkg/dpkg.git/tree/scripts/t/Dpkg_Source_Archive.t?id=7a6c03cb34d4a09f35df2f10779cbf1b70a5200b)@@ -16,12 +16,120 @@ use strict; use warnings; -use Test::More tests => 1;+use Test::More tests => 4;+use Test::Dpkg qw(:paths);++use File::Spec;+use File::Path qw(make\_path rmtree);  BEGIN { use\_ok('Dpkg::Source::Archive'); } +use Dpkg;++my $tmpdir = test\_get\_temp\_path();++rmtree($tmpdir);++sub test\_touch+{+ my ($name, $data) = @\_;++ open my $fh, '>', $name+ or die "cannot touch file $name\n";+ print { $fh } $data if $data;+ close $fh;+}++sub test\_path\_escape+{+ my $name = shift;++ my $treedir = File::Spec->rel2abs("$tmpdir/$name-tree");+ my $overdir = File::Spec->rel2abs("$tmpdir/$name-overlay");+ my $outdir = "$tmpdir/$name-out";+ my $expdir = "$tmpdir/$name-exp";++ # This is the base directory, where we are going to be extracting stuff+ # into, which include traps.+ make\_path("$treedir/subdir-a");+ test\_touch("$treedir/subdir-a/file-a");+ test\_touch("$treedir/subdir-a/file-pre-a");+ make\_path("$treedir/subdir-b");+ test\_touch("$treedir/subdir-b/file-b");+ test\_touch("$treedir/subdir-b/file-pre-b");+ symlink File::Spec->abs2rel($outdir, $treedir), "$treedir/symlink-escape";+ symlink File::Spec->abs2rel("$outdir/nonexistent", $treedir), "$treedir/symlink-nonexistent";+ symlink "$treedir/file", "$treedir/symlink-within";+ test\_touch("$treedir/supposed-dir");++ # This is the overlay directory, which we'll pack and extract over the+ # base directory.+ make\_path($overdir);+ make\_path("$overdir/subdir-a/aa");+ test\_touch("$overdir/subdir-a/aa/file-aa", 'aa');+ test\_touch("$overdir/subdir-a/file-a", 'a');+ make\_path("$overdir/subdir-b/bb");+ test\_touch("$overdir/subdir-b/bb/file-bb", 'bb');+ test\_touch("$overdir/subdir-b/file-b", 'b');+ make\_path("$overdir/symlink-escape");+ test\_touch("$overdir/symlink-escape/escaped-file", 'escaped');+ test\_touch("$overdir/symlink-nonexistent", 'nonexistent');+ make\_path("$overdir/symlink-within");+ make\_path("$overdir/supposed-dir");+ test\_touch("$overdir/supposed-dir/supposed-file", 'something');++ # Generate overlay tar.+ system($Dpkg::PROGTAR, '-cf', "$overdir.tar", '-C', $overdir, qw(+ subdir-a subdir-b+ symlink-escape/escaped-file symlink-nonexistent symlink-within+ supposed-dir+ )) == 0+ or die "cannot create overlay tar archive\n";++ # This is the expected directory, which we'll be comparing against.+ make\_path($expdir);+ system('cp', '-a', $overdir, $expdir) == 0+ or die "cannot copy overlay hierarchy into expected directory\n";++ # Store the expected and out reference directories into a tar to compare+ # its structure against the result reference.+ system($Dpkg::PROGTAR, '-cf', "$expdir.tar", '-C', $overdir, qw(+ subdir-a subdir-b+ symlink-escape/escaped-file symlink-nonexistent symlink-within+ supposed-dir+ ), '-C', $treedir, qw(+ subdir-a/file-pre-a+ subdir-b/file-pre-b+ )) == 0+ or die "cannot create expected tar archive\n";++ # This directory is supposed to remain empty, anything inside implies a+ # directory traversal.+ make\_path($outdir);++ my $warnseen;+ local $SIG{\_\_WARN\_\_} = sub { $warnseen = $\_[0] };++ # Perform the extraction.+ my $tar = Dpkg::Source::Archive->new(filename => "$overdir.tar");+ $tar->extract($treedir, in\_place => 1);++ # Store the result into a tar to compare its structure against a reference.+ system($Dpkg::PROGTAR, '-cf', "$treedir.tar", '-C', $treedir, '.');++ # Check results+ ok(length $warnseen && $warnseen =~ m/points outside source root/,+ 'expected warning seen');+ ok(system($Dpkg::PROGTAR, '--compare', '-f', "$expdir.tar", '-C', $treedir) == 0,+ 'expected directory matches');+ ok(! -e "$outdir/escaped-file",+ 'expected output directory is empty, directory traversal');+}++test\_path\_escape('in-place');+ # TODO: Add actual test cases.  1; |
| --- |

generated by [cgit v1.2.3](https://git.zx2c4.com/cgit/about/) ([git 2.39.1](https://git-scm.com/)) at 2025-01-14 19:23:51 +0000



=== Content from security.netapp.com_8b8bd271_20250115_114408.html ===

[Skip to main content](#n-main-content)

* [NetApp.com](https://www.netapp.com/)
* [Support](https://mysupport.netapp.com)
* [Community](https://community.netapp.com)
* [Training](https://www.netapp.com/support-and-training/netapp-learning-services/)

* [Contact Us](https://www.netapp.com/company/contact-us/)

English
Ã¦Â—Â¥Ã¦ÂœÂ¬Ã¨ÂªÂž

[netapp-mark

NetApp

## Product Security](https://security.netapp.com)

Search

Search

* Search

Search

Search

* [Home](https://security.netapp.com/en)
* [Advisories](https://security.netapp.com/advisory/)
* [Bulletins](https://security.netapp.com/bulletins/)
* [Contact](https://security.netapp.com/contact/)
* [Policy](https://security.netapp.com/policy/)
* [Resources](https://security.netapp.com/resources/)
* [Certifications](https://security.netapp.com/certs/)

* [Home](https://security.netapp.com/en)
* [Advisory](https://security.netapp.com/advisory)
* [CVE-2022-1664 Dpkg Vulnerability in NetApp Products](https://security.netapp.com/advisory/ntap-20221007-0002)

## CVE-2022-1664 Dpkg Vulnerability in NetApp Products

circle-check-alt

This advisory should be considered the single source of current, up-to-date, authorized and accurate information from NetApp regarding Full Support products and versions.

close Ã—

#### Subscribe to NTAP-20221007-0002 updates

Email

Yes, please send me emails when NetApp Security Advisories are posted or updated.

 By filling and submitting this form, I understand and agree with the [NetApp privacy policy](https://www.netapp.com/company/legal/privacy-policy/ "Privacy Policy") and understand that I can unsubscribe from NetApp Security Advisory communications at any time.

Subscribe

#### Subscribe to NTAP-20221007-0002 advisory updates

OTP

Confirm

ionicons-v5-e

Confirmed your subscription to advisory alerts

close Ã—

#### Unsubscribe from NTAP-20221007-0002 advisory updates

Email

Unsubscribe

#### Unsubscribe from NTAP-20221007-0002 advisory updates

Email

Confirm

ionicons-v5-e

Unsubscribed successfully from advisory alerts

Subscribe to receive email updates

**Advisory ID:** NTAP-20221007-0002
**Version:**
2.0

**Last updated:**
03/07/2024

**Status:**
Final.

**CVEs:** CVE-2022-1664

Overview
#### Summary

Multiple NetApp products incorporate the Debian package management system (dpkg). Dpkg versions prior to 1.21.8, 1.20.10, 1.19.8, and 1.18.26 are susceptible to a vulnerability which when successfully exploited could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS).

#### Impact

Successful exploitation of this vulnerability could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS).

#### Vulnerability Scoring Details

| **CVE** | **Score** | **Vector** |
| --- | --- | --- |
| [CVE-2022-1664](https://nvd.nist.gov/vuln/detail/CVE-2022-1664) | 9.8 (CRITICAL) | CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H |

#### Exploitation and Public Announcements

NetApp is aware of public discussion of this vulnerability.

#### References

* <https://lists.debian.org/debian-lts-announce/2022/05/msg00033.html>
* <https://lists.debian.org/debian-security-announce/2022/msg00115.html>

Affected Products
#### Affected Products

* ONTAP Select Deploy administration utility

#### Products Not Affected

* AFF Baseboard Management Controller (BMC) - A700s
* ATTO FibreBridge - 7500N
* ATTO FibreBridge - 7600N
* Active IQ Unified Manager for Linux
* Active IQ Unified Manager for Microsoft Windows
* Active IQ Unified Manager for VMware vSphere
* Active IQ mobile app
* Astra Control Center
* Astra Control Center - Cloud Insights Telegraf Agent
* Astra Control Center - NetApp Kubernetes Monitoring Operator
* Astra Trident
* Astra Trident Autosupport
* BlueXP Classification
* Brocade Fabric Operating System Firmware
* Brocade SAN Navigator (SANnav)
* Cloud Insights Acquisition Unit
* Cloud Insights Storage Workload Security Agent
* Cloud Insights Telegraf Agent
* Cloud Volumes ONTAP Mediator
* E-Series BIOS
* E-Series SANtricity OS Controller Software 11.x
* E-Series SANtricity Unified Manager and Web Services Proxy
* Element .NET SDK
* Element HealthTools
* Element JAVA SDK
* Element Plug-in for vCenter Server
* Element Powershell Tools
* Element Python SDK
* FAS/AFF BIOS - 8300/8700/A400/C400
* FAS/AFF Baseboard Management Controller (BMC) - 8300/8700/A400/C400
* FAS/AFF Baseboard Management Controller (BMC) - A250/500f/C250
* FAS/AFF Baseboard Management Controller (BMC) - A900/9500
* FAS/AFF Baseboard Management Controller (BMC) - C190/A150/A220/FAS2720/FAS2750
* Global File Cache
* Host Utilities - SAN for Linux
* Host Utilities - SAN for Windows
* IOM6 SAS Disk Shelf Firmware
* Management Services for Element Software and NetApp HCI
* MetroCluster Tiebreaker for clustered Data ONTAP
* Multipath I/O (SANtricity DSM for Windows MPIO)
* NetApp BlueXP
* NetApp Converged Systems Advisor Agent
* NetApp E-Series Host Collection
* NetApp E-Series SANtricity Collection
* NetApp HCI Baseboard Management Controller (BMC) - H300S/H500S/H700S/H410S
* NetApp HCI Baseboard Management Controller (BMC) - H410C
* NetApp HCI Baseboard Management Controller (BMC) - H610C
* NetApp HCI Baseboard Management Controller (BMC) - H610S
* NetApp HCI Baseboard Management Controller (BMC) - H615C
* NetApp HCI Compute Node (Bootstrap OS)
* NetApp HCI Compute Node BIOS
* NetApp HCI Storage Node BIOS
* NetApp Kubernetes Monitoring Operator
* NetApp Manageability SDK
* NetApp NFS Plug-in for VMware VAAI
* NetApp ONTAP PowerShell Toolkit (PSTK)
* NetApp SolidFire & HCI Management Node
* NetApp SolidFire & HCI Storage Node (Element Software)
* NetApp SolidFire Plug-in for vRealize Orchestrator (SolidFire vRO)
* NetApp XCP NFS
* NetApp XCP SMB
* ONTAP 9 (formerly Clustered Data ONTAP)
* ONTAP Antivirus Connector
* ONTAP Mediator
* ONTAP tools for VMware vSphere 9
* OnCommand Insight
* OnCommand Workflow Automation
* SANtricity Storage Plugin for vCenter
* SRA Plugin for Linux
* SRA Plugin for Windows
* Single Mailbox Recovery
* Snap Creator Framework
* SnapCenter
* SnapCenter Plug-in for VMware vSphere/BlueXP backup and Recovery for Virtual Machine
* SnapManager for Hyper-V
* SolidFire Storage Replication Adapter
* StorageGRID (formerly StorageGRID Webscale)
* StorageGRID BIOS SG1000/SG100
* StorageGRID BIOS SG5660/SG5612/SG5760/SG5712
* StorageGRID BIOS SG6060/SGF6024/SGF6112
* StorageGRID Baseboard Management Controller (BMC)
* System Manager 9.x

Remediation
#### Software Versions and Fixes

NetApp's currently available patches are listed below.

| **Product** | **First Fixed in Release** |
| --- | --- |
| **ONTAP Select Deploy administration utility** | <https://mysupport.netapp.com/site/products/all/details/ontapselect-deploy/downloads-tab/download/62910/9.14.1> |

#### Workarounds

None at this time.

#### Obtaining Software Fixes

Software fixes will be made available through the NetApp Support website in the Software Download section.

<https://mysupport.netapp.com/site/downloads/>

Customers who do not have access to the Support website should contact Technical Support at the number below to obtain the patches.

#### Contact Information

Check <http://mysupport.netapp.com> for further
updates.

**Technical Support**

Revision History
#### Status of This Notice

**Final.**

This advisory should be considered the single source of current, up-to-date, authorized and accurate information from NetApp regarding Full Support products and versions.

This advisory is posted at the following link:

<https://security.netapp.com/advisory/NTAP-20221007-0002>
#### Revision History

| **Revision #** | **Date** | **Comments** |
| --- | --- | --- |
| 1.0 | 20221007 | Initial Public Release |
| 2.0 | 20240307 | ONTAP Select Deploy administration utility added to Software Versions and Fixes, Final status |

This document is provided solely for informational purposes. All information is based upon NetAppÃ¢Â€Â™s current knowledge and understanding of the hardware and software products tested by NetApp, and the methodology and assumptions used by NetApp. NetApp is not responsible for any errors or omissions that may be contained herein, and no warranty, representation, or other legal commitment or obligation is being provided by NetApp. Ã‚Â© 2025 NetApp, Inc. All rights reserved. No portions of this document may be reproduced without prior written consent of NetApp, Inc.

 Â©  NetApp

Have feedback for our website?
[Let us know](https://www.netapp.com/forms/site-feedback/)



=== Content from git.dpkg.org_549df7a6_20250114_192352.html ===


| [cgit logo](/cgit/) | [index](/cgit/) : [dpkg/dpkg.git](/cgit/dpkg/dpkg.git/) | 1.13.x 1.14.x 1.15.x 1.16.x 1.17.x 1.18.x 1.19.x 1.20.x 1.21.x bookworm bullseye buster etch jessie lenny main sid squeeze squeeze-backports stretch wheezy |
| --- | --- | --- |
| Debian package management system | [Dpkg Team](https://wiki.debian.org/Teams/Dpkg) |

| [summary](/cgit/dpkg/dpkg.git/)[refs](/cgit/dpkg/dpkg.git/refs/?id=faa4c92debe45412bfcf8a44f26e827800bb24be)[log](/cgit/dpkg/dpkg.git/log/)[tree](/cgit/dpkg/dpkg.git/tree/?id=faa4c92debe45412bfcf8a44f26e827800bb24be)[commit](/cgit/dpkg/dpkg.git/commit/?id=faa4c92debe45412bfcf8a44f26e827800bb24be)[diff](/cgit/dpkg/dpkg.git/diff/?id=faa4c92debe45412bfcf8a44f26e827800bb24be) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Guillem Jover <guillem@debian.org> | 2022-05-03 02:09:32 +0200 |
| --- | --- | --- |
| committer | Guillem Jover <guillem@debian.org> | 2022-05-24 14:58:50 +0200 |
| commit | [faa4c92debe45412bfcf8a44f26e827800bb24be](/cgit/dpkg/dpkg.git/commit/?id=faa4c92debe45412bfcf8a44f26e827800bb24be) ([patch](/cgit/dpkg/dpkg.git/patch/?id=faa4c92debe45412bfcf8a44f26e827800bb24be)) | |
| tree | [163b955283a1e281ad32bf7e1d763b627ff553d5](/cgit/dpkg/dpkg.git/tree/?id=faa4c92debe45412bfcf8a44f26e827800bb24be) | |
| parent | [bb73779d2110d8e902f11da66ed87e0e4589f497](/cgit/dpkg/dpkg.git/commit/?id=bb73779d2110d8e902f11da66ed87e0e4589f497) ([diff](/cgit/dpkg/dpkg.git/diff/?id=faa4c92debe45412bfcf8a44f26e827800bb24be&id2=bb73779d2110d8e902f11da66ed87e0e4589f497)) | |

Dpkg::Source::Archive: Prevent directory traversal for in-place extractsFor untrusted v2 and v3 source package formats that include a debian.tar
archive, when we are extracting it, we do that as an in-place extraction,
which can lead to directory traversal situations on specially crafted
orig.tar and debian.tar tarballs.
GNU tar replaces entries on the filesystem by the entries present on
the tarball, but it will follow symlinks when the symlink pathname
itself is not present as an actual directory on the tarball.
This means we can create an orig.tar where there's a symlink pointing
out of the source tree root directory, and then a debian.tar that
contains an entry within that symlink as if it was a directory, without
a directory entry for the symlink pathname itself, which will be
extracted following the symlink outside the source tree root.
This is currently noted as expected in GNU tar documentation. But even
if there was a new extraction mode avoiding this problem we'd need such
new version. Using perl's Archive::Tar would solve the problem, but
switching to such different pure perl implementation, could cause
compatibility or performance issues.
What we do is when we are requested to perform an in-place extract, we
instead still use a temporary directory, then walk that directory and
remove any matching entry in the destination directory, replicating what
GNU tar would do, but in addition avoiding the directory traversal issue
for symlinks. Which should work with any tar implementation and be safe.
Reported-by: Max Justicz <max@justi.cz>
Stable-Candidates: 1.18.x 1.19.x 1.20.x
Fixes: commit 0c0057a27fecccab77d2b3cffa9a7d172846f0b4 (1.14.17)
Fixes: CVE-2022-1664
(cherry picked from commit 7a6c03cb34d4a09f35df2f10779cbf1b70a5200b)
[Diffstat](/cgit/dpkg/dpkg.git/diff/?id=faa4c92debe45412bfcf8a44f26e827800bb24be)

| -rw-r--r-- | [scripts/Dpkg/Source/Archive.pm](/cgit/dpkg/dpkg.git/diff/scripts/Dpkg/Source/Archive.pm?id=faa4c92debe45412bfcf8a44f26e827800bb24be) | 122 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |
| -rw-r--r-- | [scripts/t/Dpkg\_Source\_Archive.t](/cgit/dpkg/dpkg.git/diff/scripts/t/Dpkg_Source_Archive.t?id=faa4c92debe45412bfcf8a44f26e827800bb24be) | 110 | |  |  |  | | --- | --- | --- | |

2 files changed, 204 insertions, 28 deletions

| diff --git a/scripts/Dpkg/Source/Archive.pm b/scripts/Dpkg/Source/Archive.pmindex 33c181b20..2ddd04af8 100644--- a/[scripts/Dpkg/Source/Archive.pm](/cgit/dpkg/dpkg.git/tree/scripts/Dpkg/Source/Archive.pm?id=bb73779d2110d8e902f11da66ed87e0e4589f497)+++ b/[scripts/Dpkg/Source/Archive.pm](/cgit/dpkg/dpkg.git/tree/scripts/Dpkg/Source/Archive.pm?id=faa4c92debe45412bfcf8a44f26e827800bb24be)@@ -21,9 +21,11 @@ use warnings; our $VERSION = '0.01';  use Carp;+use Errno qw(ENOENT); use File::Temp qw(tempdir); use File::Basename qw(basename); use File::Spec;+use File::Find; use Cwd;  use Dpkg ();@@ -110,19 +112,13 @@ sub extract { my %spawn\_opts = (wait\_child => 1);  # Prepare destination- my $tmp;- if ($opts{in\_place}) {- $spawn\_opts{chdir} = $dest;- $tmp = $dest; # So that fixperms call works- } else {- my $template = basename($self->get\_filename()) . '.tmp-extract.XXXXX';- unless (-e $dest) {- # Kludge so that realpath works- mkdir($dest) or syserr(g\_('cannot create directory %s'), $dest);- }- $tmp = tempdir($template, DIR => Cwd::realpath("$dest/.."), CLEANUP => 1);- $spawn\_opts{chdir} = $tmp;+ my $template = basename($self->get\_filename()) . '.tmp-extract.XXXXX';+ unless (-e $dest) {+ # Kludge so that realpath works+ mkdir($dest) or syserr(g\_('cannot create directory %s'), $dest); }+ my $tmp = tempdir($template, DIR => Cwd::realpath("$dest/.."), CLEANUP => 1);+ $spawn\_opts{chdir} = $tmp;  # Prepare stuff that handles the input of tar $self->ensure\_open('r', delete\_sig => [ 'PIPE' ]);@@ -145,22 +141,94 @@ sub extract { # have to be calculated using mount options and other madness. fixperms($tmp) unless $opts{no\_fixperms}; - # Stop here if we extracted in-place as there's nothing to move around- return if $opts{in\_place};-- # Rename extracted directory- opendir(my $dir\_dh, $tmp) or syserr(g\_('cannot opendir %s'), $tmp);- my @entries = grep { $\_ ne '.' && $\_ ne '..' } readdir($dir\_dh);- closedir($dir\_dh);- my $done = 0;- erasedir($dest);- if (scalar(@entries) == 1 && ! -l "$tmp/$entries[0]" && -d \_) {- rename("$tmp/$entries[0]", $dest)- or syserr(g\_('unable to rename %s to %s'),- "$tmp/$entries[0]", $dest);+ # If we are extracting "in-place" do not remove the destination directory.+ if ($opts{in\_place}) {+ my $canon\_basedir = Cwd::realpath($dest);+ # On Solaris /dev/null points to /devices/pseudo/mm@0:null.+ my $canon\_devnull = Cwd::realpath('/dev/null');+ my $check\_symlink = sub {+ my $pathname = shift;+ my $canon\_pathname = Cwd::realpath($pathname);+ if (not defined $canon\_pathname) {+ return if $! == ENOENT;++ syserr(g\_("pathname '%s' cannot be canonicalized"), $pathname);+ }+ return if $canon\_pathname eq $canon\_devnull;+ return if $canon\_pathname eq $canon\_basedir;+ return if $canon\_pathname =~ m{^\Q$canon\_basedir/\E};+ warning(g\_("pathname '%s' points outside source root (to '%s')"),+ $pathname, $canon\_pathname);+ };++ my $move\_in\_place = sub {+ my $relpath = File::Spec->abs2rel($File::Find::name, $tmp);+ my $destpath = File::Spec->catfile($dest, $relpath);++ my ($mode, $atime, $mtime);+ lstat $File::Find::name+ or syserr(g\_('cannot get source pathname %s metadata'), $File::Find::name);+ ((undef) x 2, $mode, (undef) x 5, $atime, $mtime) = lstat \_;+ my $src\_is\_dir = -d \_;++ my $dest\_exists = 1;+ if (not lstat $destpath) {+ if ($! == ENOENT) {+ $dest\_exists = 0;+ } else {+ syserr(g\_('cannot get target pathname %s metadata'), $destpath);+ }+ }+ my $dest\_is\_dir = -d \_;+ if ($dest\_exists) {+ if ($dest\_is\_dir && $src\_is\_dir) {+ # Refresh the destination directory attributes with the+ # ones from the tarball.+ chmod $mode, $destpath+ or syserr(g\_('cannot change directory %s mode'), $File::Find::name);+ utime $atime, $mtime, $destpath+ or syserr(g\_('cannot change directory %s times'), $File::Find::name);++ # We should do nothing, and just walk further tree.+ return;+ } elsif ($dest\_is\_dir) {+ rmdir $destpath+ or syserr(g\_('cannot remove destination directory %s'), $destpath);+ } else {+ $check\_symlink->($destpath);+ unlink $destpath+ or syserr(g\_('cannot remove destination file %s'), $destpath);+ }+ }+ # If we are moving a directory, we do not need to walk it.+ if ($src\_is\_dir) {+ $File::Find::prune = 1;+ }+ rename $File::Find::name, $destpath+ or syserr(g\_('cannot move %s to %s'), $File::Find::name, $destpath);+ };++ find({+ wanted => $move\_in\_place,+ no\_chdir => 1,+ dangling\_symlinks => 0,+ }, $tmp); } else {- rename($tmp, $dest)- or syserr(g\_('unable to rename %s to %s'), $tmp, $dest);+ # Rename extracted directory+ opendir(my $dir\_dh, $tmp) or syserr(g\_('cannot opendir %s'), $tmp);+ my @entries = grep { $\_ ne '.' && $\_ ne '..' } readdir($dir\_dh);+ closedir($dir\_dh);++ erasedir($dest);++ if (scalar(@entries) == 1 && ! -l "$tmp/$entries[0]" && -d \_) {+ rename("$tmp/$entries[0]", $dest)+ or syserr(g\_('unable to rename %s to %s'),+ "$tmp/$entries[0]", $dest);+ } else {+ rename($tmp, $dest)+ or syserr(g\_('unable to rename %s to %s'), $tmp, $dest);+ } } erasedir($tmp); }diff --git a/scripts/t/Dpkg\_Source\_Archive.t b/scripts/t/Dpkg\_Source\_Archive.tindex 7b70da68e..09496aeea 100644--- a/[scripts/t/Dpkg\_Source\_Archive.t](/cgit/dpkg/dpkg.git/tree/scripts/t/Dpkg_Source_Archive.t?id=bb73779d2110d8e902f11da66ed87e0e4589f497)+++ b/[scripts/t/Dpkg\_Source\_Archive.t](/cgit/dpkg/dpkg.git/tree/scripts/t/Dpkg_Source_Archive.t?id=faa4c92debe45412bfcf8a44f26e827800bb24be)@@ -16,12 +16,120 @@ use strict; use warnings; -use Test::More tests => 1;+use Test::More tests => 4;+use Test::Dpkg qw(:paths);++use File::Spec;+use File::Path qw(make\_path rmtree);  BEGIN { use\_ok('Dpkg::Source::Archive'); } +use Dpkg;++my $tmpdir = 't.tmp/Dpkg\_Source\_Archive';++rmtree($tmpdir);++sub test\_touch+{+ my ($name, $data) = @\_;++ open my $fh, '>', $name+ or die "cannot touch file $name\n";+ print { $fh } $data if $data;+ close $fh;+}++sub test\_path\_escape+{+ my $name = shift;++ my $treedir = File::Spec->rel2abs("$tmpdir/$name-tree");+ my $overdir = File::Spec->rel2abs("$tmpdir/$name-overlay");+ my $outdir = "$tmpdir/$name-out";+ my $expdir = "$tmpdir/$name-exp";++ # This is the base directory, where we are going to be extracting stuff+ # into, which include traps.+ make\_path("$treedir/subdir-a");+ test\_touch("$treedir/subdir-a/file-a");+ test\_touch("$treedir/subdir-a/file-pre-a");+ make\_path("$treedir/subdir-b");+ test\_touch("$treedir/subdir-b/file-b");+ test\_touch("$treedir/subdir-b/file-pre-b");+ symlink File::Spec->abs2rel($outdir, $treedir), "$treedir/symlink-escape";+ symlink File::Spec->abs2rel("$outdir/nonexistent", $treedir), "$treedir/symlink-nonexistent";+ symlink "$treedir/file", "$treedir/symlink-within";+ test\_touch("$treedir/supposed-dir");++ # This is the overlay directory, which we'll pack and extract over the+ # base directory.+ make\_path($overdir);+ make\_path("$overdir/subdir-a/aa");+ test\_touch("$overdir/subdir-a/aa/file-aa", 'aa');+ test\_touch("$overdir/subdir-a/file-a", 'a');+ make\_path("$overdir/subdir-b/bb");+ test\_touch("$overdir/subdir-b/bb/file-bb", 'bb');+ test\_touch("$overdir/subdir-b/file-b", 'b');+ make\_path("$overdir/symlink-escape");+ test\_touch("$overdir/symlink-escape/escaped-file", 'escaped');+ test\_touch("$overdir/symlink-nonexistent", 'nonexistent');+ make\_path("$overdir/symlink-within");+ make\_path("$overdir/supposed-dir");+ test\_touch("$overdir/supposed-dir/supposed-file", 'something');++ # Generate overlay tar.+ system($Dpkg::PROGTAR, '-cf', "$overdir.tar", '-C', $overdir, qw(+ subdir-a subdir-b+ symlink-escape/escaped-file symlink-nonexistent symlink-within+ supposed-dir+ )) == 0+ or die "cannot create overlay tar archive\n";++ # This is the expected directory, which we'll be comparing against.+ make\_path($expdir);+ system('cp', '-a', $overdir, $expdir) == 0+ or die "cannot copy overlay hierarchy into expected directory\n";++ # Store the expected and out reference directories into a tar to compare+ # its structure against the result reference.+ system($Dpkg::PROGTAR, '-cf', "$expdir.tar", '-C', $overdir, qw(+ subdir-a subdir-b+ symlink-escape/escaped-file symlink-nonexistent symlink-within+ supposed-dir+ ), '-C', $treedir, qw(+ subdir-a/file-pre-a+ subdir-b/file-pre-b+ )) == 0+ or die "cannot create expected tar archive\n";++ # This directory is supposed to remain empty, anything inside implies a+ # directory traversal.+ make\_path($outdir);++ my $warnseen;+ local $SIG{\_\_WARN\_\_} = sub { $warnseen = $\_[0] };++ # Perform the extraction.+ my $tar = Dpkg::Source::Archive->new(filename => "$overdir.tar");+ $tar->extract($treedir, in\_place => 1);++ # Store the result into a tar to compare its structure against a reference.+ system($Dpkg::PROGTAR, '-cf', "$treedir.tar", '-C', $treedir, '.');++ # Check results+ ok(length $warnseen && $warnseen =~ m/points outside source root/,+ 'expected warning seen');+ ok(system($Dpkg::PROGTAR, '--compare', '-f', "$expdir.tar", '-C', $treedir) == 0,+ 'expected directory matches');+ ok(! -e "$outdir/escaped-file",+ 'expected output directory is empty, directory traversal');+}++test\_path\_escape('in-place');+ # TODO: Add actual test cases.  1; |
| --- |

generated by [cgit v1.2.3](https://git.zx2c4.com/cgit/about/) ([git 2.39.1](https://git-scm.com/)) at 2025-01-14 19:23:52 +0000


