=== Content from www.sqlite.org_1899dba6_20250114_190128.html ===

[![SQLite](../images/sqlite370_banner.svg)](../index.html)

Small. Fast. Reliable.
Choose any three.

* [Home](../index.html)* Menu* [About](../about.html)* [Documentation](../docs.html)* [Download](../download.html)* [License](../copyright.html)* [Support](../support.html)* [Purchase](../prosupport.html)* Search

* [About](../about.html)* [Documentation](../docs.html)* [Download](../download.html)* [Support](../support.html)* [Purchase](../prosupport.html)

Search Documentation
Search Changelog

[## SQLite C Interface](../c3ref/intro.html)
## One-Step Query Execution Interface

> ```
>
> int sqlite3_exec(
>   sqlite3*,                                  /* An open database */
>   const char *sql,                           /* SQL to be evaluated */
>   int (*callback)(void*,int,char**,char**),  /* Callback function */
>   void *,                                    /* 1st argument to callback */
>   char **errmsg                              /* Error msg written here */
> );
>
> ```

The sqlite3\_exec() interface is a convenience wrapper around
[sqlite3\_prepare\_v2()](../c3ref/prepare.html), [sqlite3\_step()](../c3ref/step.html), and [sqlite3\_finalize()](../c3ref/finalize.html),
that allows an application to run multiple statements of SQL
without having to use a lot of C code.

The sqlite3\_exec() interface runs zero or more UTF-8 encoded,
semicolon-separate SQL statements passed into its 2nd argument,
in the context of the [database connection](../c3ref/sqlite3.html) passed in as its 1st
argument. If the callback function of the 3rd argument to
sqlite3\_exec() is not NULL, then it is invoked for each result row
coming out of the evaluated SQL statements. The 4th argument to
sqlite3\_exec() is relayed through to the 1st argument of each
callback invocation. If the callback pointer to sqlite3\_exec()
is NULL, then no callback is ever invoked and result rows are
ignored.

If an error occurs while evaluating the SQL statements passed into
sqlite3\_exec(), then execution of the current statement stops and
subsequent statements are skipped. If the 5th parameter to sqlite3\_exec()
is not NULL then any error message is written into memory obtained
from [sqlite3\_malloc()](../c3ref/free.html) and passed back through the 5th parameter.
To avoid memory leaks, the application should invoke [sqlite3\_free()](../c3ref/free.html)
on error message strings returned through the 5th parameter of
sqlite3\_exec() after the error message string is no longer needed.
If the 5th parameter to sqlite3\_exec() is not NULL and no errors
occur, then sqlite3\_exec() sets the pointer in its 5th parameter to
NULL before returning.

If an sqlite3\_exec() callback returns non-zero, the sqlite3\_exec()
routine returns SQLITE\_ABORT without invoking the callback again and
without running any subsequent SQL statements.

The 2nd argument to the sqlite3\_exec() callback function is the
number of columns in the result. The 3rd argument to the sqlite3\_exec()
callback is an array of pointers to strings obtained as if from
[sqlite3\_column\_text()](../c3ref/column_blob.html), one for each column. If an element of a
result row is NULL then the corresponding string pointer for the
sqlite3\_exec() callback is a NULL pointer. The 4th argument to the
sqlite3\_exec() callback is an array of pointers to strings where each
entry represents the name of corresponding result column as obtained
from [sqlite3\_column\_name()](../c3ref/column_name.html).

If the 2nd parameter to sqlite3\_exec() is a NULL pointer, a pointer
to an empty string, or a pointer that contains only whitespace and/or
SQL comments, then no SQL statements are evaluated and the database
is not changed.

Restrictions:

* The application must ensure that the 1st parameter to sqlite3\_exec()
  is a valid and open [database connection](../c3ref/sqlite3.html).* The application must not close the [database connection](../c3ref/sqlite3.html) specified by
    the 1st parameter to sqlite3\_exec() while sqlite3\_exec() is running.* The application must not modify the SQL statement text passed into
      the 2nd parameter of sqlite3\_exec() while sqlite3\_exec() is running.* The application must not dereference the arrays or string pointers
        passed as the 3rd and 4th callback parameters after it returns.

See also lists of
[Objects](../c3ref/objlist.html),
[Constants](../c3ref/constlist.html), and
[Functions](../c3ref/funclist.html).



=== Content from github.com_58d8b4fc_20250114_190127.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FTizenRT%2Fissues%2F5628)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FTizenRT%2Fissues%2F5628)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fissues_fragments%2Fissue_layout&source=header-repo&source_repo=Samsung%2FTizenRT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[Samsung](/Samsung)
/
**[TizenRT](/Samsung/TizenRT)**
Public

* [Notifications](/login?return_to=%2FSamsung%2FTizenRT) You must be signed in to change notification settings
* [Fork
  591](/login?return_to=%2FSamsung%2FTizenRT)
* [Star
   593](/login?return_to=%2FSamsung%2FTizenRT)

* [Code](/Samsung/TizenRT)
* [Issues
  37](/Samsung/TizenRT/issues)
* [Pull requests
  83](/Samsung/TizenRT/pulls)
* [Actions](/Samsung/TizenRT/actions)
* [Projects
  0](/Samsung/TizenRT/projects)
* [Wiki](/Samsung/TizenRT/wiki)
* [Security](/Samsung/TizenRT/security)
* [Insights](/Samsung/TizenRT/pulse)

Additional navigation options

* [Code](/Samsung/TizenRT)
* [Issues](/Samsung/TizenRT/issues)
* [Pull requests](/Samsung/TizenRT/pulls)
* [Actions](/Samsung/TizenRT/actions)
* [Projects](/Samsung/TizenRT/projects)
* [Wiki](/Samsung/TizenRT/wiki)
* [Security](/Samsung/TizenRT/security)
* [Insights](/Samsung/TizenRT/pulse)

# Security: DoS vulnerability in function createDB()  #5628

[New issue](/login?return_to=)[Jump to bottom](#comment-composer-heading)Copy link[New issue](/login?return_to=)[Jump to bottom](#comment-composer-heading)Copy linkOpenOpen[Security: DoS vulnerability in function createDB()](#top) #5628Copy linkAssignees [![j11591](https://avatars.githubusercontent.com/u/42333682?s=64&v=4)](/j11591)[![hs36-kim](https://avatars.githubusercontent.com/u/61130327?s=64&v=4)](/hs36-kim)![@UVScan](https://avatars.githubusercontent.com/u/112676446?v=4&size=80)
## Description

![@UVScan](https://avatars.githubusercontent.com/u/112676446?v=4&size=48)[UVScan](https://github.com/UVScan)opened [on Sep 2, 2022](https://github.com/Samsung/TizenRT/issues/5628#issue-1359704313)
# Affected components

affected source code file: external/iotivity/iotivity\_1.2-rel/resource/csdk/security/provisioning/src/provisioningdatabasemanager.c

# Attack vector(s)

Missing sqlite3\_free after sqlite3\_exec.

To avoid memory leaks, the application should invoke [sqlite3\_free()](https://www.sqlite.org/c3ref/free.html) on error message strings returned through the 5th parameter of sqlite3\_exec() after the error message string is no longer needed.

# Suggested description of the vulnerability for use in the CVE

DoS vulnerability in createDB() function in Samsung Electronics TizenRT latest version (and earlier) due to missing sqlite3\_free after sqlite3\_exec.

# Discoverer(s)/Credits

UVScan

# Reference(s)

<https://www.sqlite.org/c3ref/exec.html>

[TizenRT/external/iotivity/iotivity\_1.2-rel/resource/csdk/security/provisioning/src/provisioningdatabasemanager.c](https://github.com/Samsung/TizenRT/blob/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning/src/provisioningdatabasemanager.c#L103)

Line 103
in
[f8f776d](/Samsung/TizenRT/commit/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf)

|  | result = sqlite3\_exec(g\_db, PDM\_CREATE\_T\_DEVICE\_LIST, NULL, NULL, NULL); |
| --- | --- |

[TizenRT/external/iotivity/iotivity\_1.2-rel/resource/csdk/security/provisioning/src/provisioningdatabasemanager.c](https://github.com/Samsung/TizenRT/blob/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning/src/provisioningdatabasemanager.c#L107)

Line 107
in
[f8f776d](/Samsung/TizenRT/commit/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf)

|  | result = sqlite3\_exec(g\_db, PDM\_CREATE\_T\_DEVICE\_LINK, NULL, NULL, NULL); |
| --- | --- |

## Metadata

### Assignees

* [![@hs36-kim](https://avatars.githubusercontent.com/u/61130327?s=64&v=4)hs36-kim](/hs36-kim)
* [![@j11591](https://avatars.githubusercontent.com/u/42333682?s=64&v=4)j11591](/j11591)
### Labels

No labelsNo labels
### Type

No type
### Projects

No projects
### Milestone

No milestone

### Relationships

None yet
### Development

No branches or pull requests
## Issue actions

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_60568c94_20250114_190125.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FTizenRT%2Fblob%2Ff8f776dd183246ad8890422c1ee5e8f33ab2aaaf%2Fexternal%2Fiotivity%2Fiotivity_1.2-rel%2Fresource%2Fcsdk%2Fsecurity%2Fprovisioning%2Fsrc%2Fprovisioningdatabasemanager.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FTizenRT%2Fblob%2Ff8f776dd183246ad8890422c1ee5e8f33ab2aaaf%2Fexternal%2Fiotivity%2Fiotivity_1.2-rel%2Fresource%2Fcsdk%2Fsecurity%2Fprovisioning%2Fsrc%2Fprovisioningdatabasemanager.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=Samsung%2FTizenRT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[Samsung](/Samsung)
/
**[TizenRT](/Samsung/TizenRT)**
Public

* [Notifications](/login?return_to=%2FSamsung%2FTizenRT) You must be signed in to change notification settings
* [Fork
  591](/login?return_to=%2FSamsung%2FTizenRT)
* [Star
   593](/login?return_to=%2FSamsung%2FTizenRT)

* [Code](/Samsung/TizenRT)
* [Issues
  37](/Samsung/TizenRT/issues)
* [Pull requests
  83](/Samsung/TizenRT/pulls)
* [Actions](/Samsung/TizenRT/actions)
* [Projects
  0](/Samsung/TizenRT/projects)
* [Wiki](/Samsung/TizenRT/wiki)
* [Security](/Samsung/TizenRT/security)
* [Insights](/Samsung/TizenRT/pulse)

Additional navigation options

* [Code](/Samsung/TizenRT)
* [Issues](/Samsung/TizenRT/issues)
* [Pull requests](/Samsung/TizenRT/pulls)
* [Actions](/Samsung/TizenRT/actions)
* [Projects](/Samsung/TizenRT/projects)
* [Wiki](/Samsung/TizenRT/wiki)
* [Security](/Samsung/TizenRT/security)
* [Insights](/Samsung/TizenRT/pulse)

## Files

 f8f776d
## Breadcrumbs

1. [TizenRT](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf)
2. /[external](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external)
3. /[iotivity](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity)
4. /[iotivity\_1.2-rel](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel)
5. /[resource](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource)
6. /[csdk](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk)
7. /[security](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security)
8. /[provisioning](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning)
9. /[src](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning/src)
/
# provisioningdatabasemanager.c

Copy path Blame  Blame
## Latest commit

## History

[History](/Samsung/TizenRT/commits/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning/src/provisioningdatabasemanager.c)1061 lines (906 loc) · 32.1 KB f8f776d
## Breadcrumbs

1. [TizenRT](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf)
2. /[external](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external)
3. /[iotivity](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity)
4. /[iotivity\_1.2-rel](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel)
5. /[resource](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource)
6. /[csdk](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk)
7. /[security](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security)
8. /[provisioning](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning)
9. /[src](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning/src)
/
# provisioningdatabasemanager.c

Top
## File metadata and controls

* Code
* Blame

1061 lines (906 loc) · 32.1 KB[Raw](https://github.com/Samsung/TizenRT/raw/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning/src/provisioningdatabasemanager.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* \* Copyright 2015 Samsung Electronics All Rights Reserved. \* \* \* \* Licensed under the Apache License, Version 2.0 (the "License"); \* you may not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an "AS IS" BASIS, \* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \* \* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
#include <stdio.h>#include <stdbool.h>#include <string.h>#include <stdlib.h>
#include "sqlite3.h"#include "logger.h"#include "oic\_malloc.h"#include "provisioningdatabasemanager.h"#include "pmutility.h"#include "oic\_string.h"#include "utlist.h"
#define DB\_FILE "PDM.db"
#define TAG "OIC\_PDM"
#define PDM\_FIRST\_INDEX 0#define PDM\_SECOND\_INDEX 1
#define PDM\_BIND\_INDEX\_FIRST 1#define PDM\_BIND\_INDEX\_SECOND 2#define PDM\_BIND\_INDEX\_THIRD 3
#define PDM\_CREATE\_T\_DEVICE\_LIST "create table T\_DEVICE\_LIST(ID INTEGER PRIMARY KEY AUTOINCREMENT,\ UUID BLOB NOT NULL UNIQUE, STATE INT NOT NULL);"
#define PDM\_CREATE\_T\_DEVICE\_LINK "create table T\_DEVICE\_LINK\_STATE(ID INT NOT NULL, ID2 INT NOT \ NULL,STATE INT NOT NULL, PRIMARY KEY (ID, ID2));"/\*\* \* Macro to verify sqlite success. \* eg: VERIFY\_NON\_NULL(TAG, ptrData, ERROR,OC\_STACK\_ERROR); \*/#define PDM\_VERIFY\_SQLITE\_OK(tag, arg, logLevel, retValue) do{ if (SQLITE\_OK != (arg)) \ { OIC\_LOG\_V((logLevel), tag, "Error in " #arg ", Error Message: %s", \ sqlite3\_errmsg(g\_db)); return retValue; }}while(0)
#define PDM\_SQLITE\_TRANSACTION\_BEGIN "BEGIN TRANSACTION;"#define PDM\_SQLITE\_TRANSACTION\_COMMIT "COMMIT;"#define PDM\_SQLITE\_TRANSACTION\_ROLLBACK "ROLLBACK;"#define PDM\_SQLITE\_GET\_STALE\_INFO "SELECT ID,ID2 FROM T\_DEVICE\_LINK\_STATE WHERE STATE = ?"#define PDM\_SQLITE\_INSERT\_T\_DEVICE\_LIST "INSERT INTO T\_DEVICE\_LIST VALUES(?,?,?)"#define PDM\_SQLITE\_GET\_ID "SELECT ID FROM T\_DEVICE\_LIST WHERE UUID like ?"#define PDM\_SQLITE\_INSERT\_LINK\_DATA "INSERT INTO T\_DEVICE\_LINK\_STATE VALUES(?,?,?)"#define PDM\_SQLITE\_DELETE\_LINK "DELETE FROM T\_DEVICE\_LINK\_STATE WHERE ID = ? and ID2 = ?"#define PDM\_SQLITE\_DELETE\_DEVICE\_LINK "DELETE FROM T\_DEVICE\_LINK\_STATE WHERE ID = ? or ID2 = ?"#define PDM\_SQLITE\_DELETE\_DEVICE "DELETE FROM T\_DEVICE\_LIST WHERE ID = ?"#define PDM\_SQLITE\_DELETE\_DEVICE\_WITH\_STATE "DELETE FROM T\_DEVICE\_LIST WHERE STATE= ?"#define PDM\_SQLITE\_UPDATE\_LINK "UPDATE T\_DEVICE\_LINK\_STATE SET STATE = ? WHERE ID = ? and ID2 = ?"#define PDM\_SQLITE\_LIST\_ALL\_UUID "SELECT UUID FROM T\_DEVICE\_LIST WHERE STATE = 0"#define PDM\_SQLITE\_GET\_UUID "SELECT UUID,STATE FROM T\_DEVICE\_LIST WHERE ID = ?"#define PDM\_SQLITE\_GET\_LINKED\_DEVICES "SELECT ID,ID2 FROM T\_DEVICE\_LINK\_STATE WHERE \ (ID = ? or ID2 = ?) and state = 0"#define PDM\_SQLITE\_GET\_DEVICE\_LINKS "SELECT ID,ID2 FROM T\_DEVICE\_LINK\_STATE WHERE \ ID = ? and ID2 = ? and state = 0"#define PDM\_SQLITE\_UPDATE\_DEVICE "UPDATE T\_DEVICE\_LIST SET STATE = ? WHERE UUID like ?"#define PDM\_SQLITE\_GET\_DEVICE\_STATUS "SELECT STATE FROM T\_DEVICE\_LIST WHERE UUID like ?"#define PDM\_SQLITE\_UPDATE\_LINK\_STALE\_FOR\_STALE\_DEVICE "UPDATE T\_DEVICE\_LINK\_STATE SET STATE = 1\ WHERE ID = ? or ID2 = ?"
#define ASCENDING\_ORDER(id1, id2) do{if( (id1) > (id2) )\ { int temp; temp = id1; id1 = id2; id2 = temp; }}while(0)
#define CHECK\_PDM\_INIT(tag) do{if(true != gInit)\ { OIC\_LOG(ERROR, (tag), "PDB is not initialized"); \ return OC\_STACK\_PDM\_IS\_NOT\_INITIALIZED; }}while(0)
static sqlite3 \*g\_db = NULL;static bool gInit = false; /\* Only if we can open sqlite db successfully, gInit is true. \*/
/\*\* \* function to create DB in case DB doesn't exists \*/static OCStackResult createDB(const char\* path){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 int result = 0; result = sqlite3\_open\_v2(path, &g\_db, SQLITE\_OPEN\_READWRITE|SQLITE\_OPEN\_CREATE, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, result, ERROR, OC\_STACK\_ERROR);
 result = sqlite3\_exec(g\_db, PDM\_CREATE\_T\_DEVICE\_LIST, NULL, NULL, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, result, ERROR, OC\_STACK\_ERROR);
 OIC\_LOG(INFO, TAG, "Created T\_DEVICE\_LIST"); result = sqlite3\_exec(g\_db, PDM\_CREATE\_T\_DEVICE\_LINK, NULL, NULL, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, result, ERROR, OC\_STACK\_ERROR);
 OIC\_LOG(INFO, TAG, "Created T\_DEVICE\_LINK\_STATE"); gInit = true;
 OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_);
 return OC\_STACK\_OK;}
/\*\* \* Function to begin any transaction \*/static OCStackResult begin(){ int res = 0; res = sqlite3\_exec(g\_db, PDM\_SQLITE\_TRANSACTION\_BEGIN, NULL, NULL, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR); return OC\_STACK\_OK;}
/\*\* \* Function to commit any transaction \*/static OCStackResult commit(){ int res = 0; res = sqlite3\_exec(g\_db, PDM\_SQLITE\_TRANSACTION\_COMMIT, NULL, NULL, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR); return OC\_STACK\_OK;}
/\*\* \* Function to rollback any transaction \*/static OCStackResult rollback(){ int res = 0; res = sqlite3\_exec(g\_db, PDM\_SQLITE\_TRANSACTION\_ROLLBACK, NULL, NULL, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR); return OC\_STACK\_OK;}
/\*\* \* Error log callback called by SQLite stack in case of error \*/void errLogCallback(void \*pArg, int iErrCode, const char \*zMsg){ (void) pArg; (void) iErrCode; (void) zMsg; OIC\_LOG\_V(DEBUG,TAG, "%s : (%d) %s", \_\_func\_\_, iErrCode, zMsg);}
OCStackResult PDMInit(const char \*path){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 int rc; const char \*dbPath = NULL; if (SQLITE\_OK != sqlite3\_config(SQLITE\_CONFIG\_LOG, errLogCallback, NULL)) { OIC\_LOG(INFO, TAG, "Unable to enable debug log of sqlite"); }
 if (NULL == path || !\*path) { dbPath = DB\_FILE; } else { dbPath = path; } rc = sqlite3\_open\_v2(dbPath, &g\_db, SQLITE\_OPEN\_READWRITE, NULL); if (SQLITE\_OK != rc) { OIC\_LOG\_V(INFO, TAG, "ERROR: Can't open database: %s", sqlite3\_errmsg(g\_db)); sqlite3\_close(g\_db); OCStackResult ret = createDB(dbPath); if (OC\_STACK\_OK != ret) { sqlite3\_close(g\_db); } return ret; } gInit = true;
 /\* \* Remove PDM\_DEVICE\_INIT status devices. \* PDM\_DEVICE\_INIT means that the OTM process is in progress. \* PDM\_DEVICE\_INIT state device can be existed when the program is terminated during the OTM process in progress. \* For this reason, PDM\_DEVICE\_INIT devices should be removed at PDM initialization time. \*/ if(OC\_STACK\_OK != PDMDeleteDeviceWithState(PDM\_DEVICE\_INIT)) { OIC\_LOG\_V(WARNING, TAG, "Failed to delete init state devices."); }
 OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_);
 return OC\_STACK\_OK;}
OCStackResult PDMAddDevice(const OicUuid\_t \*UUID){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == UUID) { return OC\_STACK\_INVALID\_PARAM; }
 sqlite3\_stmt \*stmt = 0; int res =0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_INSERT\_T\_DEVICE\_LIST, strlen(PDM\_SQLITE\_INSERT\_T\_DEVICE\_LIST) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_blob(stmt, PDM\_BIND\_INDEX\_SECOND, UUID, UUID\_LENGTH, SQLITE\_STATIC); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_THIRD, PDM\_DEVICE\_INIT); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_step(stmt); if (SQLITE\_DONE != res) { if (SQLITE\_CONSTRAINT == res) { //new OCStack result code OIC\_LOG\_V(ERROR, TAG, "Error Occured: %s",sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_DUPLICATE\_UUID; } OIC\_LOG\_V(ERROR, TAG, "Error Occured: %s",sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt);
 OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
/\*\* \*function to get Id for given UUID \*/static OCStackResult getIdForUUID(const OicUuid\_t \*UUID , int \*id){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_GET\_ID, strlen(PDM\_SQLITE\_GET\_ID) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_blob(stmt, PDM\_BIND\_INDEX\_FIRST, UUID, UUID\_LENGTH, SQLITE\_STATIC); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 OIC\_LOG(DEBUG, TAG, "Binding Done"); while (SQLITE\_ROW == sqlite3\_step(stmt)) { int tempId = sqlite3\_column\_int(stmt, PDM\_FIRST\_INDEX); OIC\_LOG\_V(DEBUG, TAG, "ID is %d", tempId); \*id = tempId; sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK; } sqlite3\_finalize(stmt); return OC\_STACK\_INVALID\_PARAM;}
/\*\* \* Function to check duplication of device's Device ID. \*/OCStackResult PDMIsDuplicateDevice(const OicUuid\_t\* UUID, bool \*result){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == UUID || NULL == result) { OIC\_LOG(ERROR, TAG, "UUID or result is NULL"); return OC\_STACK\_INVALID\_PARAM; } sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_GET\_ID, strlen(PDM\_SQLITE\_GET\_ID) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_blob(stmt, PDM\_BIND\_INDEX\_FIRST, UUID, UUID\_LENGTH, SQLITE\_STATIC); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 OIC\_LOG(DEBUG, TAG, "Binding Done"); bool retValue = false; while(SQLITE\_ROW == sqlite3\_step(stmt)) { OIC\_LOG(INFO, TAG, "Duplicated UUID"); retValue = true; }
 sqlite3\_finalize(stmt); \*result = retValue;
 OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
/\*\* \* Function to add link in sqlite \*/static OCStackResult addlink(int id1, int id2){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_INSERT\_LINK\_DATA, strlen(PDM\_SQLITE\_INSERT\_LINK\_DATA) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id1); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_SECOND, id2); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_THIRD, PDM\_DEVICE\_ACTIVE); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 if (sqlite3\_step(stmt) != SQLITE\_DONE) { OIC\_LOG\_V(ERROR, TAG, "Error Occured: %s",sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMLinkDevices(const OicUuid\_t \*UUID1, const OicUuid\_t \*UUID2){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == UUID1 || NULL == UUID2) { OIC\_LOG(ERROR, TAG, "Invalid PARAM"); return OC\_STACK\_INVALID\_PARAM; }
 PdmDeviceState\_t state = PDM\_DEVICE\_UNKNOWN; if (OC\_STACK\_OK != PDMGetDeviceState(UUID1, &state)) { OIC\_LOG(ERROR, TAG, "Internal error occured"); return OC\_STACK\_ERROR; } if (PDM\_DEVICE\_ACTIVE != state) { OIC\_LOG\_V(ERROR, TAG, "UUID1: Device state is not active : %d", state); return OC\_STACK\_INVALID\_PARAM; }
 state = PDM\_DEVICE\_UNKNOWN; if (OC\_STACK\_OK != PDMGetDeviceState(UUID2, &state)) { OIC\_LOG(ERROR, TAG, "Internal error occured"); return OC\_STACK\_ERROR; } if (PDM\_DEVICE\_ACTIVE != state) { OIC\_LOG\_V(ERROR, TAG, "UUID2: Device state is not active : %d", state); return OC\_STACK\_INVALID\_PARAM; }
 int id1 = 0; if (OC\_STACK\_OK != getIdForUUID(UUID1, &id1)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; } int id2 = 0; if (OC\_STACK\_OK != getIdForUUID(UUID2, &id2)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 ASCENDING\_ORDER(id1, id2); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return addlink(id1, id2);}
/\*\* \* Function to remove created link \*/static OCStackResult removeLink(int id1, int id2){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 int res = 0; sqlite3\_stmt \*stmt = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_DELETE\_LINK, strlen(PDM\_SQLITE\_DELETE\_LINK) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id1); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_SECOND, id2); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 if (SQLITE\_DONE != sqlite3\_step(stmt)) { OIC\_LOG\_V(ERROR, TAG, "Error message: %s", sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMUnlinkDevices(const OicUuid\_t \*UUID1, const OicUuid\_t \*UUID2){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == UUID1 || NULL == UUID2) { OIC\_LOG(ERROR, TAG, "Invalid PARAM"); return OC\_STACK\_INVALID\_PARAM; }
 int id1 = 0; if (OC\_STACK\_OK != getIdForUUID(UUID1, &id1)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 int id2 = 0; if (OC\_STACK\_OK != getIdForUUID(UUID2, &id2)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; } ASCENDING\_ORDER(id1, id2); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return removeLink(id1, id2);}
static OCStackResult removeFromDeviceList(int id){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_DELETE\_DEVICE, strlen(PDM\_SQLITE\_DELETE\_DEVICE) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 if (sqlite3\_step(stmt) != SQLITE\_DONE) { OIC\_LOG\_V(ERROR, TAG, "Error message: %s", sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMDeleteDevice(const OicUuid\_t \*UUID){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == UUID) { return OC\_STACK\_INVALID\_PARAM; } int id = 0; if (OC\_STACK\_OK != getIdForUUID(UUID, &id)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; } begin(); if(OC\_STACK\_OK != removeFromDeviceList(id)) { rollback(); OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_ERROR; } commit(); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
static OCStackResult updateLinkState(int id1, int id2, int state){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0 ; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_UPDATE\_LINK, strlen(PDM\_SQLITE\_UPDATE\_LINK) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, state); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_SECOND, id1); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_THIRD, id2); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 if (SQLITE\_DONE != sqlite3\_step(stmt)) { OIC\_LOG\_V(ERROR, TAG, "Error message: %s", sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMSetLinkStale(const OicUuid\_t\* uuidOfDevice1, const OicUuid\_t\* uuidOfDevice2){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == uuidOfDevice1 || NULL == uuidOfDevice2) { OIC\_LOG(ERROR, TAG, "Invalid PARAM"); return OC\_STACK\_INVALID\_PARAM; }
 int id1 = 0; if (OC\_STACK\_OK != getIdForUUID(uuidOfDevice1, &id1)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 int id2 = 0; if (OC\_STACK\_OK != getIdForUUID(uuidOfDevice2, &id2)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; } ASCENDING\_ORDER(id1, id2); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return updateLinkState(id1, id2, PDM\_DEVICE\_STALE);}
OCStackResult PDMGetOwnedDevices(OCUuidList\_t \*\*uuidList, size\_t \*numOfDevices){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL != \*uuidList) { OIC\_LOG(ERROR, TAG, "Not null list will cause memory leak"); return OC\_STACK\_INVALID\_PARAM; } sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_LIST\_ALL\_UUID, strlen(PDM\_SQLITE\_LIST\_ALL\_UUID) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 size\_t counter = 0; while (SQLITE\_ROW == sqlite3\_step(stmt)) { const void \*ptr = sqlite3\_column\_blob(stmt, PDM\_FIRST\_INDEX); OicUuid\_t \*uid = (OicUuid\_t \*)ptr; OCUuidList\_t \*temp = (OCUuidList\_t \*) OICCalloc(1,sizeof(OCUuidList\_t)); if (NULL == temp) { OIC\_LOG\_V(ERROR, TAG, "Memory allocation problem"); sqlite3\_finalize(stmt); return OC\_STACK\_NO\_MEMORY; } memcpy(&temp->dev.id, uid->id, UUID\_LENGTH); LL\_PREPEND(\*uuidList,temp); ++counter; } \*numOfDevices = counter; sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
static OCStackResult getUUIDforId(int id, OicUuid\_t \*uid, bool \*result){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_GET\_UUID, strlen(PDM\_SQLITE\_GET\_UUID) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 while (SQLITE\_ROW == sqlite3\_step(stmt)) { const void \*ptr = sqlite3\_column\_blob(stmt, PDM\_FIRST\_INDEX); memcpy(uid, ptr, sizeof(OicUuid\_t));
 int temp = sqlite3\_column\_int(stmt, PDM\_SECOND\_INDEX); if(PDM\_DEVICE\_STALE == temp) { if(result) { \*result = true; } } else { if(result) { \*result = false; } } sqlite3\_finalize(stmt); return OC\_STACK\_OK; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_INVALID\_PARAM;}
OCStackResult PDMGetLinkedDevices(const OicUuid\_t \*UUID, OCUuidList\_t \*\*UUIDLIST, size\_t \*numOfDevices){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == UUID || NULL == numOfDevices || !UUIDLIST) { return OC\_STACK\_INVALID\_PARAM; } if (NULL != \*UUIDLIST ) { OIC\_LOG(ERROR, TAG, "Not null list will cause memory leak"); return OC\_STACK\_INVALID\_PARAM; } PdmDeviceState\_t state = PDM\_DEVICE\_UNKNOWN; OCStackResult ret = PDMGetDeviceState(UUID, &state); if (OC\_STACK\_OK != ret) { OIC\_LOG(ERROR, TAG, "Internal error occured"); return OC\_STACK\_ERROR; } if (PDM\_DEVICE\_ACTIVE != state) { OIC\_LOG\_V(ERROR, TAG, "Device state is not active : %d", state); return OC\_STACK\_INVALID\_PARAM; } int id = 0; if (OC\_STACK\_OK != getIdForUUID(UUID, &id)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_GET\_LINKED\_DEVICES, strlen(PDM\_SQLITE\_GET\_LINKED\_DEVICES) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_SECOND, id); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 size\_t counter = 0; while (SQLITE\_ROW == sqlite3\_step(stmt)) { int i1 = sqlite3\_column\_int(stmt, PDM\_FIRST\_INDEX); int i2 = sqlite3\_column\_int(stmt, PDM\_SECOND\_INDEX);
 OicUuid\_t temp = {{0,}}; if (i1 != id) { getUUIDforId(i1, &temp, NULL); } if (i2 != id) { getUUIDforId(i2, &temp, NULL); }
 OCUuidList\_t \*tempNode = (OCUuidList\_t \*) OICCalloc(1,sizeof(OCUuidList\_t)); if (NULL == tempNode) { OIC\_LOG(ERROR, TAG, "No Memory"); sqlite3\_finalize(stmt); return OC\_STACK\_NO\_MEMORY; } memcpy(&tempNode->dev.id, &temp.id, UUID\_LENGTH); LL\_PREPEND(\*UUIDLIST,tempNode); ++counter; } \*numOfDevices = counter; sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMGetToBeUnlinkedDevices(OCPairList\_t \*\*staleDevList, size\_t \*numOfDevices){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL != \*staleDevList) { OIC\_LOG(ERROR, TAG, "Not null list will cause memory leak"); return OC\_STACK\_INVALID\_PARAM; }
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_GET\_STALE\_INFO, strlen(PDM\_SQLITE\_GET\_STALE\_INFO) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, PDM\_DEVICE\_STALE); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 size\_t counter = 0; while (SQLITE\_ROW == sqlite3\_step(stmt)) { int i1 = sqlite3\_column\_int(stmt, PDM\_FIRST\_INDEX); int i2 = sqlite3\_column\_int(stmt, PDM\_SECOND\_INDEX); OicUuid\_t temp1 = {{0,}}; OicUuid\_t temp2 = {{0,}};; getUUIDforId(i1, &temp1, NULL); getUUIDforId(i2, &temp2, NULL);
 OCPairList\_t \*tempNode = (OCPairList\_t \*) OICCalloc(1, sizeof(OCPairList\_t)); if (NULL == tempNode) { OIC\_LOG(ERROR, TAG, "No Memory"); sqlite3\_finalize(stmt); return OC\_STACK\_NO\_MEMORY; } memcpy(&tempNode->dev.id, &temp1.id, UUID\_LENGTH); memcpy(&tempNode->dev2.id, &temp2.id, UUID\_LENGTH); LL\_PREPEND(\*staleDevList, tempNode); ++counter; } \*numOfDevices = counter; sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMClose(){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); int res = 0; res = sqlite3\_close(g\_db); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
void PDMDestoryOicUuidLinkList(OCUuidList\_t\* ptr){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 if(ptr) { OCUuidList\_t \*tmp1 = NULL,\*tmp2=NULL; LL\_FOREACH\_SAFE(ptr, tmp1, tmp2) { LL\_DELETE(ptr, tmp1); OICFree(tmp1); } }
 OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_);}
void PDMDestoryStaleLinkList(OCPairList\_t\* ptr){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 if(ptr) { OCPairList\_t \*tmp1 = NULL,\*tmp2=NULL; LL\_FOREACH\_SAFE(ptr, tmp1, tmp2) { LL\_DELETE(ptr, tmp1); OICFree(tmp1); } }
 OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_);}
OCStackResult PDMIsLinkExists(const OicUuid\_t\* uuidOfDevice1, const OicUuid\_t\* uuidOfDevice2, bool\* result){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == uuidOfDevice1 || NULL == uuidOfDevice2 || NULL == result) { return OC\_STACK\_INVALID\_PARAM; } int id1 = 0; int id2 = 0; if (OC\_STACK\_OK != getIdForUUID(uuidOfDevice1, &id1)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 if (OC\_STACK\_OK != getIdForUUID(uuidOfDevice2, &id2)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 PdmDeviceState\_t state = PDM\_DEVICE\_UNKNOWN; if (OC\_STACK\_OK != PDMGetDeviceState(uuidOfDevice1, &state)) { OIC\_LOG(ERROR, TAG, "uuidOfDevice1:Internal error occured"); return OC\_STACK\_ERROR; } if (PDM\_DEVICE\_ACTIVE != state) { OIC\_LOG\_V(ERROR, TAG, "uuidOfDevice1:Device state is not active : %d", state); return OC\_STACK\_INVALID\_PARAM; }
 state = PDM\_DEVICE\_UNKNOWN; if (OC\_STACK\_OK != PDMGetDeviceState(uuidOfDevice2, &state)) { OIC\_LOG(ERROR, TAG, "uuidOfDevice2:Internal error occured"); return OC\_STACK\_ERROR; } if (PDM\_DEVICE\_ACTIVE != state) { OIC\_LOG\_V(ERROR, TAG, "uuidOfDevice2:Device state is not active : %d", state); return OC\_STACK\_INVALID\_PARAM; }
 ASCENDING\_ORDER(id1, id2);
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_GET\_DEVICE\_LINKS, strlen(PDM\_SQLITE\_GET\_DEVICE\_LINKS) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id1); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_SECOND, id2); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 bool ret = false; while(SQLITE\_ROW == sqlite3\_step(stmt)) { OIC\_LOG(INFO, TAG, "Link already exists between devices"); ret = true; } sqlite3\_finalize(stmt); \*result = ret; OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
static OCStackResult updateDeviceState(const OicUuid\_t \*uuid, PdmDeviceState\_t state){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0 ; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_UPDATE\_DEVICE, strlen(PDM\_SQLITE\_UPDATE\_DEVICE) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, state); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_blob(stmt, PDM\_BIND\_INDEX\_SECOND, uuid, UUID\_LENGTH, SQLITE\_STATIC); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 if (SQLITE\_DONE != sqlite3\_step(stmt)) { OIC\_LOG\_V(ERROR, TAG, "Error message: %s", sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
static OCStackResult updateLinkForStaleDevice(const OicUuid\_t \*devUuid){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0 ;
 int id = 0; if (OC\_STACK\_OK != getIdForUUID(devUuid, &id)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_UPDATE\_LINK\_STALE\_FOR\_STALE\_DEVICE, strlen(PDM\_SQLITE\_UPDATE\_LINK\_STALE\_FOR\_STALE\_DEVICE) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_SECOND, id); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 if (SQLITE\_DONE != sqlite3\_step(stmt)) { OIC\_LOG\_V(ERROR, TAG, "Error message: %s", sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMSetDeviceState(const OicUuid\_t\* uuid, PdmDeviceState\_t state){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 OCStackResult res = OC\_STACK\_ERROR;
 CHECK\_PDM\_INIT(TAG); if (NULL == uuid) { OIC\_LOG(ERROR, TAG, "Invalid PARAM"); return OC\_STACK\_INVALID\_PARAM; } begin();
 if(PDM\_DEVICE\_STALE == state) { res = updateLinkForStaleDevice(uuid); if (OC\_STACK\_OK != res) { rollback(); OIC\_LOG(ERROR, TAG, "unable to update links"); return res; } }
 res = updateDeviceState(uuid, state); if (OC\_STACK\_OK != res) { rollback(); OIC\_LOG(ERROR, TAG, "unable to update device state"); return res; } commit(); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
[View remainder of file in raw view](https://github.com/Samsung/TizenRT/raw/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning/src/provisioningdatabasemanager.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_aca18bae_20250114_190126.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FTizenRT%2Fblob%2Ff8f776dd183246ad8890422c1ee5e8f33ab2aaaf%2Fexternal%2Fiotivity%2Fiotivity_1.2-rel%2Fresource%2Fcsdk%2Fsecurity%2Fprovisioning%2Fsrc%2Fprovisioningdatabasemanager.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FTizenRT%2Fblob%2Ff8f776dd183246ad8890422c1ee5e8f33ab2aaaf%2Fexternal%2Fiotivity%2Fiotivity_1.2-rel%2Fresource%2Fcsdk%2Fsecurity%2Fprovisioning%2Fsrc%2Fprovisioningdatabasemanager.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=Samsung%2FTizenRT)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[Samsung](/Samsung)
/
**[TizenRT](/Samsung/TizenRT)**
Public

* [Notifications](/login?return_to=%2FSamsung%2FTizenRT) You must be signed in to change notification settings
* [Fork
  591](/login?return_to=%2FSamsung%2FTizenRT)
* [Star
   593](/login?return_to=%2FSamsung%2FTizenRT)

* [Code](/Samsung/TizenRT)
* [Issues
  37](/Samsung/TizenRT/issues)
* [Pull requests
  83](/Samsung/TizenRT/pulls)
* [Actions](/Samsung/TizenRT/actions)
* [Projects
  0](/Samsung/TizenRT/projects)
* [Wiki](/Samsung/TizenRT/wiki)
* [Security](/Samsung/TizenRT/security)
* [Insights](/Samsung/TizenRT/pulse)

Additional navigation options

* [Code](/Samsung/TizenRT)
* [Issues](/Samsung/TizenRT/issues)
* [Pull requests](/Samsung/TizenRT/pulls)
* [Actions](/Samsung/TizenRT/actions)
* [Projects](/Samsung/TizenRT/projects)
* [Wiki](/Samsung/TizenRT/wiki)
* [Security](/Samsung/TizenRT/security)
* [Insights](/Samsung/TizenRT/pulse)

## Files

 f8f776d
## Breadcrumbs

1. [TizenRT](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf)
2. /[external](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external)
3. /[iotivity](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity)
4. /[iotivity\_1.2-rel](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel)
5. /[resource](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource)
6. /[csdk](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk)
7. /[security](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security)
8. /[provisioning](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning)
9. /[src](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning/src)
/
# provisioningdatabasemanager.c

Copy path Blame  Blame
## Latest commit

## History

[History](/Samsung/TizenRT/commits/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning/src/provisioningdatabasemanager.c)1061 lines (906 loc) · 32.1 KB f8f776d
## Breadcrumbs

1. [TizenRT](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf)
2. /[external](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external)
3. /[iotivity](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity)
4. /[iotivity\_1.2-rel](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel)
5. /[resource](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource)
6. /[csdk](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk)
7. /[security](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security)
8. /[provisioning](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning)
9. /[src](/Samsung/TizenRT/tree/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning/src)
/
# provisioningdatabasemanager.c

Top
## File metadata and controls

* Code
* Blame

1061 lines (906 loc) · 32.1 KB[Raw](https://github.com/Samsung/TizenRT/raw/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning/src/provisioningdatabasemanager.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* \* Copyright 2015 Samsung Electronics All Rights Reserved. \* \* \* \* Licensed under the Apache License, Version 2.0 (the "License"); \* you may not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an "AS IS" BASIS, \* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \* \* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
#include <stdio.h>#include <stdbool.h>#include <string.h>#include <stdlib.h>
#include "sqlite3.h"#include "logger.h"#include "oic\_malloc.h"#include "provisioningdatabasemanager.h"#include "pmutility.h"#include "oic\_string.h"#include "utlist.h"
#define DB\_FILE "PDM.db"
#define TAG "OIC\_PDM"
#define PDM\_FIRST\_INDEX 0#define PDM\_SECOND\_INDEX 1
#define PDM\_BIND\_INDEX\_FIRST 1#define PDM\_BIND\_INDEX\_SECOND 2#define PDM\_BIND\_INDEX\_THIRD 3
#define PDM\_CREATE\_T\_DEVICE\_LIST "create table T\_DEVICE\_LIST(ID INTEGER PRIMARY KEY AUTOINCREMENT,\ UUID BLOB NOT NULL UNIQUE, STATE INT NOT NULL);"
#define PDM\_CREATE\_T\_DEVICE\_LINK "create table T\_DEVICE\_LINK\_STATE(ID INT NOT NULL, ID2 INT NOT \ NULL,STATE INT NOT NULL, PRIMARY KEY (ID, ID2));"/\*\* \* Macro to verify sqlite success. \* eg: VERIFY\_NON\_NULL(TAG, ptrData, ERROR,OC\_STACK\_ERROR); \*/#define PDM\_VERIFY\_SQLITE\_OK(tag, arg, logLevel, retValue) do{ if (SQLITE\_OK != (arg)) \ { OIC\_LOG\_V((logLevel), tag, "Error in " #arg ", Error Message: %s", \ sqlite3\_errmsg(g\_db)); return retValue; }}while(0)
#define PDM\_SQLITE\_TRANSACTION\_BEGIN "BEGIN TRANSACTION;"#define PDM\_SQLITE\_TRANSACTION\_COMMIT "COMMIT;"#define PDM\_SQLITE\_TRANSACTION\_ROLLBACK "ROLLBACK;"#define PDM\_SQLITE\_GET\_STALE\_INFO "SELECT ID,ID2 FROM T\_DEVICE\_LINK\_STATE WHERE STATE = ?"#define PDM\_SQLITE\_INSERT\_T\_DEVICE\_LIST "INSERT INTO T\_DEVICE\_LIST VALUES(?,?,?)"#define PDM\_SQLITE\_GET\_ID "SELECT ID FROM T\_DEVICE\_LIST WHERE UUID like ?"#define PDM\_SQLITE\_INSERT\_LINK\_DATA "INSERT INTO T\_DEVICE\_LINK\_STATE VALUES(?,?,?)"#define PDM\_SQLITE\_DELETE\_LINK "DELETE FROM T\_DEVICE\_LINK\_STATE WHERE ID = ? and ID2 = ?"#define PDM\_SQLITE\_DELETE\_DEVICE\_LINK "DELETE FROM T\_DEVICE\_LINK\_STATE WHERE ID = ? or ID2 = ?"#define PDM\_SQLITE\_DELETE\_DEVICE "DELETE FROM T\_DEVICE\_LIST WHERE ID = ?"#define PDM\_SQLITE\_DELETE\_DEVICE\_WITH\_STATE "DELETE FROM T\_DEVICE\_LIST WHERE STATE= ?"#define PDM\_SQLITE\_UPDATE\_LINK "UPDATE T\_DEVICE\_LINK\_STATE SET STATE = ? WHERE ID = ? and ID2 = ?"#define PDM\_SQLITE\_LIST\_ALL\_UUID "SELECT UUID FROM T\_DEVICE\_LIST WHERE STATE = 0"#define PDM\_SQLITE\_GET\_UUID "SELECT UUID,STATE FROM T\_DEVICE\_LIST WHERE ID = ?"#define PDM\_SQLITE\_GET\_LINKED\_DEVICES "SELECT ID,ID2 FROM T\_DEVICE\_LINK\_STATE WHERE \ (ID = ? or ID2 = ?) and state = 0"#define PDM\_SQLITE\_GET\_DEVICE\_LINKS "SELECT ID,ID2 FROM T\_DEVICE\_LINK\_STATE WHERE \ ID = ? and ID2 = ? and state = 0"#define PDM\_SQLITE\_UPDATE\_DEVICE "UPDATE T\_DEVICE\_LIST SET STATE = ? WHERE UUID like ?"#define PDM\_SQLITE\_GET\_DEVICE\_STATUS "SELECT STATE FROM T\_DEVICE\_LIST WHERE UUID like ?"#define PDM\_SQLITE\_UPDATE\_LINK\_STALE\_FOR\_STALE\_DEVICE "UPDATE T\_DEVICE\_LINK\_STATE SET STATE = 1\ WHERE ID = ? or ID2 = ?"
#define ASCENDING\_ORDER(id1, id2) do{if( (id1) > (id2) )\ { int temp; temp = id1; id1 = id2; id2 = temp; }}while(0)
#define CHECK\_PDM\_INIT(tag) do{if(true != gInit)\ { OIC\_LOG(ERROR, (tag), "PDB is not initialized"); \ return OC\_STACK\_PDM\_IS\_NOT\_INITIALIZED; }}while(0)
static sqlite3 \*g\_db = NULL;static bool gInit = false; /\* Only if we can open sqlite db successfully, gInit is true. \*/
/\*\* \* function to create DB in case DB doesn't exists \*/static OCStackResult createDB(const char\* path){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 int result = 0; result = sqlite3\_open\_v2(path, &g\_db, SQLITE\_OPEN\_READWRITE|SQLITE\_OPEN\_CREATE, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, result, ERROR, OC\_STACK\_ERROR);
 result = sqlite3\_exec(g\_db, PDM\_CREATE\_T\_DEVICE\_LIST, NULL, NULL, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, result, ERROR, OC\_STACK\_ERROR);
 OIC\_LOG(INFO, TAG, "Created T\_DEVICE\_LIST"); result = sqlite3\_exec(g\_db, PDM\_CREATE\_T\_DEVICE\_LINK, NULL, NULL, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, result, ERROR, OC\_STACK\_ERROR);
 OIC\_LOG(INFO, TAG, "Created T\_DEVICE\_LINK\_STATE"); gInit = true;
 OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_);
 return OC\_STACK\_OK;}
/\*\* \* Function to begin any transaction \*/static OCStackResult begin(){ int res = 0; res = sqlite3\_exec(g\_db, PDM\_SQLITE\_TRANSACTION\_BEGIN, NULL, NULL, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR); return OC\_STACK\_OK;}
/\*\* \* Function to commit any transaction \*/static OCStackResult commit(){ int res = 0; res = sqlite3\_exec(g\_db, PDM\_SQLITE\_TRANSACTION\_COMMIT, NULL, NULL, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR); return OC\_STACK\_OK;}
/\*\* \* Function to rollback any transaction \*/static OCStackResult rollback(){ int res = 0; res = sqlite3\_exec(g\_db, PDM\_SQLITE\_TRANSACTION\_ROLLBACK, NULL, NULL, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR); return OC\_STACK\_OK;}
/\*\* \* Error log callback called by SQLite stack in case of error \*/void errLogCallback(void \*pArg, int iErrCode, const char \*zMsg){ (void) pArg; (void) iErrCode; (void) zMsg; OIC\_LOG\_V(DEBUG,TAG, "%s : (%d) %s", \_\_func\_\_, iErrCode, zMsg);}
OCStackResult PDMInit(const char \*path){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 int rc; const char \*dbPath = NULL; if (SQLITE\_OK != sqlite3\_config(SQLITE\_CONFIG\_LOG, errLogCallback, NULL)) { OIC\_LOG(INFO, TAG, "Unable to enable debug log of sqlite"); }
 if (NULL == path || !\*path) { dbPath = DB\_FILE; } else { dbPath = path; } rc = sqlite3\_open\_v2(dbPath, &g\_db, SQLITE\_OPEN\_READWRITE, NULL); if (SQLITE\_OK != rc) { OIC\_LOG\_V(INFO, TAG, "ERROR: Can't open database: %s", sqlite3\_errmsg(g\_db)); sqlite3\_close(g\_db); OCStackResult ret = createDB(dbPath); if (OC\_STACK\_OK != ret) { sqlite3\_close(g\_db); } return ret; } gInit = true;
 /\* \* Remove PDM\_DEVICE\_INIT status devices. \* PDM\_DEVICE\_INIT means that the OTM process is in progress. \* PDM\_DEVICE\_INIT state device can be existed when the program is terminated during the OTM process in progress. \* For this reason, PDM\_DEVICE\_INIT devices should be removed at PDM initialization time. \*/ if(OC\_STACK\_OK != PDMDeleteDeviceWithState(PDM\_DEVICE\_INIT)) { OIC\_LOG\_V(WARNING, TAG, "Failed to delete init state devices."); }
 OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_);
 return OC\_STACK\_OK;}
OCStackResult PDMAddDevice(const OicUuid\_t \*UUID){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == UUID) { return OC\_STACK\_INVALID\_PARAM; }
 sqlite3\_stmt \*stmt = 0; int res =0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_INSERT\_T\_DEVICE\_LIST, strlen(PDM\_SQLITE\_INSERT\_T\_DEVICE\_LIST) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_blob(stmt, PDM\_BIND\_INDEX\_SECOND, UUID, UUID\_LENGTH, SQLITE\_STATIC); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_THIRD, PDM\_DEVICE\_INIT); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_step(stmt); if (SQLITE\_DONE != res) { if (SQLITE\_CONSTRAINT == res) { //new OCStack result code OIC\_LOG\_V(ERROR, TAG, "Error Occured: %s",sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_DUPLICATE\_UUID; } OIC\_LOG\_V(ERROR, TAG, "Error Occured: %s",sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt);
 OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
/\*\* \*function to get Id for given UUID \*/static OCStackResult getIdForUUID(const OicUuid\_t \*UUID , int \*id){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_GET\_ID, strlen(PDM\_SQLITE\_GET\_ID) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_blob(stmt, PDM\_BIND\_INDEX\_FIRST, UUID, UUID\_LENGTH, SQLITE\_STATIC); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 OIC\_LOG(DEBUG, TAG, "Binding Done"); while (SQLITE\_ROW == sqlite3\_step(stmt)) { int tempId = sqlite3\_column\_int(stmt, PDM\_FIRST\_INDEX); OIC\_LOG\_V(DEBUG, TAG, "ID is %d", tempId); \*id = tempId; sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK; } sqlite3\_finalize(stmt); return OC\_STACK\_INVALID\_PARAM;}
/\*\* \* Function to check duplication of device's Device ID. \*/OCStackResult PDMIsDuplicateDevice(const OicUuid\_t\* UUID, bool \*result){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == UUID || NULL == result) { OIC\_LOG(ERROR, TAG, "UUID or result is NULL"); return OC\_STACK\_INVALID\_PARAM; } sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_GET\_ID, strlen(PDM\_SQLITE\_GET\_ID) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_blob(stmt, PDM\_BIND\_INDEX\_FIRST, UUID, UUID\_LENGTH, SQLITE\_STATIC); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 OIC\_LOG(DEBUG, TAG, "Binding Done"); bool retValue = false; while(SQLITE\_ROW == sqlite3\_step(stmt)) { OIC\_LOG(INFO, TAG, "Duplicated UUID"); retValue = true; }
 sqlite3\_finalize(stmt); \*result = retValue;
 OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
/\*\* \* Function to add link in sqlite \*/static OCStackResult addlink(int id1, int id2){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_INSERT\_LINK\_DATA, strlen(PDM\_SQLITE\_INSERT\_LINK\_DATA) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id1); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_SECOND, id2); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_THIRD, PDM\_DEVICE\_ACTIVE); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 if (sqlite3\_step(stmt) != SQLITE\_DONE) { OIC\_LOG\_V(ERROR, TAG, "Error Occured: %s",sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMLinkDevices(const OicUuid\_t \*UUID1, const OicUuid\_t \*UUID2){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == UUID1 || NULL == UUID2) { OIC\_LOG(ERROR, TAG, "Invalid PARAM"); return OC\_STACK\_INVALID\_PARAM; }
 PdmDeviceState\_t state = PDM\_DEVICE\_UNKNOWN; if (OC\_STACK\_OK != PDMGetDeviceState(UUID1, &state)) { OIC\_LOG(ERROR, TAG, "Internal error occured"); return OC\_STACK\_ERROR; } if (PDM\_DEVICE\_ACTIVE != state) { OIC\_LOG\_V(ERROR, TAG, "UUID1: Device state is not active : %d", state); return OC\_STACK\_INVALID\_PARAM; }
 state = PDM\_DEVICE\_UNKNOWN; if (OC\_STACK\_OK != PDMGetDeviceState(UUID2, &state)) { OIC\_LOG(ERROR, TAG, "Internal error occured"); return OC\_STACK\_ERROR; } if (PDM\_DEVICE\_ACTIVE != state) { OIC\_LOG\_V(ERROR, TAG, "UUID2: Device state is not active : %d", state); return OC\_STACK\_INVALID\_PARAM; }
 int id1 = 0; if (OC\_STACK\_OK != getIdForUUID(UUID1, &id1)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; } int id2 = 0; if (OC\_STACK\_OK != getIdForUUID(UUID2, &id2)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 ASCENDING\_ORDER(id1, id2); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return addlink(id1, id2);}
/\*\* \* Function to remove created link \*/static OCStackResult removeLink(int id1, int id2){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 int res = 0; sqlite3\_stmt \*stmt = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_DELETE\_LINK, strlen(PDM\_SQLITE\_DELETE\_LINK) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id1); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_SECOND, id2); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 if (SQLITE\_DONE != sqlite3\_step(stmt)) { OIC\_LOG\_V(ERROR, TAG, "Error message: %s", sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMUnlinkDevices(const OicUuid\_t \*UUID1, const OicUuid\_t \*UUID2){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == UUID1 || NULL == UUID2) { OIC\_LOG(ERROR, TAG, "Invalid PARAM"); return OC\_STACK\_INVALID\_PARAM; }
 int id1 = 0; if (OC\_STACK\_OK != getIdForUUID(UUID1, &id1)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 int id2 = 0; if (OC\_STACK\_OK != getIdForUUID(UUID2, &id2)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; } ASCENDING\_ORDER(id1, id2); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return removeLink(id1, id2);}
static OCStackResult removeFromDeviceList(int id){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_DELETE\_DEVICE, strlen(PDM\_SQLITE\_DELETE\_DEVICE) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 if (sqlite3\_step(stmt) != SQLITE\_DONE) { OIC\_LOG\_V(ERROR, TAG, "Error message: %s", sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMDeleteDevice(const OicUuid\_t \*UUID){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == UUID) { return OC\_STACK\_INVALID\_PARAM; } int id = 0; if (OC\_STACK\_OK != getIdForUUID(UUID, &id)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; } begin(); if(OC\_STACK\_OK != removeFromDeviceList(id)) { rollback(); OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_ERROR; } commit(); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
static OCStackResult updateLinkState(int id1, int id2, int state){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0 ; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_UPDATE\_LINK, strlen(PDM\_SQLITE\_UPDATE\_LINK) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, state); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_SECOND, id1); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_THIRD, id2); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 if (SQLITE\_DONE != sqlite3\_step(stmt)) { OIC\_LOG\_V(ERROR, TAG, "Error message: %s", sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMSetLinkStale(const OicUuid\_t\* uuidOfDevice1, const OicUuid\_t\* uuidOfDevice2){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == uuidOfDevice1 || NULL == uuidOfDevice2) { OIC\_LOG(ERROR, TAG, "Invalid PARAM"); return OC\_STACK\_INVALID\_PARAM; }
 int id1 = 0; if (OC\_STACK\_OK != getIdForUUID(uuidOfDevice1, &id1)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 int id2 = 0; if (OC\_STACK\_OK != getIdForUUID(uuidOfDevice2, &id2)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; } ASCENDING\_ORDER(id1, id2); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return updateLinkState(id1, id2, PDM\_DEVICE\_STALE);}
OCStackResult PDMGetOwnedDevices(OCUuidList\_t \*\*uuidList, size\_t \*numOfDevices){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL != \*uuidList) { OIC\_LOG(ERROR, TAG, "Not null list will cause memory leak"); return OC\_STACK\_INVALID\_PARAM; } sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_LIST\_ALL\_UUID, strlen(PDM\_SQLITE\_LIST\_ALL\_UUID) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 size\_t counter = 0; while (SQLITE\_ROW == sqlite3\_step(stmt)) { const void \*ptr = sqlite3\_column\_blob(stmt, PDM\_FIRST\_INDEX); OicUuid\_t \*uid = (OicUuid\_t \*)ptr; OCUuidList\_t \*temp = (OCUuidList\_t \*) OICCalloc(1,sizeof(OCUuidList\_t)); if (NULL == temp) { OIC\_LOG\_V(ERROR, TAG, "Memory allocation problem"); sqlite3\_finalize(stmt); return OC\_STACK\_NO\_MEMORY; } memcpy(&temp->dev.id, uid->id, UUID\_LENGTH); LL\_PREPEND(\*uuidList,temp); ++counter; } \*numOfDevices = counter; sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
static OCStackResult getUUIDforId(int id, OicUuid\_t \*uid, bool \*result){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_GET\_UUID, strlen(PDM\_SQLITE\_GET\_UUID) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 while (SQLITE\_ROW == sqlite3\_step(stmt)) { const void \*ptr = sqlite3\_column\_blob(stmt, PDM\_FIRST\_INDEX); memcpy(uid, ptr, sizeof(OicUuid\_t));
 int temp = sqlite3\_column\_int(stmt, PDM\_SECOND\_INDEX); if(PDM\_DEVICE\_STALE == temp) { if(result) { \*result = true; } } else { if(result) { \*result = false; } } sqlite3\_finalize(stmt); return OC\_STACK\_OK; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_INVALID\_PARAM;}
OCStackResult PDMGetLinkedDevices(const OicUuid\_t \*UUID, OCUuidList\_t \*\*UUIDLIST, size\_t \*numOfDevices){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == UUID || NULL == numOfDevices || !UUIDLIST) { return OC\_STACK\_INVALID\_PARAM; } if (NULL != \*UUIDLIST ) { OIC\_LOG(ERROR, TAG, "Not null list will cause memory leak"); return OC\_STACK\_INVALID\_PARAM; } PdmDeviceState\_t state = PDM\_DEVICE\_UNKNOWN; OCStackResult ret = PDMGetDeviceState(UUID, &state); if (OC\_STACK\_OK != ret) { OIC\_LOG(ERROR, TAG, "Internal error occured"); return OC\_STACK\_ERROR; } if (PDM\_DEVICE\_ACTIVE != state) { OIC\_LOG\_V(ERROR, TAG, "Device state is not active : %d", state); return OC\_STACK\_INVALID\_PARAM; } int id = 0; if (OC\_STACK\_OK != getIdForUUID(UUID, &id)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_GET\_LINKED\_DEVICES, strlen(PDM\_SQLITE\_GET\_LINKED\_DEVICES) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_SECOND, id); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 size\_t counter = 0; while (SQLITE\_ROW == sqlite3\_step(stmt)) { int i1 = sqlite3\_column\_int(stmt, PDM\_FIRST\_INDEX); int i2 = sqlite3\_column\_int(stmt, PDM\_SECOND\_INDEX);
 OicUuid\_t temp = {{0,}}; if (i1 != id) { getUUIDforId(i1, &temp, NULL); } if (i2 != id) { getUUIDforId(i2, &temp, NULL); }
 OCUuidList\_t \*tempNode = (OCUuidList\_t \*) OICCalloc(1,sizeof(OCUuidList\_t)); if (NULL == tempNode) { OIC\_LOG(ERROR, TAG, "No Memory"); sqlite3\_finalize(stmt); return OC\_STACK\_NO\_MEMORY; } memcpy(&tempNode->dev.id, &temp.id, UUID\_LENGTH); LL\_PREPEND(\*UUIDLIST,tempNode); ++counter; } \*numOfDevices = counter; sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMGetToBeUnlinkedDevices(OCPairList\_t \*\*staleDevList, size\_t \*numOfDevices){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL != \*staleDevList) { OIC\_LOG(ERROR, TAG, "Not null list will cause memory leak"); return OC\_STACK\_INVALID\_PARAM; }
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_GET\_STALE\_INFO, strlen(PDM\_SQLITE\_GET\_STALE\_INFO) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, PDM\_DEVICE\_STALE); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 size\_t counter = 0; while (SQLITE\_ROW == sqlite3\_step(stmt)) { int i1 = sqlite3\_column\_int(stmt, PDM\_FIRST\_INDEX); int i2 = sqlite3\_column\_int(stmt, PDM\_SECOND\_INDEX); OicUuid\_t temp1 = {{0,}}; OicUuid\_t temp2 = {{0,}};; getUUIDforId(i1, &temp1, NULL); getUUIDforId(i2, &temp2, NULL);
 OCPairList\_t \*tempNode = (OCPairList\_t \*) OICCalloc(1, sizeof(OCPairList\_t)); if (NULL == tempNode) { OIC\_LOG(ERROR, TAG, "No Memory"); sqlite3\_finalize(stmt); return OC\_STACK\_NO\_MEMORY; } memcpy(&tempNode->dev.id, &temp1.id, UUID\_LENGTH); memcpy(&tempNode->dev2.id, &temp2.id, UUID\_LENGTH); LL\_PREPEND(\*staleDevList, tempNode); ++counter; } \*numOfDevices = counter; sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMClose(){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); int res = 0; res = sqlite3\_close(g\_db); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
void PDMDestoryOicUuidLinkList(OCUuidList\_t\* ptr){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 if(ptr) { OCUuidList\_t \*tmp1 = NULL,\*tmp2=NULL; LL\_FOREACH\_SAFE(ptr, tmp1, tmp2) { LL\_DELETE(ptr, tmp1); OICFree(tmp1); } }
 OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_);}
void PDMDestoryStaleLinkList(OCPairList\_t\* ptr){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 if(ptr) { OCPairList\_t \*tmp1 = NULL,\*tmp2=NULL; LL\_FOREACH\_SAFE(ptr, tmp1, tmp2) { LL\_DELETE(ptr, tmp1); OICFree(tmp1); } }
 OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_);}
OCStackResult PDMIsLinkExists(const OicUuid\_t\* uuidOfDevice1, const OicUuid\_t\* uuidOfDevice2, bool\* result){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 CHECK\_PDM\_INIT(TAG); if (NULL == uuidOfDevice1 || NULL == uuidOfDevice2 || NULL == result) { return OC\_STACK\_INVALID\_PARAM; } int id1 = 0; int id2 = 0; if (OC\_STACK\_OK != getIdForUUID(uuidOfDevice1, &id1)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 if (OC\_STACK\_OK != getIdForUUID(uuidOfDevice2, &id2)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 PdmDeviceState\_t state = PDM\_DEVICE\_UNKNOWN; if (OC\_STACK\_OK != PDMGetDeviceState(uuidOfDevice1, &state)) { OIC\_LOG(ERROR, TAG, "uuidOfDevice1:Internal error occured"); return OC\_STACK\_ERROR; } if (PDM\_DEVICE\_ACTIVE != state) { OIC\_LOG\_V(ERROR, TAG, "uuidOfDevice1:Device state is not active : %d", state); return OC\_STACK\_INVALID\_PARAM; }
 state = PDM\_DEVICE\_UNKNOWN; if (OC\_STACK\_OK != PDMGetDeviceState(uuidOfDevice2, &state)) { OIC\_LOG(ERROR, TAG, "uuidOfDevice2:Internal error occured"); return OC\_STACK\_ERROR; } if (PDM\_DEVICE\_ACTIVE != state) { OIC\_LOG\_V(ERROR, TAG, "uuidOfDevice2:Device state is not active : %d", state); return OC\_STACK\_INVALID\_PARAM; }
 ASCENDING\_ORDER(id1, id2);
 sqlite3\_stmt \*stmt = 0; int res = 0; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_GET\_DEVICE\_LINKS, strlen(PDM\_SQLITE\_GET\_DEVICE\_LINKS) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id1); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_SECOND, id2); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 bool ret = false; while(SQLITE\_ROW == sqlite3\_step(stmt)) { OIC\_LOG(INFO, TAG, "Link already exists between devices"); ret = true; } sqlite3\_finalize(stmt); \*result = ret; OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
static OCStackResult updateDeviceState(const OicUuid\_t \*uuid, PdmDeviceState\_t state){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0 ; res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_UPDATE\_DEVICE, strlen(PDM\_SQLITE\_UPDATE\_DEVICE) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, state); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_blob(stmt, PDM\_BIND\_INDEX\_SECOND, uuid, UUID\_LENGTH, SQLITE\_STATIC); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 if (SQLITE\_DONE != sqlite3\_step(stmt)) { OIC\_LOG\_V(ERROR, TAG, "Error message: %s", sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
static OCStackResult updateLinkForStaleDevice(const OicUuid\_t \*devUuid){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 sqlite3\_stmt \*stmt = 0; int res = 0 ;
 int id = 0; if (OC\_STACK\_OK != getIdForUUID(devUuid, &id)) { OIC\_LOG(ERROR, TAG, "Requested value not found"); return OC\_STACK\_INVALID\_PARAM; }
 res = sqlite3\_prepare\_v2(g\_db, PDM\_SQLITE\_UPDATE\_LINK\_STALE\_FOR\_STALE\_DEVICE, strlen(PDM\_SQLITE\_UPDATE\_LINK\_STALE\_FOR\_STALE\_DEVICE) + 1, &stmt, NULL); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_FIRST, id); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 res = sqlite3\_bind\_int(stmt, PDM\_BIND\_INDEX\_SECOND, id); PDM\_VERIFY\_SQLITE\_OK(TAG, res, ERROR, OC\_STACK\_ERROR);
 if (SQLITE\_DONE != sqlite3\_step(stmt)) { OIC\_LOG\_V(ERROR, TAG, "Error message: %s", sqlite3\_errmsg(g\_db)); sqlite3\_finalize(stmt); return OC\_STACK\_ERROR; } sqlite3\_finalize(stmt); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
OCStackResult PDMSetDeviceState(const OicUuid\_t\* uuid, PdmDeviceState\_t state){ OIC\_LOG\_V(DEBUG, TAG, "IN %s", \_\_func\_\_);
 OCStackResult res = OC\_STACK\_ERROR;
 CHECK\_PDM\_INIT(TAG); if (NULL == uuid) { OIC\_LOG(ERROR, TAG, "Invalid PARAM"); return OC\_STACK\_INVALID\_PARAM; } begin();
 if(PDM\_DEVICE\_STALE == state) { res = updateLinkForStaleDevice(uuid); if (OC\_STACK\_OK != res) { rollback(); OIC\_LOG(ERROR, TAG, "unable to update links"); return res; } }
 res = updateDeviceState(uuid, state); if (OC\_STACK\_OK != res) { rollback(); OIC\_LOG(ERROR, TAG, "unable to update device state"); return res; } commit(); OIC\_LOG\_V(DEBUG, TAG, "OUT %s", \_\_func\_\_); return OC\_STACK\_OK;}
[View remainder of file in raw view](https://github.com/Samsung/TizenRT/raw/f8f776dd183246ad8890422c1ee5e8f33ab2aaaf/external/iotivity/iotivity_1.2-rel/resource/csdk/security/provisioning/src/provisioningdatabasemanager.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


