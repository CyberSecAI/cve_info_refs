The provided content details a Server-Side Request Forgery (SSRF) vulnerability in iCMS v7.0.16.

**Root cause of vulnerability:**
The vulnerability lies within the `remote` function of `app\spider\spider_tools.class.php`. This function takes a URL as input and uses `curl` to fetch content from the provided URL. The `safe_url` function intended to sanitize the URL is insufficient, allowing for manipulation of the URL and potential SSRF.

**Weaknesses/vulnerabilities present:**
- **Insufficient URL Sanitization:** The `safe_url` function fails to prevent malicious URLs from being processed.
- **Unrestricted URL Parameter:** The `url` parameter in `admincp.php` is directly passed to the vulnerable `remote` function.
- **Lack of proper validation of Host:**  The parsing logic of the URL allows for embedding credentials, leading to arbitrary host access.

**Impact of exploitation:**
- **Internal Service Access:** An attacker can use the vulnerable server to access internal services that are not publicly accessible. This includes internal applications, databases, or even the server's own metadata.
- **Port Scanning:** The attacker can perform port scans of internal networks via the vulnerable server.
- **Information Disclosure:** Sensitive information might be obtained through requests to internal resources.

**Attack vectors:**
- The attack vector is the `url` parameter of the `admincp.php` interface.
- A malicious user can craft a URL with embedded credentials using the format `http://user:pass@host/` to make the vulnerable server connect to attacker-controlled or internal resources.

**Required attacker capabilities/position:**
- The attacker must have access to the `admincp.php` page.
- The attacker needs the ability to inject a malicious URL into the `url` parameter.
- The attacker needs to have some knowledge about internal infrastructure to target internal resources.

**Technical details:**
The PoC provided demonstrates the vulnerability by crafting a URL such as `http://m09ic@192.168.156.136:80@baidu.com/` which results in the server making a request to `192.168.156.136:88`. This indicates that the parser extracts the part of url between the second @ and the next /, and uses the part between the first and second @ as username and password.

The vulnerable code snippet is shown as:
```php
public static function remote($url,$ref=null,$_count = 0) {
        if(self::safe_url($url)===false) return false;

        (iPHP_SHELL && self::$debug) && print self::datetime()."\033[36mspider_tools::remote\033[0m [".($_count+1)."] => ".$url.PHP_EOL;

        $parsed = parse_url($url);
        $url = str_replace('&amp;', '&', $url);
        if(empty(spider::$referer)){
            spider::$referer = $parsed['scheme'] . '://' . $parsed['host'];
        }

        $options = array(
            CURLOPT_URL                  => $url,
            CURLOPT_REFERER              => self::$CURLOPT_REFERER?self::$CURLOPT_REFERER:spider::$referer,
            CURLOPT_USERAGENT            => self::$CURLOPT_USERAGENT?self::$CURLOPT_USERAGENT:spider::$useragent,
            CURLOPT_ENCODING             => self::$CURLOPT_ENCODING?self::$CURLOPT_ENCODING:spider::$encoding,
            CURLOPT_TIMEOUT              => self::$CURLOPT_TIMEOUT,
            CURLOPT_CONNECTTIMEOUT       => self::$CURLOPT_CONNECTTIMEOUT,
            CURLOPT_RETURNTRANSFER       => 1,
            CURLOPT_FAILONERROR          => 0,
            CURLOPT_HEADER               => 0,
            CURLOPT_NOSIGNAL             => true,
            // CURLOPT_DNS_USE_GLOBAL_CACHE => true,
            // CURLOPT_DNS_CACHE_TIMEOUT    => 86400,
            CURLOPT_SSL_VERIFYPEER       => false,
            CURLOPT_SSL_VERIFYHOST       => false
            // CURLOPT_FOLLOWLOCATION => 1,// 使用自动跳转
            // CURLOPT_MAXREDIRS => 7,//查找次数，防止查找太深
        );
        ...
```