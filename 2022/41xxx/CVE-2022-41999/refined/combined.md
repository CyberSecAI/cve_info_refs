=== Content from talosintelligence.com_76607d3b_20250114_214004.html ===


* [Cisco Login](/users/auth/saml)

* [Intelligence Center](/reputation)

  + [# Intelligence Center](/reputation)
  + BACK
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* [Vulnerability Research](/vulnerability_info)

  + [# Vulnerability Research](/vulnerability_info)
  + BACK
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* [Incident Response](/incident_response)

  + [# Incident Response](/incident_response)
  + BACK
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* [Blog](https://blog.talosintelligence.com)
* [Support](https://support.talosintelligence.com)

More

* Security Resources

  # Security Resources

  + BACK
  Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* Media

  # Media

  + BACK
  Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* Company

  # Company

  + BACK
  Company
  + [About Talos](/about)
  + [Careers](/careers)

* Under Attack?
* [Cisco Login](/users/auth/saml)

## Contact Cisco Talos Incident Response

×

Close

This form is for Incident Response service inquiries only, including emergency network security needs.

For reputation or categorization inquiries, visit the [Talos Support site](/support).
For emergency DDoS mitigation assistance, please contact the [Cisco Secure DDoS Protection Team](https://www.cisco.com/c/en/us/products/collateral/security/ddos-emergency-attack-mitigation-aag.pdf).

Name

Company (optional)

Email address

Phone number

Preferred communication:

Email

Phone

What Incident Response Service are you interested in?
General Talos IR services and retainer information
Emergency Response
IR Plan
IR Playbooks
IR Readiness Assessment
Tabletop Exercises
Compromise Assessment
Threat Hunting
Cyber Range Training
Intelligence on Demand

Please provide as much detail as possible so we can best address your needs

I acknowledge that this is an inquiry for Incident Response services and that any other use of this form will not receive a response.

Send Email
Cancel

# Talos Vulnerability Report

### TALOS-2022-1635

## OpenImageIO DDS native tile reading denial of service vulnerability

##### December 22, 2022

##### CVE Number

CVE-2022-41999

##### SUMMARY

A denial of service vulnerability exists in the DDS native tile reading functionality of OpenImageIO Project OpenImageIO v2.3.19.0 and v2.4.4.2. A specially-crafted .dds can lead to denial of service. An attacker can provide a malicious file to trigger this vulnerability.

##### CONFIRMED VULNERABLE VERSIONS

The versions below were either tested or verified to be vulnerable by Talos or confirmed to be vulnerable by the vendor.

OpenImageIO Project OpenImageIO v2.3.19.0

OpenImageIO Project OpenImageIO v2.4.4.2

##### PRODUCT URLS

OpenImageIO - <https://github.com/OpenImageIO/oiio>

##### CVSSv3 SCORE

7.5 - CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H

##### CWE

CWE-476 - NULL Pointer Dereference

##### DETAILS

OpenImageIO is an image processing library with easy-to-use interfaces and a sizable number of supported image formats. Useful for conversion and processing and even image comparison, this library is utilized by 3D-processing software from AliceVision (including Meshroom), as well as Blender for reading Photoshop .psd files.

The DirectDraw Surface file format (.dds) is another one of the file formats that libOpenImageIO can handle. It’s primarily used for DirectX and can contain a large number of textures, both compressed and uncompressed. When using libOpenImageIO to interact with .dds files, the same basic work flow occurs, in that we create a generic ImageInput object and then call `ReadImage()` on our input file. After a certain amount of generic `ImageInput` files, we end up hitting the `DDSInput` object’s more specific handlers, so let us take a quick look at `DDSInput::read_native_tile`:

```
bool
DDSInput::read_native_tile(int subimage, int miplevel, int x, int y, int z,
                           void* data)
{
    lock_guard lock(*this);
    if (!seek_subimage(subimage, miplevel))
        return false;

    // static ints to keep track of the current cube face and re-seek and
    // re-read face
    static int lastx = -1, lasty = -1, lastz = -1;
    // don't proceed if not a cube map - use scanlines then instead
    if (!(m_dds.caps.flags2 & DDS_CAPS2_CUBEMAP))
        return false;
    // make sure we get the right dimensions
    if (x % m_spec.tile_width || y % m_spec.tile_height
        || z % m_spec.tile_width)
        return false;
    if (m_buf.empty() || x != lastx || y != lasty || z != lastz) {        // [1]
        lastx          = x;
        lasty          = y;
        lastz          = z;
        unsigned int w = 0, h = 0, d = 0;
#ifdef DDS_3X2_CUBE_MAP_LAYOUT
        internal_seek_subimage(((x / m_spec.tile_width) << 1)
                                   + y / m_spec.tile_height,
                               m_miplevel, w, h, d);
#else   // 1x6 layout
        internal_seek_subimage(y / m_spec.tile_height, m_miplevel, w, h, d);
#endif  // DDS_3X2_CUBE_MAP_LAYOUT
        if (!w && !h && !d)
            // face not present in file, black-pad the image
            memset(&m_buf[0], 0, m_spec.tile_bytes());                        // [2]
        else
            readimg_tiles();
    }

    memcpy(data, &m_buf[0], m_spec.tile_bytes());                         // [3]
    return true;
}

```

Over all, the function is supposed to copy the bytes out of `m_buf` into the `void *data` at [3]. But if the `m_buf` vector (which is a DDSInput object variable) is empty [1] and no subimages can be found, then the vector is cleared out at [2]. But interestingly, let us quickly look at where the `m_buf` vector gets populated:

```
bool
DDSInput::readimg_scanlines()
{
    //std::cerr << "[dds] readimg: " << ftell() << "\n";
    // resize destination buffer
    m_buf.resize(m_spec.scanline_bytes() * m_spec.height * m_spec.depth
                 /*/ (1 << m_miplevel)*/);

    return internal_readimg(&m_buf[0], m_spec.width, m_spec.height,
                            m_spec.depth);
}

bool
DDSInput::readimg_tiles()
{
    // resize destination buffer
    m_buf.resize(m_spec.tile_bytes());

    return internal_readimg(&m_buf[0], m_spec.tile_width, m_spec.tile_height,
                            m_spec.tile_depth);
}

```

As we can see, both the `DDSInput::readimg_scanlines()` and `DDSInput::readimg_tiles()` functions resize the `m_buf` and read in data, but let’s quickly look at `DDSInput::read_native_scanline` so we can compare it with the above listed `DDSInput::read_native_tile`:

```
bool
DDSInput::read_native_scanline(int subimage, int miplevel, int y, int z,
                               void* data)
{
    lock_guard lock(*this);
    if (!seek_subimage(subimage, miplevel))
        return false;

    // don't proceed if a cube map - use tiles then instead
    if (m_dds.caps.flags2 & DDS_CAPS2_CUBEMAP)
        return false;
    if (m_buf.empty())            // [4]
        readimg_scanlines();

    size_t size = spec().scanline_bytes();
    memcpy(data, &m_buf[0] + z * m_spec.height * size + y * size, size);
    return true;
}

```

At [4], we clearly see that if `m_buf` is empty, then the `readimg_scanlines` function is called to correctly insert data into the `m_buf` vector before we use it. So let’s look again at how `DDSInput::read_native_tiles` behaves if `m_buf` is empty:

```
 bool
    DDSInput::read_native_tile(int subimage, int miplevel, int x, int y, int z,
                               void* data)
    {
    // [...]
    if (m_buf.empty() || x != lastx || y != lasty || z != lastz) {        // [5]
        lastx          = x;
        lasty          = y;
        lastz          = z;
        unsigned int w = 0, h = 0, d = 0;

#ifdef DDS_3X2_CUBE_MAP_LAYOUT
        internal_seek_subimage(((x / m_spec.tile_width) << 1)
                                   + y / m_spec.tile_height,
                               m_miplevel, w, h, d);
#else   // 1x6 layout
        internal_seek_subimage(y / m_spec.tile_height, m_miplevel, w, h, d);
#endif  // DDS_3X2_CUBE_MAP_LAYOUT

        if (!w && !h && !d)                                                 // [6]
            // face not present in file, black-pad the image
            memset(&m_buf[0], 0, m_spec.tile_bytes());                        // [7]
        else
            readimg_tiles();

```

We enter the branch at [5] if `m_buf` is empty, then the code attempts to populate the `w`, `h` and `d` variables inside of `internal_seek_subimage`. If this is unsuccessful, we call `memset` on the `m_buf` vector, which, if we’ll remember, has not been populated yet, resulting in a write to the null page and a quick denial of service [7]. As for how we get to this particular code path, it just seems like we need the image to have a `spec.tile_width`, such that we enter the tiled-image codepaths. This is done via the initial opening of the .dds file, in which the first 0x80 bytes are read directly into a `dds_header` struct:

```
/// DDS file header.
typedef struct {
    uint32_t fourCC;   ///< file four-character code
    uint32_t size;     ///< structure size, must be 124
    uint32_t flags;    ///< flags to indicate valid fields
    uint32_t height;   ///< image height
    uint32_t width;    ///< image width
    uint32_t pitch;    ///< bytes per scanline (uncmp.)/total byte size (cmp.)
    uint32_t depth;    ///< image depth (for 3D textures)
    uint32_t mipmaps;  ///< number of mipmaps
    uint32_t unused0[11];
    dds_pixformat fmt;  ///< pixel format
    dds_caps caps;      ///< DirectDraw Surface caps
    uint32_t unused1;
} dds_header;

```

Subsequently the `width` is copied into the `m_spec.tile_width` inside `DDSInput::seek_subimage`:

```
bool
DDSInput::seek_subimage(int subimage, int miplevel)
{
    // [...]
    m_spec.tile_width = m_spec.full_width = w;
    m_spec.tile_height = m_spec.full_height = h;
    m_spec.tile_depth = m_spec.full_depth = d;

```

The second requirement to hit the `memset` is the branch at [6], but this seems easily doable as long as our `dds_header.caps.flags2` (offset 0x70 in file, little endian) are correctly set:

```
// NOTE: This function has no sanity checks! It's a private method and relies
// on the input being correct and valid!
void
DDSInput::internal_seek_subimage(int cubeface, int miplevel, unsigned int& w,
                                 unsigned int& h, unsigned int& d)
{
    // early out for cubemaps that don't contain the requested face
    if (m_dds.caps.flags2 & DDS_CAPS2_CUBEMAP
        && !(m_dds.caps.flags2 & (DDS_CAPS2_CUBEMAP_POSITIVEX << cubeface))) {
        w = h = d = 0;
        return;
    }

```
### Crash Information

```
Running: ./mini_crash.dds
/usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:9: runtime error: reference binding to null pointer of type 'unsigned char'
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_vector.h:1046:9 in
/oiio/oiio-2.4.4.2/src/dds.imageio/ddsinput.cpp:870:20: runtime error: null pointer passed as argument 1, which is declared to never be null
/usr/include/string.h:61:62: note: nonnull attribute specified here
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /oiio/oiio-2.4.4.2/src/dds.imageio/ddsinput.cpp:870:20 in

Thread 1 "fuzz_oiio.bin" received signal SIGSEGV, Segmentation fault.
__memset_evex_unaligned_erms () at ../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:283
283     ../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S: No such file or directory.

[^_^] SIGSEGV

***********************************************************************************
***********************************************************************************
rax        : 0x0                                | rip[L]     : 0x7fffec45bbce <__memset_evex_unali
rbx        : 0x0                                | eflags     : 0x10283
rcx        : 0x0                                | cs         : 0x33
rdx        : 0x80                               | ss         : 0x2b
rsi        : 0x0                                | ds         : 0x0
rdi        : 0x0                                | es         : 0x0
rbp[S]     : 0x7fffffffa430                     | fs         : 0x0
rsp[S]     : 0x7fffffff9bf8                     | gs         : 0x0
r8         : 0x7fff8010                         | k0         : 0xffff0000
r9         : 0x6                                | k1         : 0xffff
r10        : 0xf                                | k2         : 0x7
r11        : 0x206                              | k3         : 0x0
r12        : 0x617000000e80                     | k4         : 0x0
r13        : 0x1                                | k5         : 0x0
r14        : 0x0                                | k6         : 0x0
r15        : 0x80                               | k7         : 0x0
***********************************************************************************
   0x7fffec45bbbe <__memset_evex_unaligned_erms+126>:   rol    bl,1
   0x7fffec45bbc0 <__memset_evex_unaligned_erms+128>:   cmp    rdx,QWORD PTR [rip+0x69829]        # 0x7fffec4c53f0 <__x86_rep_stosb_threshold>
   0x7fffec45bbc7 <__memset_evex_unaligned_erms+135>:   ja     0x7fffec45bbb0 <__memset_evex_unaligned_erms+112>
   0x7fffec45bbc9 <__memset_evex_unaligned_erms+137>:   lea    rcx,[rdi+rdx*1-0x80]
=> 0x7fffec45bbce <__memset_evex_unaligned_erms+142>:   vmovdqu64 YMMWORD PTR [rax],ymm16
   0x7fffec45bbd4 <__memset_evex_unaligned_erms+148>:   vmovdqu64 YMMWORD PTR [rax+0x20],ymm16
   0x7fffec45bbdb <__memset_evex_unaligned_erms+155>:   cmp    rdx,0x80
   0x7fffec45bbe2 <__memset_evex_unaligned_erms+162>:   jbe    0x7fffec45bb70 <__memset_evex_unaligned_erms+48>
   0x7fffec45bbe4 <__memset_evex_unaligned_erms+164>:   vmovdqu64 YMMWORD PTR [rax+0x40],ymm16
***********************************************************************************
#0  __memset_evex_unaligned_erms () at ../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:283
#1  0x00005555556311c4 in __asan_memset ()
#2  0x00007ffff3792c20 in OpenImageIO_v2_4::DDSInput::read_native_tile (this=0x614000000c40, subimage=0, miplevel=0, x=0, y=0, z=0, data=0x60c000000b80) at/ddsinput.cpp:870
#3  0x00007ffff2d3f167 in OpenImageIO_v2_4::ImageInput::read_native_tiles (this=0x614000000c40, subimage=0, miplevel=0, xbegin=0, xend=16, ybegin=0, yend=8, zbegin=0, zend=1, data=0x617000000e80) at/imageinput.cpp:774
#4  0x00007ffff2d37840 in OpenImageIO_v2_4::ImageInput::read_tiles (this=0x614000000c40, subimage=0, miplevel=0, xbegin=0, xend=16, ybegin=0, yend=8, zbegin=0, zend=1, chbegin=0, chend=1, format=..., data=0x617000000e80, xstride=1, ystride=16, zstride=768) at/imageinput.cpp:620
#5  0x00007ffff2d47951 in OpenImageIO_v2_4::ImageInput::read_image (this=0x614000000c40, subimage=0, miplevel=0, chbegin=0, chend=1, format=..., data=0x617000000e80, xstride=1, ystride=16, zstride=768, progress_callback=0x0, progress_callback_data=0x0) at/imageinput.cpp:941
#6  0x000055555566fa76 in LLVMFuzzerTestOneInput (Data=0x60d000000110 "DDS |", Size=133) at/oiio_harness.cpp:90
#7  0x00005555555954e4 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) ()
#8  0x000055555557f260 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) ()
#9  0x0000555555584fb7 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) ()
#10 0x00005555555aedd3 in main ()
***********************************************************************************

```
##### TIMELINE

2022-10-19 - Initial Vendor Contact

2022-10-20 - Vendor Disclosure

2022-11-01 - Vendor Patch Release

2022-12-22 - Public Release

##### Credit

Discovered by Lilith >\_> of Cisco Talos.

---

[Vulnerability Reports](/vulnerability_reports) [Next Report

TALOS-2022-1634](/vulnerability_reports/TALOS-2022-1634) [Previous Report

TALOS-2022-1636](/vulnerability_reports/TALOS-2022-1636)

* + ###### [Intelligence Center](/reputation)
  + [Intelligence Search](/reputation_center)
  + [Email & Spam Trends](/reputation_center/email_rep)
* + ###### [Vulnerability Research](/vulnerability_info)
  + [Vulnerability Reports](/vulnerability_reports)
  + [Microsoft Advisories](/ms_advisories)
* + ###### [Incident Response](/incident_response)
  + [Reactive Services](/incident_response/services#reactive-services)
  + [Proactive Services](/incident_response/services#proactive-services)
  + Emergency Support
* + ###### Security Resources
  + [Open Source Security Tools](/software)
  + [Intelligence Categories Reference](/categories)
  + [Secure Endpoint Naming Reference](/secure-endpoint-naming)
* + ###### Media
  + [Talos Intelligence Blog](https://blog.talosintelligence.com)
  + [Threat Source Newsletter](https://blog.talosintelligence.com/category/threat-source-newsletter/)
  + [Beers with Talos Podcast](/podcasts/shows/beers_with_talos)
  + [Talos Takes Podcast](/podcasts/shows/talos_takes)
  + [Talos Videos](https://www.youtube.com/channel/UCPZ1DtzQkStYBSG3GTNoyfg/featured)
* + ###### Support
  + [Support Documentation](https://support.talosintelligence.com)
* + ###### Company
  + [About Talos](/about)
  + [Careers](/careers)
  + [Cisco Security](https://www.cisco.com/c/en/us/products/security/product-listing.html)

###### Follow us

[![Cisco](/assets/logo_cisco_white-d87b7f7d3152ad412e48aad924a972cc5b802b7a53cb56b0792a4456c9b7b3a5.svg)](http://tools.cisco.com/security/center/home.x)

©
2025
Cisco Systems, Inc. and/or its affiliates. All rights
reserved. View our
[Privacy Policy.](http://www.cisco.com/web/siteassets/legal/privacy_full.html)



=== Content from security.gentoo.org_506cade4_20250114_214002.html ===

[![Gentoo](https://assets.gentoo.org/tyrian/v2/site-logo.png)](/ "Back to the homepage")
Security

[**Get Gentoo!**](https://get.gentoo.org/)
gentoo.org sites
[gentoo.org](https://www.gentoo.org/ "Main Gentoo website")
[Wiki](https://wiki.gentoo.org/ "Find and contribute documentation")
[Bugs](https://bugs.gentoo.org/ "Report issues and find common issues")
[Forums](https://forums.gentoo.org/ "Discuss with the community")
[Packages](https://packages.gentoo.org/ "Find software for your Gentoo")

[Planet](https://planet.gentoo.org/ "Find out what's going on in the developer community")
[Archives](https://archives.gentoo.org/ "Read up on past discussions")
[Sources](https://sources.gentoo.org/ "Browse our source code")

[Infra Status](https://infra-status.gentoo.org/ "Get updates on the services provided by Gentoo")

* [Home](/)
* [Stay informed](/subscribe)
* [Advisories](/glsa)

# OpenImageIO: Multiple Vulnerabilities — GLSA **202305-33**

Multiple vulnerabilities have been found in OpenImageIO, the worst of which could result in arbitrary code execution.

### Affected packages

| Package | **media-libs/openimageio** on all architectures |
| --- | --- |
| Affected versions | < **2.4.6.0** |
| Unaffected versions | >= **2.4.6.0** |

### Background

OpenImageIO is a library for reading and writing images.

### Description

Multiple vulnerabilities have been discovered in OpenImageIO. Please review the CVE identifiers referenced below for details.

### Impact

Please review the referenced CVE identifiers for details.

### Workaround

There is no known workaround at this time.

### Resolution

All OpenImageIO users should upgrade to the latest version:

```
 # emerge --sync
 # emerge --ask --oneshot --verbose ">=media-libs/openimageio-2.4.6.0"

```
### References

* [CVE-2022-4198](https://nvd.nist.gov/vuln/detail/CVE-2022-4198)
* [CVE-2022-36354](https://nvd.nist.gov/vuln/detail/CVE-2022-36354)
* [CVE-2022-38143](https://nvd.nist.gov/vuln/detail/CVE-2022-38143)
* [CVE-2022-41639](https://nvd.nist.gov/vuln/detail/CVE-2022-41639)
* [CVE-2022-41649](https://nvd.nist.gov/vuln/detail/CVE-2022-41649)
* [CVE-2022-41684](https://nvd.nist.gov/vuln/detail/CVE-2022-41684)
* [CVE-2022-41794](https://nvd.nist.gov/vuln/detail/CVE-2022-41794)
* [CVE-2022-41837](https://nvd.nist.gov/vuln/detail/CVE-2022-41837)
* [CVE-2022-41838](https://nvd.nist.gov/vuln/detail/CVE-2022-41838)
* [CVE-2022-41977](https://nvd.nist.gov/vuln/detail/CVE-2022-41977)
* [CVE-2022-41981](https://nvd.nist.gov/vuln/detail/CVE-2022-41981)
* [CVE-2022-41988](https://nvd.nist.gov/vuln/detail/CVE-2022-41988)
* [CVE-2022-41999](https://nvd.nist.gov/vuln/detail/CVE-2022-41999)
* [CVE-2022-43592](https://nvd.nist.gov/vuln/detail/CVE-2022-43592)
* [CVE-2022-43593](https://nvd.nist.gov/vuln/detail/CVE-2022-43593)
* [CVE-2022-43594](https://nvd.nist.gov/vuln/detail/CVE-2022-43594)
* [CVE-2022-43595](https://nvd.nist.gov/vuln/detail/CVE-2022-43595)
* [CVE-2022-43596](https://nvd.nist.gov/vuln/detail/CVE-2022-43596)
* [CVE-2022-43597](https://nvd.nist.gov/vuln/detail/CVE-2022-43597)
* [CVE-2022-43598](https://nvd.nist.gov/vuln/detail/CVE-2022-43598)
* [CVE-2022-43599](https://nvd.nist.gov/vuln/detail/CVE-2022-43599)
* [CVE-2022-43600](https://nvd.nist.gov/vuln/detail/CVE-2022-43600)
* [CVE-2022-43601](https://nvd.nist.gov/vuln/detail/CVE-2022-43601)
* [CVE-2022-43602](https://nvd.nist.gov/vuln/detail/CVE-2022-43602)
* [CVE-2022-43603](https://nvd.nist.gov/vuln/detail/CVE-2022-43603)
* TALOS-2022-1626
* TALOS-2022-1627
* TALOS-2022-1628
* TALOS-2022-1629
* TALOS-2022-1630
* TALOS-2022-1632
* TALOS-2022-1633
* TALOS-2022-1634
* TALOS-2022-1635
* TALOS-2022-1643
* TALOS-2022-1651
* TALOS-2022-1652
* TALOS-2022-1653
* TALOS-2022-1654
* TALOS-2022-1655
* TALOS-2022-1656
* TALOS-2022-1657

**Release date**

May 30, 2023

**Latest revision**

May 30, 2023: 1

**Severity**

normal

**Exploitable**

remote

**Bugzilla entries**

* [879255](https://bugs.gentoo.org/show_bug.cgi?id=879255)
* [884085](https://bugs.gentoo.org/show_bug.cgi?id=884085)
* [888045](https://bugs.gentoo.org/show_bug.cgi?id=888045)

### Questions or comments?

Please feel free to contact us.

**© 2001–2020 Gentoo Foundation, Inc.**



=== Content from www.debian.org_b478156b_20250114_214005.html ===


---

[[Date Prev](msg00073.html)][[Date Next](msg00075.html)]
[[Thread Prev](msg00073.html)][[Thread Next](msg00075.html)]
[[Date Index](maillist.html#00074)]
[[Thread Index](threads.html#00074)]

# [SECURITY] [DSA 5384-1] openimageio security update

---

* *To*: debian-security-announce@lists.debian.org
* *Subject*: [SECURITY] [DSA 5384-1] openimageio security update
* *From*: Markus Koschany <apo@debian.org>
* *Date*: Mon, 10 Apr 2023 09:18:20 +0000
* *Message-id*: <[[🔎]](/msgid-search/ZDPUXJWxZqdNN565%40seger.debian.org) [ZDPUXJWxZqdNN565@seger.debian.org](msg00074.html)>
* *Reply-to*: debian-security-announce-request@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

- -------------------------------------------------------------------------
Debian Security Advisory DSA-5384-1                   security@debian.org
<https://www.debian.org/security/>                          Markus Koschany
April 10, 2023                        <https://www.debian.org/security/faq>
- -------------------------------------------------------------------------

Package        : openimageio
CVE ID         : CVE-2022-36354 CVE-2022-41639 CVE-2022-41649 CVE-2022-41684
                 CVE-2022-41794 CVE-2022-41837 CVE-2022-41838 CVE-2022-41977
                 CVE-2022-41981 CVE-2022-41988 CVE-2022-41999 CVE-2022-43592
                 CVE-2022-43593 CVE-2022-43594 CVE-2022-43595 CVE-2022-43596
                 CVE-2022-43597 CVE-2022-43598 CVE-2022-43599 CVE-2022-43600
                 CVE-2022-43601 CVE-2022-43602 CVE-2022-43603
Debian Bug     : 1027143 1027808

Multiple security vulnerabilities have been discovered in OpenImageIO, a
library for reading and writing images. Buffer overflows and out-of-bounds
read and write programming errors may lead to a denial of service
(application crash) or the execution of arbitrary code if a malformed image
file is processed.

For the stable distribution (bullseye), these problems have been fixed in
version 2.2.10.1+dfsg-1+deb11u1.

We recommend that you upgrade your openimageio packages.

For the detailed security status of openimageio please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/openimageio>

Further information about Debian Security Advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://www.debian.org/security/>

Mailing list: debian-security-announce@lists.debian.org
-----BEGIN PGP SIGNATURE-----

iQKTBAEBCgB9FiEErPPQiO8y7e9qGoNf2a0UuVE7UeQFAmQz0zJfFIAAAAAALgAo
aXNzdWVyLWZwckBub3RhdGlvbnMub3BlbnBncC5maWZ0aGhvcnNlbWFuLm5ldEFD
RjNEMDg4RUYzMkVERUY2QTFBODM1RkQ5QUQxNEI5NTEzQjUxRTQACgkQ2a0UuVE7
UeS2VhAAkzf+mdeKhMeJwj6tgMsq3GwyOvvyUwbCNxH31z43l+EX2SSLROOXfp8H
N9pkxAPmMfkzNR77FFwKFyHmAMeHwQdO+9w4YQ+Bz2h1xs25snwW9k+4BFGvgZfc
T4RF5l808YGPJWUoxS3EOfgVYAv7nYc/eSxHvLBSW/4uhsg9fzNeTvWbdGVATNDw
2Fiy2b5uFeo+uBGveyhzd7sj+spe7cYdFklrSAirKA/QAh0cUlRVfP4uyQysO1iT
/JK3+vXP+Xis7VmRADNLIfK8xnX5maW6Uru6IuHVHHFMqaSBYPw+1BwIfkz0n60A
VL+wpVZ+eBdN1QM3srizcHfkB4ZuH/XU+NoNmKiCFPdmguwSPubH6NNEtqr4UHew
29/PMcneOfGzjSf4tQ6Bk4wjhYEUOTiN3UAJ7Nc7xce92iapzzeHbulAMO9nROch
KOUVyfauOBLWd5UTKSWGhlb/AWwGCBxhqBnumKRFS8t842xxsrMiufZBWM23q0fr
smxfDs4uxUhmmQI4nCLUTCjLcFz50/flJNDKSTaRh5Vxu26wklxwFu0kFpiSxc2U
3K6Ku+nH96ydlSjFLfKGP6L3+SPWzxaojpfxqgkjsA81k6/27arvamlZEb4+LC0D
EuUmUYu9+6OYBmP6Qa/Awy+6tMX9x6DGtn2VOWpvyAD0xprGi0A=
=mZTJ
-----END PGP SIGNATURE-----

```

---


