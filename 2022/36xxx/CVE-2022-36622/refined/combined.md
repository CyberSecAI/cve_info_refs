=== Content from github.com_b96ab405_20250114_205848.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower%2Fblob%2F18f4b592a8a973ce5972f4e2658ea0f6e3686284%2Ftee%2Ftee%2Ftee_svc.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower%2Fblob%2F18f4b592a8a973ce5972f4e2658ea0f6e3686284%2Ftee%2Ftee%2Ftee_svc.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=Samsung%2FmTower)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[Samsung](/Samsung)
/
**[mTower](/Samsung/mTower)**
Public

* [Notifications](/login?return_to=%2FSamsung%2FmTower) You must be signed in to change notification settings
* [Fork
  17](/login?return_to=%2FSamsung%2FmTower)
* [Star
   53](/login?return_to=%2FSamsung%2FmTower)

* [Code](/Samsung/mTower)
* [Issues
  13](/Samsung/mTower/issues)
* [Pull requests
  0](/Samsung/mTower/pulls)
* [Actions](/Samsung/mTower/actions)
* [Projects
  0](/Samsung/mTower/projects)
* [Security](/Samsung/mTower/security)
* [Insights](/Samsung/mTower/pulse)

Additional navigation options

* [Code](/Samsung/mTower)
* [Issues](/Samsung/mTower/issues)
* [Pull requests](/Samsung/mTower/pulls)
* [Actions](/Samsung/mTower/actions)
* [Projects](/Samsung/mTower/projects)
* [Security](/Samsung/mTower/security)
* [Insights](/Samsung/mTower/pulse)

## Files

 18f4b59
## Breadcrumbs

1. [mTower](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284)
2. /[tee](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee)
3. /[tee](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee/tee)
/
# tee\_svc.c

Copy path Blame  Blame
## Latest commit

## History

[History](/Samsung/mTower/commits/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee/tee/tee_svc.c)1105 lines (1097 loc) · 29.9 KB 18f4b59
## Breadcrumbs

1. [mTower](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284)
2. /[tee](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee)
3. /[tee](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee/tee)
/
# tee\_svc.c

Top
## File metadata and controls

* Code
* Blame

1105 lines (1097 loc) · 29.9 KB[Raw](https://github.com/Samsung/mTower/raw/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee/tee/tee_svc.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000// SPDX-License-Identifier: BSD-2-Clause/\* \* Copyright (c) 2014, STMicroelectronics International N.V. \* All rights reserved. \* \* Redistribution and use in source and binary forms, with or without \* modification, are permitted provided that the following conditions are met: \* \* 1. Redistributions of source code must retain the above copyright notice, \* this list of conditions and the following disclaimer. \* \* 2. Redistributions in binary form must reproduce the above copyright notice, \* this list of conditions and the following disclaimer in the documentation \* and/or other materials provided with the distribution. \* \* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" \* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE \* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \* POSSIBILITY OF SUCH DAMAGE. \*/#include <string.h>#include <util.h>//#include <kernel/tee\_common\_otp.h>//#include <kernel/tee\_common.h>#include <tee\_api\_types.h>#include <kernel/tee\_ta\_manager.h>#include <utee\_types.h>#include <tee/tee\_svc.h>#include <tee/tee\_cryp\_utl.h>//#include <mm/tee\_mmu.h>//#include <mm/tee\_mm.h>//#include <mm/core\_memprot.h>//#include <kernel/tee\_time.h>
#include <user\_ta\_header.h>#include <trace.h>//#include <kernel/trace\_ta.h>//#include <kernel/chip\_services.h>//#include <kernel/pseudo\_ta.h>//#include <mm/mobj.h>
vaddr\_t tee\_svc\_uref\_base = 0;
//void syscall\_log(const void \*buf \_\_maybe\_unused, size\_t len \_\_maybe\_unused)//{//#ifdef CFG\_TEE\_CORE\_TA\_TRACE// char \*kbuf;//// if (len == 0)// return;//// kbuf = malloc(len + 1);// if (kbuf == NULL)// return;//// if (tee\_svc\_copy\_from\_user(kbuf, buf, len) == TEE\_SUCCESS) {// kbuf[len] = '\0';// trace\_ext\_puts(kbuf);// }//// free(kbuf);//#endif//}////TEE\_Result syscall\_not\_supported(void)//{// return TEE\_ERROR\_NOT\_SUPPORTED;//}/////\* Configuration properties \*////\* API implementation version \*///static const char api\_vers[] = TO\_STR(CFG\_TEE\_API\_VERSION);/////\* Implementation description (implementation-dependent) \*///static const char descr[] = TO\_STR(CFG\_TEE\_IMPL\_DESCR);/////\*// \* TA persistent time protection level// \* 100: Persistent time based on an REE-controlled real-time clock// \* and on the TEE Trusted Storage for the storage of origins (default).// \* 1000: Persistent time based on a TEE-controlled real-time clock// \* and the TEE Trusted Storage.// \* The real-time clock MUST be out of reach of software attacks// \* from the REE.// \*///static const uint32\_t ta\_time\_prot\_lvl = 100;/////\* Elliptic Curve Cryptographic support \*///#ifdef CFG\_CRYPTO\_ECC//static const bool crypto\_ecc\_en = 1;//#else//static const bool crypto\_ecc\_en;//#endif/////\*// \* Trusted storage anti rollback protection level// \* 0 (or missing): No antirollback protection (default)// \* 100: Antirollback enforced at REE level// \* 1000: Antirollback TEE-controlled hardware// \*///#ifdef CFG\_RPMB\_FS//static const uint32\_t ts\_antiroll\_prot\_lvl = 1000;//#else//static const uint32\_t ts\_antiroll\_prot\_lvl;//#endif/////\* Trusted OS implementation version \*///static const char trustedos\_impl\_version[] = TO\_STR(TEE\_IMPL\_VERSION);/////\* Trusted OS implementation version (binary value) \*///static const uint32\_t trustedos\_impl\_bin\_version; /\* 0 by default \*//////\* Trusted OS implementation manufacturer name \*///static const char trustedos\_manufacturer[] = TO\_STR(CFG\_TEE\_MANUFACTURER);/////\* Trusted firmware version \*///static const char fw\_impl\_version[] = TO\_STR(CFG\_TEE\_FW\_IMPL\_VERSION);/////\* Trusted firmware version (binary value) \*///static const uint32\_t fw\_impl\_bin\_version; /\* 0 by default \*//////\* Trusted firmware manufacturer name \*///static const char fw\_manufacturer[] = TO\_STR(CFG\_TEE\_FW\_MANUFACTURER);////static TEE\_Result get\_prop\_tee\_dev\_id(struct tee\_ta\_session \*sess \_\_unused,// void \*buf, size\_t \*blen)//{// TEE\_Result res;// TEE\_UUID uuid;// const size\_t nslen = 5;// uint8\_t data[5 + FVR\_DIE\_ID\_NUM\_REGS \* sizeof(uint32\_t)] = {// 'O', 'P', 'T', 'E', 'E' };//// if (\*blen < sizeof(uuid)) {// \*blen = sizeof(uuid);// return TEE\_ERROR\_SHORT\_BUFFER;// }// \*blen = sizeof(uuid);//// if (tee\_otp\_get\_die\_id(data + nslen, sizeof(data) - nslen))// return TEE\_ERROR\_BAD\_STATE;//// res = tee\_hash\_createdigest(TEE\_ALG\_SHA256, data, sizeof(data),// (uint8\_t \*)&uuid, sizeof(uuid));// if (res != TEE\_SUCCESS)// return TEE\_ERROR\_BAD\_STATE;//// /\*// \* Changes the random value into and UUID as specifiec// \* in RFC 4122. The magic values are from the example// \* code in the RFC.// \*// \* TEE\_UUID is defined slightly different from the RFC,// \* but close enough for our purpose.// \*///// uuid.timeHiAndVersion &= 0x0fff;// uuid.timeHiAndVersion |= 5 << 12;//// /\* uuid.clock\_seq\_hi\_and\_reserved in the RFC \*/// uuid.clockSeqAndNode[0] &= 0x3f;// uuid.clockSeqAndNode[0] |= 0x80;//// return tee\_svc\_copy\_to\_user(buf, &uuid, sizeof(TEE\_UUID));//}////static TEE\_Result get\_prop\_tee\_sys\_time\_prot\_level(// struct tee\_ta\_session \*sess \_\_unused,// void \*buf, size\_t \*blen)//{// uint32\_t prot;//// if (\*blen < sizeof(prot)) {// \*blen = sizeof(prot);// return TEE\_ERROR\_SHORT\_BUFFER;// }// \*blen = sizeof(prot);// prot = tee\_time\_get\_sys\_time\_protection\_level();// return tee\_svc\_copy\_to\_user(buf, &prot, sizeof(prot));//}////static TEE\_Result get\_prop\_client\_id(struct tee\_ta\_session \*sess \_\_unused,// void \*buf, size\_t \*blen)//{// if (\*blen < sizeof(TEE\_Identity)) {// \*blen = sizeof(TEE\_Identity);// return TEE\_ERROR\_SHORT\_BUFFER;// }// \*blen = sizeof(TEE\_Identity);// return tee\_svc\_copy\_to\_user(buf, &sess->clnt\_id, sizeof(TEE\_Identity));//}////static TEE\_Result get\_prop\_ta\_app\_id(struct tee\_ta\_session \*sess,// void \*buf, size\_t \*blen)//{// if (\*blen < sizeof(TEE\_UUID)) {// \*blen = sizeof(TEE\_UUID);// return TEE\_ERROR\_SHORT\_BUFFER;// }// \*blen = sizeof(TEE\_UUID);// return tee\_svc\_copy\_to\_user(buf, &sess->ctx->uuid, sizeof(TEE\_UUID));//}/////\* Properties of the set TEE\_PROPSET\_CURRENT\_CLIENT \*///const struct tee\_props tee\_propset\_client[] = {// {// .name = "gpd.client.identity",// .prop\_type = USER\_TA\_PROP\_TYPE\_IDENTITY,// .get\_prop\_func = get\_prop\_client\_id// },//};/////\* Properties of the set TEE\_PROPSET\_CURRENT\_TA \*///const struct tee\_props tee\_propset\_ta[] = {// {// .name = "gpd.ta.appID",// .prop\_type = USER\_TA\_PROP\_TYPE\_UUID,// .get\_prop\_func = get\_prop\_ta\_app\_id// },//// /\*// \* Following properties are processed directly in libutee:// \* TA\_PROP\_STR\_SINGLE\_INSTANCE// \* TA\_PROP\_STR\_MULTI\_SESSION// \* TA\_PROP\_STR\_KEEP\_ALIVE// \* TA\_PROP\_STR\_DATA\_SIZE// \* TA\_PROP\_STR\_STACK\_SIZE// \* TA\_PROP\_STR\_VERSION// \* TA\_PROP\_STR\_DESCRIPTION// \* USER\_TA\_PROP\_TYPE\_STRING,// \* TA\_DESCRIPTION// \*///};/////\* Properties of the set TEE\_PROPSET\_TEE\_IMPLEMENTATION \*///const struct tee\_props tee\_propset\_tee[] = {// {// .name = "gpd.tee.apiversion",// .prop\_type = USER\_TA\_PROP\_TYPE\_STRING,// .data = api\_vers,// .len = sizeof(api\_vers),// },// {// .name = "gpd.tee.description",// .prop\_type = USER\_TA\_PROP\_TYPE\_STRING,// .data = descr, .len = sizeof(descr)// },// {// .name = "gpd.tee.deviceID",// .prop\_type = USER\_TA\_PROP\_TYPE\_UUID,// .get\_prop\_func = get\_prop\_tee\_dev\_id// },// {// .name = "gpd.tee.systemTime.protectionLevel",// .prop\_type = USER\_TA\_PROP\_TYPE\_U32,// .get\_prop\_func = get\_prop\_tee\_sys\_time\_prot\_level// },// {// .name = "gpd.tee.TAPersistentTime.protectionLevel",// .prop\_type = USER\_TA\_PROP\_TYPE\_U32,// .data = &ta\_time\_prot\_lvl,// .len = sizeof(ta\_time\_prot\_lvl)// },// {// .name = "gpd.tee.cryptography.ecc",// .prop\_type = USER\_TA\_PROP\_TYPE\_BOOL,// .data = &crypto\_ecc\_en,// .len = sizeof(crypto\_ecc\_en)// },// {// .name = "gpd.tee.trustedStorage.antiRollback.protectionLevel",// .prop\_type = USER\_TA\_PROP\_TYPE\_U32,// .data = &ts\_antiroll\_prot\_lvl,// .len = sizeof(ts\_antiroll\_prot\_lvl)// },// {// .name = "gpd.tee.trustedos.implementation.version",// .prop\_type = USER\_TA\_PROP\_TYPE\_STRING,// .data = trustedos\_impl\_version,// .len = sizeof(trustedos\_impl\_version)// },// {// .name = "gpd.tee.trustedos.implementation.binaryversion",// .prop\_type = USER\_TA\_PROP\_TYPE\_U32,// .data = &trustedos\_impl\_bin\_version,// .len = sizeof(trustedos\_impl\_bin\_version)// },// {// .name = "gpd.tee.trustedos.manufacturer",// .prop\_type = USER\_TA\_PROP\_TYPE\_STRING,// .data = trustedos\_manufacturer,// .len = sizeof(trustedos\_manufacturer)// },// {// .name = "gpd.tee.firmware.implementation.version",// .prop\_type = USER\_TA\_PROP\_TYPE\_STRING,// .data = fw\_impl\_version,// .len = sizeof(fw\_impl\_version)// },// {// .name = "gpd.tee.firmware.implementation.binaryversion",// .prop\_type = USER\_TA\_PROP\_TYPE\_U32,// .data = &fw\_impl\_bin\_version,// .len = sizeof(fw\_impl\_bin\_version)// },// {// .name = "gpd.tee.firmware.manufacturer",// .prop\_type = USER\_TA\_PROP\_TYPE\_STRING,// .data = fw\_manufacturer,// .len = sizeof(fw\_manufacturer)// },//// /\*// \* Following properties are processed directly in libutee:// \* gpd.tee.arith.maxBigIntSize// \*///};////\_\_weak const struct tee\_vendor\_props vendor\_props\_client;//\_\_weak const struct tee\_vendor\_props vendor\_props\_ta;//\_\_weak const struct tee\_vendor\_props vendor\_props\_tee;////static void get\_prop\_set(unsigned long prop\_set,// const struct tee\_props \*\*props,// size\_t \*size,// const struct tee\_props \*\*vendor\_props,// size\_t \*vendor\_size)//{// if ((TEE\_PropSetHandle)prop\_set == TEE\_PROPSET\_CURRENT\_CLIENT) {// \*props = tee\_propset\_client;// \*size = ARRAY\_SIZE(tee\_propset\_client);// \*vendor\_props = vendor\_props\_client.props;// \*vendor\_size = vendor\_props\_client.len;// } else if ((TEE\_PropSetHandle)prop\_set == TEE\_PROPSET\_CURRENT\_TA) {// \*props = tee\_propset\_ta;// \*size = ARRAY\_SIZE(tee\_propset\_ta);// \*vendor\_props = vendor\_props\_ta.props;// \*vendor\_size = vendor\_props\_ta.len;// } else if ((TEE\_PropSetHandle)prop\_set ==// TEE\_PROPSET\_TEE\_IMPLEMENTATION) {// \*props = tee\_propset\_tee;// \*size = ARRAY\_SIZE(tee\_propset\_tee);// \*vendor\_props = vendor\_props\_tee.props;// \*vendor\_size = vendor\_props\_tee.len;// } else {// \*props = NULL;// \*size = 0;// \*vendor\_props = NULL;// \*vendor\_size = 0;// }//}////static const struct tee\_props \*get\_prop\_struct(unsigned long prop\_set,// unsigned long index)//{// const struct tee\_props \*props;// const struct tee\_props \*vendor\_props;// size\_t size;// size\_t vendor\_size;//// get\_prop\_set(prop\_set, &props, &size, &vendor\_props, &vendor\_size);//// if (index < size)// return &(props[index]);// index -= size;//// if (index < vendor\_size)// return &(vendor\_props[index]);//// return NULL;//}/////\*// \* prop\_set is part of TEE\_PROPSET\_xxx// \* index is the index in the Property Set to retrieve// \* if name is not NULL, the name of "index" property is returned// \* if buf is not NULL, the property is returned// \*///TEE\_Result syscall\_get\_property(unsigned long prop\_set,// unsigned long index,// void \*name, uint32\_t \*name\_len,// void \*buf, uint32\_t \*blen,// uint32\_t \*prop\_type)//{// struct tee\_ta\_session \*sess;// TEE\_Result res;// TEE\_Result res2;// const struct tee\_props \*prop;// uint32\_t klen;// size\_t klen\_size;// uint32\_t elen;//// prop = get\_prop\_struct(prop\_set, index);// if (!prop)// return TEE\_ERROR\_ITEM\_NOT\_FOUND;//// res = tee\_ta\_get\_current\_session(&sess);// if (res != TEE\_SUCCESS)// return res;//// /\* Get the property type \*/// if (prop\_type) {// res = tee\_svc\_copy\_to\_user(prop\_type, &prop->prop\_type,// sizeof(\*prop\_type));// if (res != TEE\_SUCCESS)// return res;// }//// /\* Get the property \*/// if (buf && blen) {// res = tee\_svc\_copy\_from\_user(&klen, blen, sizeof(klen));// if (res != TEE\_SUCCESS)// return res;//// if (prop->get\_prop\_func) {// klen\_size = klen;// res = prop->get\_prop\_func(sess, buf, &klen\_size);// klen = klen\_size;// res2 = tee\_svc\_copy\_to\_user(blen, &klen, sizeof(\*blen));// } else {// if (klen < prop->len)// res = TEE\_ERROR\_SHORT\_BUFFER;// else// res = tee\_svc\_copy\_to\_user(buf, prop->data,// prop->len);// res2 = tee\_svc\_copy\_to\_user(blen, &prop->len,// sizeof(\*blen));// }// if (res2 != TEE\_SUCCESS)// return res2;// if (res != TEE\_SUCCESS)// return res;// }//// /\* Get the property name \*/// if (name && name\_len) {// res = tee\_svc\_copy\_from\_user(&klen, name\_len, sizeof(klen));// if (res != TEE\_SUCCESS)// return res;//// elen = strlen(prop->name) + 1;//// if (klen < elen)// res = TEE\_ERROR\_SHORT\_BUFFER;// else// res = tee\_svc\_copy\_to\_user(name, prop->name, elen);// res2 = tee\_svc\_copy\_to\_user(name\_len, &elen, sizeof(\*name\_len));// if (res2 != TEE\_SUCCESS)// return res2;// if (res != TEE\_SUCCESS)// return res;// }//// return res;//}/////\*// \* prop\_set is part of TEE\_PROPSET\_xxx// \*///TEE\_Result syscall\_get\_property\_name\_to\_index(unsigned long prop\_set,// void \*name,// unsigned long name\_len,// uint32\_t \*index)//{// TEE\_Result res;// struct tee\_ta\_session \*sess;// const struct tee\_props \*props;// size\_t size;// const struct tee\_props \*vendor\_props;// size\_t vendor\_size;// char \*kname = 0;// uint32\_t i;//// get\_prop\_set(prop\_set, &props, &size, &vendor\_props, &vendor\_size);// if (!props)// return TEE\_ERROR\_ITEM\_NOT\_FOUND;//// res = tee\_ta\_get\_current\_session(&sess);// if (res != TEE\_SUCCESS)// goto out;//// if (!name || !name\_len) {// res = TEE\_ERROR\_BAD\_PARAMETERS;// goto out;// }//// kname = malloc(name\_len);// if (!kname)// return TEE\_ERROR\_OUT\_OF\_MEMORY;// res = tee\_svc\_copy\_from\_user(kname, name, name\_len);// if (res != TEE\_SUCCESS)// goto out;// kname[name\_len - 1] = 0;//// res = TEE\_ERROR\_ITEM\_NOT\_FOUND;// for (i = 0; i < size; i++) {// if (!strcmp(kname, props[i].name)) {// res = tee\_svc\_copy\_to\_user(index, &i, sizeof(\*index));// goto out;// }// }// for (i = size; i < size + vendor\_size; i++) {// if (!strcmp(kname, vendor\_props[i - size].name)) {// res = tee\_svc\_copy\_to\_user(index, &i, sizeof(\*index));// goto out;// }// }////out:// free(kname);// return res;//}////static void utee\_param\_to\_param(struct tee\_ta\_param \*p, struct utee\_params \*up)//{// size\_t n;// uint32\_t types = up->types;//// p->types = types;// for (n = 0; n < TEE\_NUM\_PARAMS; n++) {// uintptr\_t a = up->vals[n \* 2];// size\_t b = up->vals[n \* 2 + 1];//// switch (TEE\_PARAM\_TYPE\_GET(types, n)) {// case TEE\_PARAM\_TYPE\_MEMREF\_INPUT:// case TEE\_PARAM\_TYPE\_MEMREF\_OUTPUT:// case TEE\_PARAM\_TYPE\_MEMREF\_INOUT:// p->u[n].mem.mobj = &mobj\_virt;// p->u[n].mem.offs = a;// p->u[n].mem.size = b;// break;// case TEE\_PARAM\_TYPE\_VALUE\_INPUT:// case TEE\_PARAM\_TYPE\_VALUE\_INOUT:// p->u[n].val.a = a;// p->u[n].val.b = b;// break;// default:// memset(&p->u[n], 0, sizeof(p->u[n]));// break;// }// }//}////static TEE\_Result alloc\_temp\_sec\_mem(size\_t size, struct mobj \*\*mobj,// uint8\_t \*\*va)//{// /\* Allocate section in secure DDR \*///#ifdef CFG\_PAGED\_USER\_TA// \*mobj = mobj\_seccpy\_shm\_alloc(size);//#else// \*mobj = mobj\_mm\_alloc(mobj\_sec\_ddr, size, &tee\_mm\_sec\_ddr);//#endif// if (!\*mobj)// return TEE\_ERROR\_GENERIC;//// \*va = mobj\_get\_va(\*mobj, 0);// return TEE\_SUCCESS;//}/////\*// \* TA invokes some TA with parameter.// \* If some parameters are memory references:// \* - either the memref is inside TA private RAM: TA is not allowed to expose// \* its private RAM: use a temporary memory buffer and copy the data.// \* - or the memref is not in the TA private RAM:// \* - if the memref was mapped to the TA, TA is allowed to expose it.// \* - if so, converts memref virtual address into a physical address.// \*///static TEE\_Result tee\_svc\_copy\_param(struct tee\_ta\_session \*sess,// struct tee\_ta\_session \*called\_sess,// struct utee\_params \*callee\_params,// struct tee\_ta\_param \*param,// void \*tmp\_buf\_va[TEE\_NUM\_PARAMS],// struct mobj \*\*mobj\_tmp)//{// size\_t n;// TEE\_Result res;// size\_t req\_mem = 0;// size\_t s;// uint8\_t \*dst = 0;// bool ta\_private\_memref[TEE\_NUM\_PARAMS];// struct user\_ta\_ctx \*utc = to\_user\_ta\_ctx(sess->ctx);// void \*va;// size\_t dst\_offs;//// /\* fill 'param' input struct with caller params description buffer \*/// if (!callee\_params) {// memset(param, 0, sizeof(\*param));// } else {// res = tee\_mmu\_check\_access\_rights(utc,// TEE\_MEMORY\_ACCESS\_READ | TEE\_MEMORY\_ACCESS\_ANY\_OWNER,// (uaddr\_t)callee\_params, sizeof(struct utee\_params));// if (res != TEE\_SUCCESS)// return res;// utee\_param\_to\_param(param, callee\_params);// }//// if (called\_sess && is\_pseudo\_ta\_ctx(called\_sess->ctx)) {// /\*// \* static TA, borrow the mapping of the calling// \* during this call.// \*/// return TEE\_SUCCESS;// }//// /\* All mobj in param are of type MOJB\_TYPE\_VIRT \*///// for (n = 0; n < TEE\_NUM\_PARAMS; n++) {//// ta\_private\_memref[n] = false;//// switch (TEE\_PARAM\_TYPE\_GET(param->types, n)) {// case TEE\_PARAM\_TYPE\_MEMREF\_INPUT:// case TEE\_PARAM\_TYPE\_MEMREF\_OUTPUT:// case TEE\_PARAM\_TYPE\_MEMREF\_INOUT:// va = (void \*)param->u[n].mem.offs;// s = param->u[n].mem.size;// if (!va) {// if (s)// return TEE\_ERROR\_BAD\_PARAMETERS;// break;// }// /\* uTA cannot expose its private memory \*/// if (tee\_mmu\_is\_vbuf\_inside\_ta\_private(utc, va, s)) {//// s = ROUNDUP(s, sizeof(uint32\_t));// if (ADD\_OVERFLOW(req\_mem, s, &req\_mem))// return TEE\_ERROR\_BAD\_PARAMETERS;// ta\_private\_memref[n] = true;// break;// }//// res = tee\_mmu\_vbuf\_to\_mobj\_offs(utc, va, s,// &param->u[n].mem.mobj,// &param->u[n].mem.offs);// if (res != TEE\_SUCCESS)// return res;// break;// default:// break;// }// }//// if (req\_mem == 0)// return TEE\_SUCCESS;//// res = alloc\_temp\_sec\_mem(req\_mem, mobj\_tmp, &dst);// if (res != TEE\_SUCCESS)// return res;// dst\_offs = 0;//// for (n = 0; n < TEE\_NUM\_PARAMS; n++) {//// if (!ta\_private\_memref[n])// continue;//// s = ROUNDUP(param->u[n].mem.size, sizeof(uint32\_t));//// switch (TEE\_PARAM\_TYPE\_GET(param->types, n)) {// case TEE\_PARAM\_TYPE\_MEMREF\_INPUT:// case TEE\_PARAM\_TYPE\_MEMREF\_INOUT:// va = (void \*)param->u[n].mem.offs;// if (va) {// res = tee\_svc\_copy\_from\_user(dst, va,// param->u[n].mem.size);// if (res != TEE\_SUCCESS)// return res;// param->u[n].mem.offs = dst\_offs;// param->u[n].mem.mobj = \*mobj\_tmp;// tmp\_buf\_va[n] = dst;// dst += s;// dst\_offs += s;// }// break;//// case TEE\_PARAM\_TYPE\_MEMREF\_OUTPUT:// va = (void \*)param->u[n].mem.offs;// if (va) {// param->u[n].mem.offs = dst\_offs;// param->u[n].mem.mobj = \*mobj\_tmp;// tmp\_buf\_va[n] = dst;// dst += s;// dst\_offs += s;// }// break;//// default:// continue;// }// }//// return TEE\_SUCCESS;//}/////\*// \* Back from execution of service: update parameters passed from TA:// \* If some parameters were memory references:// \* - either the memref was temporary: copy back data and update size// \* - or it was the original TA memref: update only the size value.// \*///static TEE\_Result tee\_svc\_update\_out\_param(// struct tee\_ta\_session \*sess,// struct tee\_ta\_session \*called\_sess,// struct tee\_ta\_param \*param,// void \*tmp\_buf\_va[TEE\_NUM\_PARAMS],// struct utee\_params \*usr\_param)//{// size\_t n;// void \*p;// struct user\_ta\_ctx \*utc = to\_user\_ta\_ctx(sess->ctx);// bool have\_private\_mem\_map = is\_user\_ta\_ctx(called\_sess->ctx);//// for (n = 0; n < TEE\_NUM\_PARAMS; n++) {// switch (TEE\_PARAM\_TYPE\_GET(param->types, n)) {// case TEE\_PARAM\_TYPE\_MEMREF\_OUTPUT:// case TEE\_PARAM\_TYPE\_MEMREF\_INOUT:// p = (void \*)(uintptr\_t)usr\_param->vals[n \* 2];//// /\* outside TA private => memref is valid, update size \*/// if (!tee\_mmu\_is\_vbuf\_inside\_ta\_private(utc, p,// param->u[n].mem.size)) {// usr\_param->vals[n \* 2 + 1] =// param->u[n].mem.size;// break;// }//// /\*// \* If we called a kernel TA the parameters are in shared// \* memory and no copy is needed.// \*/// if (have\_private\_mem\_map &&// param->u[n].mem.size <=// usr\_param->vals[n \* 2 + 1]) {// uint8\_t \*src = tmp\_buf\_va[n];// TEE\_Result res;//// res = tee\_svc\_copy\_to\_user(p, src,// param->u[n].mem.size);// if (res != TEE\_SUCCESS)// return res;//// }// usr\_param->vals[n \* 2 + 1] = param->u[n].mem.size;// break;//// case TEE\_PARAM\_TYPE\_VALUE\_OUTPUT:// case TEE\_PARAM\_TYPE\_VALUE\_INOUT:// usr\_param->vals[n \* 2] = param->u[n].val.a;// usr\_param->vals[n \* 2 + 1] = param->u[n].val.b;// break;//// default:// continue;// }// }//// return TEE\_SUCCESS;//}/////\* Called when a TA calls an OpenSession on another TA \*///TEE\_Result syscall\_open\_ta\_session(const TEE\_UUID \*dest,// unsigned long cancel\_req\_to,// struct utee\_params \*usr\_param, uint32\_t \*ta\_sess,// uint32\_t \*ret\_orig)//{// TEE\_Result res;// uint32\_t ret\_o = TEE\_ORIGIN\_TEE;// struct tee\_ta\_session \*s = NULL;// struct tee\_ta\_session \*sess;// struct mobj \*mobj\_param = NULL;// TEE\_UUID \*uuid = malloc(sizeof(TEE\_UUID));// struct tee\_ta\_param \*param = malloc(sizeof(struct tee\_ta\_param));// TEE\_Identity \*clnt\_id = malloc(sizeof(TEE\_Identity));// void \*tmp\_buf\_va[TEE\_NUM\_PARAMS];// struct user\_ta\_ctx \*utc;//// if (uuid == NULL || param == NULL || clnt\_id == NULL) {// res = TEE\_ERROR\_OUT\_OF\_MEMORY;// goto out\_free\_only;// }//// memset(param, 0, sizeof(struct tee\_ta\_param));//// res = tee\_ta\_get\_current\_session(&sess);// if (res != TEE\_SUCCESS)// goto out\_free\_only;// utc = to\_user\_ta\_ctx(sess->ctx);//// res = tee\_svc\_copy\_from\_user(uuid, dest, sizeof(TEE\_UUID));// if (res != TEE\_SUCCESS)// goto function\_exit;//// clnt\_id->login = TEE\_LOGIN\_TRUSTED\_APP;// memcpy(&clnt\_id->uuid, &sess->ctx->uuid, sizeof(TEE\_UUID));//// res = tee\_svc\_copy\_param(sess, NULL, usr\_param, param, tmp\_buf\_va,// &mobj\_param);// if (res != TEE\_SUCCESS)// goto function\_exit;//// /\*// \* Find session of a multi session TA or a static TA// \* In such a case, there is no need to ask the supplicant for the TA// \* code// \*/// res = tee\_ta\_open\_session(&ret\_o, &s, &utc->open\_sessions, uuid,// clnt\_id, cancel\_req\_to, param);// if (res != TEE\_SUCCESS)// goto function\_exit;//// res = tee\_svc\_update\_out\_param(sess, s, param, tmp\_buf\_va, usr\_param);////function\_exit:// mobj\_free(mobj\_param);// if (res == TEE\_SUCCESS)// tee\_svc\_copy\_kaddr\_to\_uref(ta\_sess, s);// tee\_svc\_copy\_to\_user(ret\_orig, &ret\_o, sizeof(ret\_o));////out\_free\_only:// free(param);// free(uuid);// free(clnt\_id);// return res;//}////TEE\_Result syscall\_close\_ta\_session(unsigned long ta\_sess)//{// TEE\_Result res;// struct tee\_ta\_session \*sess;// TEE\_Identity clnt\_id;// struct tee\_ta\_session \*s = tee\_svc\_uref\_to\_kaddr(ta\_sess);// struct user\_ta\_ctx \*utc;//// res = tee\_ta\_get\_current\_session(&sess);// if (res != TEE\_SUCCESS)// return res;// utc = to\_user\_ta\_ctx(sess->ctx);//// clnt\_id.login = TEE\_LOGIN\_TRUSTED\_APP;// memcpy(&clnt\_id.uuid, &sess->ctx->uuid, sizeof(TEE\_UUID));//// return tee\_ta\_close\_session(s, &utc->open\_sessions, &clnt\_id);//}////TEE\_Result syscall\_invoke\_ta\_command(unsigned long ta\_sess,// unsigned long cancel\_req\_to, unsigned long cmd\_id,// struct utee\_params \*usr\_param, uint32\_t \*ret\_orig)//{// TEE\_Result res;// TEE\_Result res2;// uint32\_t ret\_o = TEE\_ORIGIN\_TEE;// struct tee\_ta\_param param = { 0 };// TEE\_Identity clnt\_id;// struct tee\_ta\_session \*sess;// struct tee\_ta\_session \*called\_sess;// struct mobj \*mobj\_param = NULL;// void \*tmp\_buf\_va[TEE\_NUM\_PARAMS];// struct user\_ta\_ctx \*utc;//// res = tee\_ta\_get\_current\_session(&sess);// if (res != TEE\_SUCCESS)// return res;// utc = to\_user\_ta\_ctx(sess->ctx);//// called\_sess = tee\_ta\_get\_session(// (vaddr\_t)tee\_svc\_uref\_to\_kaddr(ta\_sess), true,// &utc->open\_sessions);// if (!called\_sess)// return TEE\_ERROR\_BAD\_PARAMETERS;//// clnt\_id.login = TEE\_LOGIN\_TRUSTED\_APP;// memcpy(&clnt\_id.uuid, &sess->ctx->uuid, sizeof(TEE\_UUID));//// res = tee\_svc\_copy\_param(sess, called\_sess, usr\_param, &param,// tmp\_buf\_va, &mobj\_param);// if (res != TEE\_SUCCESS)// goto function\_exit;//// res = tee\_ta\_invoke\_command(&ret\_o, called\_sess, &clnt\_id,// cancel\_req\_to, cmd\_id, &param);//// res2 = tee\_svc\_update\_out\_param(sess, called\_sess, &param, tmp\_buf\_va,// usr\_param);// if (res2 != TEE\_SUCCESS) {// /\*// \* Spec for TEE\_InvokeTACommand() says:// \* "If the return origin is different from// \* TEE\_ORIGIN\_TRUSTED\_APP, then the function has failed// \* before it could reach the destination Trusted// \* Application."// \*// \* But if we can't update params to the caller we have no// \* choice we need to return some error to indicate that// \* parameters aren't updated as expected.// \*/// ret\_o = TEE\_ORIGIN\_TEE;// res = res2;// }////function\_exit:// tee\_ta\_put\_session(called\_sess);// mobj\_free(mobj\_param);// if (ret\_orig)// tee\_svc\_copy\_to\_user(ret\_orig, &ret\_o, sizeof(ret\_o));// return res;//}////TEE\_Result syscall\_check\_access\_rights(unsigned long flags, const void \*buf,// size\_t len)//{// TEE\_Result res;// struct tee\_ta\_session \*s;//// res = tee\_ta\_get\_current\_session(&s);// if (res != TEE\_SUCCESS)// return res;//// return tee\_mmu\_check\_access\_rights(to\_user\_ta\_ctx(s->ctx), flags,// (uaddr\_t)buf, len);//}//TEE\_Result tee\_svc\_copy\_from\_user(void \*kaddr, const void \*uaddr, size\_t len){// TEE\_Result res;// struct tee\_ta\_session \*s;//// res = tee\_ta\_get\_current\_session(&s);// if (res != TEE\_SUCCESS)// return res;//// res = tee\_mmu\_check\_access\_rights(to\_user\_ta\_ctx(s->ctx),// TEE\_MEMORY\_ACCESS\_READ |// TEE\_MEMORY\_ACCESS\_ANY\_OWNER,// (uaddr\_t)uaddr, len);// if (res != TEE\_SUCCESS)// return res;// memcpy(kaddr, uaddr, len); return TEE\_SUCCESS;}
TEE\_Result tee\_svc\_copy\_to\_user(void \*uaddr, const void \*kaddr, size\_t len){// TEE\_Result res;// struct tee\_ta\_session \*s;//// res = tee\_ta\_get\_current\_session(&s);// if (res != TEE\_SUCCESS)// return res;//// res = tee\_mmu\_check\_access\_rights(to\_user\_ta\_ctx(s->ctx),// TEE\_MEMORY\_ACCESS\_WRITE |// TEE\_MEMORY\_ACCESS\_ANY\_OWNER,// (uaddr\_t)uaddr, len);// if (res != TEE\_SUCCESS)// return res;
 memcpy(uaddr, kaddr, len); return TEE\_SUCCESS;}
TEE\_Result tee\_svc\_copy\_kaddr\_to\_uref(uint32\_t \*uref, void \*kaddr){ uint32\_t ref = tee\_svc\_kaddr\_to\_uref(kaddr);
 return tee\_svc\_copy\_to\_user(uref, &ref, sizeof(ref));}
//TEE\_Result syscall\_get\_cancellation\_flag(uint32\_t \*cancel)//{// TEE\_Result res;// struct tee\_ta\_session \*s = NULL;// uint32\_t c;//// res = tee\_ta\_get\_current\_session(&s);// if (res != TEE\_SUCCESS)// return res;//// c = tee\_ta\_session\_is\_cancelled(s, NULL);//// return tee\_svc\_copy\_to\_user(cancel, &c, sizeof(c));//}////TEE\_Result syscall\_unmask\_cancellation(uint32\_t \*old\_mask)//{// TEE\_Result res;// struct tee\_ta\_session \*s = NULL;// uint32\_t m;//// res = tee\_ta\_get\_current\_session(&s);// if (res != TEE\_SUCCESS)// return res;//[View remainder of file in raw view](https://github.com/Samsung/mTower/raw/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee/tee/tee_svc.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from security.samsungmobile.com_ec09b238_20250114_205854.html ===


close

Samsung Mobile Security and Cookies

Our site uses essential cookies only. You can read our [Privacy Policy](/./privacy/global/privacy_notice.html "Privacy Policy") and Cookie Policy for more information.

close
## Samsung Mobile Security Cookie Policy

Updated on Jan 17, 2022

This Cookie Policy describes the different types of cookies that may be used in connection with Samsung Mobile Security website which is owned and controlled by Samsung Electronics Co., Ltd (“Samsung Electronics”). This Cookie Policy also describes how you can manage cookies.

It’s important that you check back often for updates to the Policy as we may change it from time to time to reflect changes to our use of cookies. Please check the date at the top of this page to see when this Policy was last revised. Any changes to this Policy will become effective when we make the revised Policy available on our website.

Samsung Electronics has offices across Europe, so we can ensure that your request or query will be handled by the data protection team based in your region. If you have any questions, the easiest way to contact us is through our Privacy Support Page at <https://www.samsung.com/request-desk>.

You can also contact us at:

European Data Protection Officer

Samsung Electronics (UK) Limited

Samsung House, 2000 Hillswood Drive, Chertsey, Surrey KT16 0RS

#### Cookies

Cookies are small files that store information on your computer, TV, mobile phone, or other device. They enable the entity that put the cookie on your device to recognize you across different websites, services, devices, and/or browsing sessions.

We use the following types of cookies on this website:

**Essential Cookies**: enable you to receive the services you request via our website. Without these cookies, services that you have asked for cannot be provided. For example, these enable to identify users and provide proper service for each user. These cookies are automatically enabled and cannot be turned off because they are essential to enable you to browse our website. Without these cookies this Samsung Mobile Security website could not be provided.

| Cookie | Domain | Purpose |
| --- | --- | --- |
| JSESSIONID | security.samsungmobile.com | to keep login session |
| lastActivityTime | security.samsungmobile.com | to save the user's last activity time to automatically logout after 30 minutes of inactivity |

#### Managing Cookies and Other Technologies

You can also update your browser settings at any time, if you want to remove or block cookies from your device (consult your browser's "help" menu to learn how to remove or block cookies). Samsung Electronics is not responsible for your browser settings. You can find good and simple instructions on how to manage cookies on the different types of web browsers at <http://www.allaboutcookies.org>.

[Go straight to the menu](#gnb)
[Go straight to the text](#home)

# [**Samsung** Mobile Security](/./main.smsb)

* [Security Updates](/./workScope.smsb)
  + [Scope](/./workScope.smsb)
  + [Firmware Updates](/./securityUpdate.smsb)
  + [Other Updates](/./serviceWeb.smsb)
* [Security Reporting](/./securityReporting.smsb)
  + [Reporting](/./securityReporting.smsb)
  + [Process](/./securityReportingProcess.smsb)
  + [Severity Classification](/./securityReportingRiskClassification.smsb)
* [Rewards Program](/./rewardsProgram.smsb)
  + [How it works](/./rewardsProgram.smsb)
  + [Hall of Fame](/./hallOfFameInfo.smsb)
* [Security Post](/./securityPost.smsb)

Login

Search
Search Close

Search

Total Menu
Close the entire menu

Search

* [Security Updates](/./workScope.smsb)
* [Security Reporting](/./securityReporting.smsb)
* [Rewards Program](/./rewardsProgram.smsb)
* [Security Post](/./securityPost.smsb)

* Login

[Home](/main.smsb "Go to Home")>[Security Updates](/workScope.smsb)>*Firmware Updates*

## Security Updates

* [Scope](/workScope.smsb)
* Firmware Updates
* [Other Updates](/serviceWeb.smsb)

Move to the previous year
Move to the next year

2025

2025Open selected window by year

* 2025
* 2024
* 2023
* 2022
* 2021
* 2020
* 2019
* 2018
* 2017
* 2016
* 2015

Close selected window by year

January

[**Disclaimer**](#su_disc)

* Please note that in some cases regular OS upgrades may cause delays to planned security updates. However, users can be rest assured the OS upgrades will include up-to-date security patches when delivered.
* While we are doing our best to deliver the security patches as soon as possible to all applicable models, delivery time of security patches may vary depending on the regions and models.
* Some patches to be received from chipset vendors (also known as Device Specific patches) may not be included in the security update package of the month. They will be included in upcoming security update packages as soon as the patches are ready to deliver.

**Acknowledgements**

```
ycmint working at ADLab of VenusTech: SVE-2024-1217
Sam of Honor Cyber Security Lab: SVE-2024-1527
tdx: SVE-2024-1828, SVE-2024-1834
hsia.angsh: SVE-2024-1875
Andrea Toska: SVE-2024-2171
```

SMR-JAN-2025
Samsung Mobile is releasing a maintenance release for major flagship models as part of monthly Security Maintenance Release (SMR) process. This SMR package includes patches from Google and Samsung.

**Acknowledgements**
```
ycmint working at ADLab of VenusTech: SVE-2024-1217
Sam of Honor Cyber Security Lab: SVE-2024-1527
tdx: SVE-2024-1828, SVE-2024-1834
hsia.angsh: SVE-2024-1875
Andrea Toska: SVE-2024-2171
```

SITE MAP

* [Security Updates](/workScope.smsb)
* [Security Reporting](/securityReporting.smsb)
* [Rewards Program](/rewardsProgram.smsb)
* [Security Post](/securityPost.smsb)

Cookie Policy
Privacy Policy
[Global](/privacy/global/privacy_notice.html "Global")
[US](/privacy/us/privacy_notice_us.html "US")
[EU](/privacy/eu/privacy_notice_eu.html "EU")
[Latin America](/privacy/latin/privacy_notice_latin.html "Latin America")
[Korea](/privacy/korea/privacy_notice_korea.html "Korea")
[Brazil](/privacy/brazil/privacy_notice_brazil.html "Brazil")
[Turkey](/privacy/turkey/privacy_notice_turkey.html "Turkey")
[Vietnam](/privacy/vietnam/privacy_notice_vietnam.html "Vietnam")

Samsung.com

Top
Copyright© 2017 SAMSUNG All Rights Reserved.



=== Content from github.com_fed9f83b_20250114_205841.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=Samsung%2FmTower)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[Samsung](/Samsung)
/
**[mTower](/Samsung/mTower)**
Public

* [Notifications](/login?return_to=%2FSamsung%2FmTower) You must be signed in to change notification settings
* [Fork
  17](/login?return_to=%2FSamsung%2FmTower)
* [Star
   53](/login?return_to=%2FSamsung%2FmTower)

mTower is Trusted Execution Environment specially designed to be used on MicroController Units (MCUs) supporting ARM TrustZone technology (e.g., Cortex-M23/33/35p). mTower operates well under restrictions typical for such environment – small RAM and ROM sizes, relatively low performance, absence of rich OSes providing variety of services availab…

### License

Apache-2.0, Unknown licenses found

### Licenses found

[Apache-2.0
LICENSE](/Samsung/mTower/blob/master/./LICENSE) [Unknown
COPYING](/Samsung/mTower/blob/master/./COPYING)

[53
stars](/Samsung/mTower/stargazers) [17
forks](/Samsung/mTower/forks) [Branches](/Samsung/mTower/branches) [Tags](/Samsung/mTower/tags) [Activity](/Samsung/mTower/activity)
 [Star](/login?return_to=%2FSamsung%2FmTower)

 [Notifications](/login?return_to=%2FSamsung%2FmTower) You must be signed in to change notification settings

* [Code](/Samsung/mTower)
* [Issues
  13](/Samsung/mTower/issues)
* [Pull requests
  0](/Samsung/mTower/pulls)
* [Actions](/Samsung/mTower/actions)
* [Projects
  0](/Samsung/mTower/projects)
* [Security](/Samsung/mTower/security)
* [Insights](/Samsung/mTower/pulse)

Additional navigation options

* [Code](/Samsung/mTower)
* [Issues](/Samsung/mTower/issues)
* [Pull requests](/Samsung/mTower/pulls)
* [Actions](/Samsung/mTower/actions)
* [Projects](/Samsung/mTower/projects)
* [Security](/Samsung/mTower/security)
* [Insights](/Samsung/mTower/pulse)

# Samsung/mTower

    master[Branches](/Samsung/mTower/branches)[Tags](/Samsung/mTower/tags)Go to fileCode
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit History[157 Commits](/Samsung/mTower/commits/master/) | | |
| [.github](/Samsung/mTower/tree/master/.github ".github") | | [.github](/Samsung/mTower/tree/master/.github ".github") |  |  |
| [apps](/Samsung/mTower/tree/master/apps "apps") | | [apps](/Samsung/mTower/tree/master/apps "apps") |  |  |
| [arch](/Samsung/mTower/tree/master/arch "arch") | | [arch](/Samsung/mTower/tree/master/arch "arch") |  |  |
| [common](/Samsung/mTower/tree/master/common "common") | | [common](/Samsung/mTower/tree/master/common "common") |  |  |
| [configs](/Samsung/mTower/tree/master/configs "configs") | | [configs](/Samsung/mTower/tree/master/configs "configs") |  |  |
| [crypto](/Samsung/mTower/tree/master/crypto "crypto") | | [crypto](/Samsung/mTower/tree/master/crypto "crypto") |  |  |
| [docs](/Samsung/mTower/tree/master/docs "docs") | | [docs](/Samsung/mTower/tree/master/docs "docs") |  |  |
| [freertos](/Samsung/mTower/tree/master/freertos "freertos") | | [freertos](/Samsung/mTower/tree/master/freertos "freertos") |  |  |
| [include/mtower](/Samsung/mTower/tree/master/include/mtower "This path skips through empty directories") | | [include/mtower](/Samsung/mTower/tree/master/include/mtower "This path skips through empty directories") |  |  |
| [lib](/Samsung/mTower/tree/master/lib "lib") | | [lib](/Samsung/mTower/tree/master/lib "lib") |  |  |
| [tee](/Samsung/mTower/tree/master/tee "tee") | | [tee](/Samsung/mTower/tree/master/tee "tee") |  |  |
| [tee\_client](/Samsung/mTower/tree/master/tee_client "tee_client") | | [tee\_client](/Samsung/mTower/tree/master/tee_client "tee_client") |  |  |
| [tools](/Samsung/mTower/tree/master/tools "tools") | | [tools](/Samsung/mTower/tree/master/tools "tools") |  |  |
| [.gitignore](/Samsung/mTower/blob/master/.gitignore ".gitignore") | | [.gitignore](/Samsung/mTower/blob/master/.gitignore ".gitignore") |  |  |
| [AUTHORS](/Samsung/mTower/blob/master/AUTHORS "AUTHORS") | | [AUTHORS](/Samsung/mTower/blob/master/AUTHORS "AUTHORS") |  |  |
| [COPYING](/Samsung/mTower/blob/master/COPYING "COPYING") | | [COPYING](/Samsung/mTower/blob/master/COPYING "COPYING") |  |  |
| [Doxyfile](/Samsung/mTower/blob/master/Doxyfile "Doxyfile") | | [Doxyfile](/Samsung/mTower/blob/master/Doxyfile "Doxyfile") |  |  |
| [Kconfig](/Samsung/mTower/blob/master/Kconfig "Kconfig") | | [Kconfig](/Samsung/mTower/blob/master/Kconfig "Kconfig") |  |  |
| [LICENSE](/Samsung/mTower/blob/master/LICENSE "LICENSE") | | [LICENSE](/Samsung/mTower/blob/master/LICENSE "LICENSE") |  |  |
| [Makefile](/Samsung/mTower/blob/master/Makefile "Makefile") | | [Makefile](/Samsung/mTower/blob/master/Makefile "Makefile") |  |  |
| [README.md](/Samsung/mTower/blob/master/README.md "README.md") | | [README.md](/Samsung/mTower/blob/master/README.md "README.md") |  |  |
| [whitelist.json](/Samsung/mTower/blob/master/whitelist.json "whitelist.json") | | [whitelist.json](/Samsung/mTower/blob/master/whitelist.json "whitelist.json") |  |  |
| View all files | | |

## Repository files navigation

* README
* Code of conduct
* Apache-2.0 license
* License
* Security
# mTower

[![Build](https://github.com/samsung/mtower/workflows/Build/badge.svg)](https://github.com/samsung/mtower/actions?query=workflow%3ABuild)
[![CII Best Practices](https://camo.githubusercontent.com/913dc2dbc16eb65cdc1ac531308e0d42846b89b8aabeeac783d50b9da03f3bc0/68747470733a2f2f626573747072616374696365732e636f7265696e6672617374727563747572652e6f72672f70726f6a656374732f363130382f6261646765)](https://bestpractices.coreinfrastructure.org/projects/6108)
[![OpenSSF Scorecard](https://camo.githubusercontent.com/f2e4b28fe2273fbf8afa3b0c673de2a1c0dd16d495d132d2d238ebe578fc91c2/68747470733a2f2f6170692e736563757269747973636f726563617264732e6465762f70726f6a656374732f6769746875622e636f6d2f53616d73756e672f6d546f7765722f6261646765)](https://api.securityscorecards.dev/projects/github.com/Samsung/mTower)
[![cpp-linter](https://github.com/cpp-linter/cpp-linter-action/actions/workflows/cpp-linter.yml/badge.svg)](https://github.com/cpp-linter/cpp-linter-action/actions/workflows/cpp-linter.yml)
[![RepoSize](https://camo.githubusercontent.com/9a26835694eecb17834d3110f0aac41910fa5284a5f323273cbf1319c37ebaa1/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f7265706f2d73697a652f73616d73756e672f6d746f7765722e737667)](https://github.com/samsung/mtower)
[![Release](https://camo.githubusercontent.com/7f3cb244de56c52ab3ae6a1c3ef5b52e0f86fe1e76ed57d4b64c1ea97bdf8a9f/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f762f72656c656173652f73616d73756e672f6d746f7765722e737667)](https://github.com/samsung/mtower/releases)
[![LICENSE](https://camo.githubusercontent.com/f4adfda1cc7569b03c31c8dfedbff7cce9c265bd3b9f0d7b68b1ec43e73925a4/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f73616d73756e672f6d746f7765722e737667)](https://github.com/samsung/mtower/blob/master/LICENSE)

## Contents

1. [Introduction](#1-introduction)
2. [License](#2-license)
3. [Platforms supported](#3-platforms-supported)
4. [Get and build mTower software](#4-get-and-build-mtower-software)
5. [Source code structure](#5-source-code-structure)
6. [Coding standards](#6-coding-standards)
7. [Documentation](#7-documentation)
8. [Contributing](#8-contributing)

## 1. Introduction

The `mTower` is a new Trusted Execution Environment (TEE) specially designed
to protect size-constrained IoT devices based on Cortex-m23 MCU. Usage mTower
pre-embedded into the microcontroller, a module developer can use a simple SDK
that based on Global Platform API standards to add security to their solution.

---

## 2. License

mTower software consists of multiple components that are individually available
under different licensing terms. Terms for each individual file are listed at
the beginnings of corresponding files; also, all licenses are listed in
[COPYING](/Samsung/mTower/blob/master/COPYING) file.

---

## 3. Platforms supported

| **NuMaker-PFM-M2351**  Cortex-M23 | **M2351-Badge**  Cortex-M23 | **V2M-MPS2**  Cortex-M33 (Qemu) | **SparkFun RedBoard**  RISC-V |
| --- | --- | --- | --- |
|  |  | [V2M-MPS2](/Samsung/mTower/blob/master/docs/v2m-mps2-qemu.md) |  |
| **Pine64 Ox64**  RISC-V | **How to add a platform** |  |  |
|  |  |  |  |

Several platforms are supported. In order to manage slight differences
between platforms, a `PLATFORM` flag has been introduced.

| Platform | Composite PLATFORM flag | Maintained |
| --- | --- | --- |
| [NuMaker-PFM-M2351](http://www.nuvoton.com.cn/hq/products/iot-solution/iot-platform/numaker-maker-platform/numaker-pfm-m2351?__locale=en) | `PLATFORM=numaker_pfm_m2351` | v0.6.0 |
| [M2351-Badge](/Samsung/mTower/blob/master/docs/schemes/m2351_badge) | `PLATFORM=m2351_badge` | v0.6.0 |
| [V2M-MPS2](https://developer.arm.com/documentation/100964/1114/Microcontroller-Prototyping-System-2?lang=en) | `PLATFORM=mps2_an505_qemu` | v0.6.0 |
| [SparkFun RED-V RedBoard](https://www.sparkfun.com/products/15594) | `PLATFORM=sparkfun_redboard` | v0.6.0 |
| [Pine64 Ox64](https://wiki.pine64.org/wiki/Ox64) | `PLATFORM=pine64_ox64` | v0.6.0 |

For information on adding a new platform see the [how to add a platform](/Samsung/mTower/blob/master/docs/port-new-platform.md).

---

## 4. Get and build mTower software

Please see [build](/Samsung/mTower/blob/master/docs/build.md) for instructions how to run mTower on various devices.

---

## 5. Source code structure

The general [source code structure](/Samsung/mTower/blob/master/docs/source-code-structure.md) for mTower is similar to the structure of the
multy platforms source code.

---

## 6. Coding standards

In this project we are trying to adhere to the mTower coding convention
(see [CodingStyle](/Samsung/mTower/blob/master/docs/mtower-coding-standard.md)). However there are a few exceptions that we had to make since
the code also uses other open source components.

---

## 7. Documentation

There is a brief overall [functionality description](/Samsung/mTower/blob/master/docs/mtower_functionality_description.md) of mTower. Other mTower documentation for the project is located in the [docs](/Samsung/mTower/blob/master/docs) folder. The latest version of the specification that describes the mTower source code can be generated using [doxygen](http://www.doxygen.nl) tool from command line. To generate documentation, use

```
make docs_gen
```

command, and to view generated docs use

```
make docs_show
```
> Note that documentation on mTower is work in progress, and right now doxygen does not provide much documentation.

---

## 8. Contributing

If you want to contribute to the mTower project and make it better, your help is
very welcome. Contributing is also a great way to learn more about social
coding on Github, new technologies and and their ecosystems. [How to contribute
you can find here](/Samsung/mTower/blob/master/.github/CONTRIBUTING.md).

---

## About

mTower is Trusted Execution Environment specially designed to be used on MicroController Units (MCUs) supporting ARM TrustZone technology (e.g., Cortex-M23/33/35p). mTower operates well under restrictions typical for such environment – small RAM and ROM sizes, relatively low performance, absence of rich OSes providing variety of services availab…

### Topics

[iot](/topics/iot "Topic: iot")
[microcontroller](/topics/microcontroller "Topic: microcontroller")
[smarthome](/topics/smarthome "Topic: smarthome")
[makefile](/topics/makefile "Topic: makefile")
[gcc](/topics/gcc "Topic: gcc")
[secure](/topics/secure "Topic: secure")
[freertos](/topics/freertos "Topic: freertos")
[bootloader](/topics/bootloader "Topic: bootloader")
[risc-v](/topics/risc-v "Topic: risc-v")
[trustzone](/topics/trustzone "Topic: trustzone")
[nuvoton](/topics/nuvoton "Topic: nuvoton")
[trusted-execution-environment](/topics/trusted-execution-environment "Topic: trusted-execution-environment")
[cortex-m23](/topics/cortex-m23 "Topic: cortex-m23")
[numaker-pfm-m2351](/topics/numaker-pfm-m2351 "Topic: numaker-pfm-m2351")
[m2351](/topics/m2351 "Topic: m2351")

### Resources

[Readme](#readme-ov-file)
### License

Apache-2.0, Unknown licenses found

### Licenses found

[Apache-2.0
LICENSE](/Samsung/mTower/blob/master/./LICENSE) [Unknown
COPYING](/Samsung/mTower/blob/master/./COPYING)
### Code of conduct

[Code of conduct](#coc-ov-file)
### Security policy

[Security policy](#security-ov-file)

[Activity](/Samsung/mTower/activity)
[Custom properties](/Samsung/mTower/custom-properties)
### Stars

[**53**
stars](/Samsung/mTower/stargazers)
### Watchers

[**2**
watching](/Samsung/mTower/watchers)
### Forks

[**17**
forks](/Samsung/mTower/forks)
[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower&report=Samsung+%28user%29)

## [Releases 7](/Samsung/mTower/releases)

[mTower v0.6.0
Latest

Dec 9, 2024](/Samsung/mTower/releases/tag/v0.6.0)
[+ 6 releases](/Samsung/mTower/releases)

## [Packages 0](/orgs/Samsung/packages?repo_name=mTower)

No packages published

## [Contributors 6](/Samsung/mTower/graphs/contributors)

## Languages

* [C
  98.6%](/Samsung/mTower/search?l=c)
* Other
  1.4%

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_c164420b_20250114_205846.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower%2Fblob%2F18f4b592a8a973ce5972f4e2658ea0f6e3686284%2Ftee%2Flib%2Flibutee%2Ftee_api_objects.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSamsung%2FmTower%2Fblob%2F18f4b592a8a973ce5972f4e2658ea0f6e3686284%2Ftee%2Flib%2Flibutee%2Ftee_api_objects.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=Samsung%2FmTower)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[Samsung](/Samsung)
/
**[mTower](/Samsung/mTower)**
Public

* [Notifications](/login?return_to=%2FSamsung%2FmTower) You must be signed in to change notification settings
* [Fork
  17](/login?return_to=%2FSamsung%2FmTower)
* [Star
   53](/login?return_to=%2FSamsung%2FmTower)

* [Code](/Samsung/mTower)
* [Issues
  13](/Samsung/mTower/issues)
* [Pull requests
  0](/Samsung/mTower/pulls)
* [Actions](/Samsung/mTower/actions)
* [Projects
  0](/Samsung/mTower/projects)
* [Security](/Samsung/mTower/security)
* [Insights](/Samsung/mTower/pulse)

Additional navigation options

* [Code](/Samsung/mTower)
* [Issues](/Samsung/mTower/issues)
* [Pull requests](/Samsung/mTower/pulls)
* [Actions](/Samsung/mTower/actions)
* [Projects](/Samsung/mTower/projects)
* [Security](/Samsung/mTower/security)
* [Insights](/Samsung/mTower/pulse)

## Files

 18f4b59
## Breadcrumbs

1. [mTower](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284)
2. /[tee](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee)
3. /[lib](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee/lib)
4. /[libutee](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee/lib/libutee)
/
# tee\_api\_objects.c

Copy path Blame  Blame
## Latest commit

## History

[History](/Samsung/mTower/commits/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee/lib/libutee/tee_api_objects.c)799 lines (644 loc) · 18.6 KB 18f4b59
## Breadcrumbs

1. [mTower](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284)
2. /[tee](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee)
3. /[lib](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee/lib)
4. /[libutee](/Samsung/mTower/tree/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee/lib/libutee)
/
# tee\_api\_objects.c

Top
## File metadata and controls

* Code
* Blame

799 lines (644 loc) · 18.6 KB[Raw](https://github.com/Samsung/mTower/raw/18f4b592a8a973ce5972f4e2658ea0f6e3686284/tee/lib/libutee/tee_api_objects.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799// SPDX-License-Identifier: BSD-2-Clause/\* \* Copyright (c) 2014, STMicroelectronics International N.V. \* All rights reserved. \* \* Redistribution and use in source and binary forms, with or without \* modification, are permitted provided that the following conditions are met: \* \* 1. Redistributions of source code must retain the above copyright notice, \* this list of conditions and the following disclaimer. \* \* 2. Redistributions in binary form must reproduce the above copyright notice, \* this list of conditions and the following disclaimer in the documentation \* and/or other materials provided with the distribution. \* \* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" \* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE \* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \* POSSIBILITY OF SUCH DAMAGE. \*/#include <stdlib.h>#include <string.h>
#include <tee\_api.h>#include <utee\_syscalls.h>//#include "tee\_api\_private.h"#include "utee\_types.h"
#define TEE\_USAGE\_DEFAULT 0xffffffff
#define TEE\_ATTR\_BIT\_VALUE (1 << 29)#define TEE\_ATTR\_BIT\_PROTECTED (1 << 28)
void \_\_utee\_from\_attr(struct utee\_attribute \*ua, const TEE\_Attribute \*attrs, uint32\_t attr\_count){ size\_t n;
 for (n = 0; n < attr\_count; n++) { ua[n].attribute\_id = attrs[n].attributeID; if (attrs[n].attributeID & TEE\_ATTR\_BIT\_VALUE) { ua[n].a = attrs[n].content.value.a; ua[n].b = attrs[n].content.value.b; } else { ua[n].a = (uintptr\_t)attrs[n].content.ref.buffer; ua[n].b = attrs[n].content.ref.length; } }}
/\* Data and Key Storage API - Generic Object Functions \*//\* \* Use of this function is deprecated \* new code SHOULD use the TEE\_GetObjectInfo1 function instead \* These functions will be removed at some future major revision of \* this specification \*/void TEE\_GetObjectInfo(TEE\_ObjectHandle object, TEE\_ObjectInfo \*objectInfo){ TEE\_Result res;
 res = utee\_cryp\_obj\_get\_info((unsigned long)object, objectInfo);
 if (res != TEE\_SUCCESS) TEE\_Panic(res);
 if (objectInfo->objectType == TEE\_TYPE\_CORRUPTED\_OBJECT) { objectInfo->keySize = 0; objectInfo->maxKeySize = 0; objectInfo->objectUsage = 0; objectInfo->dataSize = 0; objectInfo->dataPosition = 0; objectInfo->handleFlags = 0; }}
TEE\_Result TEE\_GetObjectInfo1(TEE\_ObjectHandle object, TEE\_ObjectInfo \*objectInfo){ TEE\_Result res;
 res = utee\_cryp\_obj\_get\_info((unsigned long)object, objectInfo);
 if (res != TEE\_SUCCESS && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}
/\* \* Use of this function is deprecated \* new code SHOULD use the TEE\_RestrictObjectUsage1 function instead \* These functions will be removed at some future major revision of \* this specification \*/void TEE\_RestrictObjectUsage(TEE\_ObjectHandle object, uint32\_t objectUsage){ TEE\_Result res; TEE\_ObjectInfo objectInfo;
 res = utee\_cryp\_obj\_get\_info((unsigned long)object, &objectInfo); if (objectInfo.objectType == TEE\_TYPE\_CORRUPTED\_OBJECT) return;
 res = TEE\_RestrictObjectUsage1(object, objectUsage);
 if (res != TEE\_SUCCESS) TEE\_Panic(res);}
TEE\_Result TEE\_RestrictObjectUsage1(TEE\_ObjectHandle object, uint32\_t objectUsage){ TEE\_Result res;
 res = utee\_cryp\_obj\_restrict\_usage((unsigned long)object, objectUsage);
 if (res != TEE\_SUCCESS && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}
TEE\_Result TEE\_GetObjectBufferAttribute(TEE\_ObjectHandle object, uint32\_t attributeID, void \*buffer, uint32\_t \*size){ TEE\_Result res; TEE\_ObjectInfo info; uint64\_t sz;
 res = utee\_cryp\_obj\_get\_info((unsigned long)object, &info); if (res != TEE\_SUCCESS) goto exit;
 /\* This function only supports reference attributes \*/ if ((attributeID & TEE\_ATTR\_BIT\_VALUE)) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto exit; }
 sz = \*size; res = utee\_cryp\_obj\_get\_attr((unsigned long)object, attributeID, buffer, &sz); \*size = sz;
exit: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_ITEM\_NOT\_FOUND && res != TEE\_ERROR\_SHORT\_BUFFER && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}
TEE\_Result TEE\_GetObjectValueAttribute(TEE\_ObjectHandle object, uint32\_t attributeID, uint32\_t \*a, uint32\_t \*b){ TEE\_Result res; TEE\_ObjectInfo info; uint32\_t buf[2]; uint64\_t size = sizeof(buf);
 res = utee\_cryp\_obj\_get\_info((unsigned long)object, &info); if (res != TEE\_SUCCESS) goto exit;
 /\* This function only supports value attributes \*/ if (!(attributeID & TEE\_ATTR\_BIT\_VALUE)) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto exit; }
 res = utee\_cryp\_obj\_get\_attr((unsigned long)object, attributeID, buf, &size);
exit: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_ITEM\_NOT\_FOUND && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 if (size != sizeof(buf)) TEE\_Panic(0);
 if (res == TEE\_SUCCESS) { if (a) \*a = buf[0]; if (b) \*b = buf[1]; }
 return res;}
void TEE\_CloseObject(TEE\_ObjectHandle object){ TEE\_Result res;
 if (object == TEE\_HANDLE\_NULL) return;
 res = utee\_cryp\_obj\_close((unsigned long)object); if (res != TEE\_SUCCESS) TEE\_Panic(res);}
/\* Data and Key Storage API - Transient Object Functions \*/
TEE\_Result TEE\_AllocateTransientObject(TEE\_ObjectType objectType, uint32\_t maxKeySize, TEE\_ObjectHandle \*object){ TEE\_Result res; uint32\_t obj;
 res = utee\_cryp\_obj\_alloc(objectType, maxKeySize, &obj);
 if (res != TEE\_SUCCESS && res != TEE\_ERROR\_OUT\_OF\_MEMORY && res != TEE\_ERROR\_NOT\_SUPPORTED) TEE\_Panic(res);
 if (res == TEE\_SUCCESS) \*object = (TEE\_ObjectHandle)(uintptr\_t)obj;
 return res;}
void TEE\_FreeTransientObject(TEE\_ObjectHandle object){ TEE\_Result res; TEE\_ObjectInfo info;
 if (object == TEE\_HANDLE\_NULL) return;
 res = utee\_cryp\_obj\_get\_info((unsigned long)object, &info); if (res != TEE\_SUCCESS) TEE\_Panic(res);
 if ((info.handleFlags & TEE\_HANDLE\_FLAG\_PERSISTENT) != 0) TEE\_Panic(0);
 res = utee\_cryp\_obj\_close((unsigned long)object); if (res != TEE\_SUCCESS) TEE\_Panic(res);}
void TEE\_ResetTransientObject(TEE\_ObjectHandle object){ TEE\_Result res; TEE\_ObjectInfo info;
 if (object == TEE\_HANDLE\_NULL) return;
 res = utee\_cryp\_obj\_get\_info((unsigned long)object, &info); if (res != TEE\_SUCCESS) TEE\_Panic(res);
 if ((info.handleFlags & TEE\_HANDLE\_FLAG\_PERSISTENT) != 0) TEE\_Panic(0);
 res = utee\_cryp\_obj\_reset((unsigned long)object); if (res != TEE\_SUCCESS) TEE\_Panic(res);}
TEE\_Result TEE\_PopulateTransientObject(TEE\_ObjectHandle object, const TEE\_Attribute \*attrs, uint32\_t attrCount){ TEE\_Result res; TEE\_ObjectInfo info; struct utee\_attribute ua[attrCount];
 res = utee\_cryp\_obj\_get\_info((unsigned long)object, &info); if (res != TEE\_SUCCESS) TEE\_Panic(res);
 /\* Must be a transient object \*/ if ((info.handleFlags & TEE\_HANDLE\_FLAG\_PERSISTENT) != 0) TEE\_Panic(0);
 /\* Must not be initialized already \*/ if ((info.handleFlags & TEE\_HANDLE\_FLAG\_INITIALIZED) != 0) TEE\_Panic(0);
 \_\_utee\_from\_attr(ua, attrs, attrCount);res = utee\_cryp\_obj\_populate((unsigned long)object, ua, attrCount); if (res != TEE\_SUCCESS && res != TEE\_ERROR\_BAD\_PARAMETERS) TEE\_Panic(res); return res;}
void TEE\_InitRefAttribute(TEE\_Attribute \*attr, uint32\_t attributeID, const void \*buffer, uint32\_t length){ if (attr == NULL) TEE\_Panic(0); if ((attributeID & TEE\_ATTR\_BIT\_VALUE) != 0) TEE\_Panic(0); attr->attributeID = attributeID; attr->content.ref.buffer = (void \*)buffer; attr->content.ref.length = length;}
void TEE\_InitValueAttribute(TEE\_Attribute \*attr, uint32\_t attributeID, uint32\_t a, uint32\_t b){ if (attr == NULL) TEE\_Panic(0); if ((attributeID & TEE\_ATTR\_BIT\_VALUE) == 0) TEE\_Panic(0); attr->attributeID = attributeID; attr->content.value.a = a; attr->content.value.b = b;}
/\* \* Use of this function is deprecated \* new code SHOULD use the TEE\_CopyObjectAttributes1 function instead \* These functions will be removed at some future major revision of \* this specification \*/void TEE\_CopyObjectAttributes(TEE\_ObjectHandle destObject, TEE\_ObjectHandle srcObject){ TEE\_Result res; TEE\_ObjectInfo src\_info;
 res = utee\_cryp\_obj\_get\_info((unsigned long)srcObject, &src\_info); if (src\_info.objectType == TEE\_TYPE\_CORRUPTED\_OBJECT) return;
 res = TEE\_CopyObjectAttributes1(destObject, srcObject); if (res != TEE\_SUCCESS) TEE\_Panic(res);}
TEE\_Result TEE\_CopyObjectAttributes1(TEE\_ObjectHandle destObject, TEE\_ObjectHandle srcObject){ TEE\_Result res; TEE\_ObjectInfo dst\_info; TEE\_ObjectInfo src\_info;
 res = utee\_cryp\_obj\_get\_info((unsigned long)destObject, &dst\_info); if (res != TEE\_SUCCESS) goto exit;
 res = utee\_cryp\_obj\_get\_info((unsigned long)srcObject, &src\_info); if (res != TEE\_SUCCESS) goto exit;
 if (!(src\_info.handleFlags & TEE\_HANDLE\_FLAG\_INITIALIZED)) TEE\_Panic(0);
 if ((dst\_info.handleFlags & TEE\_HANDLE\_FLAG\_PERSISTENT)) TEE\_Panic(0);
 if ((dst\_info.handleFlags & TEE\_HANDLE\_FLAG\_INITIALIZED)) TEE\_Panic(0);
 res = utee\_cryp\_obj\_copy((unsigned long)destObject, (unsigned long)srcObject);
exit: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}
TEE\_Result TEE\_GenerateKey(TEE\_ObjectHandle object, uint32\_t keySize, const TEE\_Attribute \*params, uint32\_t paramCount){ TEE\_Result res; struct utee\_attribute ua[paramCount];
 \_\_utee\_from\_attr(ua, params, paramCount); res = utee\_cryp\_obj\_generate\_key((unsigned long)object, keySize, ua, paramCount);
 if (res != TEE\_SUCCESS && res != TEE\_ERROR\_BAD\_PARAMETERS) TEE\_Panic(res);
 return res;}
/\* Data and Key Storage API - Persistent Object Functions \*/
TEE\_Result TEE\_OpenPersistentObject(uint32\_t storageID, const void \*objectID, uint32\_t objectIDLen, uint32\_t flags, TEE\_ObjectHandle \*object){ TEE\_Result res; uint32\_t obj;
 if (!objectID) { res = TEE\_ERROR\_ITEM\_NOT\_FOUND; goto out; }
 if (objectIDLen > TEE\_OBJECT\_ID\_MAX\_LEN) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (!object) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 res = utee\_storage\_obj\_open(storageID, objectID, objectIDLen, flags, &obj); if (res == TEE\_SUCCESS) \*object = (TEE\_ObjectHandle)(uintptr\_t)obj;
out: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_ITEM\_NOT\_FOUND && res != TEE\_ERROR\_ACCESS\_CONFLICT && res != TEE\_ERROR\_OUT\_OF\_MEMORY && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}
TEE\_Result TEE\_CreatePersistentObject(uint32\_t storageID, const void \*objectID, uint32\_t objectIDLen, uint32\_t flags, TEE\_ObjectHandle attributes, const void \*initialData, uint32\_t initialDataLen, TEE\_ObjectHandle \*object){ TEE\_Result res; uint32\_t obj;
 if (!objectID) { res = TEE\_ERROR\_ITEM\_NOT\_FOUND; goto err; }
 if (objectIDLen > TEE\_OBJECT\_ID\_MAX\_LEN) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto err; }
 res = utee\_storage\_obj\_create(storageID, objectID, objectIDLen, flags, (unsigned long)attributes, initialData, initialDataLen, &obj); if (res == TEE\_SUCCESS) { if (object) \*object = (TEE\_ObjectHandle)(uintptr\_t)obj; else res = utee\_cryp\_obj\_close(obj); if (res == TEE\_SUCCESS) goto out; }err: if (object) \*object = TEE\_HANDLE\_NULL; if (res == TEE\_ERROR\_ITEM\_NOT\_FOUND || res == TEE\_ERROR\_ACCESS\_CONFLICT || res == TEE\_ERROR\_OUT\_OF\_MEMORY || res == TEE\_ERROR\_STORAGE\_NO\_SPACE || res == TEE\_ERROR\_CORRUPT\_OBJECT || res == TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) return res; TEE\_Panic(res);out: return TEE\_SUCCESS;}
/\* \* Use of this function is deprecated \* new code SHOULD use the TEE\_CloseAndDeletePersistentObject1 function instead \* These functions will be removed at some future major revision of \* this specification \*/void TEE\_CloseAndDeletePersistentObject(TEE\_ObjectHandle object){ TEE\_Result res;
 if (object == TEE\_HANDLE\_NULL) return;
 res = TEE\_CloseAndDeletePersistentObject1(object);
 if (res != TEE\_SUCCESS) TEE\_Panic(0);}
TEE\_Result TEE\_CloseAndDeletePersistentObject1(TEE\_ObjectHandle object){ TEE\_Result res;
 if (object == TEE\_HANDLE\_NULL) return TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE;
 res = utee\_storage\_obj\_del((unsigned long)object);
 if (res != TEE\_SUCCESS && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}
TEE\_Result TEE\_RenamePersistentObject(TEE\_ObjectHandle object, const void \*newObjectID, uint32\_t newObjectIDLen){ TEE\_Result res;
 if (object == TEE\_HANDLE\_NULL) { res = TEE\_ERROR\_ITEM\_NOT\_FOUND; goto out; }
 if (!newObjectID) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (newObjectIDLen > TEE\_OBJECT\_ID\_MAX\_LEN) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 res = utee\_storage\_obj\_rename((unsigned long)object, newObjectID, newObjectIDLen);
out: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_ACCESS\_CONFLICT && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}
TEE\_Result TEE\_AllocatePersistentObjectEnumerator(TEE\_ObjectEnumHandle \* objectEnumerator){ TEE\_Result res; uint32\_t oe;
 if (!objectEnumerator) return TEE\_ERROR\_BAD\_PARAMETERS;
 res = utee\_storage\_alloc\_enum(&oe);
 if (res != TEE\_SUCCESS) oe = TEE\_HANDLE\_NULL;
 \*objectEnumerator = (TEE\_ObjectEnumHandle)(uintptr\_t)oe;
 if (res != TEE\_SUCCESS && res != TEE\_ERROR\_ACCESS\_CONFLICT) TEE\_Panic(res);
 return res;}
void TEE\_FreePersistentObjectEnumerator(TEE\_ObjectEnumHandle objectEnumerator){ TEE\_Result res;
 if (objectEnumerator == TEE\_HANDLE\_NULL) return;
 res = utee\_storage\_free\_enum((unsigned long)objectEnumerator);
 if (res != TEE\_SUCCESS) TEE\_Panic(res);}
void TEE\_ResetPersistentObjectEnumerator(TEE\_ObjectEnumHandle objectEnumerator){ TEE\_Result res;
 if (objectEnumerator == TEE\_HANDLE\_NULL) return;
 res = utee\_storage\_reset\_enum((unsigned long)objectEnumerator);
 if (res != TEE\_SUCCESS) TEE\_Panic(res);}
TEE\_Result TEE\_StartPersistentObjectEnumerator(TEE\_ObjectEnumHandle objectEnumerator, uint32\_t storageID){ TEE\_Result res;
 res = utee\_storage\_start\_enum((unsigned long)objectEnumerator, storageID);
 if (res != TEE\_SUCCESS && res != TEE\_ERROR\_ITEM\_NOT\_FOUND && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}
TEE\_Result TEE\_GetNextPersistentObject(TEE\_ObjectEnumHandle objectEnumerator, TEE\_ObjectInfo \*objectInfo, void \*objectID, uint32\_t \*objectIDLen){ TEE\_Result res; uint64\_t len; TEE\_ObjectInfo local\_info; TEE\_ObjectInfo \*pt\_info;
 if (!objectID) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (!objectIDLen) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (objectInfo) pt\_info = objectInfo; else pt\_info = &local\_info; len = \*objectIDLen; res = utee\_storage\_next\_enum((unsigned long)objectEnumerator, pt\_info, objectID, &len); \*objectIDLen = len;
out: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_ITEM\_NOT\_FOUND && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}
/\* Data and Key Storage API - Data Stream Access Functions \*/
TEE\_Result TEE\_ReadObjectData(TEE\_ObjectHandle object, void \*buffer, uint32\_t size, uint32\_t \*count){ TEE\_Result res; uint64\_t cnt64;
 if (object == TEE\_HANDLE\_NULL) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 cnt64 = \*count; res = utee\_storage\_obj\_read((unsigned long)object, buffer, size, &cnt64); \*count = cnt64;
out: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}
TEE\_Result TEE\_WriteObjectData(TEE\_ObjectHandle object, const void \*buffer, uint32\_t size){ TEE\_Result res;
 if (object == TEE\_HANDLE\_NULL) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 if (size > TEE\_DATA\_MAX\_POSITION) { res = TEE\_ERROR\_OVERFLOW; goto out; }
 res = utee\_storage\_obj\_write((unsigned long)object, buffer, size);
out: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_STORAGE\_NO\_SPACE && res != TEE\_ERROR\_OVERFLOW && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}
TEE\_Result TEE\_TruncateObjectData(TEE\_ObjectHandle object, uint32\_t size){ TEE\_Result res;
 if (object == TEE\_HANDLE\_NULL) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 res = utee\_storage\_obj\_trunc((unsigned long)object, size);
out: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_STORAGE\_NO\_SPACE && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}
TEE\_Result TEE\_SeekObjectData(TEE\_ObjectHandle object, int32\_t offset, TEE\_Whence whence){ TEE\_Result res; TEE\_ObjectInfo info;
 if (object == TEE\_HANDLE\_NULL) { res = TEE\_ERROR\_BAD\_PARAMETERS; goto out; }
 res = utee\_cryp\_obj\_get\_info((unsigned long)object, &info); if (res != TEE\_SUCCESS) goto out;
 switch (whence) { case TEE\_DATA\_SEEK\_SET: if (offset > 0 && (uint32\_t)offset > TEE\_DATA\_MAX\_POSITION) { res = TEE\_ERROR\_OVERFLOW; goto out; } break; case TEE\_DATA\_SEEK\_CUR: if (offset > 0 && ((uint32\_t)offset + info.dataPosition > TEE\_DATA\_MAX\_POSITION || (uint32\_t)offset + info.dataPosition < info.dataPosition)) { res = TEE\_ERROR\_OVERFLOW; goto out; } break; case TEE\_DATA\_SEEK\_END: if (offset > 0 && ((uint32\_t)offset + info.dataSize > TEE\_DATA\_MAX\_POSITION || (uint32\_t)offset + info.dataSize < info.dataSize)) { res = TEE\_ERROR\_OVERFLOW; goto out; } break; default: res = TEE\_ERROR\_ITEM\_NOT\_FOUND; goto out; }
 res = utee\_storage\_obj\_seek((unsigned long)object, offset, whence);
out: if (res != TEE\_SUCCESS && res != TEE\_ERROR\_OVERFLOW && res != TEE\_ERROR\_CORRUPT\_OBJECT && res != TEE\_ERROR\_STORAGE\_NOT\_AVAILABLE) TEE\_Panic(res);
 return res;}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


