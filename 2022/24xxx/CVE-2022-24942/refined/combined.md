=== Content from github.com_c49686ed_20250114_205257.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSiliconLabs%2Fgecko_sdk%2Fblame%2Fv4.1.1%2Fplatform%2Fmicrium_os%2Fnet%2Fsource%2Fhttp%2Fserver%2Fhttp_server_req.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FSiliconLabs%2Fgecko_sdk%2Fblame%2Fv4.1.1%2Fplatform%2Fmicrium_os%2Fnet%2Fsource%2Fhttp%2Fserver%2Fhttp_server_req.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fblame&source=header-repo&source_repo=SiliconLabs%2Fgecko_sdk)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[SiliconLabs](/SiliconLabs)
/
**[gecko\_sdk](/SiliconLabs/gecko_sdk)**
Public

* [Notifications](/login?return_to=%2FSiliconLabs%2Fgecko_sdk) You must be signed in to change notification settings
* [Fork
  165](/login?return_to=%2FSiliconLabs%2Fgecko_sdk)
* [Star
   395](/login?return_to=%2FSiliconLabs%2Fgecko_sdk)

* [Code](/SiliconLabs/gecko_sdk/tree/v4.1.1)
* [Pull requests
  11](/SiliconLabs/gecko_sdk/pulls)
* [Actions](/SiliconLabs/gecko_sdk/actions)
* [Security](/SiliconLabs/gecko_sdk/security)
* [Insights](/SiliconLabs/gecko_sdk/pulse)

Additional navigation options

* [Code](/SiliconLabs/gecko_sdk/tree/v4.1.1)
* [Pull requests](/SiliconLabs/gecko_sdk/pulls)
* [Actions](/SiliconLabs/gecko_sdk/actions)
* [Security](/SiliconLabs/gecko_sdk/security)
* [Insights](/SiliconLabs/gecko_sdk/pulse)

## Files

 v4.1.1
## Breadcrumbs

1. [gecko\_sdk](/SiliconLabs/gecko_sdk/tree/v4.1.1)
2. /[platform](/SiliconLabs/gecko_sdk/tree/v4.1.1/platform)
3. /[micrium\_os](/SiliconLabs/gecko_sdk/tree/v4.1.1/platform/micrium_os)
4. /[net](/SiliconLabs/gecko_sdk/tree/v4.1.1/platform/micrium_os/net)
5. /[source](/SiliconLabs/gecko_sdk/tree/v4.1.1/platform/micrium_os/net/source)
6. /[http](/SiliconLabs/gecko_sdk/tree/v4.1.1/platform/micrium_os/net/source/http)
7. /[server](/SiliconLabs/gecko_sdk/tree/v4.1.1/platform/micrium_os/net/source/http/server)
/
# http\_server\_req.c

Copy path Blame  Blame
## Latest commit

## History

[History](/SiliconLabs/gecko_sdk/commits/v4.1.1/platform/micrium_os/net/source/http/server/http_server_req.c)2852 lines (2551 loc) · 127 KB v4.1.1
## Breadcrumbs

1. [gecko\_sdk](/SiliconLabs/gecko_sdk/tree/v4.1.1)
2. /[platform](/SiliconLabs/gecko_sdk/tree/v4.1.1/platform)
3. /[micrium\_os](/SiliconLabs/gecko_sdk/tree/v4.1.1/platform/micrium_os)
4. /[net](/SiliconLabs/gecko_sdk/tree/v4.1.1/platform/micrium_os/net)
5. /[source](/SiliconLabs/gecko_sdk/tree/v4.1.1/platform/micrium_os/net/source)
6. /[http](/SiliconLabs/gecko_sdk/tree/v4.1.1/platform/micrium_os/net/source/http)
7. /[server](/SiliconLabs/gecko_sdk/tree/v4.1.1/platform/micrium_os/net/source/http/server)
/
# http\_server\_req.c

Top
## File metadata and controls

* Code
* Blame

2852 lines (2551 loc) · 127 KB[Raw](https://github.com/SiliconLabs/gecko_sdk/raw/refs/tags/v4.1.1/platform/micrium_os/net/source/http/server/http_server_req.c)OlderNewer Dec 15, 2021![](https://avatars.githubusercontent.com/u/91222120?s=80&v=4)[Gecko SDK 4.0.0](/SiliconLabs/gecko_sdk/commit/991121c706578c9a2135b6f75cc88856e8c64bdc)Dec 15, 20211234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\*\* \* @file \* @brief Network - HTTP Server Request Module \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* # License \* <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b> \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* \* The licensor of this software is Silicon Laboratories Inc. Your use of this \* software is governed by the terms of Silicon Labs Master Software License \* Agreement (MSLA) available at \* www.silabs.com/about-us/legal/master-software-license-agreement. \* The software is governed by the sections of the MSLA applicable to Micrium \* Software. \* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* DEPENDENCIES & AVAIL CHECK(S) \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
#include <rtos\_description.h>
#if (defined(RTOS\_MODULE\_NET\_HTTP\_SERVER\_AVAIL))
#if (!defined(RTOS\_MODULE\_NET\_AVAIL))#error HTTP Server Module requires Network Core module. Make sure it is part of your project \ and that RTOS\_MODULE\_NET\_AVAIL is defined in rtos\_description.h.#endif
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* INCLUDE FILES \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
#include "http\_server\_priv.h"
#include "../http\_priv.h"#include "../http\_dict\_priv.h"
#include <cpu/include/cpu.h>#include <common/include/lib\_ascii.h>#include <common/include/lib\_str.h>
#include <common/source/rtos/rtos\_utils\_priv.h>#include <common/source/logging/logging\_priv.h>
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* LOCAL DEFINES \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
#define LOG\_DFLT\_CH (NET, HTTP)#define RTOS\_MODULE\_CUR RTOS\_CFG\_MODULE\_NET
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* FORM DEFINES \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
#define HTTPs\_STR\_MULTIPART\_CTRL\_END\_SEC STR\_CR\_LF STR\_CR\_LF#define HTTPs\_STR\_MULTIPART\_CTRL\_END\_SEC\_LEN (sizeof(HTTPs\_STR\_MULTIPART\_CTRL\_END\_SEC) - 1)
#define HTTPs\_STR\_MULTIPART\_DATA\_START "--"#define HTTPs\_STR\_MULTIPART\_DATA\_START\_LEN (sizeof(HTTPs\_STR\_MULTIPART\_DATA\_START) - 1)
#define HTTPs\_STR\_MULTIPART\_DATA\_END STR\_CR\_LF "--"#define HTTPs\_STR\_MULTIPART\_DATA\_END\_LEN (sizeof(HTTPs\_STR\_MULTIPART\_DATA\_END) - 1)
#define HTTPs\_STR\_MULTIPART\_LAST "--" STR\_CR\_LF#define HTTPs\_STR\_MULTIPART\_LAST\_LEN (sizeof(HTTPs\_STR\_MULTIPART\_LAST) - 1)
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* LOCAL FUNCTION PROTOTYPES \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
static void HTTPsReq\_MethodParse(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, HTTPs\_ERR \*p\_err);
static CPU\_BOOLEAN HTTPsReq\_URI\_Parse(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, HTTPs\_ERR \*p\_err);
static void HTTPsReq\_QueryStrParse(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, HTTPs\_ERR \*p\_err);
#if (HTTPs\_CFG\_QUERY\_STR\_EN == DEF\_ENABLED)static CPU\_BOOLEAN HTTPsReq\_QueryStrKeyValBlkAdd(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, CPU\_CHAR \*p\_str, CPU\_SIZE\_T str\_len, HTTPs\_ERR \*p\_err);#endif
static void HTTPsReq\_ProtocolVerParse(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, HTTPs\_ERR \*p\_err);
static void HTTPsReq\_HdrParse(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, HTTPs\_ERR \*p\_err);
static CPU\_CHAR \*HTTPsReq\_HdrParseValGet(CPU\_CHAR \*p\_field, CPU\_INT16U field\_len, CPU\_CHAR \*p\_field\_end, CPU\_INT16U \*p\_len\_rem);
#if (HTTPs\_CFG\_FORM\_EN == DEF\_ENABLED)static CPU\_BOOLEAN HTTPsReq\_BodyForm(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, HTTPs\_ERR \*p\_err);
static CPU\_BOOLEAN HTTPsReq\_BodyFormAppParse(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_connn, HTTPs\_ERR \*p\_err);
static CPU\_BOOLEAN HTTPsReq\_BodyFormAppKeyValBlkAdd(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, CPU\_CHAR \*p\_str, CPU\_SIZE\_T str\_len, HTTPs\_ERR \*p\_err);
#if (HTTPs\_CFG\_FORM\_MULTIPART\_EN == DEF\_ENABLED)static CPU\_BOOLEAN HTTPsReq\_BodyFormMultipartParse(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, HTTPs\_ERR \*p\_err);
static CPU\_CHAR \*HTTPsReq\_BodyFormMultipartBoundarySrch(CPU\_CHAR \*p\_boundary, CPU\_INT08U boundary\_len, CPU\_CHAR \*p\_buf, CPU\_INT16U buf\_len, CPU\_CHAR \*\*p\_boundary\_sep);
static CPU\_BOOLEAN HTTPsReq\_BodyFormMultipartCtrlParse(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, HTTPs\_ERR \*p\_err);
static CPU\_BOOLEAN HTTPsReq\_BodyFormMultipartFileWr(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, HTTPs\_ERR \*p\_err);#endif#endif
#if ((HTTPs\_CFG\_QUERY\_STR\_EN == DEF\_ENABLED) \ || ((HTTPs\_CFG\_FORM\_EN == DEF\_ENABLED)))static CPU\_BOOLEAN HTTPsReq\_URL\_EncodeStrParse(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, HTTPs\_KEY\_VAL \*p\_key\_val, CPU\_BOOLEAN from\_query, CPU\_CHAR \*p\_str, CPU\_SIZE\_T str\_len);#endif
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* GLOBAL FUNCTIONS \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\*\* \* HTTPsReq\_Handler() \* \* @brief (1) Parse request: \* - (a) Parse request method \* - (b) Parse request URI \* - (c) Parse request query string (if necessary) \* - (d) Parse request protocol version \* - (e) Parse request headers \* - (f) (HOOK) Authentication \* \* @param p\_instance Pointer to the instance. \* \* @param p\_conn Pointer to the connection. \* \* @return HTTPs\_CONN\_PROCESS\_CONTINUE, connection successfully updated and the process can continue. \* HTTPs\_CONN\_PROCESS\_RX\_TX, connection requires more data to complete the parse process. \* \* @note (2) RFC #2616, Section 5 'Request' specifies how a request message must be structured: \*\* A request message from a client to a server includes, within the first line of that message, \* the method to be applied to the resource, the identifier of the resource, and the protocol \* version in use. \* \* Request = Request-Line \* \*(( general-header \* | request-header \* | entity-header ) CRLF) \* CRLF \* [ message-body ] \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/void HTTPsReq\_Handler(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn){ const HTTPs\_CFG \*p\_cfg; HTTPs\_INSTANCE\_STATS \*p\_ctr\_stats = DEF\_NULL; HTTPs\_INSTANCE\_ERRS \*p\_ctr\_err = DEF\_NULL; CPU\_BOOLEAN accepted; CPU\_BOOLEAN done; CPU\_BOOLEAN hook\_def; CPU\_BOOLEAN is\_query\_str\_found; HTTPs\_ERR err\_http = HTTPs\_ERR\_NONE;
 p\_cfg = (HTTPs\_CFG \*)p\_instance->CfgPtr;
 HTTPs\_SET\_PTR\_STATS(p\_ctr\_stats, p\_instance); HTTPs\_SET\_PTR\_ERRS(p\_ctr\_err, p\_instance);
 done = DEF\_NO; while (done != DEF\_YES) { switch (p\_conn->State) { case HTTPs\_CONN\_STATE\_REQ\_INIT: LOG\_VRB(("HTTPs - SockID: ", (u)p\_conn->SockID, " - New Request received")); HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatRxdCtr);#if (HTTPs\_CFG\_HDR\_RX\_EN == DEF\_ENABLED) p\_conn->HdrType = HTTPs\_HDR\_TYPE\_REQ;#endif p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_PARSE\_METHOD; break;
 // ---------------- PARSE REQ METHOD ------------------ case HTTPs\_CONN\_STATE\_REQ\_PARSE\_METHOD: HTTPsReq\_MethodParse(p\_instance, p\_conn, &err\_http); if (err\_http != HTTPs\_ERR\_NONE) { // If the Method parsing has failed... HTTPs\_ERR\_INC(p\_ctr\_err->Req\_ErrInvalidCtr); // ...generate an error... p\_conn->ErrCode = err\_http; p\_conn->State = HTTPs\_CONN\_STATE\_ERR\_INTERNAL; p\_conn->SockState = HTTPs\_SOCK\_STATE\_NONE; done = DEF\_YES; // ...and exit the state machine. break; } // If the Method parsing is successful... p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_PARSE\_URI; // ...go to the next step. break;
 // ------------------ PARSE REQ URI ------------------- case HTTPs\_CONN\_STATE\_REQ\_PARSE\_URI: is\_query\_str\_found = HTTPsReq\_URI\_Parse(p\_instance, p\_conn, &err\_http); switch (err\_http) { case HTTPs\_ERR\_NONE: // If the URI parsing is successful... if (is\_query\_str\_found == DEF\_YES) { // ...check if query string need to be parse. p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_PARSE\_QUERY\_STRING; } else { p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_PARSE\_PROTOCOL\_VERSION; } break;
 case HTTPs\_ERR\_REQ\_MORE\_DATA\_REQUIRED: // If more data is required to complete the... p\_conn->SockState = HTTPs\_SOCK\_STATE\_RX; // ...URI Parsing, exit the state machine. done = DEF\_YES; break;
 default: // If the URI parsing has failed... HTTPs\_ERR\_INC(p\_ctr\_err->Req\_ErrInvalidCtr); // ...generate an error... p\_conn->SockState = HTTPs\_SOCK\_STATE\_NONE; p\_conn->ErrCode = err\_http; p\_conn->State = HTTPs\_CONN\_STATE\_ERR\_INTERNAL; done = DEF\_YES; // ...and exit the state machine. break; } break;
 // --------------- PARSE REQ QUERY STR ---------------- case HTTPs\_CONN\_STATE\_REQ\_PARSE\_QUERY\_STRING: HTTPsReq\_QueryStrParse(p\_instance, p\_conn, &err\_http); switch (err\_http) { case HTTPs\_ERR\_NONE: // If the Query Str parsing is successful... // ...go to the next step. p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_PARSE\_PROTOCOL\_VERSION; break;
 case HTTPs\_ERR\_REQ\_MORE\_DATA\_REQUIRED: // If more data is required to complete the... p\_conn->SockState = HTTPs\_SOCK\_STATE\_RX; // ...Query Str Parsing, exit the state machine. done = DEF\_YES; break;
 default: // If the Query Str parsing has failed... HTTPs\_ERR\_INC(p\_ctr\_err->Req\_ErrInvalidCtr); // ...generate an error... p\_conn->SockState = HTTPs\_SOCK\_STATE\_NONE; p\_conn->ErrCode = err\_http; p\_conn->State = HTTPs\_CONN\_STATE\_ERR\_INTERNAL; done = DEF\_YES; // ...and exit the state machine. break; } break;
 // -------------- PARSE REQ PROTOCOL VER -------------- case HTTPs\_CONN\_STATE\_REQ\_PARSE\_PROTOCOL\_VERSION: HTTPsReq\_ProtocolVerParse(p\_instance, p\_conn, &err\_http); switch (err\_http) { case HTTPs\_ERR\_NONE: // If the Protocol Ver parsing is successful... // ...go to the next step. p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_PARSE\_HDR; p\_conn->SockState = HTTPs\_SOCK\_STATE\_NONE; DEF\_BIT\_CLR(p\_conn->Flags, (HTTPs\_FLAGS)HTTPs\_FLAG\_RESP\_LOCATION); break;
 case HTTPs\_ERR\_REQ\_MORE\_DATA\_REQUIRED: // If more data is required to complete the... p\_conn->SockState = HTTPs\_SOCK\_STATE\_RX; // ...Protocol Ver parsing, exit the state... done = DEF\_YES; // ...machine. break;
 default: // If the Protocol Ver parsing has failed... HTTPs\_ERR\_INC(p\_ctr\_err->Req\_ErrInvalidCtr); // ...generate an error... p\_conn->SockState = HTTPs\_SOCK\_STATE\_NONE; p\_conn->ErrCode = err\_http; p\_conn->State = HTTPs\_CONN\_STATE\_ERR\_INTERNAL; done = DEF\_YES; // ...and exit the state machine. break; } break;
 // ------------------ PARSE REQ HDR ------------------- case HTTPs\_CONN\_STATE\_REQ\_PARSE\_HDR: HTTPsReq\_HdrParse(p\_instance, p\_conn, &err\_http); // See Note #2. switch (err\_http) { case HTTPs\_ERR\_NONE: // If the Protocol Ver parsing is successful... // ...go to the next step. p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_LINE\_HDR\_HOOK; p\_conn->SockState = HTTPs\_SOCK\_STATE\_NONE; HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatProcessedCtr); break;
 case HTTPs\_ERR\_REQ\_MORE\_DATA\_REQUIRED: // If more data is required to complete the... p\_conn->SockState = HTTPs\_SOCK\_STATE\_RX; // ...Protocol Ver parsing, exit the state... done = DEF\_YES; // ...machine. break;
 default: // If the Header parsing has failed... HTTPs\_ERR\_INC(p\_ctr\_err->Req\_ErrInvalidCtr); // ...generate an error... p\_conn->ErrCode = err\_http; p\_conn->State = HTTPs\_CONN\_STATE\_ERR\_INTERNAL; done = DEF\_YES; // ...and exit the state machine. break; } break;
 // --------------- CONN REQ EXT PROCESS --------------- case HTTPs\_CONN\_STATE\_REQ\_LINE\_HDR\_HOOK: hook\_def = HTTPs\_HOOK\_DEFINED(p\_cfg->HooksPtr, OnReqHook); if (hook\_def == DEF\_YES) { accepted = p\_cfg->HooksPtr->OnReqHook(p\_instance, p\_conn, p\_cfg->Hooks\_CfgPtr); if (accepted != DEF\_YES) { // If the connection is not authorized ... if (p\_conn->StatusCode == HTTP\_STATUS\_OK) { p\_conn->StatusCode = HTTP\_STATUS\_UNAUTHORIZED; } DEF\_BIT\_SET(p\_conn->Flags, HTTPs\_FLAG\_REQ\_FLUSH); p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_FLUSH\_DATA; } } // Otherwise, receive the body. p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_INIT; done = DEF\_YES; // ... exit the state machine. break;
 default: HTTPs\_ERR\_INC(p\_ctr\_err->Req\_ErrStateUnkownCtr); p\_conn->ErrCode = HTTPs\_ERR\_STATE\_UNKNOWN; p\_conn->State = HTTPs\_CONN\_STATE\_ERR\_INTERNAL; done = DEF\_YES; RTOS\_CRITICAL\_FAIL\_EXEC(RTOS\_ERR\_INVALID\_STATE,; ); } }}
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\*\* \* HTTPsReq\_Body() \* \* @brief Process Body received in HTTP request. \* \* @param p\_instance Pointer to the instance. \* \* @param p\_conn Pointer to the connection. \* \* @note (2) RFC #2616, Section 9 'Method Definitions' describes methods for HTTP/1.1: \* - (a) RFC #2616, Section 9.3 'GET' describes GET method: \* \* The GET method means retrieve whatever information (in the form of an \* entity) is identified by the Request-URI. If the Request-URI refers \* to a data-producing process, it is the produced data which shall be \* returned as the entity in the response and not the source text of the \* process, unless that text happens to be the output of the process. \* \* The semantics of the GET method change to a "conditional GET" if the \* request message includes an If-Modified-Since, If-Unmodified-Since, \* If-Match, If-None-Match, or If-Range header field. A conditional GET \* method requests that the entity be transferred only under the \* circumstances described by the conditional header field(s). The \* conditional GET method is intended to reduce unnecessary network \* usage by allowing cached entities to be refreshed without requiring \* multiple requests or transferring data already held by the client. \* \* The semantics of the GET method change to a "partial GET" if the \* request message includes a Range header field. A partial GET requests \* that only part of the entity be transferred, as described in section \* 14.35. The partial GET method is intended to reduce unnecessary \* network usage by allowing partially-retrieved entities to be \* completed without transferring data already held by the client. \* \* The response to a GET request is cacheable if and only if it meets \* the requirements for HTTP caching described in section 13. \* \* See section 15.1.3 for security considerations when used for forms. \* \* - (b) RFC #2616, Section 9.4 'HEAD' describes HEAD method: \* \* The HEAD method is identical to GET except that the server MUST NOT \* return a message-body in the response. The metainformation contained \* in the HTTP headers in response to a HEAD request SHOULD be identical \* to the information sent in response to a GET request. This method can \* be used for obtaining metainformation about the entity implied by the \* request without transferring the entity-body itself. This method is \* often used for testing hypertext links for validity, accessibility, \* and recent modification. \* \* - (c) RFC #2616, Section 9.5 'POST' describes POST method: \* \* The POST method is used to request that the origin server accept the entity \* enclosed in the request as a new subordinate of the resource identified by \* the Request-URI in the Request-Line. POST is designed to allow a uniform \* method to cover the following functions: \* \* - Annotation of existing resources; \* - Posting a message to a bulletin board, newsgroup, mailing list, \* or similar group of articles; \* - Providing a block of data, such as the result of submitting a \* form, to a data-handling process; \* - Extending a database through an append operation. \* \* The actual function performed by the POST method is determined by the server \* and is usually dependent on the Request-URI. The posted entity is subordinate \* to that URI in the same way that a file is subordinate to a directory \* containing it, a news article is subordinate to a newsgroup to which it is \* posted, or a record is subordinate to a database. \* \* The action performed by the POST method might not result in a resource that \* can be identified by a URI. In this case, either 200 (OK) or 204 (No Content) \* is the appropriate response status, depending on whether or not the response \* includes an entity that describes the result. \* \* If a resource has been created on the origin server, the response SHOULD be 201 \* (Created) and contain an entity which describes the status of the request and \* refers to the new resource, and a Location header (see section 14.30). \* \* Responses to this method are not cacheable, unless the response includes \* appropriate Cache-Control or Expires header fields. However, the 303 (See Other) \* response can be used to direct the user agent to retrieve a cacheable resource. \* \* POST requests MUST obey the message transmission requirements set out in \* section 8.2. \* \* See section 15.1.3 for security considerations. \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/void HTTPsReq\_Body(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn){ const HTTPs\_CFG \*p\_cfg; HTTPs\_INSTANCE\_STATS \*p\_ctr\_stats = DEF\_NULL; HTTPs\_INSTANCE\_ERRS \*p\_ctr\_err = DEF\_NULL; CPU\_SIZE\_T data\_len\_rd; CPU\_BOOLEAN hook\_continue; CPU\_BOOLEAN done; CPU\_BOOLEAN body\_hook\_def; CPU\_BOOLEAN req\_flushed;#if (HTTPs\_CFG\_FORM\_EN == DEF\_ENABLED) CPU\_BOOLEAN parse\_done; HTTPs\_ERR local\_err = HTTPs\_ERR\_NONE;#endif
 HTTPs\_SET\_PTR\_STATS(p\_ctr\_stats, p\_instance); HTTPs\_SET\_PTR\_ERRS(p\_ctr\_err, p\_instance);
 p\_cfg = p\_instance->CfgPtr;
 done = DEF\_NO; while (done == DEF\_NO) { switch (p\_conn->State) { // ------------- PREPARE FOR BODY PARSING ------------- case HTTPs\_CONN\_STATE\_REQ\_BODY\_INIT: p\_conn->ReqContentLenRxd = 0u; // Clear the length of data received variable.
 // SET CONN STATE AND SOCKET STATE FOR BODY PARSING. if (p\_conn->ReqContentLen == 0) { // If all data received (no body) ... // ... jump to response preparation. p\_conn->SockState = HTTPs\_SOCK\_STATE\_NONE; p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_READY\_SIGNAL; p\_conn->RxBufLenRem = 0; done = DEF\_YES; } else { // If a body is present in the request received: switch (p\_conn->Method) { // (1) Set the conn state for the parsing. case HTTP\_METHOD\_GET: p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_DATA; HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatMethodGetProcessedCtr); break;
 case HTTP\_METHOD\_HEAD: p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_DATA; HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatMethodHeadProcessedCtr); break;
 case HTTP\_METHOD\_DELETE: p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_DATA; HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatMethodDeleteProcessedCtr); break;
 case HTTP\_METHOD\_PUT: p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_DATA; HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatMethodPutProcessedCtr); break;
 case HTTP\_METHOD\_POST: // Check if the POST Content-Type matches with those ... // ... the server core can parse.#if (HTTPs\_CFG\_FORM\_EN == DEF\_ENABLED) if (p\_conn->ReqContentType == HTTP\_CONTENT\_TYPE\_APP\_FORM) { p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_FORM\_APP\_PARSE; } else if (p\_conn->ReqContentType == HTTP\_CONTENT\_TYPE\_MULTIPART\_FORM) { p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_FORM\_MULTIPART\_INIT; } else { p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_DATA; }#else HTTPs\_ERR\_INC(p\_ctr\_err->Req\_ErrBodyFormNotEn); p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_DATA;#endif HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatMethodPostProcessedCtr); break;
 default: HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatMethodUnsupportedProcessedCtr); p\_conn->ErrCode = HTTPs\_ERR\_REQ\_METHOD\_NOT\_SUPPORTED; p\_conn->State = HTTPs\_CONN\_STATE\_ERR\_INTERNAL; goto exit; }
 if (p\_conn->RxBufLenRem == 0) { // (2) Set the socket state. p\_conn->SockState = HTTPs\_SOCK\_STATE\_RX; // Need to Rx more data for parsing step. done = DEF\_YES; } else { p\_conn->SockState = HTTPs\_SOCK\_STATE\_NONE; } } break;
 // ----- NOTIFY UPPER APP THAT DATA IS AVAILABLE ------ case HTTPs\_CONN\_STATE\_REQ\_BODY\_DATA: body\_hook\_def = HTTPs\_HOOK\_DEFINED(p\_cfg->HooksPtr, OnReqBodyRxHook); // If the hook for the body is defined. if (body\_hook\_def == DEF\_TRUE) { // Call the hook function. hook\_continue = p\_cfg->HooksPtr->OnReqBodyRxHook(p\_instance, p\_conn, p\_cfg->Hooks\_CfgPtr, p\_conn->RxBufPtr, p\_conn->RxBufLenRem, &data\_len\_rd);
 if ((data\_len\_rd > p\_conn->RxBufLenRem) && (p\_conn->RxBufLenRem > 0) ) { // Fatal error. p\_conn->ErrCode = HTTPs\_ERR\_REQ\_BODY\_FAULT; p\_conn->State = HTTPs\_CONN\_STATE\_ERR\_INTERNAL; goto exit; }
 // Update length of data consumed. p\_conn->RxBufLenRem -= data\_len\_rd; p\_conn->ReqContentLenRxd += data\_len\_rd; p\_conn->RxBufPtr += data\_len\_rd;
 if (hook\_continue == DEF\_NO) { // Case when the App doesn't want to rx more data. // While there is data to receive, flush it. p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_FLUSH\_DATA; p\_conn->SockState = HTTPs\_SOCK\_STATE\_RX; } else { // If there is more data to read if (p\_conn->ReqContentLenRxd < p\_conn->ReqContentLen) { // Ask for more data. p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_DATA; p\_conn->SockState = HTTPs\_SOCK\_STATE\_RX; } else { // Otherwise, prepare the request response body. p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_READY\_SIGNAL; p\_conn->SockState = HTTPs\_SOCK\_STATE\_NONE; } } } else { // Case hook is not defined: flush data rx. p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_FLUSH\_DATA; p\_conn->SockState = HTTPs\_SOCK\_STATE\_RX; } done = DEF\_YES; break;
 // ----------- PARSE FORM RECEIVED IN POST ------------ case HTTPs\_CONN\_STATE\_REQ\_BODY\_FORM\_APP\_PARSE: case HTTPs\_CONN\_STATE\_REQ\_BODY\_FORM\_MULTIPART\_INIT: case HTTPs\_CONN\_STATE\_REQ\_BODY\_FORM\_MULTIPART\_PARSE: case HTTPs\_CONN\_STATE\_REQ\_BODY\_FORM\_MULTIPART\_FILE\_OPEN: case HTTPs\_CONN\_STATE\_REQ\_BODY\_FORM\_MULTIPART\_FILE\_WR:#if (HTTPs\_CFG\_FORM\_EN == DEF\_ENABLED) parse\_done = HTTPsReq\_BodyForm(p\_instance, p\_conn, &local\_err); switch (local\_err) { case HTTPs\_ERR\_NONE: if (parse\_done == DEF\_YES) { p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_READY\_SIGNAL; p\_conn->SockState = HTTPs\_SOCK\_STATE\_NONE; done = DEF\_YES; } break;
 case HTTPs\_ERR\_REQ\_MORE\_DATA\_REQUIRED: done = DEF\_YES; p\_conn->SockState = HTTPs\_SOCK\_STATE\_RX; break;
 default: done = DEF\_YES; p\_conn->ErrCode = local\_err; p\_conn->State = HTTPs\_CONN\_STATE\_ERR\_INTERNAL; p\_conn->SockState = HTTPs\_SOCK\_STATE\_NONE; HTTPs\_ERR\_INC(p\_ctr\_err->Req\_ErrBodyPostFormCtr); break; }#else HTTPs\_ERR\_INC(p\_ctr\_err->Req\_ErrBodyFormNotEn); p\_conn->ErrCode = HTTPs\_ERR\_CFG\_INVALID\_FORM\_EN; p\_conn->State = HTTPs\_CONN\_STATE\_ERR\_INTERNAL; p\_conn->SockState = HTTPs\_SOCK\_STATE\_NONE;#endif break;
 // ---------- FLUSH ALL REMAINING BODY DATA ----------- case HTTPs\_CONN\_STATE\_REQ\_BODY\_FLUSH\_DATA: p\_conn->ReqContentLenRxd += p\_conn->RxBufLenRem; p\_conn->RxBufLenRem = 0;
 if ((p\_conn->ReqContentLen == 0) || (p\_conn->ReqContentLenRxd >= p\_conn->ReqContentLen)) { // If there is no more data to receive. Process status. req\_flushed = DEF\_BIT\_IS\_SET(p\_conn->Flags, HTTPs\_FLAG\_REQ\_FLUSH); if (req\_flushed == DEF\_YES) { p\_conn->State = HTTPs\_CONN\_STATE\_RESP\_PREPARE; } else { p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_READY\_SIGNAL; } p\_conn->SockState = HTTPs\_SOCK\_STATE\_NONE; } else { // While there is data to receive, flush it. p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_BODY\_FLUSH\_DATA; p\_conn->SockState = HTTPs\_SOCK\_STATE\_RX; } done = DEF\_YES; break;
 default: HTTPs\_ERR\_INC(p\_ctr\_err->Req\_ErrBodyStateUnknownCtr); p\_conn->ErrCode = HTTPs\_ERR\_STATE\_UNKNOWN; p\_conn->State = HTTPs\_CONN\_STATE\_ERR\_INTERNAL; RTOS\_CRITICAL\_FAIL\_EXEC(RTOS\_ERR\_INVALID\_STATE,; ); } }
exit: return;}
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\*\* \* HTTPsReq\_RdySignal() \* \* @brief Signal the upper application that the request was received completely and that it CAN \* start the request processing. \* \* @param p\_instance Pointer to the instance. \* \* @param p\_conn Pointer to the connection. \* \* @return DEF\_YES, if upper application has finish the request processing. \* DEF\_NO, otherwise. \* \* @note (1) If the request processing by the application is not completed the poll hook will be called \* until it's done. \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/CPU\_BOOLEAN HTTPsReq\_RdySignal(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn){ const HTTPs\_CFG \*p\_cfg = p\_instance->CfgPtr; HTTPs\_KEY\_VAL \*p\_key\_val = DEF\_NULL; CPU\_BOOLEAN hook\_def = DEF\_NO; CPU\_BOOLEAN process\_done = DEF\_NO;
#if (HTTPs\_CFG\_FORM\_EN == DEF\_ENABLED) p\_key\_val = p\_conn->FormDataListPtr;#endif
 switch (p\_conn->State) { // ------------ POST DATA RX TO USER APP -------------- case HTTPs\_CONN\_STATE\_REQ\_READY\_SIGNAL: hook\_def = HTTPs\_HOOK\_DEFINED(p\_cfg->HooksPtr, OnReqRdySignalHook); if (hook\_def == DEF\_YES) { // Callback fnct process data. process\_done = p\_cfg->HooksPtr->OnReqRdySignalHook(p\_instance, p\_conn, p\_cfg->Hooks\_CfgPtr, (const HTTPs\_KEY\_VAL \*)p\_key\_val);
 if (process\_done != DEF\_YES) { p\_conn->State = HTTPs\_CONN\_STATE\_REQ\_READY\_POLL; } } else { process\_done = DEF\_YES; } break;
 // ----------- WAIT END OF DATA PROCESSING ------------ case HTTPs\_CONN\_STATE\_REQ\_READY\_POLL: hook\_def = HTTPs\_HOOK\_DEFINED(p\_cfg->HooksPtr, OnReqRdyPollHook); if (hook\_def == DEF\_YES) { // Wait until data processing is completed. process\_done = p\_cfg->HooksPtr->OnReqRdyPollHook(p\_instance, p\_conn, p\_cfg->Hooks\_CfgPtr); } else { process\_done = DEF\_YES; } break;
 default: process\_done = DEF\_YES; p\_conn->ErrCode = HTTPs\_ERR\_STATE\_UNKNOWN; p\_conn->State = HTTPs\_CONN\_STATE\_ERR\_INTERNAL; RTOS\_CRITICAL\_FAIL\_EXEC(RTOS\_ERR\_INVALID\_STATE, process\_done); }
 return (process\_done);}
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* LOCAL FUNCTIONS \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\*\* \* HTTPsReq\_MethodParse() \* \* @brief Parse request Method \* \* @param p\_instance Pointer to the instance. \* \* @param p\_conn Pointer to the connection. \* \* @param p\_err Pointer to variable that will receive the return error code from this function. \* \* @note (2) RFC #2616, Section 5.1.1 'Method' defines request line methods: \* The Method token indicates the method to be performed on the resource identified by the \* Request-URI. The method is case-sensitive. \* \* Method = "OPTIONS" ; Section 9.2 \* | "GET" ; Section 9.3 \* | "HEAD" ; Section 9.4 \* | "POST" ; Section 9.5 \* | "PUT" ; Section 9.6 \* | "DELETE" ; Section 9.7 \* | "TRACE" ; Section 9.8 \* | "CONNECT" ; Section 9.9 \* | extension-method \* extension-method = token \* \* The list of methods allowed by a resource can be specified in an Allow header field \* (section 14.7). The return code of the response always notifies the client whether a \* method is currently allowed on a resource, since the set of allowed methods can change \* dynamically. An origin server SHOULD return the status code 405 (Method Not Allowed) \* if the method is known by the origin server but not allowed for the requested resource, \* and 501 (Not Implemented) if the method is unrecognized or not implemented by the origin \* server. The methods GET and HEAD MUST be supported by all general-purpose servers. All \* other methods are OPTIONAL; however, if the above methods are implemented, they MUST be \* implemented with the same semantics as those specified in section 9. \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/static void HTTPsReq\_MethodParse(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, HTTPs\_ERR \*p\_err){ CPU\_CHAR \*p\_request\_method\_start; CPU\_CHAR \*p\_request\_method\_end; CPU\_SIZE\_T len; HTTPs\_INSTANCE\_STATS \*p\_ctr\_stats = DEF\_NULL; CPU\_INT32U method;
 PP\_UNUSED\_PARAM(p\_instance); HTTPs\_SET\_PTR\_STATS(p\_ctr\_stats, p\_instance);
 len = p\_conn->RxBufLenRem;
 if (len <= sizeof(HTTP\_STR\_METHOD\_GET)) { // Check minimum length of RxBuf. \*p\_err = HTTPs\_ERR\_REQ\_FORMAT\_INVALID; return; } // Move the start ptr to the first meaningful char. p\_request\_method\_start = HTTP\_StrGraphSrchFirst(p\_conn->RxBufPtr, len); if (p\_request\_method\_start == DEF\_NULL) { \*p\_err = HTTPs\_ERR\_REQ\_FORMAT\_INVALID; return; } len -= p\_request\_method\_start - p\_conn->RxBufPtr; // Find the end of method string. p\_request\_method\_end = Str\_Char\_N(p\_request\_method\_start, len, ASCII\_CHAR\_SPACE); if (p\_request\_method\_end == DEF\_NULL) { \*p\_err = HTTPs\_ERR\_REQ\_FORMAT\_INVALID; return; } len = p\_request\_method\_end - p\_request\_method\_start; // Try to match the Method str received. method = HTTP\_Dict\_KeyGet(HTTP\_Dict\_ReqMethod, HTTP\_Dict\_ReqMethodSize, p\_request\_method\_start, DEF\_YES, len); // Validate the DictionaryKey search results if (method == HTTP\_DICT\_KEY\_INVALID) { p\_conn->Method = HTTP\_METHOD\_UNKNOWN; } else { p\_conn->Method = (HTTP\_METHOD)method; }
 switch (p\_conn->Method) { case HTTP\_METHOD\_GET: LOG\_VRB(("HTTPs - SockID: ", (u)p\_conn->SockID, " - Method = GET")); p\_conn->RespBodyDataType = HTTPs\_BODY\_DATA\_TYPE\_FILE; HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatMethodGetRxdCtr); break;
 case HTTP\_METHOD\_HEAD: LOG\_VRB(("HTTPs - SockID: ", (u)p\_conn->SockID, " - Method = HEAD")); p\_conn->RespBodyDataType = HTTPs\_BODY\_DATA\_TYPE\_FILE; HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatMethodHeadRxdCtr); break;
 case HTTP\_METHOD\_POST: LOG\_VRB(("HTTPs - SockID: ", (u)p\_conn->SockID, " - Method = POST")); p\_conn->RespBodyDataType = HTTPs\_BODY\_DATA\_TYPE\_NONE; HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatMethodPostRxdCtr); break;
 case HTTP\_METHOD\_DELETE: LOG\_VRB(("HTTPs - SockID: ", (u)p\_conn->SockID, " - Method = DELETE")); p\_conn->RespBodyDataType = HTTPs\_BODY\_DATA\_TYPE\_NONE; HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatMethodDeleteRxdCtr); break;
 case HTTP\_METHOD\_PUT: LOG\_VRB(("HTTPs - SockID: ", (u)p\_conn->SockID, " - Method = PUT")); p\_conn->RespBodyDataType = HTTPs\_BODY\_DATA\_TYPE\_NONE; HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatMethodPutRxdCtr); break;
 case HTTP\_METHOD\_TRACE: case HTTP\_METHOD\_CONNECT: case HTTP\_METHOD\_UNKNOWN: default: LOG\_VRB(("HTTPs - SockID: ", (u)p\_conn->SockID, " - Method = Unsupported")); HTTPs\_STATS\_INC(p\_ctr\_stats->Req\_StatMethodUnsupportedRxdCtr); \*p\_err = HTTPs\_ERR\_REQ\_METHOD\_NOT\_SUPPORTED; return; } // Update the RxBuf ptr. p\_conn->RxBufLenRem -= len; p\_conn->RxBufPtr = p\_request\_method\_end;
 \*p\_err = HTTPs\_ERR\_NONE;}
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\*\* \* HTTPsReq\_URI\_Parse() \* \* @brief Parse request URI and check for potential query string. \* \* @param p\_instance Pointer to the instance. \* \* @param ---------- Argument validated in HTTPs\_InstanceStart(). \* \* @param p\_conn Pointer to the connection. \* \* @param ----- Argument validated in HTTPs\_InstanceStart(). \* \* @param p\_err Pointer to variable that will receive the return error code from this function. \* \* @return DEF\_YES, if potential query string is found. \* DEF\_NO, if NO potential query string is found. \* \* @note (1) The Request-URI is a Uniform Resource Identifier (section 3.2) and identifies the resource \* upon which to apply the request. \* \* Request-URI = "\*" | absoluteURI | abs\_path | authority \* \* - (a) The asterisk "\*" means that the request does not apply to a particular resource, but to \* the server itself, and is only allowed when the method used does not necessarily apply \* to a resource. One example would be \* \* OPTIONS \* HTTP/1.1 \* \* - (b) The absoluteURI form is REQUIRED when the request is being made to a proxy. The proxy is \* requested to forward the request or service it from a valid cache, and return the response. \* Note that the proxy MAY forward the request on to another proxy or directly to the server \* specified by the absoluteURI. In order to avoid request loops, a proxy MUST be able to \* recognize all of its server names, including any aliases, local variations, and the numeric \* IP address. An example Request-Line would be: \* \* GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1 \* \* To allow for transition to absoluteURIs in all requests in future versions of HTTP, all \* HTTP/1.1 servers MUST accept the absoluteURI form in requests, even though HTTP/1.1 clients \* will only generate them in requests to proxies. \* \* - (c) The authority form is only used by the CONNECT method (section 9.9). \* \* - (d) The most common form of Request-URI is that used to identify a resource on an origin server or \* gateway. In this case the absolute path of the URI MUST be transmitted (see section 3.2.1, \* abs\_path) as the Request-URI, and the network location of the URI (authority) MUST be transmitted \* in a Host header field. For example, a client wishing to retrieve the resource above directly \* from the origin server would create a TCP connection to port 80 of the host "www.w3.org" and send \* the lines: \* \* GET /pub/WWW/TheProject.html HTTP/1.1 \* Host: www.w3.org \* \* followed by the remainder of the Request. Note that the absolute path cannot be empty; if none \* is present in the original URI, it MUST be given as "/" (the server root). \* \* - (e) The Request-URI is transmitted in the format specified in section 3.2.1. If the Request-URI is \* encoded using the "% HEX HEX" encoding [42], the origin server MUST decode the Request-URI in \* order to properly interpret the request. Servers SHOULD respond to invalid Request-URIs with an \* appropriate status code. \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/static CPU\_BOOLEAN HTTPsReq\_URI\_Parse(HTTPs\_INSTANCE \*p\_instance, HTTPs\_CONN \*p\_conn, HTTPs\_ERR \*p\_err){ const HTTPs\_CFG \*p\_cfg = p\_instance->CfgPtr;; CPU\_CHAR \*p\_request\_uri\_start = DEF\_NULL; CPU\_CHAR \*p\_request\_uri\_end = DEF\_NULL; CPU\_CHAR \*p\_request\_uri\_separator = DEF\_NULL; CPU\_CHAR \*p\_str = DEF\_NULL; CPU\_INT32U len = p\_conn->RxBufLenRem;; CPU\_SIZE\_T len\_decoded = 0u; CPU\_BOOLEAN is\_query\_found = DEF\_NO;
 // Move the start ptr to the first meaningful char. p\_request\_uri\_start = HTTP\_StrGraphSrchFirst(p\_conn->RxBufPtr, len); if (p\_request\_uri\_start == DEF\_NULL) { \*p\_err = HTTPs\_ERR\_REQ\_FORMAT\_INVALID; return (is\_query\_found); } // Find the end of the URI including the potential... // ...query str. len -= p\_request\_uri\_start - p\_conn->RxBufPtr; p\_request\_uri\_end = Str\_Char\_N(p\_request\_uri\_start, len, ASCII\_CHAR\_SPACE); if (p\_request\_uri\_end != DEF\_NULL) { len = p\_request\_uri\_end - p\_request\_uri\_start; // Recalculate the len to narrow the search. } // Try to find a '?' for query string. p\_request\_uri\_separator = Str\_Char\_N(p\_request\_uri\_start, len, ASCII\_CHAR\_QUESTION\_MARK); if (p\_request\_uri\_separator == DEF\_NULL) { // If no query string or a full URI is found... if (p\_request\_uri\_end == DEF\_NULL) { if (p\_conn->RxBufPtr != p\_conn->BufPtr) { // ...and if the buffer is not full... // ... get more data. \*p\_err = HTTPs\_ERR\_REQ\_MORE\_DATA\_REQUIRED; } else { // ... but if the buffer is full, generate an error. \*p\_err = HTTPs\_ERR\_REQ\_FORMAT\_INVALID; } return (is\_query\_found); } } else { is\_query\_found = DEF\_YES; len = p\_request\_uri\_separator - p\_request\_uri\_start; }
 if (len > p\_conn->PathLenMax) { // If unable to store req'd URI. \*p\_err = HTTPs\_ERR\_REQ\_URI\_LEN; // Resp with internal err page. return (is\_query\_found); }
 p\_request\_uri\_start[len] = ASCII\_CHAR\_NULL; // Replace the char at the end of the URI by NULL.
 if (len > 1) { // Req'd URI is not the default. // Copy req'd URI. len\_decoded = len;
 HTTP\_URL\_DecodeStr(p\_request\_uri\_start, p\_conn->PathPtr, &len\_decoded);
 p\_conn->PathPtr[len\_decoded] = ASCII\_CHAR\_NULL;

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from community.silabs.com_bcf2b426_20250114_205253.html ===



