=== Content from github.com_ca0c16e9_20250115_083426.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Feclipse-threadx%2Fusbx%2Fblob%2Fmaster%2Fcommon%2Fusbx_device_classes%2Fsrc%2Fux_device_class_dfu_control_request.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Feclipse-threadx%2Fusbx%2Fblob%2Fmaster%2Fcommon%2Fusbx_device_classes%2Fsrc%2Fux_device_class_dfu_control_request.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=eclipse-threadx%2Fusbx)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[eclipse-threadx](/eclipse-threadx)
/
**[usbx](/eclipse-threadx/usbx)**
Public

* [Notifications](/login?return_to=%2Feclipse-threadx%2Fusbx) You must be signed in to change notification settings
* [Fork
  95](/login?return_to=%2Feclipse-threadx%2Fusbx)
* [Star
   165](/login?return_to=%2Feclipse-threadx%2Fusbx)

* [Code](/eclipse-threadx/usbx)
* [Issues
  51](/eclipse-threadx/usbx/issues)
* [Pull requests
  6](/eclipse-threadx/usbx/pulls)
* [Discussions](/eclipse-threadx/usbx/discussions)
* [Actions](/eclipse-threadx/usbx/actions)
* [Security](/eclipse-threadx/usbx/security)
* [Insights](/eclipse-threadx/usbx/pulse)

Additional navigation options

* [Code](/eclipse-threadx/usbx)
* [Issues](/eclipse-threadx/usbx/issues)
* [Pull requests](/eclipse-threadx/usbx/pulls)
* [Discussions](/eclipse-threadx/usbx/discussions)
* [Actions](/eclipse-threadx/usbx/actions)
* [Security](/eclipse-threadx/usbx/security)
* [Insights](/eclipse-threadx/usbx/pulse)

## Files

 master
## Breadcrumbs

1. [usbx](/eclipse-threadx/usbx/tree/master)
2. /[common](/eclipse-threadx/usbx/tree/master/common)
3. /[usbx\_device\_classes](/eclipse-threadx/usbx/tree/master/common/usbx_device_classes)
4. /[src](/eclipse-threadx/usbx/tree/master/common/usbx_device_classes/src)
/
# ux\_device\_class\_dfu\_control\_request.c

Copy path Blame  Blame
## Latest commit

## History

[History](/eclipse-threadx/usbx/commits/master/common/usbx_device_classes/src/ux_device_class_dfu_control_request.c)1006 lines (729 loc) · 50.7 KB master
## Breadcrumbs

1. [usbx](/eclipse-threadx/usbx/tree/master)
2. /[common](/eclipse-threadx/usbx/tree/master/common)
3. /[usbx\_device\_classes](/eclipse-threadx/usbx/tree/master/common/usbx_device_classes)
4. /[src](/eclipse-threadx/usbx/tree/master/common/usbx_device_classes/src)
/
# ux\_device\_class\_dfu\_control\_request.c

Top
## File metadata and controls

* Code
* Blame

1006 lines (729 loc) · 50.7 KB[Raw](https://github.com/eclipse-threadx/usbx/raw/refs/heads/master/common/usbx_device_classes/src/ux_device_class_dfu_control_request.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \* Copyright (c) 2024 Microsoft Corporation  \*  \* This program and the accompanying materials are made available under the \* terms of the MIT License which is available at \* https://opensource.org/licenses/MIT. \*  \* SPDX-License-Identifier: MIT \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\*\* \*//\*\* USBX Component \*//\*\* \*//\*\* Device DFU Class \*//\*\* \*//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/
#define UX\_SOURCE\_CODE
/\* Include necessary system files. \*/
#include "ux\_api.h"#include "ux\_device\_class\_dfu.h"#include "ux\_device\_stack.h"
#if UX\_DEVICE\_CLASS\_DFU\_STATUS\_MODE == 1static inline VOID \_ux\_device\_class\_dfu\_status\_get(UX\_SLAVE\_CLASS\_DFU \*, UX\_SLAVE\_TRANSFER \*, UCHAR, UCHAR, UCHAR, UCHAR);#endif
/\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*//\* \*//\* FUNCTION RELEASE \*//\* \*//\* \_ux\_device\_class\_dfu\_control\_request PORTABLE C \*//\* 6.1.12 \*//\* AUTHOR \*//\* \*//\* Chaoqiong Xiao, Microsoft Corporation \*//\* \*//\* DESCRIPTION \*//\* \*//\* This function manages the based sent by the host on the control \*//\* endpoints with a CLASS or VENDOR SPECIFIC type. \*//\* \*//\* INPUT \*//\* \*//\* dfu Pointer to dfu class \*//\* \*//\* OUTPUT \*//\* \*//\* None \*//\* \*//\* CALLS \*//\* \*//\* \_ux\_device\_stack\_endpoint\_stall Endpoint stall \*//\* \_ux\_device\_stack\_transfer\_request Transfer request \*//\* \*//\* CALLED BY \*//\* \*//\* DFU Class \*//\* \*//\* RELEASE HISTORY \*//\* \*//\* DATE NAME DESCRIPTION \*//\* \*//\* 05-19-2020 Chaoqiong Xiao Initial Version 6.0 \*//\* 09-30-2020 Chaoqiong Xiao Modified comment(s), \*//\* used UX prefix to refer to \*//\* TX symbols instead of using \*//\* them directly, \*//\* resulting in version 6.1 \*//\* 04-02-2021 Chaoqiong Xiao Modified comment(s), \*//\* added DFU\_UPLOAD support, \*//\* removed block count (it's \*//\* from host request wValue), \*//\* resulting in version 6.1.6 \*//\* 10-15-2021 Chaoqiong Xiao Modified comment(s), \*//\* fixed compile warning, \*//\* resulting in version 6.1.9 \*//\* 01-31-2022 Chaoqiong Xiao Modified comment(s), \*//\* added UPLOAD length check, \*//\* added standalone support, \*//\* resulting in version 6.1.10 \*//\* 04-25-2022 Chaoqiong Xiao Modified comment(s), \*//\* checked r/w callback status,\*//\* resulting in version 6.1.11 \*//\* 07-29-2022 Chaoqiong Xiao Modified comment(s), \*//\* fixed parameter/variable \*//\* names conflict C++ keyword, \*//\* added UPLOAD length check \*//\* in \_UPLOAD\_IDLE state, \*//\* added DNLOAD REQ \*//\* validation, \*//\* resulting in version 6.1.12 \*//\* \*//\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/UINT \_ux\_device\_class\_dfu\_control\_request(UX\_SLAVE\_CLASS\_COMMAND \*command){
UX\_SLAVE\_TRANSFER \*transfer\_request;UX\_SLAVE\_DEVICE \*device;UX\_SLAVE\_CLASS \*class\_ptr;UX\_SLAVE\_CLASS\_DFU \*dfu;
ULONG request;ULONG request\_type;ULONG request\_value;ULONG request\_length;ULONG actual\_length;UINT status;#if defined(UX\_DEVICE\_CLASS\_DFU\_CUSTOM\_REQUEST\_ENABLE) || (UX\_DEVICE\_CLASS\_DFU\_STATUS\_MODE != 1)ULONG media\_status;#endif
 /\* Get the pointer to the device. \*/ device = &\_ux\_system\_slave -> ux\_system\_slave\_device;
 /\* Get the class container. \*/ class\_ptr = command -> ux\_slave\_class\_command\_class\_ptr;
 /\* Get the storage instance from this class container. \*/ dfu = (UX\_SLAVE\_CLASS\_DFU \*) class\_ptr -> ux\_slave\_class\_instance;
 /\* Get the pointer to the transfer request associated with the control endpoint. \*/ transfer\_request = &device -> ux\_slave\_device\_control\_endpoint.ux\_slave\_endpoint\_transfer\_request;
#ifdef UX\_DEVICE\_CLASS\_DFU\_CUSTOM\_REQUEST\_ENABLE if (dfu -> ux\_device\_class\_dfu\_custom\_request) {
 /\* The status simply tells us if the registered callback handled the request - if there was an issue processing the request, it would've stalled the control endpoint, notifying the host (and not us). \*/ media\_status = dfu -> ux\_device\_class\_dfu\_custom\_request(dfu, transfer\_request);
 /\* Custom request handled. \*/ if (media\_status == UX\_SUCCESS) return(media\_status);
 /\* Try to handle with standard handler. \*/ }#endif
 /\* Extract all necessary fields of the request. \*/ request = \*(transfer\_request -> ux\_slave\_transfer\_request\_setup + UX\_SETUP\_REQUEST); request\_type = \*(transfer\_request -> ux\_slave\_transfer\_request\_setup + UX\_SETUP\_REQUEST\_TYPE);
 /\* Pickup the request wValue. \*/ request\_value = \_ux\_utility\_short\_get(transfer\_request -> ux\_slave\_transfer\_request\_setup + UX\_SETUP\_VALUE);
 /\* Pickup the request wLength. \*/ request\_length = \_ux\_utility\_short\_get(transfer\_request -> ux\_slave\_transfer\_request\_setup + UX\_SETUP\_LENGTH);
 /\* What state are we in ? \*/ switch (\_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine) {
 case UX\_SYSTEM\_DFU\_STATE\_APP\_IDLE :
 /\* Here we process only the request we can accept in the APP IDLE state. \*/ switch (request) {
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_DETACH :
 /\* The host is asking for a Detach and switch to the DFU mode. Either we force the reset here or we wait for a specified timer. If there is no reset while this timer is running we abandon the DFU Detach.\*/ if (\_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_capabilities & UX\_SLAVE\_CLASS\_DFU\_CAPABILITY\_WILL\_DETACH) {
 /\* Wake up the DFU thread and send a detach request.. \*/ \_ux\_device\_class\_dfu\_event\_flags\_set(dfu, UX\_DEVICE\_CLASS\_DFU\_THREAD\_EVENT\_DISCONNECT); } else {
 /\* We expect the host to issue a reset. Arm a timer in the DFU thread. \*/ \_ux\_device\_class\_dfu\_event\_flags\_set(dfu, UX\_DEVICE\_CLASS\_DFU\_THREAD\_EVENT\_WAIT\_RESET); }
 /\* We can switch dfu state machine. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_APP\_DETACH;
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATUS :
#if UX\_DEVICE\_CLASS\_DFU\_STATUS\_MODE == 1 \_ux\_device\_class\_dfu\_status\_get(dfu, transfer\_request, UX\_FALSE, 0, 0, 0);#else /\* Fill the status data payload. First with status. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) dfu -> ux\_slave\_class\_dfu\_status;
 /\* Poll time out value is set to 1ms. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT) = UX\_DW0(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 1) = UX\_DW1(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 2) = UX\_DW2(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT);
 /\* Next state. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STATE) = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* String index set to 0. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STRING) = 0;#endif
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH);
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATE :
 /\* Fill the status data payload. First with state. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH);
 break;
 default:
 /\* Unknown function. Stall the endpoint. \*/ \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint); break; }
 break;
 case UX\_SYSTEM\_DFU\_STATE\_APP\_DETACH :
 /\* Here we process only the request we can accept in the APP DETACH state. \*/ switch (request) {
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATUS :
#if UX\_DEVICE\_CLASS\_DFU\_STATUS\_MODE == 1 \_ux\_device\_class\_dfu\_status\_get(dfu, transfer\_request, UX\_FALSE, 0, 0, 0);#else
 /\* Fill the status data payload. First with status. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) dfu -> ux\_slave\_class\_dfu\_status;
 /\* Poll time out value is set to 1ms. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT) = UX\_DW0(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 1) = UX\_DW1(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 2) = UX\_DW2(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT);
 /\* Next state. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STATE) = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* String index set to 0. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STRING) = 0;#endif
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH);
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATE :
 /\* Fill the status data payload. First with state. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH);
 break;
 default:
 /\* Unknown function. Stall the endpoint. \*/ \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint); break; }
 break;
 case UX\_SYSTEM\_DFU\_STATE\_DFU\_IDLE :
 /\* Here we process only the request we can accept in the DFU mode IDLE state. \*/ switch (request) {
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_DOWNLOAD :
 /\* Command verify: check bmRequestType and data length. \*/ if ((request\_type != UX\_DEVICE\_CLASS\_DFU\_REQTYPE\_INTERFACE\_SET) || (request\_length != transfer\_request -> ux\_slave\_transfer\_request\_actual\_length)) {
 /\* Zero length download is not accepted. Stall the endpoint. \*/ \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint);
 /\* In the system, state the DFU state machine to dfu ERROR. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR; }
 /\* We received a DOWNLOAD command. Check the length field of the request. It cannot be 0. \*/ else if (request\_length == 0) {
 /\* Zero length download is not accepted. Stall the endpoint. \*/ \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint);
 /\* In the system, state the DFU state machine to dfu ERROR. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR;
 } else {
 /\* Have we declared a DOWNLOAD possible in our device framework ? \*/ if (\_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_capabilities & UX\_SLAVE\_CLASS\_DFU\_CAPABILITY\_CAN\_DOWNLOAD) {
 /\* Send a notification to the application. Begin of transfer. \*/ dfu -> ux\_slave\_class\_dfu\_notify(dfu, UX\_SLAVE\_CLASS\_DFU\_NOTIFICATION\_BEGIN\_DOWNLOAD);
 /\* Write the first block to the firmware. \*/ status = dfu -> ux\_slave\_class\_dfu\_write(dfu, request\_value, transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer, request\_length, &actual\_length);
 /\* Application can actively reject and set error state. \*/ if (status != UX\_SUCCESS) { \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint); \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR; break; }
 /\* In the system, state the DFU state machine to dfu DOWNLOAD SYNC. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_DNLOAD\_SYNC;
 } else {
 /\* Download is not accepted. Stall the endpoint. \*/ \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint);
 /\* In the system, state the DFU state machine to dfu ERROR. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR;
 }
 } break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_ABORT :
 /\* Send a notification to the application. \*/ dfu -> ux\_slave\_class\_dfu\_notify(dfu, UX\_SLAVE\_CLASS\_DFU\_NOTIFICATION\_ABORT\_DOWNLOAD);
 /\* In the system, state the DFU state machine to dfu IDLE. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_IDLE;
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATUS :
#if UX\_DEVICE\_CLASS\_DFU\_STATUS\_MODE == 1 \_ux\_device\_class\_dfu\_status\_get(dfu, transfer\_request, UX\_FALSE, 0, 0, 0);#else
 /\* Fill the status data payload. First with status. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) dfu -> ux\_slave\_class\_dfu\_status;
 /\* Poll time out value is set to 1ms. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT) = UX\_DW0(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 1) = UX\_DW1(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 2) = UX\_DW2(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT);
 /\* Next state. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STATE) = (UCHAR) UX\_SYSTEM\_DFU\_STATE\_DFU\_IDLE;
 /\* String index set to 0. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STRING) = 0;#endif
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH);
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATE :
 /\* Fill the status data payload. First with state. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH);
 break;
#ifndef UX\_DEVICE\_CLASS\_DFU\_UPLOAD\_DISABLE case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_UPLOAD:
 /\* bitCanUpload != 1, or length = 0, or length > wTransferSize (we can support max of control buffer size). \*/ if (!(\_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_capabilities & UX\_SLAVE\_CLASS\_DFU\_CAPABILITY\_CAN\_UPLOAD) || (request\_length == 0) || (request\_length > UX\_SLAVE\_REQUEST\_CONTROL\_MAX\_LENGTH)) { \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint);
 /\* In the system, state the DFU state machine to dfu ERROR. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR;
 break; }
 /\* bitCanUpload = 1. \*/
 /\* Send a notification to the application. Begin of transfer. \*/ dfu -> ux\_slave\_class\_dfu\_notify(dfu, UX\_SLAVE\_CLASS\_DFU\_NOTIFICATION\_BEGIN\_UPLOAD);
 /\* Read the first block to the firmware. \*/ status = dfu -> ux\_slave\_class\_dfu\_read(dfu, request\_value, transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer, request\_length, &actual\_length);
 /\* Application can actively reject and set error state. \*/ if (status != UX\_SUCCESS) { \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint); \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR; break; }
 /\* In the system, state the DFU state machine to dfu UPLOAD IDLE. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_UPLOAD\_IDLE;
 /\* We have a request to upload DFU firmware block. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, actual\_length, request\_length);
 break;#endif
 default:
 /\* Unknown function. Stall the endpoint. \*/ \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint);
 /\* In the system, state the DFU state machine to dfu ERROR. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR;
 break; }
 break;
 case UX\_SYSTEM\_DFU\_STATE\_DFU\_DNLOAD\_SYNC :
 /\* Here we process only the request we can accept in the DFU mode DOWNLOAD state. \*/ switch (request) {
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATUS :
#if UX\_DEVICE\_CLASS\_DFU\_STATUS\_MODE == 1 \_ux\_device\_class\_dfu\_status\_get(dfu, transfer\_request, UX\_TRUE, UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_DNLOAD\_IDLE, UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_DNBUSY, UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_ERROR);#else
 /\* Check if the device is still buys performing the write. Write could be delayed. \*/ dfu -> ux\_slave\_class\_dfu\_get\_status(dfu, &media\_status);
 /\* Check status of device. \*/ switch (media\_status) {
 case UX\_SLAVE\_CLASS\_DFU\_MEDIA\_STATUS\_OK :
 /\* Set the next state for idle and no error status. \*/ dfu -> ux\_slave\_class\_dfu\_status = UX\_SLAVE\_CLASS\_DFU\_STATUS\_OK ; \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_DNLOAD\_IDLE; break;
 case UX\_SLAVE\_CLASS\_DFU\_MEDIA\_STATUS\_BUSY :
 /\* Set the next state for busy but no error status. \*/ dfu -> ux\_slave\_class\_dfu\_status = UX\_SLAVE\_CLASS\_DFU\_STATUS\_OK ; \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_DNBUSY; break;
 case UX\_SLAVE\_CLASS\_DFU\_MEDIA\_STATUS\_ERROR :
 /\* Set the next state for busy and error status. \*/ dfu -> ux\_slave\_class\_dfu\_status = UX\_SLAVE\_CLASS\_DFU\_STATUS\_ERROR\_WRITE ; \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_ERROR; break;
 }
 /\* Fill the status data payload. First with status. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) dfu -> ux\_slave\_class\_dfu\_status;
 /\* Poll time out value is set to 1ms. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT) = UX\_DW0(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 1) = UX\_DW1(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 2) = UX\_DW2(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT);
 /\* Next state. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STATE) = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* String index set to 0. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STRING) = 0;#endif
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH);
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATE :
 /\* Fill the status data payload. First with state. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH);
 break;
 default:
 /\* Unknown function. Stall the endpoint. \*/ \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint);
 /\* In the system, state the DFU state machine to dfu ERROR. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR;
 break; }
 break;
 case UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_DNLOAD\_IDLE :
 /\* Here we process only the request we can accept in the DFU mode DNLOAD state. \*/ switch (request) {
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_DOWNLOAD :
 /\* Command verify: check bmRequestType and data length. \*/ if ((request\_type != UX\_DEVICE\_CLASS\_DFU\_REQTYPE\_INTERFACE\_SET) || (request\_length != transfer\_request -> ux\_slave\_transfer\_request\_actual\_length)) {
 /\* Zero length download is not accepted. Stall the endpoint. \*/ \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint);
 /\* In the system, state the DFU state machine to dfu ERROR. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR; }
 /\* We received a DOWNLOAD command. Check the length field of the request. If it is 0, we are done with the transfer. \*/ else if (request\_length == 0) {
 /\* Send the notification of end of download to application. \*/ dfu -> ux\_slave\_class\_dfu\_notify(dfu, UX\_SLAVE\_CLASS\_DFU\_NOTIFICATION\_END\_DOWNLOAD);
 /\* In the system, state the DFU state machine to DFU MANIFEST SYNCH. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_MANIFEST\_SYNC;
 }
 else {
 /\* Write the next block to the firmware. \*/ status = dfu -> ux\_slave\_class\_dfu\_write(dfu, request\_value, transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer, request\_length, &actual\_length);
 /\* Application can actively reject and set error state. \*/ if (status != UX\_SUCCESS) { \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint); \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR; break; }
 /\* In the system, state the DFU state machine to dfu DOWNLOAD SYNC. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_DNLOAD\_SYNC; }
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_ABORT :
 /\* Send a notification to the application. \*/ dfu -> ux\_slave\_class\_dfu\_notify(dfu, UX\_SLAVE\_CLASS\_DFU\_NOTIFICATION\_ABORT\_DOWNLOAD);
 /\* In the system, state the DFU state machine to dfu IDLE. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_IDLE;
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATUS :
#if UX\_DEVICE\_CLASS\_DFU\_STATUS\_MODE == 1 \_ux\_device\_class\_dfu\_status\_get(dfu, transfer\_request, UX\_FALSE, 0, 0, 0);#else
 /\* Fill the status data payload. First with status. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) dfu -> ux\_slave\_class\_dfu\_status;
 /\* Poll time out value is set to 1ms. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT) = UX\_DW0(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 1) = UX\_DW1(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 2) = UX\_DW2(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT);
 /\* Next state. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STATE) = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* String index set to 0. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STRING) = 0;#endif
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH);
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATE :
 /\* Fill the status data payload. First with state. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH);
 break;
 default:
 /\* Unknown function. Stall the endpoint. \*/ \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint);
 /\* In the system, state the DFU state machine to dfu ERROR. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR;
 break; }
 break;
 case UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_MANIFEST\_SYNC :
 /\* Here we process only the request we can accept in the MANIFEST SYNCH state. \*/ switch (request) {
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATUS :
#if UX\_DEVICE\_CLASS\_DFU\_STATUS\_MODE == 1 \_ux\_device\_class\_dfu\_status\_get(dfu, transfer\_request, UX\_TRUE, UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_MANIFEST\_WAIT\_RESET, UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_MANIFEST, UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_ERROR); if ((\_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine == UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_MANIFEST\_WAIT\_RESET) && (\_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_capabilities & UX\_SLAVE\_CLASS\_DFU\_CAPABILITY\_WILL\_DETACH)) {
 /\* Wake up the DFU thread and send a detach request.. \*/ \_ux\_device\_class\_dfu\_event\_flags\_set(dfu, UX\_DEVICE\_CLASS\_DFU\_THREAD\_EVENT\_DISCONNECT); }#else
 /\* Check if the device is still buys performing the write. Write could be delayed. \*/ dfu -> ux\_slave\_class\_dfu\_get\_status(dfu, &media\_status);
 /\* Check status of device. \*/ switch (media\_status) {
 case UX\_SLAVE\_CLASS\_DFU\_MEDIA\_STATUS\_OK :
 /\* Set the next state for wait reset and no error status. \*/ dfu -> ux\_slave\_class\_dfu\_status = UX\_SLAVE\_CLASS\_DFU\_STATUS\_OK ; \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_MANIFEST\_WAIT\_RESET;
 /\* Check who is responsible for the RESET. \*/ if (\_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_capabilities & UX\_SLAVE\_CLASS\_DFU\_CAPABILITY\_WILL\_DETACH) {
 /\* Wake up the DFU thread and send a detach request.. \*/ \_ux\_device\_class\_dfu\_event\_flags\_set(dfu, UX\_DEVICE\_CLASS\_DFU\_THREAD\_EVENT\_DISCONNECT);
 }
 break;
 case UX\_SLAVE\_CLASS\_DFU\_MEDIA\_STATUS\_BUSY :
 /\* Set the next state for busy but no error status. \*/ dfu -> ux\_slave\_class\_dfu\_status = UX\_SLAVE\_CLASS\_DFU\_STATUS\_OK ; \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_MANIFEST; break;
 case UX\_SLAVE\_CLASS\_DFU\_MEDIA\_STATUS\_ERROR :
 /\* Set the next state for busy and error status. \*/ dfu -> ux\_slave\_class\_dfu\_status = UX\_SLAVE\_CLASS\_DFU\_STATUS\_ERROR\_WRITE ; \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_ERROR; break; }
 /\* Fill the status data payload. First with status. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) dfu -> ux\_slave\_class\_dfu\_status;
 /\* Poll time out value is set to 1ms. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT) = UX\_DW0(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 1) = UX\_DW1(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 2) = UX\_DW2(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT);
 /\* Next state. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STATE) = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* String index set to 0. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STRING) = 0;#endif
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH);
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATE :
 /\* Fill the status data payload. First with state. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH);
 break;
 default:
 /\* Unknown function. Stall the endpoint. \*/ \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint); break; }
 break;
 case UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_ERROR :
 /\* Here we process only the request we can accept in the ERROR state. \*/ switch (request) {
#ifdef UX\_DEVICE\_CLASS\_DFU\_ERROR\_GET\_ENABLE case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATUS :
 /\* Fill the status data payload. First with status. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) dfu -> ux\_slave\_class\_dfu\_status;
 /\* Poll time out value is set to 1ms. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT) = 1; \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 1) = 0; \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 2) = 0;
 /\* Next state. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STATE) = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* String index set to 0. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STRING) = 0;
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH);
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATE :
 /\* Fill the status data payload. First with state. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH);
 break;#endif
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_CLEAR\_STATUS :
 /\* In the system, state the DFU state machine to dfu IDLE. \*/ dfu -> ux\_slave\_class\_dfu\_status = UX\_SLAVE\_CLASS\_DFU\_MEDIA\_STATUS\_OK; \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_IDLE;
 break;
 default:
 /\* Unknown function. Stall the endpoint. \*/ \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint); break;
 }
 break;
#ifndef UX\_DEVICE\_CLASS\_DFU\_UPLOAD\_DISABLE case UX\_SLAVE\_CLASS\_DFU\_STATUS\_STATE\_DFU\_UPLOAD\_IDLE: /\* bitCanUpload == 1. \*/
 /\* Here we process only the request we can accept in the DFU mode UPLOAD IDLE state. \*/ switch (request) {
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_UPLOAD:
 /\* Check if length > wTransferSize (we can support max of control buffer size). \*/ if (request\_length > UX\_SLAVE\_REQUEST\_CONTROL\_MAX\_LENGTH) { \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint); \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR; break; }
 /\* Length 0 case undefined, just keep state. \*/ if (request\_length == 0) break;
 /\* We received a UPLOAD command with length > 0. \*/
 /\* Read the next block from the firmware. \*/ status = dfu -> ux\_slave\_class\_dfu\_read(dfu, request\_value, transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer, request\_length, &actual\_length);
 /\* Application can actively reject and set error state. \*/ if (status != UX\_SUCCESS) { \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint); \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR; break; }
 /\* If it's short frame, switch to dfu IDLE. \*/ if (actual\_length < request\_length) {
 /\* Send a notification to the application. \*/ dfu -> ux\_slave\_class\_dfu\_notify(dfu, UX\_SLAVE\_CLASS\_DFU\_NOTIFICATION\_END\_UPLOAD);
 /\* In the system, state the DFU state machine to dfu IDLE. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_IDLE; }
 /\* We have a request to upload DFU firmware block. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, actual\_length, request\_length);
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_ABORT :
 /\* Send a notification to the application. \*/ dfu -> ux\_slave\_class\_dfu\_notify(dfu, UX\_SLAVE\_CLASS\_DFU\_NOTIFICATION\_ABORT\_UPLOAD);
 /\* In the system, state the DFU state machine to dfu IDLE. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_IDLE;
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATUS :
#if UX\_DEVICE\_CLASS\_DFU\_STATUS\_MODE == 1 \_ux\_device\_class\_dfu\_status\_get(dfu, transfer\_request, UX\_FALSE, 0, 0, 0);#else
 /\* Fill the status data payload. First with status. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) dfu -> ux\_slave\_class\_dfu\_status;
 /\* Poll time out value is set to 1ms. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT) = UX\_DW0(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 1) = UX\_DW1(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT); \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 2) = UX\_DW2(UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT);
 /\* Next state. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STATE) = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* String index set to 0. \*/ \*(transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_STRING) = 0;#endif
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_LENGTH);
 break;
 case UX\_SLAVE\_CLASS\_DFU\_COMMAND\_GET\_STATE :
 /\* Fill the status data payload. First with state. \*/ \*transfer\_request -> ux\_slave\_transfer\_request\_data\_pointer = (UCHAR) \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine;
 /\* We have a request to obtain the status of the DFU instance. \*/ \_ux\_device\_stack\_transfer\_request(transfer\_request, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH, UX\_SLAVE\_CLASS\_DFU\_GET\_STATE\_LENGTH);
 break;
 default:
 /\* Unknown function. Stall the endpoint. \*/ \_ux\_device\_stack\_endpoint\_stall(&device -> ux\_slave\_device\_control\_endpoint);
 /\* In the system, state the DFU state machine to dfu ERROR. \*/ \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = UX\_SYSTEM\_DFU\_STATE\_DFU\_ERROR;
 break; }
 break;#endif
 default:
 /\* Unknown state. Should not happen. \*/ return(UX\_ERROR); }
 return(UX\_SUCCESS);}
#if UX\_DEVICE\_CLASS\_DFU\_STATUS\_MODE == 1static inline VOID \_ux\_device\_class\_dfu\_status\_get(UX\_SLAVE\_CLASS\_DFU \*dfu, UX\_SLAVE\_TRANSFER \*transfer, UCHAR move\_state, UCHAR state\_ok, UCHAR state\_busy, UCHAR state\_error){ULONG media\_status = ((UX\_SLAVE\_CLASS\_DFU\_MEDIA\_STATUS\_OK) | (UX\_SLAVE\_CLASS\_DFU\_STATUS\_OK << 4) | (UX\_DEVICE\_CLASS\_DFU\_STATUS\_POLLTIMEOUT << 8));UCHAR \*buffer = transfer -> ux\_slave\_transfer\_request\_data\_pointer;ULONG dfu\_status, dfu\_polltimeout;
 /\* Get status from application. \*/ dfu -> ux\_slave\_class\_dfu\_get\_status(dfu, &media\_status);
 /\* Extract bStatus and bwPollTimeout. \*/ dfu\_status = (media\_status >> 4) & 0xFu; dfu\_polltimeout = (media\_status >> 8) & 0xFFFFFFu; dfu -> ux\_slave\_class\_dfu\_status = dfu\_status;
 /\* Move state based on returned status. \*/ if (move\_state) {
 /\* OK/BUSY/ERROR ? \*/ switch((media\_status & 0xF)) { case UX\_SLAVE\_CLASS\_DFU\_MEDIA\_STATUS\_OK: \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = state\_ok; break; case UX\_SLAVE\_CLASS\_DFU\_MEDIA\_STATUS\_BUSY: \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = state\_busy; break; case UX\_SLAVE\_CLASS\_DFU\_MEDIA\_STATUS\_ERROR: default: \_ux\_system\_slave -> ux\_system\_slave\_device\_dfu\_state\_machine = state\_error; break; } }
 /\* Fill the status data payload. First with status. \*/ \*buffer = (UCHAR) dfu\_status;
 /\* Poll time out value is set to 1ms. \*/ \*(buffer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT) = UX\_DW0(dfu\_polltimeout); \*(buffer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 1) = UX\_DW1(dfu\_polltimeout); \*(buffer + UX\_SLAVE\_CLASS\_DFU\_GET\_STATUS\_POLL\_TIMEOUT + 2) = UX\_DW2(dfu\_polltimeout);
 /\* Next state. \*/[View remainder of file in raw view](https://github.com/eclipse-threadx/usbx/raw/refs/heads/master/common/usbx_device_classes/src/ux_device_class_dfu_control_request.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_8b97b463_20250115_083428.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Feclipse-threadx%2Fusbx%2Freleases%2Ftag%2Fv6.1.11_rel)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Feclipse-threadx%2Fusbx%2Freleases%2Ftag%2Fv6.1.11_rel)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Freleases%2Fshow&source=header-repo&source_repo=eclipse-threadx%2Fusbx)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[eclipse-threadx](/eclipse-threadx)
/
**[usbx](/eclipse-threadx/usbx)**
Public

* [Notifications](/login?return_to=%2Feclipse-threadx%2Fusbx) You must be signed in to change notification settings
* [Fork
  95](/login?return_to=%2Feclipse-threadx%2Fusbx)
* [Star
   165](/login?return_to=%2Feclipse-threadx%2Fusbx)

* [Code](/eclipse-threadx/usbx/tree/v6.1.11_rel)
* [Issues
  51](/eclipse-threadx/usbx/issues)
* [Pull requests
  6](/eclipse-threadx/usbx/pulls)
* [Discussions](/eclipse-threadx/usbx/discussions)
* [Actions](/eclipse-threadx/usbx/actions)
* [Security](/eclipse-threadx/usbx/security)
* [Insights](/eclipse-threadx/usbx/pulse)

Additional navigation options

* [Code](/eclipse-threadx/usbx/tree/v6.1.11_rel)
* [Issues](/eclipse-threadx/usbx/issues)
* [Pull requests](/eclipse-threadx/usbx/pulls)
* [Discussions](/eclipse-threadx/usbx/discussions)
* [Actions](/eclipse-threadx/usbx/actions)
* [Security](/eclipse-threadx/usbx/security)
* [Insights](/eclipse-threadx/usbx/pulse)

1. [Releases](/eclipse-threadx/usbx/releases)
2. [v6.1.11\_rel](/eclipse-threadx/usbx/releases/tag/v6.1.11_rel)

# Azure RTOS 6.1.11

 Compare

Choose a tag to compare

Could not load tags

Nothing to show

[{{ refName }}
default](/eclipse-threadx/usbx/compare/%7B%7B%20urlEncodedRefName%20%7D%7D...v6.1.11_rel)

 Loading

[View all tags](/eclipse-threadx/usbx/tags)

![@yuxin-azrtos](https://avatars.githubusercontent.com/u/63439886?s=40&v=4)
[yuxin-azrtos](/yuxin-azrtos)
released this
27 Apr 06:48

·
[62 commits](/eclipse-threadx/usbx/compare/v6.1.11_rel...master)
to master
since this release

[v6.1.11\_rel](/eclipse-threadx/usbx/tree/v6.1.11_rel)

[`b693cdd`](/eclipse-threadx/usbx/commit/b693cdd782f1dc0742d6b1915cdc3d08f6d0959c)

Azure RTOS USBX 6.1.11 release contains the following features and changes:

```
Fixed maximum decimal calculation issue, file modified:
    ux_pictbridge_hexa_to_decimal_string.c

Added external (standalone) FileX support in Host Storage FileX driver, file modified:
    ux_host_class_storage_driver_entry.c

Added device video support, files modified/added:
    ux_device_stack_initialize.c

    ux_device_class_video.h
    ux_device_class_video_*.c

Improved device CDC ACM Bulk IN thread performance, file modified:
    ux_device_class_cdc_acm_bulkin_thread.c

Added event callback in device HID receiver, files modified:
    ux_device_class_hid.h
    ux_device_class_hid_receiver_initialize.c
    ux_device_class_hid_receiver_thread.c

Added read/write callback status check in Device DFU, file modified:
    ux_device_class_dfu_control_request.c

Fixed addressing issues in OHCI, files modified:
    ux_hcd_ohci_asynchronous_endpoint_create.c
    ux_hcd_ohci_asynchronous_endpoint_destroy.c

Fixed Host HID client management, files modified:
    ux_host_class_hid_keyboard.h
    ux_host_class_hid_mouse.h
    ux_host_class_hid_remote_control.h
    ux_host_class_hid_keyboard_activate.c
    ux_host_class_hid_mouse_activate.c
    ux_host_class_hid_remote_control_activate.c

Fixed host endpoint packet size calculation, file modified:
    ux_host_stack_new_endpoint_create.c

Various files were modified to improve internal logic.

```

 Assets
2

 Loading

All reactions

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_89638f4f_20250115_083429.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Feclipse-threadx%2Fusbx%2Fsecurity%2Fadvisories%2FGHSA-hh5p-x584-j8hv)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Feclipse-threadx%2Fusbx%2Fsecurity%2Fadvisories%2FGHSA-hh5p-x584-j8hv)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Frepos%2Fadvisories%2Fshow&source=header-repo&source_repo=eclipse-threadx%2Fusbx)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[eclipse-threadx](/eclipse-threadx)
/
**[usbx](/eclipse-threadx/usbx)**
Public

* [Notifications](/login?return_to=%2Feclipse-threadx%2Fusbx) You must be signed in to change notification settings
* [Fork
  95](/login?return_to=%2Feclipse-threadx%2Fusbx)
* [Star
   165](/login?return_to=%2Feclipse-threadx%2Fusbx)

* [Code](/eclipse-threadx/usbx)
* [Issues
  51](/eclipse-threadx/usbx/issues)
* [Pull requests
  6](/eclipse-threadx/usbx/pulls)
* [Discussions](/eclipse-threadx/usbx/discussions)
* [Actions](/eclipse-threadx/usbx/actions)
* [Security](/eclipse-threadx/usbx/security)
* [Insights](/eclipse-threadx/usbx/pulse)

Additional navigation options

* [Code](/eclipse-threadx/usbx)
* [Issues](/eclipse-threadx/usbx/issues)
* [Pull requests](/eclipse-threadx/usbx/pulls)
* [Discussions](/eclipse-threadx/usbx/discussions)
* [Actions](/eclipse-threadx/usbx/actions)
* [Security](/eclipse-threadx/usbx/security)
* [Insights](/eclipse-threadx/usbx/pulse)

# Potential buffer overflow in function DFU upload

High

[liydu](/liydu)
published
GHSA-hh5p-x584-j8hv
May 23, 2022

## Package

USBX
(Azure RTOS)

## Affected versions

< 6.1.11

## Patched versions

6.1.11

## Description

### Impact

The USBX DFU UPLOAD functionality may be utilized to introduce a buffer overflow resulting in overwrite of memory contents. In particular cases this may allow an attacker to bypass security features or execute arbitrary code.

The implementation of `ux_device_class_dfu_control_request` function does not assure that a buffer overflow will not occur during handling of the DFU UPLOAD command. When an attacker issues the `UX_SLAVE_CLASS_DFU_COMMAND_UPLOAD` control transfer request with `wLenght` larger than the buffer size (`UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH`, 256 bytes), depending on the actual implementation of `dfu -> ux_slave_class_dfu_read`, a buffer overflow may occur. In example `ux_slave_class_dfu_read` may read 4096 bytes (or more up to 65k) to a 256 byte buffer ultimately resulting in an overflow. Furthermore in case an attacker has some control over the read flash memory - in example DFU is used with an external SPI flash chip or the **DFU DOWNLOAD** command may be used - this may result in execution of arbitrary code and platform compromise.

### Patches

We analyzed this bug and determined that we needed to fix it. This fix has been included in USBX release [6.1.11](https://github.com/azure-rtos/usbx/releases/tag/v6.1.11_rel).

### Workarounds

Align request and buffer size to assure that buffer boundaries are respected.

### References

<https://github.com/azure-rtos/usbx/blob/master/common/usbx_device_classes/src/ux_device_class_dfu_control_request.c>

### For more information

If you have any questions or comments about this advisory:

* Open an issue in [azure-rtos/usbx](https://github.com/azure-rtos/usbx/issues)
* Post question on [Microsoft Q&A](https://docs.microsoft.com/en-us/answers/topics/25318/azure-rtos.html)

### Severity

High

### CVE ID

CVE-2022-29246

### Weaknesses

No CWEs

### Credits

* [![@szymonh](https://avatars.githubusercontent.com/u/12231135?s=40&v=4)](/szymonh)
  [szymonh](/szymonh)
  Analyst

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


