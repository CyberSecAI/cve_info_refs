### CVE-2019-9245
The provided content pertains to CVE-2019-9245.

**Description:** An information disclosure vulnerability exists in the F2FS storage driver of the Linux kernel due to insufficient validation when reading USB descriptors.

*   **Vulnerability:** The `__usb_get_extra_descriptor` function in `drivers/usb/core/usb.c` did not properly check the minimum and maximum size allowed for extra descriptors. Specifically, the code lacked validation of the descriptor's length (`header->bLength`).
*   **Root Cause:** Improper size validation when reading extra descriptors from a USB device. The code now checks if `header->bLength` is less than 2 or greater than the remaining buffer size. It also verifies if the descriptor type matches and if the length meets the minimum size requirement.
*   **Impact:** An attacker could potentially craft a malicious USB device that sends invalid or malformed descriptors, leading to information disclosure.
*   **Attack Vector:** By connecting a specially crafted USB device to a vulnerable system.
*   **Affected Component:** F2FS Storage driver, USB core.
*   **Fix:** The fix involves adding checks to ensure the descriptor length is valid (`header->bLength >= minsize && header->bLength <= size`) within the `__usb_get_extra_descriptor` function.

**Code Snippets (Before and After):**

**Before:**

```c
int __usb_get_extra_descriptor(char *buffer, unsigned size,
                                unsigned char type, void **ptr)
{
        struct usb_descriptor_header *header;

        while (size >= sizeof(struct usb_descriptor_header)) {
                header = (struct usb_descriptor_header *)buffer;
                if (header->bLength < 2) {
                        printk(KERN_ERR "%s: bogus descriptor, type %d length %d\n",
                                        usbcore_name, type, header->bLength);
                        return -1;
                }
                if (header->bDescriptorType == type) {
                        *ptr = header;
                        return 0;
                }
```

**After:**

```c
int __usb_get_extra_descriptor(char *buffer, unsigned size,
                                unsigned char type, void **ptr, size_t minsize)
{
        struct usb_descriptor_header *header;

        while (size >= sizeof(struct usb_descriptor_header)) {
                header = (struct usb_descriptor_header *)buffer;
                if (header->bLength < 2 || header->bLength > size) {
                        printk(KERN_ERR "%s: bogus descriptor, type %d length %d\n",
                                        usbcore_name, type, header->bLength);
                        return -1;
                }
                if (header->bDescriptorType == type && header->bLength >= minsize) {
                        *ptr = header;
                        return 0;
                }
```