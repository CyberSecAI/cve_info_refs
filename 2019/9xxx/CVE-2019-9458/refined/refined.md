```
{
  "CVE-2019-9458": {
    "description": "In the Android kernel in the video driver there is a use after free due to a race condition. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",
    "vulnerability": {
      "root_cause": "A race condition in the video driver's event subscription and unsubscription logic leads to a use-after-free vulnerability.",
      "weaknesses": [
        "Use-after-free",
        "Race condition"
      ],
      "impact": "Local escalation of privilege",
       "attack_vector": "Local",
      "attacker_capabilities": "Low privilege, no specific user interaction is required."
    }
  },
 "CVE-2020-11494": {
    "description": "An issue was discovered in slc_bump in drivers/net/can/slcan.c in the Linux kernel 3.16 through 5.6.2. It allows attackers to read uninitialized can_frame data, potentially containing sensitive information from kernel stack memory, if the configuration lacks CONFIG_INIT_STACK_ALL, aka CID-b9258a2cece4.",
    "vulnerability": {
      "root_cause": "The slc_bump function in the Linux kernel's slcan driver does not initialize can_frame data, allowing for the leakage of kernel stack memory.",
       "weaknesses": [
        "Information disclosure",
        "Uninitialized data"
      ],
      "impact": "Leakage of sensitive information from kernel stack memory.",
       "attack_vector": "Local",
      "attacker_capabilities": "An attacker with local access to the system"
    }
  },
  "CVE-2019-3701": {
    "description": "An issue was discovered in can_can_gw_rcv in net/can/gw.c in the Linux kernel through 4.19.13. The CAN frame modification rules allow bitwise logical operations that can be also applied to the can_dlc field. The privileged user \"root\" with CAP_NET_ADMIN can create a CAN frame modification rule that makes the data length code a higher value than the available CAN frame data size. In combination with a configured checksum calculation where the result is stored relatively to the end of the data (e.g. cgw_csum_xor_rel) the tail of the skb (e.g. frag_list pointer in skb_shared_info) can be rewritten which finally can cause a system crash. Because of a missing check, the CAN drivers may write arbitrary content beyond the data registers in the CAN controller's I/O memory when processing can-gw manipulated outgoing frames.",
    "vulnerability": {
      "root_cause": "The CAN frame modification rules lack input validation for the can_dlc field, and a missing check in the CAN drivers allows writes beyond data registers in the CAN controller's I/O memory.",
       "weaknesses": [
        "Out-of-bounds write",
        "Lack of input validation"
      ],
      "impact": "System crash, arbitrary memory write causing system instability.",
       "attack_vector": "Local",
       "attacker_capabilities": "A local user with root privileges and CAP_NET_ADMIN capability is needed to configure a specific CAN frame modification rule"
    }
  },
  "CVE-2020-10942": {
    "description": "In the Linux kernel before 5.5.8, get_raw_socket in drivers/vhost/net.c lacks validation of an sk_family field, which might allow attackers to trigger kernel stack corruption via crafted system calls.",
    "vulnerability": {
      "root_cause": "The `get_raw_socket` function in the `vhost` net driver in the Linux kernel does not validate the sk_family field allowing for kernel stack corruption.",
      "weaknesses": [
        "Stack corruption",
	"Lack of input validation"
      ],
      "impact": "Kernel stack corruption potentially leading to denial of service or other unexpected behavior.",
       "attack_vector": "Local",
      "attacker_capabilities": "Local user with access to crafting system calls"
    }
  },
  "CVE-2019-19770": {
      "description": "In the Linux kernel 4.19.83, there is a use-after-free (read) in the debugfs_remove function in fs/debugfs/inode.c (which is used to remove a file or directory in debugfs that was previously created with a call to another debugfs function such as debugfs_create_file). NOTE: Linux kernel developers dispute this issue as not being an issue with debugfs, instead this is an issue with misuse of debugfs within blktrace.",
       "vulnerability": {
        "root_cause": "A use-after-free vulnerability exists in the debugfs_remove function when removing debugfs files due to improper synchronization.",
        "weaknesses": [
            "Use-after-free"
            ],
        "impact": "System crash/denial of service, with potential for information disclosure",
        "attack_vector": "Network",
        "attacker_capabilities": "Remote attacker with access to the vulnerable system."
        }
  }
}
```