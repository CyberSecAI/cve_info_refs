=== Content from github.com_822257df_20250121_030612.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FJinBean%2FCVE-Extension%2Fblob%2Fmaster%2FCVE-2019-7167%2FZcash-1.X%2FJoinSplit.cpp)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FJinBean%2FCVE-Extension%2Fblob%2Fmaster%2FCVE-2019-7167%2FZcash-1.X%2FJoinSplit.cpp)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=JinBean%2FCVE-Extension)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[JinBean](/JinBean)
/
**[CVE-Extension](/JinBean/CVE-Extension)**
Public

* [Notifications](/login?return_to=%2FJinBean%2FCVE-Extension) You must be signed in to change notification settings
* [Fork
  4](/login?return_to=%2FJinBean%2FCVE-Extension)
* [Star
   3](/login?return_to=%2FJinBean%2FCVE-Extension)

* [Code](/JinBean/CVE-Extension)
* [Issues
  0](/JinBean/CVE-Extension/issues)
* [Pull requests
  0](/JinBean/CVE-Extension/pulls)
* [Actions](/JinBean/CVE-Extension/actions)
* [Projects
  0](/JinBean/CVE-Extension/projects)
* [Security](/JinBean/CVE-Extension/security)
* [Insights](/JinBean/CVE-Extension/pulse)

Additional navigation options

* [Code](/JinBean/CVE-Extension)
* [Issues](/JinBean/CVE-Extension/issues)
* [Pull requests](/JinBean/CVE-Extension/pulls)
* [Actions](/JinBean/CVE-Extension/actions)
* [Projects](/JinBean/CVE-Extension/projects)
* [Security](/JinBean/CVE-Extension/security)
* [Insights](/JinBean/CVE-Extension/pulse)

## Files

 master
## Breadcrumbs

1. [CVE-Extension](/JinBean/CVE-Extension/tree/master)
2. /[CVE-2019-7167](/JinBean/CVE-Extension/tree/master/CVE-2019-7167)
3. /[Zcash-1.X](/JinBean/CVE-Extension/tree/master/CVE-2019-7167/Zcash-1.X)
/
# JoinSplit.cpp

Copy path Blame  Blame
## Latest commit

## History

[History](/JinBean/CVE-Extension/commits/master/CVE-2019-7167/Zcash-1.X/JoinSplit.cpp)389 lines (311 loc) · 12.2 KB master
## Breadcrumbs

1. [CVE-Extension](/JinBean/CVE-Extension/tree/master)
2. /[CVE-2019-7167](/JinBean/CVE-Extension/tree/master/CVE-2019-7167)
3. /[Zcash-1.X](/JinBean/CVE-Extension/tree/master/CVE-2019-7167/Zcash-1.X)
/
# JoinSplit.cpp

Top
## File metadata and controls

* Code
* Blame

389 lines (311 loc) · 12.2 KB[Raw](https://github.com/JinBean/CVE-Extension/raw/refs/heads/master/CVE-2019-7167/Zcash-1.X/JoinSplit.cpp)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389#include "JoinSplit.hpp"#include "prf.h"#include "sodium.h"
#include "zcash/util.h"
#include <memory>
#include <boost/foreach.hpp>#include <boost/format.hpp>#include <boost/optional.hpp>#include <fstream>#include <libsnark/common/default\_types/r1cs\_ppzksnark\_pp.hpp>#include <libsnark/zk\_proof\_systems/ppzksnark/r1cs\_ppzksnark/r1cs\_ppzksnark.hpp>#include <libsnark/gadgetlib1/gadgets/hashes/sha256/sha256\_gadget.hpp>#include <libsnark/gadgetlib1/gadgets/merkle\_tree/merkle\_tree\_check\_read\_gadget.hpp>#include "tinyformat.h"#include "sync.h"#include "amount.h"
using namespace libsnark;
namespace libzcash {
#include "zcash/circuit/gadget.tcc"
CCriticalSection cs\_ParamsIO;CCriticalSection cs\_LoadKeys;
template<typename T>void saveToFile(const std::string path, T& obj) { LOCK(cs\_ParamsIO);
 std::stringstream ss; ss << obj; std::ofstream fh; fh.open(path, std::ios::binary); ss.rdbuf()->pubseekpos(0, std::ios\_base::out); fh << ss.rdbuf(); fh.flush(); fh.close();}
template<typename T>void loadFromFile(const std::string path, T& objIn) { LOCK(cs\_ParamsIO);
 std::stringstream ss; std::ifstream fh(path, std::ios::binary);
 if(!fh.is\_open()) { throw std::runtime\_error(strprintf("could not load param file at %s", path)); }
 ss << fh.rdbuf(); fh.close();
 ss.rdbuf()->pubseekpos(0, std::ios\_base::in);
 T obj; ss >> obj;
 objIn = std::move(obj);}
template<size\_t NumInputs, size\_t NumOutputs>class JoinSplitCircuit : public JoinSplit<NumInputs, NumOutputs> {public: typedef default\_r1cs\_ppzksnark\_pp ppzksnark\_ppT; typedef Fr<ppzksnark\_ppT> FieldT;
 r1cs\_ppzksnark\_verification\_key<ppzksnark\_ppT> vk; r1cs\_ppzksnark\_processed\_verification\_key<ppzksnark\_ppT> vk\_precomp; std::string pkPath;
 JoinSplitCircuit(const std::string vkPath, const std::string pkPath) : pkPath(pkPath) { loadFromFile(vkPath, vk); vk\_precomp = r1cs\_ppzksnark\_verifier\_process\_vk(vk); } ~JoinSplitCircuit() {}
 static void generate(const std::string r1csPath, const std::string vkPath, const std::string pkPath) { protoboard<FieldT> pb;
 joinsplit\_gadget<FieldT, NumInputs, NumOutputs> g(pb); g.generate\_r1cs\_constraints();
 auto r1cs = pb.get\_constraint\_system();
 saveToFile(r1csPath, r1cs);
 r1cs\_ppzksnark\_keypair<ppzksnark\_ppT> keypair = r1cs\_ppzksnark\_generator<ppzksnark\_ppT>(r1cs);
 saveToFile(vkPath, keypair.vk); saveToFile(pkPath, keypair.pk); }
 bool verify( const ZCProof& proof, ProofVerifier& verifier, const uint256& pubKeyHash, const uint256& randomSeed, const boost::array<uint256, NumInputs>& macs, const boost::array<uint256, NumInputs>& nullifiers, const boost::array<uint256, NumOutputs>& commitments, uint64\_t vpub\_old, uint64\_t vpub\_new, const uint256& rt ) { try { auto r1cs\_proof = proof.to\_libsnark\_proof<r1cs\_ppzksnark\_proof<ppzksnark\_ppT>>();
 uint256 h\_sig = this->h\_sig(randomSeed, nullifiers, pubKeyHash);
 auto witness = joinsplit\_gadget<FieldT, NumInputs, NumOutputs>::witness\_map( rt, h\_sig, macs, nullifiers, commitments, vpub\_old, vpub\_new );
 return verifier.check( vk, vk\_precomp, witness, r1cs\_proof ); } catch (...) { return false; } }
 ZCProof prove( const boost::array<JSInput, NumInputs>& inputs, const boost::array<JSOutput, NumOutputs>& outputs, boost::array<Note, NumOutputs>& out\_notes, boost::array<ZCNoteEncryption::Ciphertext, NumOutputs>& out\_ciphertexts, uint256& out\_ephemeralKey, const uint256& pubKeyHash, uint256& out\_randomSeed, boost::array<uint256, NumInputs>& out\_macs, boost::array<uint256, NumInputs>& out\_nullifiers, boost::array<uint256, NumOutputs>& out\_commitments, uint64\_t vpub\_old, uint64\_t vpub\_new, const uint256& rt, bool computeProof, uint256 \*out\_esk // Payment disclosure ) { if (vpub\_old > MAX\_MONEY) { throw std::invalid\_argument("nonsensical vpub\_old value"); }
 if (vpub\_new > MAX\_MONEY) { throw std::invalid\_argument("nonsensical vpub\_new value"); }
 uint64\_t lhs\_value = vpub\_old; uint64\_t rhs\_value = vpub\_new;
 for (size\_t i = 0; i < NumInputs; i++) { // Sanity checks of input { // If note has nonzero value if (inputs[i].note.value != 0) { // The witness root must equal the input root. if (inputs[i].witness.root() != rt) { throw std::invalid\_argument("joinsplit not anchored to the correct root"); }
 // The tree must witness the correct element if (inputs[i].note.cm() != inputs[i].witness.element()) { throw std::invalid\_argument("witness of wrong element for joinsplit input"); } }
 // Ensure we have the key to this note. if (inputs[i].note.a\_pk != inputs[i].key.address().a\_pk) { throw std::invalid\_argument("input note not authorized to spend with given key"); }
 // Balance must be sensical if (inputs[i].note.value > MAX\_MONEY) { throw std::invalid\_argument("nonsensical input note value"); }
 lhs\_value += inputs[i].note.value;
 if (lhs\_value > MAX\_MONEY) { throw std::invalid\_argument("nonsensical left hand size of joinsplit balance"); } }
 // Compute nullifier of input out\_nullifiers[i] = inputs[i].nullifier(); }
 // Sample randomSeed out\_randomSeed = random\_uint256();
 // Compute h\_sig uint256 h\_sig = this->h\_sig(out\_randomSeed, out\_nullifiers, pubKeyHash);
 // Sample phi uint252 phi = random\_uint252();
 // Compute notes for outputs for (size\_t i = 0; i < NumOutputs; i++) { // Sanity checks of output { if (outputs[i].value > MAX\_MONEY) { throw std::invalid\_argument("nonsensical output value"); }
 rhs\_value += outputs[i].value;
 if (rhs\_value > MAX\_MONEY) { throw std::invalid\_argument("nonsensical right hand side of joinsplit balance"); } }
 // Sample r uint256 r = random\_uint256();
 out\_notes[i] = outputs[i].note(phi, r, i, h\_sig); }
 if (lhs\_value != rhs\_value) { throw std::invalid\_argument("invalid joinsplit balance"); }
 // Compute the output commitments for (size\_t i = 0; i < NumOutputs; i++) { out\_commitments[i] = out\_notes[i].cm(); }
 // Encrypt the ciphertexts containing the note // plaintexts to the recipients of the value. { ZCNoteEncryption encryptor(h\_sig);
 for (size\_t i = 0; i < NumOutputs; i++) { NotePlaintext pt(out\_notes[i], outputs[i].memo);
 out\_ciphertexts[i] = pt.encrypt(encryptor, outputs[i].addr.pk\_enc); }
 out\_ephemeralKey = encryptor.get\_epk();
 // !!! Payment disclosure START if (out\_esk != nullptr) { \*out\_esk = encryptor.get\_esk(); } // !!! Payment disclosure END }
 // Authenticate h\_sig with each of the input // spending keys, producing macs which protect // against malleability. for (size\_t i = 0; i < NumInputs; i++) { out\_macs[i] = PRF\_pk(inputs[i].key, i, h\_sig); }
 if (!computeProof) { return ZCProof(); }
 protoboard<FieldT> pb; { joinsplit\_gadget<FieldT, NumInputs, NumOutputs> g(pb); g.generate\_r1cs\_constraints(); g.generate\_r1cs\_witness( phi, rt, h\_sig, inputs, out\_notes, vpub\_old, vpub\_new ); }
 // The constraint system must be satisfied or there is an unimplemented // or incorrect sanity check above. Or the constraint system is broken! assert(pb.is\_satisfied());
 // TODO: These are copies, which is not strictly necessary. std::vector<FieldT> primary\_input = pb.primary\_input(); std::vector<FieldT> aux\_input = pb.auxiliary\_input();
 // Swap A and B if it's beneficial (less arithmetic in G2) // In our circuit, we already know that it's beneficial // to swap, but it takes so little time to perform this // estimate that it doesn't matter if we check every time. pb.constraint\_system.swap\_AB\_if\_beneficial();
 std::ifstream fh(pkPath, std::ios::binary);
 if(!fh.is\_open()) { throw std::runtime\_error(strprintf("could not load param file at %s", pkPath)); }
 return ZCProof(r1cs\_ppzksnark\_prover\_streaming<ppzksnark\_ppT>( fh, primary\_input, aux\_input, pb.constraint\_system )); }};
template<size\_t NumInputs, size\_t NumOutputs>void JoinSplit<NumInputs, NumOutputs>::Generate(const std::string r1csPath, const std::string vkPath, const std::string pkPath){ initialize\_curve\_params(); JoinSplitCircuit<NumInputs, NumOutputs>::generate(r1csPath, vkPath, pkPath);}
template<size\_t NumInputs, size\_t NumOutputs>JoinSplit<NumInputs, NumOutputs>\* JoinSplit<NumInputs, NumOutputs>::Prepared(const std::string vkPath, const std::string pkPath){ initialize\_curve\_params(); return new JoinSplitCircuit<NumInputs, NumOutputs>(vkPath, pkPath);}
template<size\_t NumInputs, size\_t NumOutputs>uint256 JoinSplit<NumInputs, NumOutputs>::h\_sig( const uint256& randomSeed, const boost::array<uint256, NumInputs>& nullifiers, const uint256& pubKeyHash) { const unsigned char personalization[crypto\_generichash\_blake2b\_PERSONALBYTES] = {'Z','c','a','s','h','C','o','m','p','u','t','e','h','S','i','g'};
 std::vector<unsigned char> block(randomSeed.begin(), randomSeed.end());
 for (size\_t i = 0; i < NumInputs; i++) { block.insert(block.end(), nullifiers[i].begin(), nullifiers[i].end()); }
 block.insert(block.end(), pubKeyHash.begin(), pubKeyHash.end());
 uint256 output;
 if (crypto\_generichash\_blake2b\_salt\_personal(output.begin(), 32, &block[0], block.size(), NULL, 0, // No key. NULL, // No salt. personalization ) != 0) { throw std::logic\_error("hash function failure"); }
 return output;}
Note JSOutput::note(const uint252& phi, const uint256& r, size\_t i, const uint256& h\_sig) const { uint256 rho = PRF\_rho(phi, i, h\_sig);
 return Note(addr.a\_pk, value, rho, r);}
JSOutput::JSOutput() : addr(uint256(), uint256()), value(0) { SpendingKey a\_sk = SpendingKey::random(); addr = a\_sk.address();}
JSInput::JSInput() : witness(ZCIncrementalMerkleTree().witness()), key(SpendingKey::random()) { note = Note(key.address().a\_pk, 0, random\_uint256(), random\_uint256()); ZCIncrementalMerkleTree dummy\_tree; dummy\_tree.append(note.cm()); witness = dummy\_tree.witness();}
template class JoinSplit<ZC\_NUM\_JS\_INPUTS, ZC\_NUM\_JS\_OUTPUTS>;
}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from bitcoin.stackexchange.com_f853eaaa_20250121_030607.html ===


[Skip to main content](#content)

#### Stack Exchange Network

Stack Exchange network consists of 183 Q&A communities including [Stack Overflow](https://stackoverflow.com), the largest, most trusted online community for developers to learn, share their knowledge, and build their careers.

[Visit Stack Exchange](https://stackexchange.com)

Loading…

* [Tour
  Start here for a quick overview of the site](/tour)
* [Help Center
  Detailed answers to any questions you might have](/help)
* [Meta
  Discuss the workings and policies of this site](https://bitcoin.meta.stackexchange.com)
* [About Us
  Learn more about Stack Overflow the company, and our products](https://stackoverflow.co/)

4. ### [current community](https://bitcoin.stackexchange.com)

   * [Bitcoin](https://bitcoin.stackexchange.com)

     [help](https://bitcoin.stackexchange.com/help)
     [chat](https://chat.stackexchange.com?tab=site&host=bitcoin.stackexchange.com)
   * [Bitcoin Meta](https://bitcoin.meta.stackexchange.com)
   ### your communities

   [Sign up](https://bitcoin.stackexchange.com/users/signup?ssrc=site_switcher&returnurl=https%3a%2f%2fbitcoin.stackexchange.com%2fquestions%2f79481%2fhow-does-the-most-recently-found-critical-vulnerability-cve-2018-17144-work%2f79484) or [log in](https://bitcoin.stackexchange.com/users/login?ssrc=site_switcher&returnurl=https%3a%2f%2fbitcoin.stackexchange.com%2fquestions%2f79481%2fhow-does-the-most-recently-found-critical-vulnerability-cve-2018-17144-work%2f79484) to customize your list.

   ### [more stack exchange communities](https://stackexchange.com/sites)

   [company blog](https://stackoverflow.blog)
6. [Log in](https://bitcoin.stackexchange.com/users/login?ssrc=head&returnurl=https%3a%2f%2fbitcoin.stackexchange.com%2fquestions%2f79481%2fhow-does-the-most-recently-found-critical-vulnerability-cve-2018-17144-work%2f79484)
7. [Sign up](https://bitcoin.stackexchange.com/users/signup?ssrc=head&returnurl=https%3a%2f%2fbitcoin.stackexchange.com%2fquestions%2f79481%2fhow-does-the-most-recently-found-critical-vulnerability-cve-2018-17144-work%2f79484)

[![Bitcoin](https://cdn.sstatic.net/Sites/bitcoin/Img/logo.svg?v=65edcd6e45f3)](https://bitcoin.stackexchange.com)

1. 1. [Home](/)
   2. [Questions](/questions)
   3. [Tags](/tags)
   5. [Users](/users)
   6. [Companies](https://stackoverflow.com/jobs/companies?so_medium=bitcoin&so_source=SiteNav)
   7. [Unanswered](/unanswered)
2. Teams
   ![](https://cdn.sstatic.net/Img/teams/teams-promo.svg?v=e507948b81bf)

   Ask questions, find answers and collaborate at work with Stack Overflow for Teams.

   [Try Teams for free](https://stackoverflowteams.com/teams/create/free/?utm_medium=referral&utm_source=bitcoin-community&utm_campaign=side-bar&utm_content=explore-teams)
   [Explore Teams](https://stackoverflow.co/teams/?utm_medium=referral&utm_source=bitcoin-community&utm_campaign=side-bar&utm_content=explore-teams)
3. Teams
4. Ask questions, find answers and collaborate at work with Stack Overflow for Teams.
   [Explore Teams](https://stackoverflow.co/teams/?utm_medium=referral&utm_source=bitcoin-community&utm_campaign=side-bar&utm_content=explore-teams-compact)

**Teams**

Q&A for work

Connect and share knowledge within a single location that is structured and easy to search.

[Learn more about Teams](https://stackoverflow.co/teams/)

# [How does the most recently found critical vulnerability (CVE-2018-17144) work?](/questions/79481/how-does-the-most-recently-found-critical-vulnerability-cve-2018-17144-work)

[Ask Question](/questions/ask)

Asked
6 years, 4 months ago

Modified
[6 years, 4 months ago](?lastactivity "2018-09-22 01:23:49Z")

Viewed
1k times

21

If you were a miner, what are the steps you would take to create the extra (21,000,012.5th) bitcoin?

Where in the source code is this exactly (link)?

Why can't this be done by a non-miner?

Also, which forks are/were vulnerable?

* [reward-schedule](/questions/tagged/reward-schedule "show questions tagged 'reward-schedule'")
* [error](/questions/tagged/error "show questions tagged 'error'")
* [weaknesses](/questions/tagged/weaknesses "show questions tagged 'weaknesses'")
* [source-code](/questions/tagged/source-code "show questions tagged 'source-code'")

[Share](/q/79481 "Short permalink to this question")

[Improve this question](/posts/79481/edit)

Follow

asked Sep 22, 2018 at 0:03

[![hedgedandlevered's user avatar](https://www.gravatar.com/avatar/040b21236346b0d22ef032e63fc06a04?s=64&d=identicon&r=PG)](/users/7144/hedgedandlevered)

[hedgedandlevered](/users/7144/hedgedandlevered)hedgedandlevered
1,50311 gold badge1010 silver badges2323 bronze badges

1

* 21 upvotes, very meta, good job everyone
  – [hedgedandlevered](/users/7144/hedgedandlevered "1,503 reputation")

  Commented
  Nov 29, 2023 at 19:19

Add a comment
 |

## 1 Answer 1

Sorted by:

[Reset to default](/questions/79481/how-does-the-most-recently-found-critical-vulnerability-cve-2018-17144-work?answertab=scoredesc#tab-top)

Highest score (default)

Date modified (newest first)

Date created (oldest first)

30

> If you were a miner, what are the steps you would take to create the extra (21,000,012.5th) bitcoin?
>
> Where in the source code is this exactly (link)?

There are two components to CVE-2018-17144. There is a crash bug and an inflation bug. Both are triggered by almost the same scenario: a transaction contains an input multiple times.

In general, how this would work is as follows: lets suppose a miner has an unspent output A for 1 BTC. They create a transaction with that input in twice, so input 1 spends from output A and input 2 *also* spends from output A. The output of that transaction has a value of 2 BTC. Note how the output's value is larger than the value of output A, but if you had output A twice, the value is correct.

The miner would then take this transaction and include it in a block that he is mining. Once the miner find a block with his transaction included in it, he broadcasts it to the Bitcoin network.

When a Bitcoin Core 0.14.x node receives this block, it will validate the block, but it will skip the duplicate input check because of [the `false` parameter on this line](https://github.com/bitcoin/bitcoin/blob/v0.14.2/src/validation.cpp#L2883). So the transaction the miner made will pass this step of validation, and the other transaction validation steps, including input script validation, until it reaches [this loop](https://github.com/bitcoin/bitcoin/blob/v0.14.2/src/validation.cpp#L1328). In this loop, the inputs to the transaction are being marked as spent in the UTXO database. The first time the duplicated input is seen, it is marked as spent. But the second time it is seen, the coin is already marked as spent so `coins->vout[nPos].IsNull()` will be true. This means that it will go into [this if statement](https://github.com/bitcoin/bitcoin/blob/v0.14.2/src/validation.cpp#L1332) and subsequently hit the [`assert` statement that follows](https://github.com/bitcoin/bitcoin/blob/v0.14.2/src/validation.cpp#L1333). The assert causes the software to crash.

For Bitcoin Core 0.15.0 - 0.16.2, the behavior is different. This is due to the change in how the UTXO database is structured. Everything is largely the same until the [same loop](https://github.com/bitcoin/bitcoin/blob/v0.15.0/src/validation.cpp#L1183) is reached. Here, instead of returning whether the output was spent, `SpendCoin` actually returns whether the input *exists* in the database. So the first time, it will pass as expected, but the second time, instead of returning `false`, it still returns `true`.

Looking at [`SpendCoin`](https://github.com/bitcoin/bitcoin/blob/v0.15.0/src/coins.cpp#L101), you can see that it only returns false when it is unable to fetch the coin (object representing a UTXO) from the database. With the new database structure, this makes sense as the output should be removed from the database when it is spent. But, if you [look a few lines down](https://github.com/bitcoin/bitcoin/blob/v0.15.0/src/coins.cpp#L109), you see that it only deletes the coin when it is marked as `FRESH`. In the case the coin was `FRESH`, `SpendCoin` would delete the object on the first pass so the second pass the coin would not be found and thus it would return false. This triggers the [`assert` following the function call](https://github.com/bitcoin/bitcoin/blob/v0.15.0/src/validation.cpp#L1186) causing the node to shutdown.

If the coin was not `FRESH`, the coin object itself is not deleted, but its contents are cleared. This means that the second time the input is seen, if the coin was not `FRESH`, `SpendCoin` would still return true as the object still exists in memory, which means that it passes the assert that follows the `SpendCoin` (which caused the crash when the coin was not `FRESH`). Then validation continues as normal, and the output this transaction created is added to the UTXO database, which means that money that shouldn't exist now exists in the UTXO database.

So now the question is, when are UTXOs marked as `FRESH`? They are marked `FRESH` when they are added to the UTXO database. But the UTXO database is still only in memory (as a cache). When it is saved to disk, the entries in memory are then no longer marked as `FRESH`. This saving to disk happens after every block (as well as at other times, but that is not important).

Thus, if a miner has an output that was part of a transaction that has already confirmed, and he spends the output twice in the same transaction (so the transaction has two inputs that refer to the same output), and this transaction is not broadcast to the network but instead included in a block that he mines, he is able to create a new output that has twice the value of the output that he spent, thereby creating coins.

> Why can't this be done by a non-miner?

The reason that this cannot be done by a non-miner is because transactions that are received outside of blocks are still checked for duplicate inputs. The transaction will be rejected as invalid and not added to the node's mempool, so the transaction will never get into a block. It is only transactions with duplicate inputs that get into blocks that trigger this vulnerability, and thus only miners can do this as they must knowingly insert an invalid transaction into their block.

> Also, which forks are/were vulnerable?

Any fork whose software includes commit [`eecffe50efc3944d713c701fa375dacbf17fb7cf`](https://github.com/bitcoin/bitcoin/pull/9049/commits/eecffe50efc3944d713c701fa375dacbf17fb7cf). This would mean any software forked from or pulled in changes from Bitcoin Core after November 10th, 2016.

[Share](/a/79484 "Short permalink to this answer")

[Improve this answer](/posts/79484/edit)

Follow

[edited Jun 16, 2020 at 11:10](/posts/79484/revisions "show all edits to this post")

[![Community's user avatar](https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG)](/users/-1/community)

[Community](/users/-1/community)Bot
1

answered Sep 22, 2018 at 1:23

[![Ava Chow's user avatar](https://www.gravatar.com/avatar/9276bf37b46395e93c63ef1c9ce34011?s=64&d=identicon&r=PG)](/users/48884/ava-chow)

[Ava Chow](/users/48884/ava-chow)♦Ava Chow
72.3k55 gold badges8484 silver badges162162 bronze badges

3

* Would a node that receives the block as a compact block check for the duplicate?
  – [Murch](/users/5406/murch "78,077 reputation")
  ♦
  Commented
  Sep 22, 2018 at 18:16
* 3

  No, it would not. The transaction with the duplicate input would not be in the mempool so it would be sent along with the block (as part of a `blocktxn` message). Such transactions are not run through the mempool acceptance code. Instead the block is reconstructed and run through the normal block acceptance code.
  – [Ava Chow](/users/48884/ava-chow "72,276 reputation")
  ♦
  Commented
  Sep 22, 2018 at 19:04
* Great write-up, thank you! It seems to me having a bool flag such as `fCheckDuplicateInputs` seems pretty unfortunate. It is quite easy to set it to an invalid value. I'm just wondering if we shouldn't be more explicit and verbose in those critical parts
  – [tsusanka](/users/61424/tsusanka "365 reputation")

  Commented
  Sep 26, 2018 at 7:54

Add a comment
 |

## Your Answer

Thanks for contributing an answer to Bitcoin Stack Exchange!

* Please be sure to *answer the question*. Provide details and share your research!

But *avoid* …

* Asking for help, clarification, or responding to other answers.
* Making statements based on opinion; back them up with references or personal experience.

To learn more, see our [tips on writing great answers](/help/how-to-answer).

Draft saved
Draft discarded

### Sign up or [log in](/users/login?ssrc=question_page&returnurl=https%3a%2f%2fbitcoin.stackexchange.com%2fquestions%2f79481%2fhow-does-the-most-recently-found-critical-vulnerability-cve-2018-17144-work%23new-answer)

 Sign up using Google

 Sign up using Email and Password

Submit
### Post as a guest

Name

Email

Required, but never shown

### Post as a guest

Name

Email

Required, but never shown

Post Your Answer

Discard

By clicking “Post Your Answer”, you agree to our [terms of service](https://stackoverflow.com/legal/terms-of-service/public) and acknowledge you have read our [privacy policy](https://stackoverflow.com/legal/privacy-policy).

## Not the answer you're looking for? Browse other questions tagged * [reward-schedule](/questions/tagged/reward-schedule "show questions tagged 'reward-schedule'") * [error](/questions/tagged/error "show questions tagged 'error'") * [weaknesses](/questions/tagged/weaknesses "show questions tagged 'weaknesses'") * [source-code](/questions/tagged/source-code "show questions tagged 'source-code'") or [ask your own question](/questions/ask).

* The Overflow Blog
* [The developer skill you might be neglecting](https://stackoverflow.blog/2025/01/17/the-developer-skill-you-might-be-neglecting/)

#### Linked

[3](/q/79630 "Question score (upvotes - downvotes)")
[Why was this transaction accepted?](/questions/79630/why-was-this-transaction-accepted?noredirect=1)

#### Related

[9](/q/20247 "Question score (upvotes - downvotes)")
[Why does bitcoind say "error: couldn't connect to server" for the first few minutes of boot-up?](/questions/20247/why-does-bitcoind-say-error-couldnt-connect-to-server-for-the-first-few-minu)

[4](/q/22404 "Question score (upvotes - downvotes)")
[Why is Enjoy Sochi a malicious spam attack](/questions/22404/why-is-enjoy-sochi-a-malicious-spam-attack)

[1](/q/30440 "Question score (upvotes - downvotes)")
[What does this mean? RPC\_CLIENT\_NOT\_CONNECTED = -9, // Bitcoin is not connected](/questions/30440/what-does-this-mean-rpc-client-not-connected-9-bitcoin-is-not-connected)

[0](/q/69673 "Question score (upvotes - downvotes)")
[Bitcoin Source Code genesisOutputScript](/questions/69673/bitcoin-source-code-genesisoutputscript)

[1](/q/79979 "Question score (upvotes - downvotes)")
[Where in the source code are transaction validation checks implemented?](/questions/79979/where-in-the-source-code-are-transaction-validation-checks-implemented)

[0](/q/83170 "Question score (upvotes - downvotes)")
[Is there a way to create 9995000 spendable BTC on regtest?](/questions/83170/is-there-a-way-to-create-9995000-spendable-btc-on-regtest)

[1](/q/84791 "Question score (upvotes - downvotes)")
[where in the source code is the the proof of work checking the blockheader hash and nonce?](/questions/84791/where-in-the-source-code-is-the-the-proof-of-work-checking-the-blockheader-hash)

[0](/q/110268 "Question score (upvotes - downvotes)")
[How are there over 18M bitcoins when the reward halves every 210,000 bitcoins?](/questions/110268/how-are-there-over-18m-bitcoins-when-the-reward-halves-every-210-000-bitcoins)

[6](/q/114216 "Question score (upvotes - downvotes)")
[What is the purpose of indexing the mempool by these five criteria?](/questions/114216/what-is-the-purpose-of-indexing-the-mempool-by-these-five-criteria)

[6](/q/118367 "Question score (upvotes - downvotes)")
[How could Bitcoin developers handle and resolve severe software vulnerability without drawing public attention?](/questions/118367/how-could-bitcoin-developers-handle-and-resolve-severe-software-vulnerability-wi)

#### [Hot Network Questions](https://stackexchange.com/questions?tab=hot)

* [Make a set of words tag mail as spam in SpamAssassin](https://serverfault.com/questions/1171274/make-a-set-of-words-tag-mail-as-spam-in-spamassassin)
* [Is it possible/ethical to try to publish results on ones own medical condition as a patient?](https://academia.stackexchange.com/questions/216247/is-it-possible-ethical-to-try-to-publish-results-on-ones-own-medical-condition-a)
* [Homoerotic account of King Minos and Theseus](https://literature.stackexchange.com/questions/28621/homoerotic-account-of-king-minos-and-theseus)
* [What was Gandalf referring to with "ticklish business" and "touch and go"?](https://scifi.stackexchange.com/questions/294346/what-was-gandalf-referring-to-with-ticklish-business-and-touch-and-go)
* [Meandering over ℤ](https://codegolf.stackexchange.com/questions/277750/meandering-over-%E2%84%A4)
* [Does ethical intuitionism solve David Hume's Is-Ought problem?](https://philosophy.stackexchange.com/questions/121768/does-ethical-intuitionism-solve-david-humes-is-ought-problem)
* [How can a character tame a dragon?](https://rpg.stackexchange.com/questions/214436/how-can-a-character-tame-a-dragon)
* [What's the best way to describe the main lines of the WoD to a total newbie without smacking them with the book?](https://rpg.stackexchange.com/questions/214447/whats-the-best-way-to-describe-the-main-lines-of-the-wod-to-a-total-newbie-with)
* [3v<>24v Bidirectional Voltage-Level Translator](https://electronics.stackexchange.com/questions/736561/3v24v-bidirectional-voltage-level-translator)
* [Does GDAL CSV driver ignore "append"?](https://gis.stackexchange.com/questions/489617/does-gdal-csv-driver-ignore-append)
* [Is there a way to convert a standardized logistic regression coefficient into a correlation?](https://stats.stackexchange.com/questions/660270/is-there-a-way-to-convert-a-standardized-logistic-regression-coefficient-into-a)
* [Detail about informal description of Forcing](https://math.stackexchange.com/questions/5025239/detail-about-informal-description-of-forcing)
* [Is it important to know what a number is? Its definition?](https://matheducators.stackexchange.com/questions/28404/is-it-important-to-know-what-a-number-is-its-definition)
* [When an oscilloscope displays a bright, DC-centered dot with "whiskers", what does it mean?](https://electronics.stackexchange.com/questions/736520/when-an-oscilloscope-displays-a-bright-dc-centered-dot-with-whiskers-what-do)
* [How do I enable Wayland in Xubuntu 24.04?](https://askubuntu.com/questions/1538644/how-do-i-enable-wayland-in-xubuntu-24-04)
* [A star and a curve](https://puzzling.stackexchange.com/questions/130153/a-star-and-a-curve)
* [Precision resistance measurement methods](https://electronics.stackexchange.com/questions/736512/precision-resistance-measurement-methods)
* [Stationary beats](https://physics.stackexchange.com/questions/840461/stationary-beats)
* [Applying square function to specific rows of a matrix](https://mathematica.stackexchange.com/questions/310333/applying-square-function-to-specific-rows-of-a-matrix)
* [What does it mean when a software update needs to "send apple events"?](https://apple.stackexchange.com/questions/478106/what-does-it-mean-when-a-software-update-needs-to-send-apple-events)
* [Specialized/hardcoded modular exponentiation circuit for Shor's](https://quantumcomputing.stackexchange.com/questions/40945/specialized-hardcoded-modular-exponentiation-circuit-for-shors)
* [Would two past PhD attempts hinder applications for a third?](https://academia.stackexchange.com/questions/216214/would-two-past-phd-attempts-hinder-applications-for-a-third)
* [Why does the survival function always decrease with time?](https://stats.stackexchange.com/questions/660241/why-does-the-survival-function-always-decrease-with-time)
* [Keep distribution when moving one object](https://blender.stackexchange.com/questions/330023/keep-distribution-when-moving-one-object)

more hot questions

[Question feed](/feeds/question/79481 "Feed of this question and its answers")

# Subscribe to RSS

Question feed

To subscribe to this RSS feed, copy and paste this URL into your RSS reader.

![](/posts/79481/ivc/74e2?prg=9d60a862-03c2-40e2-9905-1fce0f560cf9)

##### [Bitcoin](/)

* [Tour](/tour)
* [Help](/help)
* [Chat](https://chat.stackexchange.com?tab=site&host=bitcoin.stackexchange.com)
* [Contact](/contact)
* [Feedback](https://bitcoin.meta.stackexchange.com)

##### [Company](https://stackoverflow.co/)

* [Stack Overflow](https://stackoverflow.com)
* [Teams](https://stackoverflow.co/teams/)
* [Advertising](https://stackoverflow.co/advertising/)
* [Talent](https://stackoverflow.co/advertising/employer-branding/)
* [About](https://stackoverflow.co/)
* [Press](https://stackoverflow.co/company/press/)
* [Legal](https://stackoverflow.com/legal)
* [Privacy Policy](https://stackoverflow.com/legal/privacy-policy)
* [Terms of Service](https://stackoverflow.com/legal/terms-of-service/public)
* Cookie Settings
* [Cookie Policy](https://stackoverflow.com/legal/cookie-policy)

##### [Stack Exchange Network](https://stackexchange.com)

* [Technology](https://stackexchange.com/sites#technology)
* [Culture & recreation](https://stackexchange.com/sites#culturerecreation)
* [Life & arts](https://stackexchange.com/sites#lifearts)
* [Science](https://stackexchange.com/sites#science)
* [Professional](https://stackexchange.com/sites#professional)
* [Business](https://stackexchange.com/sites#business)
* [API](https://api.stackexchange.com/)
* [Data](https://data.stackexchange.com/)

* [Blog](https://stackoverflow.blog?blb=1)
* [Facebook](https://www.facebook.com/officialstackoverflow/)
* [Twitter](https://twitter.com/stackoverflow)
* [LinkedIn](https://linkedin.com/company/stack-overflow)
* [Instagram](https://www.instagram.com/thestackoverflow)

Site design / logo © 2025 Stack Exchange Inc;
user contributions licensed under
[CC BY-SA](https://stackoverflow.com/help/licensing)
.
rev 2025.1.20.21248



=== Content from eprint.iacr.org_b5be6316_20250121_030604.html ===

# What a lovely hat

#### Is it made out of [tin foil](https://iacr.org/tinfoil.html)?

[![IACR Logo](/img/iacrlogo_small.png)](https://iacr.org/)

[Cryptology ePrint Archive](/)

* Papers
  Updates from the last:+ [7 days](/days/7)
  + [31 days](/days/31)
  + [6 months](/days/183)
  + [365 days](/days/365)
  + ---
  + [Listing by year](/byyear)
  + [All papers](/complete)
  + [Compact view](/complete/compact)
  + [Subscribe](https://www.iacr.org/news/subscribe)
  + ---
  + [How to cite](/citation.html)
  + ---
  + [Harvesting metadata](/rss)
* Submissions
  + [Submit a paper](/submit)
  + [Revise or withdraw a paper](/revise)
  + [Acceptance and publishing conditions](/operations.html)
* About
  + [Goals and history](/about.html)
  + [News](/news.html)
  + [Statistics](/stats)
  + [Contact](/contact.html)

![Search Button](/img/search.svg)

Search

[Advanced search](/search)

#### Paper 2013/279

### Pinocchio: Nearly Practical Verifiable Computation

Bryan Parno, Craig Gentry, Jon Howell, and Mariana Raykova

##### Abstract

To instill greater confidence in computations outsourced to the cloud, clients should be able to verify the correctness of the results returned. To this end, we introduce Pinocchio, a built system for efficiently verifying general computations while relying only on cryptographic assumptions. With Pinocchio, the client creates a public evaluation key to describe her computation; this setup is proportional to evaluating the computation once. The worker then evaluates the computation on a particular input and uses the evaluation key to produce a proof of correctness. The proof is only 288 bytes, regardless of the computation performed or the size of the inputs and outputs. Anyone can use a public verification key to check the proof. Pinocchio achieves strong asymptotic efficiency by refining the Quadratic Arithmetic Programs of Gennaro, Gentry, Parno, and Raykova (EuroCrypt 2013).
Crucially, our evaluation on seven applications demonstrates that Pinocchio is efficient in practice too. Pinocchio's verification time is typically 10ms: 5-7 orders of magnitude less than previous work; indeed Pinocchio is the first general-purpose system to demonstrate per-instance verification cheaper than native execution (for some apps). Pinocchio also reduces the worker's proof effort by an additional 19-60x. As an additional feature, Pinocchio generalizes to zero-knowledge proofs at a negligible cost over the base protocol. Finally, to aid development, Pinocchio provides an end-to-end toolchain that compiles a subset of C into programs that implement the verifiable computation protocol.

##### Metadata

Available format(s)

[![](/img/file-pdf.svg)PDF](/2013/279.pdf)

Category
[Cryptographic protocols](/search?category=PROTOCOLS)
Publication info
Published elsewhere. This is the full version of the IEEE Symposium on Security & Privacy 2013 paper.
Keywords
[verifiable computation](/search?q=verifiable%20computation)[NIZKs](/search?q=NIZKs)[zero knowledge](/search?q=zero%20knowledge)[implementation](/search?q=implementation)
Contact author(s)
parno @ microsoft com

History
2013-05-16: received
Short URL
<https://ia.cr/2013/279>
License
[![Creative Commons Attribution](/img/license/CC_BY.svg "Creative Commons Attribution")

CC BY](https://creativecommons.org/licenses/by/4.0/)

**BibTeX**
![](/img/copy-outline.svg)Copy to clipboard

```

@misc{cryptoeprint:2013/279,
      author = {Bryan Parno and Craig Gentry and Jon Howell and Mariana Raykova},
      title = {Pinocchio: Nearly Practical Verifiable Computation},
      howpublished = {Cryptology {ePrint} Archive, Paper 2013/279},
      year = {2013},
      url = {https://eprint.iacr.org/2013/279}
}

```

[![IACR Logo](/img/iacrlogo_small.png)](https://iacr.org/)

Note: In order to protect the privacy of readers, eprint.iacr.org
does not use cookies or embedded third party content.



=== Content from eprint.iacr.org_02bb8c8b_20250121_030601.html ===

# What a lovely hat

#### Is it made out of [tin foil](https://iacr.org/tinfoil.html)?

[![IACR Logo](/img/iacrlogo_small.png)](https://iacr.org/)

[Cryptology ePrint Archive](/)

* Papers
  Updates from the last:+ [7 days](/days/7)
  + [31 days](/days/31)
  + [6 months](/days/183)
  + [365 days](/days/365)
  + ---
  + [Listing by year](/byyear)
  + [All papers](/complete)
  + [Compact view](/complete/compact)
  + [Subscribe](https://www.iacr.org/news/subscribe)
  + ---
  + [How to cite](/citation.html)
  + ---
  + [Harvesting metadata](/rss)
* Submissions
  + [Submit a paper](/submit)
  + [Revise or withdraw a paper](/revise)
  + [Acceptance and publishing conditions](/operations.html)
* About
  + [Goals and history](/about.html)
  + [News](/news.html)
  + [Statistics](/stats)
  + [Contact](/contact.html)

![Search Button](/img/search.svg)

Search

[Advanced search](/search)

#### Paper 2013/879

### Succinct Non-Interactive Zero Knowledge for a von Neumann Architecture

Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza

##### Abstract

We build a system that provides succinct non-interactive zero-knowledge proofs (zk-SNARKs) for program executions on a von Neumann RISC architecture. The system has two components: a cryptographic proof system for verifying satisfiability of arithmetic circuits, and a circuit generator to translate program executions to such circuits. Our design of both components improves in functionality and efficiency over prior work, as follows.
Our circuit generator is the first to be universal: it does not need to know the program, but only a bound on its running time. Moreover, the size of the output circuit depends additively (rather than multiplicatively) on program size, allowing verification of larger programs.
The cryptographic proof system improves proving and verification times, by leveraging new algorithms and a pairing library tailored to the protocol.
We evaluated our system for programs with up to 10,000 instructions, running for up to 32,000 machine steps, each of which can arbitrarily access random-access memory; and also demonstrated it executing programs that use just-in-time compilation. Our proofs are 230 bytes long at 80 bits of security, or 288 bytes long at 128 bits of security. Typical verification time is 5 milliseconds, regardless of the original program's running time.

**Note:** The updated version fixes an error in Appendix B, found by Ariel Gabizon.

##### Metadata

Available format(s)

[![](/img/file-pdf.svg)PDF](/2013/879.pdf)

Category
[Cryptographic protocols](/search?category=PROTOCOLS)
Publication info
Published elsewhere. Minor revision. USENIX Security 2014
Keywords
[zero-knowledge](/search?q=zero-knowledge)[succinct arguments](/search?q=succinct%20arguments)[computationally-sound proofs](/search?q=computationally-sound%20proofs)
Contact author(s)
alexch @ csail mit edu

History
2019-02-05: last of 8 revisions
2013-12-30: received
[See all versions](/archive/versions/2013/879)
Short URL
<https://ia.cr/2013/879>
License
[![Creative Commons Attribution](/img/license/CC_BY.svg "Creative Commons Attribution")

CC BY](https://creativecommons.org/licenses/by/4.0/)

**BibTeX**
![](/img/copy-outline.svg)Copy to clipboard

```

@misc{cryptoeprint:2013/879,
      author = {Eli Ben-Sasson and Alessandro Chiesa and Eran Tromer and Madars Virza},
      title = {Succinct Non-Interactive Zero Knowledge for a von Neumann Architecture},
      howpublished = {Cryptology {ePrint} Archive, Paper 2013/879},
      year = {2013},
      url = {https://eprint.iacr.org/2013/879}
}

```

[![IACR Logo](/img/iacrlogo_small.png)](https://iacr.org/)

Note: In order to protect the privacy of readers, eprint.iacr.org
does not use cookies or embedded third party content.



=== Content from github.com_088a774a_20250121_030606.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FMyHush%2Fhush)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FMyHush%2Fhush)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=MyHush%2Fhush)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[MyHush](/MyHush)
/
**[hush](/MyHush/hush)**
Public

* [Notifications](/login?return_to=%2FMyHush%2Fhush) You must be signed in to change notification settings
* [Fork
  37](/login?return_to=%2FMyHush%2Fhush)
* [Star
   67](/login?return_to=%2FMyHush%2Fhush)

Hush is a fork of Zcash focused on secure communications

[myhush.org](https://myhush.org "https://myhush.org")

### License

[View license](/MyHush/hush/blob/master/COPYING)

[67
stars](/MyHush/hush/stargazers) [37
forks](/MyHush/hush/forks) [Branches](/MyHush/hush/branches) [Tags](/MyHush/hush/tags) [Activity](/MyHush/hush/activity)
 [Star](/login?return_to=%2FMyHush%2Fhush)

 [Notifications](/login?return_to=%2FMyHush%2Fhush) You must be signed in to change notification settings

* [Code](/MyHush/hush)
* [Issues
  32](/MyHush/hush/issues)
* [Pull requests
  4](/MyHush/hush/pulls)
* [Actions](/MyHush/hush/actions)
* [Projects
  0](/MyHush/hush/projects)
* [Wiki](/MyHush/hush/wiki)
* [Security](/MyHush/hush/security)
* [Insights](/MyHush/hush/pulse)

Additional navigation options

* [Code](/MyHush/hush)
* [Issues](/MyHush/hush/issues)
* [Pull requests](/MyHush/hush/pulls)
* [Actions](/MyHush/hush/actions)
* [Projects](/MyHush/hush/projects)
* [Wiki](/MyHush/hush/wiki)
* [Security](/MyHush/hush/security)
* [Insights](/MyHush/hush/pulse)

# MyHush/hush

    master[Branches](/MyHush/hush/branches)[Tags](/MyHush/hush/tags)Go to fileCode
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit History[11,254 Commits](/MyHush/hush/commits/master/) | | |
| [.github](/MyHush/hush/tree/master/.github ".github") | | [.github](/MyHush/hush/tree/master/.github ".github") |  |  |
| [build-aux/m4](/MyHush/hush/tree/master/build-aux/m4 "This path skips through empty directories") | | [build-aux/m4](/MyHush/hush/tree/master/build-aux/m4 "This path skips through empty directories") |  |  |
| [contrib](/MyHush/hush/tree/master/contrib "contrib") | | [contrib](/MyHush/hush/tree/master/contrib "contrib") |  |  |
| [depends](/MyHush/hush/tree/master/depends "depends") | | [depends](/MyHush/hush/tree/master/depends "depends") |  |  |
| [doc](/MyHush/hush/tree/master/doc "doc") | | [doc](/MyHush/hush/tree/master/doc "doc") |  |  |
| [qa](/MyHush/hush/tree/master/qa "qa") | | [qa](/MyHush/hush/tree/master/qa "qa") |  |  |
| [share](/MyHush/hush/tree/master/share "share") | | [share](/MyHush/hush/tree/master/share "share") |  |  |
| [src](/MyHush/hush/tree/master/src "src") | | [src](/MyHush/hush/tree/master/src "src") |  |  |
| [zcutil](/MyHush/hush/tree/master/zcutil "zcutil") | | [zcutil](/MyHush/hush/tree/master/zcutil "zcutil") |  |  |
| [.gitattributes](/MyHush/hush/blob/master/.gitattributes ".gitattributes") | | [.gitattributes](/MyHush/hush/blob/master/.gitattributes ".gitattributes") |  |  |
| [.gitignore](/MyHush/hush/blob/master/.gitignore ".gitignore") | | [.gitignore](/MyHush/hush/blob/master/.gitignore ".gitignore") |  |  |
| [CONTRIBUTING.md](/MyHush/hush/blob/master/CONTRIBUTING.md "CONTRIBUTING.md") | | [CONTRIBUTING.md](/MyHush/hush/blob/master/CONTRIBUTING.md "CONTRIBUTING.md") |  |  |
| [COPYING](/MyHush/hush/blob/master/COPYING "COPYING") | | [COPYING](/MyHush/hush/blob/master/COPYING "COPYING") |  |  |
| [INSTALL.md](/MyHush/hush/blob/master/INSTALL.md "INSTALL.md") | | [INSTALL.md](/MyHush/hush/blob/master/INSTALL.md "INSTALL.md") |  |  |
| [Makefile.am](/MyHush/hush/blob/master/Makefile.am "Makefile.am") | | [Makefile.am](/MyHush/hush/blob/master/Makefile.am "Makefile.am") |  |  |
| [README.md](/MyHush/hush/blob/master/README.md "README.md") | | [README.md](/MyHush/hush/blob/master/README.md "README.md") |  |  |
| [SECURE\_SETUP.md](/MyHush/hush/blob/master/SECURE_SETUP.md "SECURE_SETUP.md") | | [SECURE\_SETUP.md](/MyHush/hush/blob/master/SECURE_SETUP.md "SECURE_SETUP.md") |  |  |
| [Testnet.md](/MyHush/hush/blob/master/Testnet.md "Testnet.md") | | [Testnet.md](/MyHush/hush/blob/master/Testnet.md "Testnet.md") |  |  |
| [autogen.sh](/MyHush/hush/blob/master/autogen.sh "autogen.sh") | | [autogen.sh](/MyHush/hush/blob/master/autogen.sh "autogen.sh") |  |  |
| [code\_of\_conduct.md](/MyHush/hush/blob/master/code_of_conduct.md "code_of_conduct.md") | | [code\_of\_conduct.md](/MyHush/hush/blob/master/code_of_conduct.md "code_of_conduct.md") |  |  |
| [configure.ac](/MyHush/hush/blob/master/configure.ac "configure.ac") | | [configure.ac](/MyHush/hush/blob/master/configure.ac "configure.ac") |  |  |
| [libzcashconsensus.pc.in](/MyHush/hush/blob/master/libzcashconsensus.pc.in "libzcashconsensus.pc.in") | | [libzcashconsensus.pc.in](/MyHush/hush/blob/master/libzcashconsensus.pc.in "libzcashconsensus.pc.in") |  |  |
| [release\_notes.md](/MyHush/hush/blob/master/release_notes.md "release_notes.md") | | [release\_notes.md](/MyHush/hush/blob/master/release_notes.md "release_notes.md") |  |  |
| View all files | | |

## Repository files navigation

* README
* Code of conduct
* License
# HUSH 2.0.0

## What is HUSH?

[![Logo](/MyHush/hush/raw/master/doc/hush/hush.png "Logo")](/MyHush/hush/blob/master/doc/hush/hush.png)

HUSH (formerly Zdash) is a code fork of [ZCash](https://z.cash/) which has it's own genesis block.
Based on Bitcoin's code, it intends to offer a far higher standard of privacy
through a sophisticated zero-knowledge proving scheme that preserves
confidentiality of transaction metadata.

This software is the HUSH node and command-line client. It downloads and stores the entire history
of HUSH transactions; depending on the speed of your computer and network
connection, the synchronization process could take a day or more once the
blockchain has reached a significant size.

**HUSH is unfinished and highly experimental.** Use at your own risk!

## Discord

Please feel free to join us on Discord at <https://myhush.org/discord.html> .
There are many channels, some you might enjoy are #general, #support and #mining.

## Forum

<https://forum.myhush.org/>

## Installing

See [INSTALL.md](https://github.com/MyHush/hush/blob/master/INSTALL.md).

## Bootstrap Nodes

Choose to add any of the following bootstrap nodes, per your preferred network configuration, to speed up peer discovery. Utilize `addnode=HOSTNAME` in your `hush.conf` file.

**IPV4**

* dnsseed.myhush.org
* dnsseed2.myhush.org
* stilgar.myhush.org
* explorer.myhush.org
* dnsseed.bleuzero.com
* dnsseed.hush.quebec

**IPV6**

* [2607:4f00:0:509::4]
* [2607:4f00:0:509::3]
* [2607:5300:60:341d::1]
* [2001:41d0:d:691::]
* [2a02:c207:2008:8708::1]
* [2001:470:1f09:3b6:7285:c2ff:fe0e:1664]
* [2a02:908:162:67dc:225:90ff:fe50:2b9b]

**Hush on Tor**

* hushwgexvojlkuhl.onion
* ozumguh2lk6uvcc3.onion
* hushnodejbnzyvfk.onion
* hushnodexptkgea3.onion
* keyrx4lugtnya7ax.onion
* j7h7df2tylc57xeo.onion

---

**Hush is experimental and a work-in-progress.** Use at your own risk.

## Testnet

<https://github.com/MyHush/hush/blob/master/Testnet.md>

## Secure Setup

<https://github.com/MyHush/hush/blob/master/SECURE_SETUP.md>

## Deprecation Policy

This release is considered deprecated 16 weeks after the release day. There
is an automatic deprecation shutdown feature which will halt the node some
time after this 52 week time period. The automatic feature is based on block
height and can be explicitly disabled.

## Where do I begin?

As a reference a guide for joining the main Zcash network may be used:
<https://github.com/zcash/zcash/wiki/1.0-User-Guide#using-zcash>
Users should *not* follow this guide blindly since it applies to ZCash instead of HUSH!
The section of using the command line is relevant to HUSH.

### Need Help?

* See the documentation at the [Zcash Wiki](https://github.com/zcash/zcash/wiki)
  for help and more general information.

### Not content with command line use of HUSH?

A [HUSH GUI Wallet](https://github.com/MyHush/hush-swing-wallet-ui/releases)

## License

For license information see the file [COPYING](/MyHush/hush/blob/master/COPYING).

## About

Hush is a fork of Zcash focused on secure communications

[myhush.org](https://myhush.org "https://myhush.org")

### Resources

[Readme](#readme-ov-file)
### License

[View license](#License-1-ov-file)
### Code of conduct

[Code of conduct](#coc-ov-file)

[Activity](/MyHush/hush/activity)
[Custom properties](/MyHush/hush/custom-properties)
### Stars

[**67**
stars](/MyHush/hush/stargazers)
### Watchers

[**28**
watching](/MyHush/hush/watchers)
### Forks

[**37**
forks](/MyHush/hush/forks)
[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2FMyHush%2Fhush&report=MyHush+%28user%29)

## [Releases 3](/MyHush/hush/releases)

[Hush 2.0.0
Latest

Oct 8, 2018](/MyHush/hush/releases/tag/v2.0.0)
[+ 2 releases](/MyHush/hush/releases)

## [Packages 0](/orgs/MyHush/packages?repo_name=hush)

No packages published

## [Contributors 371](/MyHush/hush/graphs/contributors)

[+ 357 contributors](/MyHush/hush/graphs/contributors)

## Languages

* [C++
  74.5%](/MyHush/hush/search?l=c%2B%2B)
* [Python
  9.6%](/MyHush/hush/search?l=python)
* [C
  8.9%](/MyHush/hush/search?l=c)
* [M4
  2.3%](/MyHush/hush/search?l=m4)
* [Shell
  1.9%](/MyHush/hush/search?l=shell)
* [Makefile
  1.3%](/MyHush/hush/search?l=makefile)
* Other
  1.5%

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_e0296fff_20250121_005554.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FJinBean%2FCVE-Extension)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FJinBean%2FCVE-Extension)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=JinBean%2FCVE-Extension)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[JinBean](/JinBean)
/
**[CVE-Extension](/JinBean/CVE-Extension)**
Public

* [Notifications](/login?return_to=%2FJinBean%2FCVE-Extension) You must be signed in to change notification settings
* [Fork
  4](/login?return_to=%2FJinBean%2FCVE-Extension)
* [Star
   3](/login?return_to=%2FJinBean%2FCVE-Extension)

This repository is an extension of our research on cryptocurrency clones and documents existing vulnerabilities discovered in those clones

[3
stars](/JinBean/CVE-Extension/stargazers) [4
forks](/JinBean/CVE-Extension/forks) [Branches](/JinBean/CVE-Extension/branches) [Tags](/JinBean/CVE-Extension/tags) [Activity](/JinBean/CVE-Extension/activity)
 [Star](/login?return_to=%2FJinBean%2FCVE-Extension)

 [Notifications](/login?return_to=%2FJinBean%2FCVE-Extension) You must be signed in to change notification settings

* [Code](/JinBean/CVE-Extension)
* [Issues
  0](/JinBean/CVE-Extension/issues)
* [Pull requests
  0](/JinBean/CVE-Extension/pulls)
* [Actions](/JinBean/CVE-Extension/actions)
* [Projects
  0](/JinBean/CVE-Extension/projects)
* [Security](/JinBean/CVE-Extension/security)
* [Insights](/JinBean/CVE-Extension/pulse)

Additional navigation options

* [Code](/JinBean/CVE-Extension)
* [Issues](/JinBean/CVE-Extension/issues)
* [Pull requests](/JinBean/CVE-Extension/pulls)
* [Actions](/JinBean/CVE-Extension/actions)
* [Projects](/JinBean/CVE-Extension/projects)
* [Security](/JinBean/CVE-Extension/security)
* [Insights](/JinBean/CVE-Extension/pulse)

# JinBean/CVE-Extension

    master[Branches](/JinBean/CVE-Extension/branches)[Tags](/JinBean/CVE-Extension/tags)Go to fileCode
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit History[23 Commits](/JinBean/CVE-Extension/commits/master/) | | |
| [CVE-2016-10724](/JinBean/CVE-Extension/tree/master/CVE-2016-10724 "CVE-2016-10724") | | [CVE-2016-10724](/JinBean/CVE-Extension/tree/master/CVE-2016-10724 "CVE-2016-10724") |  |  |
| [CVE-2018-17144](/JinBean/CVE-Extension/tree/master/CVE-2018-17144 "CVE-2018-17144") | | [CVE-2018-17144](/JinBean/CVE-Extension/tree/master/CVE-2018-17144 "CVE-2018-17144") |  |  |
| [CVE-2019-7167](/JinBean/CVE-Extension/tree/master/CVE-2019-7167 "CVE-2019-7167") | | [CVE-2019-7167](/JinBean/CVE-Extension/tree/master/CVE-2019-7167 "CVE-2019-7167") |  |  |
| [README.md](/JinBean/CVE-Extension/blob/master/README.md "README.md") | | [README.md](/JinBean/CVE-Extension/blob/master/README.md "README.md") |  |  |
| View all files | | |

## Repository files navigation

* README
# CVE Extensions

This repository is an extension of our research on cryptocurrency clones and vulnerabilities that takes existing vulnerabilities in major coins and uses clone detection tools as a method of identifying propagation of these vulnerabilities in other coins.

List of documented CVEs

1. [CVE-2018-17144](#cve-2018-17144)
2. [CVE-2019-7167](#cve-2019-7167)
3. [CVE-2016-10724](#cve-2016-10724)
4. [CVE-2016-10725](#cve-2016-10725)

---

## CVE-2018-17144

[National Vulnerability Database (NVD) Report](https://nvd.nist.gov/vuln/detail/CVE-2018-17144)

A reachable assert statement in Bitcoin Core allows a remote denial of service (application crash) exploitable by miners via attempting to double-spend a transaction insinde a mined block. This CVE also later leads to an inflation bug, which we do not focus on here.

The code relevant to this vulnerability can be found in the file `validation.cpp` of Bitcoin Core 0.14.X.
This specific file can be found [here](https://github.com/JinBean/CVE-Extension/tree/master/CVE-2018-17144/Bitcoin-0.14.X).

When a block containing a double spent transaction is validated, it skips the duplicate input check because of the false parameter [here](https://github.com/JinBean/CVE-Extension/blob/master/CVE-2018-17144/Bitcoin-0.14.X/validation.cpp#L2883). The double spend will reach the function [UpdateCoins()](https://github.com/JinBean/CVE-Extension/blob/master/CVE-2018-17144/Bitcoin-0.14.X/validation.cpp#L1323), and the inputs to the transaction are being marked as spent in the Unspent Transaction Output(UTXO) database. The first time the transaction is seen, the coins involved are marked as spent. Since the coins involved in the transaction are already marked as spent, the second time the transaction is seen, `coins->vout[nPos].IsNull()` will be true. It will then enter this [if statement](https://github.com/JinBean/CVE-Extension/blob/master/CVE-2018-17144/Bitcoin-0.14.X/validation.cpp#L1332) and subsequently execute the assert statement that follows. The assert then causes the node to crash, resulting in the denial of service vulnerability. (Paraphrased from Source 2)

The coin(s) that we found to still contain this vulnerability as of 26/3/2019 include:

* [Irlecoin](https://github.com/irlecoin/irlecoin)
* [MinexCoin](https://github.com/minexcoin/minexcoin) (Fixed)
* [MktCoin](https://github.com/mktcoin/mktcoin)
* [PlatinCoin](https://github.com/platincoin-project/platincoin)
* [QuasarCoin](https://github.com/quasarcoin/quasar)
* [TCOIN](https://github.com/koba24/tcoin)

**Total Coins: 6**

These coin(s) still contain unpatched instances of the vulnerability in their code base which can be found [here](https://github.com/JinBean/CVE-Extension/tree/master/CVE-2018-17144)

### Sources:

1. [CVE-2018-17144 Full Disclosure](https://bitcoincore.org/en/2018/09/20/notice/)
2. [Andrew Chow, Bitcoin StackExchange](https://bitcoin.stackexchange.com/questions/79481/how-does-the-most-recently-found-critical-vulnerability-cve-2018-17144-work/79484#79484)

---

## CVE-2019-7167

[National Vulnerability Database (NVD) Report](https://nvd.nist.gov/vuln/detail/CVE-2019-7167)

BCTV14 setup produces elements that violate soundness, misleading the original Sprout zk-SNARK verifier into accepting the correctness of a transaction. This allows an attacker to create very large, virtually unlimited amounts of counterfeit shielded tokens without detection. Zcash has switched to different parameters using a new “Sprout-on-Groth16” proving system as of the Sapling network upgrade on October 28th 2018, and so is not affected by the bug.

The code relevant to this vulnerability can be found in the file `JoinSplit.cpp` of Zcash 1.X.
This specific file can be found [here](https://github.com/JinBean/CVE-Extension/blob/master/CVE-2019-7167/Zcash-1.X/JoinSplit.cpp).

The coin(s) that we found to still contain this vulnerability as of 27/5/2019 include:

* [Hush](https://github.com/MyHush/hush)

**Total Coins: 1**

These coin(s) still contain unpatched instances of the vulnerability in their code base which can be found [here](https://github.com/JinBean/CVE-Extension/tree/master/CVE-2019-7167)

### Sources:

1. [Zcash blog disclosure])(<https://z.cash/blog/zcash-counterfeiting-vulnerability-successfully-remediated/>)

---

## CVE-2016-10724 / CVE-2016-10725

These two vulnerabilites are closely related and hence are grouped in the same section. All coins presented in this section are vulnerable to both vulnerabilities.

### CVE-2016-10724

[National Vulnerability Database (NVD) Report](https://nvd.nist.gov/vuln/detail/CVE-2016-10724)

A remote network alert system originating from Bitcoin allows the denial of service (memory exhaustion) if an attacker can sign a message with a certain private key that had been known by unintended actors. Due to an infinitely sized map, an attacker can send a large number of alerts (or very large alerts, or both) to a node, causing the node to run out of memory and crash.

### CVE-2016-10725

[National Vulnerability Database (NVD) Report](https://nvd.nist.gov/vuln/detail/CVE-2016-10725)

A 'final alert' was developed to prevent attackers from abusing CVE-2016-10724, which comprises a maximum ID alert that overrides all previous alerts. A final alert is an alert that meets the following conditions [here](https://github.com/JinBean/CVE-Extension/blob/master/CVE-2016-10724/Bitcoin-0.12.X/alert.cpp#L190-L196). However, due to alerts being classified by their hashes, any alert can be classified as a final alert, which can also cause the the node to run out of memory.
Final alerts are also supposed to be uncancellable, but can inadvertently be cancelled. Alerts first check they cancel any existing alert. Then they are checked for whether any of the remaining alerts cancel it. Because of this order, it is possible to create an alert which cancels a final alert before the node checks whether that alert is cancelled by the final alert. Thus an attacker can cancel a final alert with another alert allowing a node to also be vulnerable to CVE-2016-10724.

The alert system in itself also creates a centralized source in the cryptocurrency. Bitcoin has since deprecated the alert system entirely.
Bitcoin has also released a patch for the alert vulnerability which can be found [here](https://gist.github.com/achow101/02d03238090691558a68010a9ccbbf9d)

The code relevant to these vulnerabilities can be found in the file `alert.cpp` of Bitcoin 0.12.X.
This specific file can be found [here](https://github.com/JinBean/CVE-Extension/blob/master/CVE-2016-10724/Bitcoin-0.12.X/alert.cpp).

The coin(s) that we found to still contain both CVE-2016-10724 and CVE-2016-10745 as of 14/6/2019 include:

* [Absolute](https://github.com/absolute-community/absolute)
* [Adirondack](https://github.com/adirondackcoin/Adirondack)
* [AdultChain](https://github.com/AdultChain/AdultChain)
* [Advance](https://github.com/AdvanceProtocol/advance)
* [Aegeus](https://github.com/AegeusCoin/aegeus)
* [Afro](https://github.com/afro/afro)
* [AGNI coin](https://github.com/agnicoin/agni)
* [Airin](https://github.com/airincoin/airin)
* [Alpha](https://github.com/alp-project/AlphaCoin)
* [ALQO](https://github.com/alqocrypto/alqo)
* [Amero](https://github.com/bitcosur/Amero)
* [Amnesia](https://github.com/amnesiacoin/amnesia)
* [ANODOS](https://github.com/anodoscoin/anodoscoin)
* [ANON](https://github.com/anonymousbitcoin/anon)
* [APEIRON](https://github.com/apeironcoin/apeiron)
* [Apollon](https://github.com/apollondeveloper/ApollonCoin)
* [AquariusCoin](https://github.com/AquariusNetwork/ARCO)
* [Aquila](https://github.com/aquilacoin/AquilaX)
* [ArcticCoin](https://github.com/ArcticCore/arcticcoin)
* [ARGO](https://github.com/argocoins/argo)
* [Aricoin](https://github.com/aricoin/aricoin)
* [Arion](https://github.com/arioncoin/arioncoin)
* [ARTAX](https://github.com/artaxcommittee/Artax)
* [Artiqox](https://github.com/artiqox/artiqox)
* [AudioCoin](https://github.com/aurovine/audiocoin)
* [Auroracoin](https://github.com/aurarad/auroracoin)
* [B3Coin](https://github.com/B3-Coin/B3-CoinV2)
* [BANQ](https://github.com/banq-platform/banq)
* [Baxur](https://github.com/baxurdev/baxur)
* [Bettex coin](https://github.com/bettexproject/bettexcoin)
* [BiblePay](https://github.com/biblepay/biblepay)
* [Bifrost](https://github.com/bifrost-actual/bifrost-coin)
* [Birake](https://github.com/birake/birakecoin)
* [BitBay](https://github.com/dzimbeck/BitBay)
* [Bitcloud](https://github.com/LIMXTEC/Bitcloud)
* [Bitcoin 2](https://github.com/BITC2/bitcoin2)
* [Bitcoin Adult](https://github.com/BitcoinAdult/BitcoinAdult-Source-Code)
* [Bitcoin Final](https://github.com/bitcoinfinal/BitcoinFinal)
* [Bitcoin Lightning](https://github.com/Bitcoinlightning/Bitcoin-Lightning)
* [Bitcoin Private](https://github.com/BTCPrivate/BitcoinPrivate)
* [Bitcoin W Spectrum](https://github.com/raymaker/bitcoinwspectrum)
* [BitcoinZ](https://github.com/bitcoinz-pod/bitcoinz)
* [Bitcurrency](https://github.com/tokyoghetto/BitCurrencyPro)
* [BitF](https://github.com/BitFdev/BitF-source-code)
* [Bithold](https://github.com/Bitholddev/Bithold)
* [BitNodes Pro](https://github.com/bitnodes/bitnodespro)
* [Bitradio](https://github.com/thebitradio/Bitradio)
* [BitRewards](https://github.com/BitRewardsCoin/BitRewards)
* [BlackCoin](https://github.com/CoinBlack/blackcoin)
* [Blocknet](https://github.com/BlocknetDX/BlockDX)
* [Blocknode](https://github.com/blocknodetech/blocknode)
* [Braincoin](https://github.com/axelxod/braincoin)
* [BUCK](https://github.com/BuckCoin/buck)
* [Bullion](https://github.com/elambert2014/bullion)
* [Bulwark](https://github.com/bulwark-crypto/Bulwark)
* [BuzzCoin](https://github.com/buzzcoin-project/BUZZ)
* [Capital Coin](https://github.com/Cap-Project/CapitalCoin)
* [Capra Coin](https://github.com/zero24x/capracoin)
* [Carboncoin](https://github.com/carboncointrust/CarboncoinCore)
* [CardBuyers](https://github.com/CARDbuyers/BCARD)
* [Carebit](https://github.com/carebitcoin/carebitcoin)
* [CatoCoin](https://github.com/CatoCoin/CatoCoin)
* [Cazcoin](https://github.com/copicogithub1/cazcoin)
* [Cerberus](https://github.com/cerberus-ng/cerberus)
* [CHEESE](https://github.com/CheeseCoin/CheeseMasternode)
* [Clams](https://github.com/nochowderforyou/clams)
* [Coin2Play](https://github.com/Coin2Play/c2pcore)
* [CoinonatX](https://github.com/xcxt-community/CoinonatX)
* [ColossusXT](https://github.com/ColossusCoinXT/ColossusCoinXT)
* [Community coin](https://github.com/cmccommunity/communitycoin)
* [Concierge coin](https://github.com/ConciergeCoin/Concierge)
* [Condominium Coin](https://github.com/condominium/CondominiumCore)
* [Copico](https://github.com/copicogithub1/copico)
* [COREZ](https://github.com/corezcrypto/corez)
* [Cosmos Coin](https://github.com/CMOS-Project/Cosmos)
* [Crave](https://github.com/Crave-Project/Crave-NG)
* [Cropcoin](https://github.com/Cropdev/CropDev)
* [CrowdCoin](https://github.com/crowdcoinChain/Crowdcoin)
* [Crown](https://github.com/Crowndev/crown-core)
* [Cryply](https://github.com/cryply/cryply-wallet)
* [Cryptoflow](https://github.com/CryptoFlowCoin/CryptoFlowCoin)
* [Cryptonite](https://github.com/MiniblockchainProject/Cryptonite)
* [Cryptonodes](https://github.com/cryptonodes-core/cryptonodes-core)
* [CUBEX](https://github.com/cubex-network/cubex)
* [Curium](https://github.com/curiumofficial/curium)
* [CurveCoin](https://github.com/curvecoin/curve)
* [DEMOS PAY](https://github.com/DemosPay/DemosPay)
* [Desire](https://github.com/lazyboozer/Desire)
* [Deuscoin](https://github.com/deuscoin-org/deuscoin-core)
* [Deutsche eMark](https://github.com/emarkproject/eMark)
* [Deviant Coin](https://github.com/Deviantcoin/Source)
* [Dextro](https://github.com/dextrocoin/dextro)
* [Diamond](https://github.com/DMDcoin/Diamond)
* [DigiMoney](https://github.com/digimoneydgm/digimoney)
* [Digitalcoin](https://github.com/DGCDev/digitalcoin)
* [DigitalPrice](https://github.com/DigitalPrice/DigitalPrice)
* [Digiwage](https://github.com/digiwage/digiwage)
* [Dividend Cash](https://github.com/dividendcash/dividendcash)
* [DIXIcoin](https://github.com/Dixicoin-DXC/Dixicoin)
* [Dogecoin](https://github.com/dogecoin/dogecoin)
* [Dravite](https://github.com/dravitecoin/dravite)
* [Dynamic](https://github.com/duality-solutions/Dynamic)
* [Dystem](https://github.com/Dystem/dystem-core)
* [EA Coin](https://github.com/eacoin-project/eacore)
* [EarnzCoin](https://github.com/Frenzel1337/EarnzCoin)
* [Elbrus](https://github.com/Elbruscurrency/EBSCoin)
* [Ellerium Project](https://github.com/ElleriumProject/Elleriumv2)
* [Elliot Coin](https://github.com/elliotproject/elli)
* [Elliotcoin](https://github.com/elliotproject/elli)
* [EmerCoin](https://github.com/EvgenijM86/emercoin)
* [Emrals](https://github.com/Emrals/emrals)
* [Epic](https://github.com/EpicCoinDev/Epic)
* [Eternity](https://github.com/eternity-group/eternity)
* [Ethereum Cash](https://github.com/ethereumcashdev/ethereumcash)
* [ExclusiveCoin](https://github.com/exclfork/ExclusiveCoin)
* [Exsolution](https://github.com/exsolution/ext-wallet)
* [EXUS Coin](https://github.com/exuscoin/exus)
* [Fantasy Cash](https://github.com/FootyCash/FootyCashV2)
* [Fantasy Gold](https://github.com/FantasyGold/FantasyGold-Core)
* [FEIRM](https://github.com/feirm/feirm)
* [FLCoin](https://github.com/cryptofreelance/FLCoin)
* [Folm](https://github.com/folm/folm)
* [Force Network](https://github.com/forceunited/force)
* [Francs](https://github.com/FRN-Crypto/FRN)
* [Freicoin](https://github.com/freicoin/freicoin)
* [FriendshipCoin](https://github.com/friendshipCoin/friendshipcoin-core)
* [Frozen](https://github.com/frznice/frozen)
* [FuturoCoin](https://github.com/futuro-coin/Futuro)
* [Gainer](https://github.com/gainercoin/gainercoin)
* [GambleCoin](https://github.com/GambleCoin-Project/GambleCoin)
* [GameCredits](https://github.com/gamers-coin/GameCredits)
* [GenesisX](https://github.com/genesis-x/genesis-x)
* [Gentarium](https://github.com/genterium-project/gentarium)
* [GeyserCoin](https://github.com/geysercoin/geysercoin)
* [Giant](https://github.com/GiantPay/GiantCore)
* [Globycoin](https://github.com/Globycoin/glbcore)
* [GoaCoin](https://github.com/goacoincore/goacoin)
* [GoByte](https://github.com/gobytecoin/gobyte)
* [Gold Poker](https://github.com/GoldPoker/GoldPoker-coin)
* [GoldBlocks](https://github.com/goldblockscoin/goldblocks)
* [Graphcoin](https://github.com/Graphcoin/source)
* [Gravium](https://github.com/Gravium/gravium)
* [Growers International](https://github.com/growersintl/growers)
* [Guardian Coin](https://github.com/guardiancoin/GDNC)
* [Harvest Masternode Coin](https://github.com/HarvestMasternodecoin/Harvestcoin)
* [HeldCoin](https://github.com/heldcoindev/HeldCoin)
* [Helium Chain](https://github.com/heliumchain/helium)
* [Help The Homeless Coin](https://github.com/HTHcoin/HTH)
* [Helpico](https://github.com/AnonymousDo/Helpico)
* [Hera Coin](https://github.com/Heraproject/HeraCoin)
* [HERB](https://github.com/herbcoin/herb)
* [HiddenTalk](https://github.com/htkcoin/htk)
* [High Temperature Coin](https://github.com/htrcoin/htrcoin)
* [HIGHLAND](https://github.com/highlandpay/highlandcoin)
* [Hilux](https://github.com/swatchie-1/hilux)
* [Hobonickels](https://github.com/Crypto-Expert/HoboNickels)
* [Horizen](https://github.com/ZencashOfficial/zen)
* [Hush](https://github.com/J-Stuhlman/zdash)
* [I0Coin](https://github.com/domob1812/i0coin)
* [Ignition](https://github.com/ignitioncoin/ignitioncoin)
* [ImageCash](https://github.com/mceme/ImageCash)
* [INDINODE](https://github.com/coinwebfactory/indinode)
* [Infinex](https://github.com/InfinexOfficial/Infinex)
* [Infinipay](https://github.com/infinipay/infinipay)
* [Innoket](https://github.com/innoket-dev/innoket-master)
* [Innova](https://github.com/innovacoin/innova)
* [INSaNe](https://github.com/CryptoCoderz/INSN)
* [InstaDEX](https://github.com/InstaDex-Coin/InstaDEX)
* [Interstellar Holdings](https://github.com/InterstellarHoldings/InterstellarHoldings)
* [Interzone](https://github.com/projectinterzone/ITZ)
* [ION](https://github.com/ionomy/ion)
* [IPSUM](https://github.com/ipsum-network/ips)
* [Jiyo](https://github.com/jiyocoin/jiyo-core)
* [Joulecoin](https://github.com/joulecoin/joulecoin)
* [Kaicoin](https://github.com/kaicoin-io/kaicoin-full-node)
* [Kalkulus](https://github.com/kalkulusteam/klks)
* [Keyco](https://github.com/keycoteam/keyco)
* [KRAIT](https://github.com/KRAITcoin/Krait)
* [Kraken Coin](https://github.com/KrakenCoins/Kraken)
* [Kzcash](https://github.com/kzcashteam/kzcash)
* [LanaCoin](https://github.com/LanaCoin/lanacoin)
* [Landcoin](https://github.com/landcoin-ldc/landcoin)
* [LasVegasCoin](https://github.com/Vegas-Guy/LasVegasCoin2)
* [League Coin](https://github.com/LGACoin/League)
* [Legion Coin](https://github.com/Legioncrypto/Legion)
* [LemonCoin](https://github.com/lemoncoin-project/lemoncoin)
* [LetItRide](https://github.com/shogdite/letitride)
* [Liberty](https://github.com/project-liberty/libertycoin)
* [LightPayCoin](https://github.com/lpcproject/LightPayCoin)
* [Linda](https://github.com/Lindacoin/Linda)
* [LINUX PAY](https://github.com/linuxpaycoin/linuxpay)
* [Lizus Payments](https://github.com/lizuspayments/lizus-core)
* [LOBSTEX Coin](https://github.com/avymantech/lobstex)
* [LogisCoin](https://github.com/lgsproject/LogisCoin)
* [LUNIQUE](https://github.com/RottenCoin/LuniqueCoin)
* [Macro](https://github.com/doomdorf/Macro)
* [MagnaCoin](https://github.com/MagnaCoinProject/MagnaCoin)
* [MAKETRIP](https://github.com/maketripcoin/maketrip-MTRIP)
* [Mambo Coin](https://github.com/MMBcoin/MamboCoin)
* [MarteXcoin](https://github.com/martexcoin/martexcoin)
* [MasterBit](https://github.com/MasterBit-Coin/masterbit)
* [Masternode Community Coin](https://github.com/mcc-project/mccproject)
* [Masternodecoin](https://github.com/masternodecoin/masternodecoin)
* [Medic Coin](https://github.com/MEDICCOIN/MedicCoin)
* [Memetic](https://github.com/pepeteam/pepecoin)
* [Mero](https://github.com/merocoin/mero)
* [Mirai](https://github.com/bumbacoin/Mirai-Master)
* [MNPCoin](https://github.com/MasterNodesPro/MNPCoin)
* [MonetaryUnit](https://github.com/MonetaryUnit/MUE-Src)
* [MoneyBag](https://github.com/MoneyBagCoin/MoneyBagCoin)
* [Monkey Project](https://github.com/MONKEYPROJECT/Monkey)
* [MontBlanc 3000](https://github.com/MontBlancCoin/MontBlanc)
* [MotileCoin](https://github.com/MotileCoin/MotileCoin)
* [Motion](https://github.com/motioncrypto/motion)
* [MOUSE](https://github.com/m1ckeym0us3/Mouse)
* [MTI Coin](https://github.com/mticryptocoins/MTI-Coin)
* [MUNcoin](https://github.com/muncrypto/muncoin)
* [MYCE](https://github.com/mycelliumcoin/MycelliumMN)
* [Nanucoin](https://github.com/rodrigodepeder/nanucoin)
* [NewYorkCoin](https://github.com/NewYorkCoin-NYC/nycoin)
* [NextON](https://github.com/Next-ON/NextON)
* [Nitrous](https://github.com/Nitrous-Core/nitrous)
* [Nodium](https://github.com/nodiumproject/zNodium)
* [Northern](https://github.com/zabtc/Northern)
* [NulleX](https://github.com/white92d15b7/NLX)
* [Nyerium](https://github.com/nyerium-core/nyerium)
* [NYXCoin](https://github.com/nyxpay/nyx)
* [OASIS](https://github.com/OasisCoinTeam/Oasis)
* [Obsidian](https://github.com/obsidianproject/Obsidian-Qt)
* [Ondori](https://github.com/ondori-project/rstr)
* [Over Powered Coin](https://github.com/opcoinx/OPCoinX)
* [Oyster Platform](https://github.com/oysterplatform/oyster)
* [PACcoin](https://github.com/PACCommunity/PAC)
* [Pandacoin](https://github.com/pandacoin-official/pandacoin)
* [PapelCoin](https://github.com/papelcoin/papelcoin)
* [Parlay](https://github.com/parlaychain/parlay)
* [PAXEX](https://github.com/paxex/paxchange)
* [PayDay Coin](https://github.com/PayDayCoinIo/PayDayCoin)
* [Peony Coin](https://github.com/peonyCoin/Peony)
* [PepeCoin](https://github.com/pepeteam/pepecoin)
* [Pesetacoin](https://github.com/FundacionPesetacoin/Pesetacoin-0.9.1-Oficial)
* [PHOBOS](https://github.com/Phoboscurrency/PBSCoin)
* [Phonecoin](https://github.com/phonecoin-PHON/PhoneCoinCore)
* [Phore](https://github.com/phoreproject/Phore)
* [PICPOTO](https://github.com/picpoto/picpotocoin)
* [PIVX](https://github.com/PIVX-Project/PIVX)
* [PlatinumBAR](https://github.com/xptx/PlatinumBar)
* [Plexus](https://github.com/PlexusCoin/Plexus)
* [Printex](https://github.com/Printex-official/printex-core)
* [ProCurrency](https://github.com/procurrency/procurrency)
* [Profit Hunters Coin](https://github.com/ProfitHuntersCoin/phc)
* [Project Coin](https://github.com/projectcoincore/ProjectCoin)
* [Prototanium](https://github.com/Prototanium/Pr)
* [Pura](https://github.com/PURAcore/PURA)
* [Purealt](https://github.com/puredev321/pure)
* [PZDC Project](https://github.com/pzdc-project/pzdc)
* [Qbic](https://github.com/qbic-platform/qbic)
* [Quantis](https://github.com/QuantisNetwork/Quantis-public)
* [Quark](https://github.com/MaxGuevara/quark)
* [Qubitcoin](https://github.com/willowrose/QubitCoin)
* [Quix](https://github.com/quixcoin/quix)
* [QYNO](https://github.com/qyno/qynocoin)
* [Rabbit](https://github.com/RabbitcoreDEV/RabbitCore)
* [Race](https://github.com/racecrypto/racecoin)
* [Radium](https://github.com/RadiumCore/radium-0.11)
* [Ragnarok](https://github.com/ragnaproject/Ragnarok)
* [Rampant Coin](https://github.com/rampantco/Rampant)
* [Rapture](https://github.com/RaptureCore/Rapture)
* [Reddcoin](https://github.com/reddcoin-project/reddcoin)
* [Reliance](https://github.com/relianceproject/Rel)
* [Renos](https://github.com/RenosCoin/RenosCoin)
* [Revolvercoin](https://github.com/RevolverCoin/revolvercoin)
* [Rhenium](https://github.com/Rheniumnetwork/Rhenium)
* [Ride My Car](https://github.com/RideMyCar/RideMyCar-Coin)
* [Riecoin](https://github.com/riecoin/riecoin)
* [Roi Coin](https://github.com/ROIcoin/ROIcoin)
* [Rover Coin](https://github.com/RoverCoin/Rovercoin)
* [RPICoin](https://github.com/rpicoin/rpicore)
* [Rubycoin](https://github.com/rubycoinorg/rubycoin)
* [Safe](https://github.com/bankledger/safe)
* [SafeCoin](https://github.com/Fair-Exchange/safecoin)
* [SafeInsure](https://github.com/safeinsure/sins-coin)
* [SagaCoin](https://github.com/sagacrypto/SagaCoin)
* [SaluS](https://github.com/saluscoin/salus)
* [Sanchezium](https://github.com/sanchezium/sanchezium)
* [SAROS](https://github.com/sarospay/saros)
* [Satoshicoin](https://github.com/SatoshiCoin-Crypto/SatoshiCoin)
* [savenode](https://github.com/savenode/SaveNodeCore)
* [Scorecoin](https://github.com/marksteven2017/Scorecoin)
* [SCRIV](https://github.com/ScrivNetwork/scriv)
* [SecureCloudCoin](https://github.com/SecureCloudCoin/securecloudcoin)
* [SecureTag](https://github.com/securetag/securetag)
* [Seedcoin](https://github.com/seedcoinfoundation/Seedcoin)
* [Shard Coin](https://github.com/ShardcoinRepo/shard)
* [Sharingmarketcoin](https://github.com/sharingmarketcoin/sharingmarketcoin)
* [SIBCoin](https://github.com/ivansib/sibcoin)
* [SimpleBank](https://github.com/Simplebankdev/Simple.)
* [SJWCoin](https://github.com/sjwcoin/sjwcoin-core)
* [Smart Quorum](https://github.com/smartquorum/sqrcoin)
* [SmartFox](https://github.com/smartfoxteam/smartfox)
* [SnowGem](https://github.com/Snowgem/Snowgem)
* [Social Send](https://github.com/SocialSend/SocialSend)
* [Solaris](https://github.com/Solaris-Project/Solaris)
* [Solarium](https://github.com/solariumcoin/solarium-XLRC)
* [Somnio](https://github.com/SMNcoin/SMNCoin)
* [SoomCoin](https://github.com/soom-4th-blockchain/soom-core)
* [Sovereign Coin](https://github.com/SovCoinX/SovCoin)
* [SPEDO](https://github.com/spedo-tech/spedo)
* [Sphere](https://github.com/SphereDevs/sphere)
* [Stakecube](https://github.com/stakecube/stakecube)
* [StarCash Network](https://github.com/cybernetik7/StarCash-Network-2.0)
* [Stipend](https://github.com/Stipend-Developer/stipend)
* [StoneCoin](https://github.com/stonecoinproject/Stonecoin)
* [StrongHands Masternode](https://github.com/bitcoinbabys/StrongHandsMasterNode)
* [SUB1X](https://github.com/SuB1X-Coin/zSub1x)
* [Sucre](https://github.com/sucremoneda/SucreCore)
* [SunCoin](https://github.com/suncoin-network/suncoin-core)
* [SuppoCoin](https://github.com/codeclock/sc)
* [Supro](https://github.com/suprodev/supro)
* [SwagBucks](https://github.com/pinkmagicdev/SwagBucks)
* [SwapCash](https://github.com/SwapCash/swapcash)
* [Swipp](https://github.com/teamswipp/swippcore)
* [SwisscoinCash](https://github.com/SwisscoinTM/SwisscoinNode)
* [Syndicate](https://github.com/SyndicateLabs/SyndicateQT)
* [TajCoin](https://github.com/Taj-Coin/tajcoin)
* [Talium](https://github.com/taliumtech/talium)
* [Talus](https://github.com/talusdev/TAL)
* [Tao](https://github.com/taoblockchain/tao-core)
* [Teloscoin](https://github.com/phoenixkonsole/transcendence)
* [Terracoin](https://github.com/terracoin/terracoin)
* [The Freedom Coin](https://github.com/TheFreedomCoin/Freedom-Coin)
* [TIMEISMONEY](https://github.com/rmcpartner/timeismoneycrypto)
* [Timicoin](https://github.com/timihealth/timicoin)
* [Tincoin](https://github.com/tincoinpay/tincoin)
* [Tokugawa](https://github.com/tokugawacoin/tokugawa)
* [Traid](https://github.com/TraidPlatform/traidcoin)
* [Transfercoin](https://github.com/transferdev/Transfercoin)
* [TravelPay](https://github.com/TravelPay/TravelPay)
* [Tribe](https://github.com/TribeCrypto/tribe)
* [Trittium](https://github.com/Trittium/trittium)
* [Trollcoin](https://github.com/TrollCoin2/TrollCoin-2.0)
* [Ultranatum](https://github.com/ultranatum/ultranatum)
* [United Crypto Community](https://github.com/unitedcryptocommunity/ucom)
* [Unobtanium](https://github.com/unobtanium-official/Unobtanium)
* [UservCoin](https://github.com/uservapp/uservcoin)
* [Vantaur](https://github.com/vantaur/vantaur)
* [VapersCoin](https://github.com/vaperscoin/vaperscoin)
* [VectorAI](https://github.com/vectorcoindev/Vector)
* [Velum](https://github.com/VelumPlatform/VelumPlatform)
* [VIOG](https://github.com/ViogCommunity/VIOG)
* [Vitae](https://github.com/VitaeTeam/Vitae)
* [Vivid Coin](https://github.com/vividplatform/vividcoin)
* [VIVO](https://github.com/vivocoin/vivo)
* [VIZZOTOP](https://github.com/VizzoTopCore/vizzotop)
* [VoteCoin](https://github.com/Tomas-M/VoteCoin)
* [Vsync](https://github.com/VsyncCrypto/VSX)
* [Wavi](https://github.com/wavidev-the-man/wavi)
* [Worx](https://github.com/worxcoin/worx)
* [XANO](https://github.com/XanoCoin/Xano-Coin)
* [Xchange](https://github.com/Xcgtech/Wallet)
* [Xdna](https://github.com/XDNA-Core/XDNA)
* [xGalaxy](https://github.com/officialXGalaxy/XGalaxy)
* [XORN](https://github.com/XORNcore/XORN)
* [XUEZ](https://github.com/XUEZ/XUEZ)
* [Xuma](https://github.com/xumacoin/xuma-core)
* [YICOIN](https://github.com/YiDeveloper/Yi)
* [Zcash](https://github.com/zcash/zcash)
* [ZCore](https://github.com/zcore-coin/zcore-source)
* [Zealium](https://github.com/zealiumcoin/Zealium)
* [ZelCash](https://github.com/zelcash/zelcash)
* [Zennies](https://github.com/zennies/zennies)
* [Zero](https://github.com/zerocurrency/zero)
* [Zest](https://github.com/ZestFoundation/ZestCoin)
* [Zixx](https://github.com/zixxcrypto/zixxcore)
* [Zoomba](https://github.com/zoombacoin/zoomba)
* [ZoZoCoin](https://github.com/ZoZoCoin/ZoZo-blockchain)
* [zXFLEA](https://github.com/zxfleacoin/xflea)

**Total Coins: 377**

These coin(s) still contain unpatched instances of the vulnerability in their code base which can be found [here](https://github.com/JinBean/CVE-Extension/tree/master/CVE-2016-10724)

### Sources:

1. [Bitcoin disclosure](https://bitcoin.org/en/posts/alert-key-and-vulnerabilities-disclosure)
2. [Linux Foundation](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016189.html)

---

## Contributors

* [Hum Qing Ze](https://github.com/Fishbiscuit)
* [Latasha Lenus](https://github.com/latashalenus)
* [Tan Wei Jin](https://github.com/JinBean)
* [Tey Shi Ying](https://github.com/shiyingt)

---

\*All files uploaded have been cloned from their respective coin repositories.

## About

This repository is an extension of our research on cryptocurrency clones and documents existing vulnerabilities discovered in those clones

### Topics

[cve-2018-17144](/topics/cve-2018-17144 "Topic: cve-2018-17144")
[cve-2019-7176](/topics/cve-2019-7176 "Topic: cve-2019-7176")
[cve-2016-10724](/topics/cve-2016-10724 "Topic: cve-2016-10724")
[cve-2016-10725](/topics/cve-2016-10725 "Topic: cve-2016-10725")

### Resources

[Readme](#readme-ov-file)

[Activity](/JinBean/CVE-Extension/activity)
### Stars

[**3**
stars](/JinBean/CVE-Extension/stargazers)
### Watchers

[**1**
watching](/JinBean/CVE-Extension/watchers)
### Forks

[**4**
forks](/JinBean/CVE-Extension/forks)
[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2FJinBean%2FCVE-Extension&report=JinBean+%28user%29)

## [Releases](/JinBean/CVE-Extension/releases)

No releases published

## [Packages 0](/users/JinBean/packages?repo_name=CVE-Extension)

No packages published

## Languages

* [C++
  100.0%](/JinBean/CVE-Extension/search?l=c%2B%2B)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_737d58e9_20250121_030608.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FJinBean%2FCVE-Extension%2Ftree%2Fmaster%2FCVE-2019-7167)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FJinBean%2FCVE-Extension%2Ftree%2Fmaster%2FCVE-2019-7167)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Ffiles%2Fdisambiguate&source=header-repo&source_repo=JinBean%2FCVE-Extension)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[JinBean](/JinBean)
/
**[CVE-Extension](/JinBean/CVE-Extension)**
Public

* [Notifications](/login?return_to=%2FJinBean%2FCVE-Extension) You must be signed in to change notification settings
* [Fork
  4](/login?return_to=%2FJinBean%2FCVE-Extension)
* [Star
   3](/login?return_to=%2FJinBean%2FCVE-Extension)

* [Code](/JinBean/CVE-Extension)
* [Issues
  0](/JinBean/CVE-Extension/issues)
* [Pull requests
  0](/JinBean/CVE-Extension/pulls)
* [Actions](/JinBean/CVE-Extension/actions)
* [Projects
  0](/JinBean/CVE-Extension/projects)
* [Security](/JinBean/CVE-Extension/security)
* [Insights](/JinBean/CVE-Extension/pulse)

Additional navigation options

* [Code](/JinBean/CVE-Extension)
* [Issues](/JinBean/CVE-Extension/issues)
* [Pull requests](/JinBean/CVE-Extension/pulls)
* [Actions](/JinBean/CVE-Extension/actions)
* [Projects](/JinBean/CVE-Extension/projects)
* [Security](/JinBean/CVE-Extension/security)
* [Insights](/JinBean/CVE-Extension/pulse)

## Files

 master
## Breadcrumbs

1. [CVE-Extension](/JinBean/CVE-Extension/tree/master)
/
# CVE-2019-7167

/Copy path
## Directory actions

## More options

## Directory actions

## More options

## Latest commit

## History

[History](/JinBean/CVE-Extension/commits/master/CVE-2019-7167) master
## Breadcrumbs

1. [CVE-Extension](/JinBean/CVE-Extension/tree/master)
/
# CVE-2019-7167

/Top
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| parent directory[..](/JinBean/CVE-Extension/tree/master) | | |
| [Hush](/JinBean/CVE-Extension/tree/master/CVE-2019-7167/Hush "Hush") | | [Hush](/JinBean/CVE-Extension/tree/master/CVE-2019-7167/Hush "Hush") |  |  |
| [Zcash-1.X](/JinBean/CVE-Extension/tree/master/CVE-2019-7167/Zcash-1.X "Zcash-1.X") | | [Zcash-1.X](/JinBean/CVE-Extension/tree/master/CVE-2019-7167/Zcash-1.X "Zcash-1.X") |  |  |
| View all files | | |

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from web.archive.org_b8435de4_20250121_030604.html ===


[![Wayback Machine](/_static/images/toolbar/wayback-toolbar-logo-200.png)](/web/ "Wayback Machine home page")

[22 captures](/web/20240413183948%2A/https%3A//eprint.iacr.org/2017/587 "See a list of every capture for this URL")
23 Jun 2017 - 21 Jul 2024

| [**Mar**](https://web.archive.org/web/20240309231731/http%3A//eprint.iacr.org/2017/587 "09 Mar 2024") | APR | [**Jul**](https://web.archive.org/web/20240721100357/https%3A//eprint.iacr.org/2017/587 "21 Jul 2024") |
| [Previous capture](https://web.archive.org/web/20240309231731/http%3A//eprint.iacr.org/2017/587 "23:17:31 Mar 09, 2024") | 13 | [Next capture](https://web.archive.org/web/20240721100357/https%3A//eprint.iacr.org/2017/587 "10:03:57 Jul 21, 2024") |
| [**2023**](https://web.archive.org/web/20230127152917/https%3A//eprint.iacr.org/2017/587 "27 Jan 2023") | 2024 | 2025 |

success
fail

 [About this capture](#expand)

COLLECTED BY

Collection: [Common Crawl](https://archive.org/details/commoncrawl)

Web crawl data from Common Crawl.

TIMESTAMPS

![loading](/_static/images/loading.gif)

The Wayback Machine - https://web.archive.org/web/20240413183948/https://eprint.iacr.org/2017/587

# What a lovely hat

#### Is it made out of [tin foil](https://web.archive.org/web/20240413183948/https%3A//iacr.org/tinfoil.html)?

[![IACR Logo](/web/20240413183948im_/https://eprint.iacr.org/img/iacrlogo_small.png)](https://web.archive.org/web/20240413183948/https%3A//iacr.org/)

[Cryptology ePrint Archive](/web/20240413183948/https%3A//eprint.iacr.org/)

* Papers
  Updates from the last:+ [7 days](/web/20240413183948/https%3A//eprint.iacr.org/days/7)
  + [31 days](/web/20240413183948/https%3A//eprint.iacr.org/days/31)
  + [6 months](/web/20240413183948/https%3A//eprint.iacr.org/days/183)
  + [365 days](/web/20240413183948/https%3A//eprint.iacr.org/days/365)
  + ---
  + [Listing by year](/web/20240413183948/https%3A//eprint.iacr.org/byyear)
  + [All papers](/web/20240413183948/https%3A//eprint.iacr.org/complete)
  + [Compact view](/web/20240413183948/https%3A//eprint.iacr.org/complete/compact)
  + ---
  + [How to cite](/web/20240413183948/https%3A//eprint.iacr.org/citation.html)
  + ---
  + [Harvesting metadata](/web/20240413183948/https%3A//eprint.iacr.org/rss)
* Submissions
  + [Submit a paper](/web/20240413183948/https%3A//eprint.iacr.org/submit)
  + [Revise or withdraw a paper](/web/20240413183948/https%3A//eprint.iacr.org/revise)
  + [Acceptance and publishing conditions](/web/20240413183948/https%3A//eprint.iacr.org/operations.html)
* About
  + [Goals and history](/web/20240413183948/https%3A//eprint.iacr.org/about.html)
  + [News](/web/20240413183948/https%3A//eprint.iacr.org/news.html)
  + [Statistics](/web/20240413183948/https%3A//eprint.iacr.org/stats)
  + [Contact](/web/20240413183948/https%3A//eprint.iacr.org/contact.html)

![Search Button](/web/20240413183948im_/https://eprint.iacr.org/img/search.svg)

Search

[Advanced search](/web/20240413183948/https%3A//eprint.iacr.org/search)

#### Paper 2017/587

### Subversion-zero-knowledge SNARKs

Georg Fuchsbauer

##### Abstract

Subversion zero knowledge for non-interactive proof systems demands that zero knowledge (ZK) be maintained even when the common reference string (CRS) is chosen maliciously. SNARKs are proof systems with succinct proofs, which are at the core of the cryptocurrency Zcash, whose anonymity relies on ZK-SNARKs; they are also used for ZK contingent payments in Bitcoin.
We show that under a plausible hardness assumption, the most efficient SNARK schemes proposed in the literature, including the one underlying Zcash and contingent payments, satisfy subversion ZK or can be made to at very little cost. In particular, we prove subversion ZK of the original SNARKs by Gennaro et al. and the almost optimal construction by Groth; for the Pinocchio scheme implemented in libsnark we show that it suffices to add 4 group elements to the CRS. We also argue informally that Zcash is anonymous even if its parameters were set up maliciously.

**Note:** This version incorporates the corrections of the BCTV14 scheme (ia.cr/2013/879, version 20190205) and some small fixes on p. 26.

##### Metadata

Available format(s)

[![](/web/20240413183948im_/https://eprint.iacr.org/img/file-pdf.svg)PDF](/web/20240413183948/https%3A//eprint.iacr.org/2017/587.pdf)

Category
[Cryptographic protocols](/web/20240413183948/https%3A//eprint.iacr.org/search?category=PROTOCOLS)
Publication info
A major revision of an IACR publication in PKC 2018
Keywords
[SNARKs](/web/20240413183948/https%3A//eprint.iacr.org/search?q=SNARKs)[subversion-resistance](/web/20240413183948/https%3A//eprint.iacr.org/search?q=subversion-resistance)[zero knowledge](/web/20240413183948/https%3A//eprint.iacr.org/search?q=zero%20knowledge)[Zcash](/web/20240413183948/https%3A//eprint.iacr.org/search?q=Zcash)
Contact author(s)
fuchsbau @ di ens fr

History
2020-05-16: last of 4 revisions
2017-06-20: received
[See all versions](/web/20240413183948/https%3A//eprint.iacr.org/archive/versions/2017/587)
Short URL
[https://ia.cr/2017/587](https://web.archive.org/web/20240413183948/https%3A//ia.cr/2017/587)
License
[![Creative Commons Attribution](/web/20240413183948im_/https://eprint.iacr.org/img/license/CC_BY.svg "Creative Commons Attribution")

CC BY](https://web.archive.org/web/20240413183948/https%3A//creativecommons.org/licenses/by/4.0/)

**BibTeX**
![](/web/20240413183948im_/https://eprint.iacr.org/img/copy-outline.svg)Copy to clipboard

```

@misc{cryptoeprint:2017/587,
      author = {Georg Fuchsbauer},
      title = {Subversion-zero-knowledge SNARKs},
      howpublished = {Cryptology ePrint Archive, Paper 2017/587},
      year = {2017},
      note = {\url{https://eprint.iacr.org/2017/587}},
      url = {https://eprint.iacr.org/2017/587}
}

```

[![IACR Logo](/web/20240413183948im_/https://eprint.iacr.org/img/iacrlogo_small.png)](https://web.archive.org/web/20240413183948/https%3A//iacr.org/)

Note: In order to protect the privacy of readers, eprint.iacr.org
does not use cookies or embedded third party content.



=== Content from eprint.iacr.org_e748aa0d_20250121_030600.html ===
Pinocchio: Nearly Practical Veriﬁable Computation

Bryan Parno
Jon Howell
Microsoft Research

Craig Gentry
Mariana Raykova
IBM Research

Abstract

To instill greater conﬁdence in computations outsourced to
the cloud, clients should be able to verify the correctness
of the results returned. To this end, we introduce Pinoc-
chio, a built system for efﬁciently verifying general computa-
tions while relying only on cryptographic assumptions. With
Pinocchio, the client creates a public evaluation key to de-
scribe her computation; this setup is proportional to evalu-
ating the computation once. The worker then evaluates the
computation on a particular input and uses the evaluation key
to produce a proof of correctness. The proof is only 288
bytes, regardless of the computation performed or the size of
the inputs and outputs. Anyone can use a public veriﬁcation
key to check the proof.

Crucially, our evaluation on seven applications demon-
strates that Pinocchio is efﬁcient in practice too. Pinocchio’s
veriﬁcation time is typically 10ms: 5-7 orders of magni-
tude less than previous work; indeed Pinocchio is the ﬁrst
general-purpose system to demonstrate veriﬁcation cheaper
than native execution (for some apps). Pinocchio also reduces
the worker’s proof effort by an additional 19-60×. As an
additional feature, Pinocchio generalizes to zero-knowledge
proofs at a negligible cost over the base protocol. Finally, to
aid development, Pinocchio provides an end-to-end toolchain
that compiles a subset of C into programs that implement the
veriﬁable computation protocol.

1 Introduction

Since computational power is often asymmetric (particularly
for mobile devices), a relatively weak client may wish to out-
source computation to one or more powerful workers. Com-
mon examples include cloud or grid computing, as well as
volunteer distributed computing [1]. In all of these settings,
the client should be able to verify the results returned, to guard
against malicious or malfunctioning workers. Even from a
legitimate worker’s perspective, veriﬁable results are beneﬁ-
cial, since they are likely to command a higher price. They
also allow the worker to shed liability: any undesired outputs
are provably the result of data the client supplied.

Considerable systems and theory research has looked at the
problem of verifying computation (§6). However, most of
this work has either been function speciﬁc, relied on assump-
tions we prefer to avoid, or simply failed to pass basic prac-
ticality requirements. Function speciﬁc solutions [2–6] are
often efﬁcient, but only for a narrow class of computations.
More general solutions often rely on assumptions that may
not apply. For example, systems based on replication [1, 7, 8]
assume uncorrelated failures, while those based on Trusted

Computing [9–11] or other secure hardware [12–15] assume
that physical protections cannot be defeated. Finally, the the-
ory community has produced a number of beautiful, general-
purpose protocols [16–23] that offer compelling asymptotics.
In practice however, because they rely on complex Probabilis-
tically Checkable Proofs (PCPs) [17] or fully-homomorphic
encryption (FHE) [24], the performance is unacceptable –
verifying small instances would take hundreds to trillions of
years (§5.2). Very recent work [25–28] has improved these
protocols considerably, but efﬁciency is still problematic, and
the protocols lack features like public veriﬁcation.

In contrast, we describe Pinocchio, a concrete system for
efﬁciently verifying general computations while making only
cryptographic assumptions. In particular, Pinocchio supports
public veriﬁable computation [22, 29], which allows an un-
trusted worker to produce signatures of computation.
Ini-
tially, the client chooses a function and generates a public
evaluation key and a (small) public veriﬁcation key. Given
the evaluation key, a worker can choose an input (or veriﬁ-
ably use one provided by the client), compute the function,
and produce a proof (or signature) to accompany the result.
Anyone (not just the client) can then use the veriﬁcation key
to check the correctness of the worker’s result for the spe-
ciﬁc input used. As an additional feature, Pinocchio supports
zero-knowledge veriﬁable computation, in which the worker
convinces the client that it knows an input with a particular
property, without revealing any information about the input.
Pinocchio’s asymptotics are excellent: key setup and proof
generation require cryptographic effort linear in the size of
the original computation, and veriﬁcation requires time linear
in the size of the inputs and outputs. Even more surprising,
Pinocchio’s proof is constant sized, regardless of the compu-
tation performed. Crucially, our evaluation (§5) demonstrates
that these asymptotics come with small constants, making
Pinocchio close to practical for a variety of applications.

Compared with previous work, Pinocchio improves veriﬁ-
cation time by 5-7 orders of magnitude and requires less than
10ms in most conﬁgurations, enabling it to beat native C ex-
ecution for some apps. We also improve the worker’s proof
efforts by 19-60× relative to prior work. The resulting proof
is tiny, 288 bytes (only slightly more than an RSA-2048 sig-
nature), regardless of the computation. Making a proof zero-
knowledge is also cheap, adding negligible overhead (213µs
to key generation and 0.1% to proof generation).

While these improvements are promising, additional
progress is likely needed before the overhead reaches true
practicality. However, even now, this overhead may be ac-
ceptable in scenarios that require high assurance, or that need
the zero-knowledge properties Pinocchio supports.

1

Figure 1: Overview of Pinocchio’s Toolchain. Pinocchio takes a
high-level C program all the way through to a distributed set of exe-
cutables that run the program in a veriﬁed fashion. It supports both
arithmetic circuits, via Quadratic Arithmetic Programs (§2.2.1), and
Boolean circuits via Quadratic Span Programs (§2.2.2).

To achieve efﬁcient veriﬁable computation, Pinocchio
combines quadratic programs, a computational model intro-
duced by Gennaro et al. [30], with a series of theoretical re-
ﬁnements and systems engineering to produce an end-to-end
toolchain for verifying computations. Speciﬁcally, via an im-
proved protocol and proof technique, we slash the cost of key
generation by 61%, and the cost of producing a proof by 64%.
From a developer’s perspective, Pinocchio provides a com-
piler that transforms C code into a circuit representation (we
support both Boolean and arithmetic), converts the circuit into
a quadratic program, and then generates programs to execute
the cryptographic protocol (Fig. 1).

Pinocchio’s end-to-end toolchain, plus its support for both
Boolean and arithmetic circuits, allows us to implement real
applications that beneﬁt from veriﬁcation. In particular, we
implement two forms of matrix multiplication, multivari-
ate polynomial evaluation, image matching, all-pairs shortest
paths, a lattice-gas scientiﬁc simulator, and SHA-1. We ﬁnd
(§5) that the ﬁrst three apps translate efﬁciently into arith-
metic circuits, and hence Pinocchio can verify their results
faster than native execution of the same program. The lat-
ter four apps translate less efﬁciently, due to their reliance on
inequality comparisons and bitwise operations, and yet they
may still be useful for zero-knowledge applications.
Contributions. In summary, this paper contributes:

1. An end-to-end system for efﬁciently verifying computa-
tion performed by one or more untrusted workers. This
includes a compiler that converts C code into a format
suitable for veriﬁcation, as well as a suite of tools for
running the actual protocol.

2. Theoretical and systems-level improvements that bring
performance down by 5-7 orders of magnitude, and
hence into the realm of plausibility.

3. An evaluation on seven real C applications, showing ver-
iﬁcation faster than 32-bit native integer execution for
some apps.

2 Background

2.1 Veriﬁable Computation (VC)

A public veriﬁable computation (VC) scheme allows a com-
putationally limited client to outsource to a worker the eval-
uation of a function F on input u. The client can then verify

the correctness of the returned result F(u) while performing
less work than required for the function evaluation.

More formally, we deﬁne public VC as follows, generaliz-

ing previous deﬁnitions [22, 29, 30].

public
Deﬁnition 1 (Public Veriﬁable Computation) A
veriﬁable computation scheme V C consists of a set of three
polynomial-time
(KeyGen, Compute, Verify)
deﬁned as follows.

algorithms

• (EKF ,V KF ) ← KeyGen(F, 1λ): The randomized key
generation algorithm takes the function F to be out-
sourced and security parameter λ; it outputs a public
evaluation key EKF , and a public veriﬁcation key V KF .
• (y, πy) ← Compute(EKF , u): The deterministic worker
algorithm uses the public evaluation key EKF and input
u. It outputs y ← F(u) and a proof πy of y’s correctness.
• {0, 1} ← Verify(V KF , u, y, πy): Given the veriﬁcation
key V KF , the deterministic veriﬁcation algorithm out-
puts 1 if F(u) = y, and 0 otherwise.

Prior work gives formal deﬁnitions for correctness, secu-

rity, and efﬁciency [30], so we merely summarize:

• Correctness For any function F, and any input u
if we run (EKF ,V KF ) ← KeyGen(F, 1λ) and
to F,
(y, πy) ← Compute(EKF , u), then we always get 1 =
Verify(V KF , u, y, πy).

• Security

For

any

function

polynomial-time

probabilistic
Pr[( ˆu, ˆy, ˆπy) ← A(EKF ,V KF )
1 = Verify(V KF , ˆu, ˆy, ˆπy)] ≤ negl(λ).

: F( ˆu)

F
and
adversary
(cid:54)= ˆy

any
A,
and

• Efﬁciency KeyGen is assumed to be a one-time opera-
tion whose cost is amortized over many calculations, but
we require that Verify is cheaper than evaluating F.
Several previous VC schemes [22, 23] were not public, but
rather designated veriﬁer, meaning that the veriﬁcation key
V KF must be kept secret. Indeed, in these schemes, even re-
vealing the output of the veriﬁcation function (i.e., whether
or not the worker had been caught cheating) could lead to at-
tacks on the system. A public VC scheme avoids such issues.
Zero-Knowledge Veriﬁable Computation. We also con-
sider an extended setting where the outsourced computation
is a function, F(u, w), of two inputs: the client’s input u and
an auxiliary input w from the worker. A VC scheme is zero-
knowledge if the client learns nothing about the worker’s in-
put beyond the output of the computation.1

Zero knowledge is relevant to practical scenarios where the
worker’s input is private. For example, to anonymously au-
thenticate, the worker’s input w might be a signature from a
third party; the client’s input u is the third party’s public key,
and the function F(u, w) validates the signature. The client
learns that the worker holds a valid credential, but learns noth-
ing about the credential itself. Another potential application
is for privately aggregating sensitive data, for example, in the

1Such a scheme may also be referred to as a non-interactive zero knowl-

edge (NIZK) proof [31].

2

CILC exprsARITHGATES+, *, splitQAPpolynomialsECCveriﬁcationBOOLGATESQSPpolynomialshigh-levellanguagelow-levellogicsatisﬁabilityencodingveriﬁcationprotocol(r5, r6)
(0,1) w1(ri)
(0,1) w2(ri)
(1,0) w3(ri)
(0,0) w4(ri)
(0,0) w5(ri)
(0,0) w6(ri)

(r5, r6)
(0,0)
(0,0)
(0,0)
(1,0)
(0,1)
(0,0)

(r5, r6)
y1(ri)
(0,0)
y2(ri)
(0,0)
y3(ri)
(0,0)
y4(ri)
(0,0)
y5(ri)
(1,0)
y6(ri) (0,1)

v1(ri)
v2(ri)
v3(ri)
v4(ri)
v5(ri)
v6(ri)

t(x) = (x − r5)(x − r6)

Figure 2: Arithmetic Circuit and Equivalent QAP. Each wire
value comes from, and all operations are performed over, a ﬁeld F.
The polynomials in the QAP are deﬁned in terms of their evaluations
at the two roots, r5 and r6. See text for details.

context of smart-meter billing [32], where individual meter
readings should be private to the client, but the utility needs
to authenticate the aggregate amount owed.

2.2 Quadratic Programs

Gennaro, Gentry, Parno, and Raykova (GGPR) recently
showed how to compactly encode computations as quadratic
programs [30], so as to obtain efﬁcient VC and zero-
knowledge VC schemes. Speciﬁcally, they show how to con-
vert any arithmetic circuit into a comparably sized Quadratic
Arithmetic Program (QAP), and any Boolean circuit into a
comparably sized Quadratic Span Program (QSP). We sum-
marize these transformations.

Standard results show that polynomially-sized circuits are
equivalent (up to a logarithmic factor) to Turing machines that
run in polynomial time [33], though of course the actual ef-
ﬁciency of computing via circuits versus on native hardware
depends heavily on the application (e.g., an arithmetic cir-
cuit for matrix multiplication adds essentially no overhead,
whereas a Boolean circuit for integer multiplication is less
efﬁcient than executing a single 32-bit assembly instruction).

2.2.1 Arithmetic Circuits and QAPs

An arithmetic circuit consists of wires that carry values from
a ﬁeld F and connect to addition and multiplication gates –
see Figure 2 for an example. We deﬁne a QAP, an encoding
of such a circuit, as follows.

Deﬁnition 2 (Quadratic Arithmetic Program (QAP) [30])
A QAP Q over ﬁeld F contains three sets of m+1 polynomials
V = {vk(x)}, W = {wk(x)},Y = {yk(x)}, for k ∈ {0 . . . m},
and a target polynomial t(x). Suppose F is a function that
takes as input n elements of F and outputs n(cid:48) elements, for
a total of N = n + n(cid:48) I/O elements. Then we say that Q
computes F if: (c1, . . . , cN) ∈ FN is a valid assignment of
F’s inputs and outputs, if and only if there exist coefﬁcients
(cN+1, . . . , cm) such that t(x) divides p(x), where:

(cid:32)

p(x) =

v0(x) +

m
∑
k=1

(cid:33)

(cid:32)

ck · vk(x)

·

w0(x) +

(cid:33)

ck · wk(x)

m
∑
k=1

(cid:32)

−

y0(x) +

m
∑
k=1

(cid:33)

ck · yk(x)

.

In other words, there must exist some polynomial h(x) such
that h(x) · t(x) = p(x). The size of Q is m, and the degree is
the degree of t(x).

Building a QAP Q for an arithmetic circuit C is fairly
straightforward. We pick an arbitrary root rg ∈ F for each
multiplication gate g in C and deﬁne the target polynomial
to be t(x) = ∏g(x − rg). We associate an index k ∈ [m] =
{1 . . . m} to each input of the circuit and to each output from
a multiplication gate (the addition gates will be compressed
into their contributions to the multiplication gates). Finally,
we deﬁne the polynomials in V , W , and Y by letting the
polynomials in V encode the left input into each gate, the W
encode the right input into each gate, and the Y encode the
outputs. For example, vk(rg) = 1 if the k-th wire is a left input
to gate g, and vk(rg) = 0 otherwise. Similarly, yk(rg) = 1 if
the k-th wire is the output of gate g, and yk(rg) = 0 otherwise.
Thus, if we consider a particular gate g and its root rg, Equa-
k=1 ck · vk(rg)) · (∑m
tion 1 simpliﬁes to: (∑m
k=1 ck · wk(rg)) =
(cid:17)
(cid:16)
(cid:17)
(cid:16)
= cgyk(rg) = cg, which just says
∑k∈Iright ck
∑k∈Ile f t ck
·
that the output value of the gate is equal to the product of its
inputs, the very deﬁnition of a multiplication gate.

In short, the divisibility check that t(x) divides p(x) de-
composes into deg(t(x)) separate checks, one for each gate g
and root rg of t(x), that p(rg) = 0.

Taking the circuit in Figure 2 as a concrete example, we
build the equivalent QAP as follows. First, we select two
roots, r5, r6 ∈ F to represent the two multiplication gates.
Hence the QAP’s degree is 2. We deﬁne six polynomials for
each set V , W , and Y , four for the input wires, and two for
the outputs from the multiplication gates. Thus, the QAP’s
size is 6. We deﬁne these polynomials based on each wire’s
contributions to the multiplication gates. Speciﬁcally all of
the vk(r5) = 0, except v3(r5) = 1, since the third input wire
contributes to the left input of c5’s multiplication gate. Simi-
larly, vk(r6) = 0, except for v1(r6) = v2(r6) = 1, since the ﬁrst
two inputs both contribute to the left input of c6’s gate. For
W , we look at right inputs. Finally, Y represents outputs;
none of the input wires is an output, so yk(r5) = yk(r6) = 0
for k ∈ {1, ..., 4}, and y5(r5) = y6(r6) = 1.

Note the extreme sparsity of the polynomials in the exam-
ple (in terms of evaluations of the polynomials). The VC pro-
tocol (§2.3) exploits this sparseness to achieve efﬁciency.

The actual construction [30] is a bit more complex, as it
handles addition and multiplication by constants. Nonethe-
less, GGPR show that for any arithmetic circuit with d mul-
tiplication gates and N I/O elements, one can construct an
equivalent QAP with degree (the number of roots rg) d and
size (number of polynomials in each set) d + N. Note that ad-
dition gates and multiplication-by-constant gates do not con-
tribute to the size or degree of the QAP. Thus, these gates are
essentially “free” in QAP-based VC schemes.
Strong QAPs. In their QAP-based VC scheme, described be-
low, GGPR unfortunately require a strong property from the
QAP. Note that Deﬁnition 2 only considers the case where the

3

+xxc2c1c3c4c5c6InputsOutputk=1 bk · wk(x)) − (∑m

same set of coefﬁcients ci are applied to all three sets of poly-
nomials. GGPR additionally require the if-and-only-if condi-
tion in Deﬁnition 2 to hold even when different coefﬁcients
ai, bi, ci are applied – i.e., when p(x) = (∑m
k=1 ck · vk(x)) ·
(∑m
k=1 ak · yk(x)). They show how to con-
vert any QAP into a strong QAP that satisﬁes this stronger
condition. Unfortunately, this strengthening step increases
the QAP’s degree to 3d + 2N, more than tripling it. This in
turn, more than triples the cost of key generation, the size of
the evaluation key, and the worker’s effort to produce a proof.

2.2.2 Boolean Circuits and QSPs

Boolean circuits operate over bits, with bitwise gates for
AND, OR, XOR, etc. GGPR propose Quadratic Span
Programs (QSPs) as a custom encoding for Boolean cir-
cuits [30]. QSPs are superﬁcially similar to QAPs, but
because they only support Boolean wire values, they use
only two sets of polynomials V and W . The divisibility
check is updated to consider p(x) = (v0(x) + ∑m
k=1 ck · vk(x)) ·
(w0(x) + ∑m
Instead of the arithmetic circuit-
based polynomial construction above, QSPs build a small set
of polynomials for each Boolean gate. Speciﬁcally, each gate
adds 9 roots and 12 polynomials to the overall QSP. Like
QAPs, the QSPs require a strengthening step.

k=1 ck · wk(x)).

2.3 Building VC from Quadratic Programs

To construct a VC protocol from a quadratic program, the
main idea is that each polynomial – e.g., vk(x) ∈ F – of the
quadratic program is mapped to an element gvk(s) in a bilin-
ear group, where s is a secret value selected by the client,
g is a generator of the group, and F is the ﬁeld of discrete
logarithms of g. These group elements are given to the
worker. For a given input, the worker evaluates the circuit
directly to obtain the output and the values of the internal
circuit wires. These values correspond to the coefﬁcients ci
of the quadratic program. Thus, the VC worker can eval-
uate v(s) = ∑k∈[m] ck · vk(s) “in the exponent” to get gv(s);
it computes w(s) and y(s), in the exponent, similarly. Fi-
nally, the worker computes h(x) = p(x)/t(x) = ∑d
i=0 hi · xi,
and then uses the hi, along with gsi
terms in the evaluation
key, to compute gh(s). To oversimplify, the proof consists of
(gv(s), gw(s), gy(s), gh(s)). The veriﬁer uses the bilinear map to
check that p(s) = h(s)t(s). The actual protocol (Protocol 1) is
a bit more complex, because additional machinery is needed
to ensure that the worker incorporates the client’s input u cor-
rectly, and that the worker indeed generates (say) v(s) in the
exponent as some linear function of the vk(s) values.

Protocol 1 (Veriﬁable Computation from strong QAPs)

• (EKF ,V KF ) ← KeyGen(F, 1λ): Let F be a function
with N input/output values from F. Convert F into
an arithmetic circuit C; then build the corresponding
QAP Q = (t(x),V ,W ,Y ) of size m and degree d. Let
Imid = {N + 1, ..., m}, i.e., the non-IO-related indices.
Let e be a non-trivial bilinear map [34] e : G × G → GT ,
and let g be a generator of G.

R← F.

Choose s, α, βv, βw, βy, γ
Construct the public evaluation key EKF as:
( {gvk(s)}k∈Imid ,
{gyk(s)}k∈[m],
{gwk(s)}k∈[m],
{gαvk(s)}k∈Imid ,
{gαyk(s)}k∈[m],
{gαwk(s)}k∈[m],
{gβvvk(s)}k∈Imid , {gβwwk(s)}k∈[m], {gβyyk(s)}k∈[m]
{gsi
).
}i∈[d]
The public veriﬁcation key is: V KF = (g1, gα, gγ, gβvγ,
gβwγ, gβyγ, gt(s), {gvk(s)}k∈[N], gv0(s), gw0(s), gy0(s)).

}i∈[d],

{gαsi

• (y, πy) ← Compute(EKF , u): On input u, the worker
evaluates the circuit for F to obtain y ← F(u). As a
result of the evaluation, he knows the values {ci}i∈[m] of
the circuit’s wires.
such that
solves
He
p(x) = h(x) · t(x)), and computes the proof πy as:

(the polynomial

for h(x)

( gvmid (s),

gw(s),

gh(s),
gαvmid (s), gαw(s), gαy(s), gαh(s),
gβvv(s)+βww(s)+βyy(s)

gy(s),

),

where vmid(x) = ∑k∈Imid ck ·vk(x), v(x) = ∑k∈[m] ck ·vk(x),
w(x) = ∑k∈[m] ck · wk(x), and y(x) = ∑k∈[m] ck · yk(x).
Since these are linear equations, he can compute them
“in the exponent” using the material in the evaluation
key, e.g., gv(s) = gv0(s) · ∏k∈[m]

(cid:16)
gvk(s)(cid:17)ck

.

• {0, 1} ← Verify(V KF , u, y, πy): To verify a proof, anyone
with access to the veriﬁcation key V KF can use the pair-
ing function e to check that the α and β proof terms are
correct (e.g., check that e(gvmid (s), gα) = e(gαvmid (s), g)).
This requires 8 pairings for the α terms, and 3 for the β
term.
Finally, the veriﬁer can compute a term representing
the I/O, u and y, by representing them as coefﬁcients
c1, . . . , cN ∈ F and computing, using elements from V KF ,
gvio(s) = ∏k∈[N]
A ﬁnal check (with 3 pairings) veriﬁes the divisibil-
that e(gv0(s) · gvio · gv(s), gw0(s) ·
ity requirement,
i.e.,
gw(s))/e(gy0(s) · gy(s), g) = e(gh(s), gt(s)).
In a designated veriﬁer setting (where the veriﬁer knows
s, α, etc.), pairings are only needed for this last check,
and the I/O term can be computed directly over F, rather
than “in the exponent”.

gvk(s)(cid:17)ck
(cid:16)

.

Regarding efﬁciency, GGPR [30] show that the one-time
setup of KeyGen runs in time linear in the original circuit size,
O(|C|). The worker performs O(|C|) cryptographic work, but
he must also perform O(|C| log2 |C|) non-cryptographic work
to calculate h(x). To achieve this performance, the worker
exploits the fact that the evaluation vectors (vk(r1), . . . , vk(rd))
are all very sparse (also for the w and y polynomials). The
proof itself is constant size, with only 7 group elements for
QSPs and 9 for QAPs, though the veriﬁer’s work is still linear,
O(N), in the size of the inputs and outputs of the function.

In terms of security, GGPR [30] show this VC scheme is
sound under the d-PKE and q-PDH assumptions (see Ap-
pendix A), which are weak versions of assumptions in prior
work [21, 35, 36]. The q-PDH assumption belongs to a class

4

of cryptographic assumptions that do not lend themselves to
efﬁcient falsiﬁcation [37], though some members have indeed
been proven false [38]. Gentry and Wichs recently showed
that assumptions from this class are likely to be inherent for
efﬁcient, non-interactive arguments for NP relations [39].
Zero Knowledge. Making the VC scheme zero-knowledge
is remarkably simple. One simply includes the target poly-
nomial t(x) itself in the polynomial sets V , W , and Y . This
allows the worker to “randomize” its proof by adding δvt(s)
in the exponent to vmid(s), δwt(s) to w(s), and δyt(s) to y(s)
for random δv, δw, δy, and modifying the other elements of
the proof accordingly. The modiﬁed value of p(x) remains
divisible by t(x), but the randomization makes the scheme
statistically zero-knowledge [30].

3 Theoretical Reﬁnements

In this section, we improve Protocol 1 to signiﬁcantly reduce
key generation time, evaluation key size, and worker effort.
We analyze our improvements empirically in §5.4.

Our main optimization is that we construct a VC scheme
that uses a regular QAP (as in Deﬁnition 2), rather than a
strong QAP. Recall that GGPR show how to transform a reg-
ular QAP into a strong QAP, but the transformation more than
triples the degree of the QAP. Consequently, when they plug
their strong QAP into their VC construction, the strengthen-
ing step more than triples the key generation time, evaluation
key size, and worker computation. We take a different ap-
proach that uses a regular QAP, and hence we do not need a
strengthening step at all. Instead, we embed additional struc-
ture into our new VC proof that ensures that the worker uses
the same linear combination to construct the v, w, and y terms
of its proof.2 Surprisingly, this additional structure comes at
no cost, and our VC scheme is actually less complicated than
GGPR’s! For example, we manage to shave the proof down
from nine group elements to eight. Experiments (§5.4) show
that these improvements indeed give substantial savings.

We also remove the need for the worker to compute gαh(s),
and hence the gαsi
i∈[d] terms from EK. Finally, we expand the
expressivity and efﬁciency of the functions QAPs can com-
pute by designing a number of custom circuit gates for spe-
cialized functions.

3.1 Our New VC Protocol

Next we describe our more efﬁcient VC scheme, with some
remarks afterwards on some its properties.

Protocol 2 (Veriﬁable Computation from regular QAPs)

• (EKF ,V KF ) ← KeyGen(F, 1λ): Let F be a function
with N input/output values from F. Convert F into
an arithmetic circuit C; then build the corresponding

QAP Q = (t(x),V ,W ,Y ) of size m and degree d. Let
Imid = {N + 1, ..., m}, i.e., the non-IO-related indices.
Let e be a non-trivial bilinear map [34] e : G × G → GT ,
and let g be a generator of G.
Choose rv, rw, s, αv, αw, αy, β, γ
gv = grv, gw = grw and gy = gry.
Construct the public evaluation key EKF as:
( {gvk(s)
v
{gαvvk(s)
v
{gsi
}i∈[d],

{gyk(s)
y
}k∈Imid , {gαyyk(s)
y
gβyk(s))
gβwk(s)
}k∈Imid
y
w

}k∈Imid , {gαwwk(s)
w
{gβvk(s)
v

R← F and set ry = rv · rw,

{gwk(s)
w

}k∈Imid ,

}k∈Imid ,

}k∈Imid ,

}k∈Imid ,

),

y

solves

, gyk(s)
y

, {gvk(s)
v

}k∈{0}∪[N].

and the public veriﬁcation key as: V KF = (g1, gαv, gαw ,
, gwk(s)
gαy, gγ, gβγ, gt(s)
w
• (y, πy) ← Compute(EKF , u): On input u, the worker
evaluates the circuit for F to obtain y ← F(u); he also
learns the values {ci}i∈[m] of the circuit’s wires.
such that
He
p(x) = h(x) · t(x)), and computes the proof πy as:
gwmid (s)
,
w
, gαwwmid (s)
w
gβwmid (s)
w

gβymid (s)
),
y
where vmid(x) = ∑k∈Imid ck · vk(x), and similarly for
wmid(s) and ymid(s).

( gvmid (s)
,
v
gαvvmid (s)
v
gβvmid (s)
v

gymid (s)
,
y
, gαyymid (s)
y

(the polynomial

for h(x)

gh(s),

• {0, 1} ← Verify(V KF , u, y, πy): The veriﬁcation of an al-
leged proof with elements gVmid , gWmid , gYmid , gH , gV (cid:48)
mid ,
gW (cid:48)
mid , and gZ uses the public veriﬁcation key V KF
and the pairing function e for the following checks.

mid , gY (cid:48)

(cid:17)ck

= ∏k∈[N]

(cid:16)
gvk(s)
v

• Divisibility check for the QAP: using elements from
V KF compute gvio(s)
(and similarly
v
and gyio(s)
for gwio(s)
w
y
gvio(s)
e(gv0(s)
v
v
e(gt(s)
y

), and check:
, gw0(s)
gVmid
w
v
, gH )e(gy0(s)

gwio(s)
w
gyio(s)
y

gWmid
w
gYmid
y

, g).

) =

(1)

(2)

y

• Check that the linear combinations computed over V ,
W and Y are in their appropriate spans:

V (cid:48)
mid
v

e(g

, g) = e(gVmid

v

, gαv),

W (cid:48)
e(g
w

mid

, g) = e(gWmid

w

, gαw),

Y (cid:48)
mid
y

e(g

, g) = e(gYmid

y

, gαy).

• Check that the same coefﬁcients were used in each of

the linear combinations over V , W and Y :
, gβγ).

e(gZ, gγ) = e(gVmid

gWmid
w

gYmid
y

v

The correctness of the VC scheme follows from the prop-
erties of the QAP. Regarding security, we have the following:

2Our proof contains a term that enforces this linear constraint without
increasing the degree. GGPR’s generic strengthening step checked the con-
sistency of the linear combinations via additional multiplication gates, which
increased the degree of the QAP.

Theorem 1 Let d be an upper bound on the degree of the
QAP used in the VC scheme, and let q = 4d + 4. The VC
scheme is sound under the d-PKE, q-PDH and 2q-SDH as-
sumptions (see Appendix A).

5

1 ), (g2, gα

The proof of Theorem 1 is in Appendix B.
Security Intuition. As intuition for why the VC scheme is
sound, note that it seems hard for an adversary who does
not know α to construct any pair of group elements h, hα ex-
cept in the obvious way: by taking pairs (g1, gα
2 ), . . .
that he is given, and applying the same linear combination
(in the exponent) to the left and right elements of the pairs.
This hardness is formalized in the d-PKE assumption, a sort
of “knowledge-of-exponent” assumption [40], that says that
the adversary must “know” such a linear combination, in the
sense that this linear combination can be extracted from him.
Roughly, this means that, in the security proof, we can extract
polynomials Vmid(x), Wmid(x), Ymid(x) such that Vmid (from
the proof) equals Vmid(s), Wmid = Wmid(s) and Ymid = Ymid(s),
and that moreover these polynomials are in the linear spans
of the vk(x)’s, wk(x)’s, and yk(x)’s respectively. If the adver-
sary manages to provide a proof of a false statement that veri-
ﬁes, then these polynomials must not actually correspond to a
QAP solution. So, either p(x) is not actually divisible by t(x)
(in this case we break 2q-SDH) or V (x) = vio(x) + Vmid(x),
W (x) and Y (x) do not use the same linear combination (in
this case we break q-PDH because in the proof we choose β
in a clever way).

Zero Knowledge. We can apply GGPR’s rerandomization
technique [30] (§2.3) to provide zero-knowledge for our new
veriﬁable computation construction. The worker chooses
R← F and in his proof, instead of the polynomials
δv, δw, δy
vmid(x), v(x), w(x) and y(x), he uses the following random-
ized versions vmid(x) + δvt(x), v(x) + δvt(x), w(x) + δwt(x)
and y(x) + δyt(x). In order to facilitate the randomization of
the proof we add the following terms to the evaluation key:
gαvt(s)
, gβt(s)
v
w

, gαwt(s)
w

, gαyt(s)
y

, gβt(s)
y

, gβt(s)
v

.

Performance. Our main improvement is that our VC scheme
only requires a regular QAP, rather than a strong QAP, which
improves performance by more than a factor of 3. Moreover,
the scheme itself is simpler, leading to fewer group elements
in the keys and proof, fewer bilinear maps for Verify, etc.

The scheme above assumes a symmetric bilinear map. In
practice, for performance reasons, we use an asymmetric bi-
linear map e : G1 × G2 → GT where G1 is an elliptic curve
group called the “base” curve, and G2 is the “twist” curve.
Operations over the base curve are about 3 times faster than
over the twist curve (§5.1). Due to our optimizations, while
the worker must compute the gw(s)
term over the twist curve,
all of the other proof terms can be over the base curve.

w

3.2 Expressive Circuit Constructions
The QAP that we use in our VC scheme is deﬁned over Fp,
where p is a large prime. We can, as explained above, de-
rive a QAP over Fp that efﬁciently computes any function F
that can be expressed in terms of addition and multiplication
modulo p. This provides no obvious way to express some op-
erations, such as a ≥ b using mod-p arithmetic. On the other
hand, given a and b as bits, comparison is easy. Hence, one

6

might infer that Boolean circuits are more general and thus
QSPs superior to QAPs.

However, we design an arithmetic split gate to translate an
arithmetic wire a ∈ Fp, known to be in [0, 2k − 1], into k bi-
nary output wires. Given such binary values, we can compute
Boolean functions using arithmetic gates: NAND(a, b) =
1 − ab, AND(a, b) = ab, OR(a, b) = 1 − (1 − a)(1 − b). Each
embedded Boolean gate costs only one multiply.

Surprisingly, even though QSPs are “designed for”
Boolean circuits, the arithmetic embedding gives a more efﬁ-
cient VC scheme. With a QSP, each gate increases the degree
of t(x) by 9 and the QSP size by 12. Embedding introduces
an expensive initial gate that constrains each input to {0, 1},
but henceforth, each embedded gate preserves the {0, 1} in-
variant, adding only 1 to the degree and size of the QAP. 3

Furthermore, the expression ∑k

i=1 2i−1ai combines a bit-
wise representation of a back into a single wire. Because the
sum consists of additions and multiplications by constants,
recombination is free; it doesn’t increase the size of the QAP.
Below, we deﬁne split and other useful new gates as stan-
dalone QAPs which can be composed [30, Thm.11] with
other gates.
Split Gate. Given input a ∈ Fp known to be in [0, 2k − 1], the
split gate outputs k wires holding the binary digits a1, . . . , ak
of a. Thus, the QAP ensures that ∑k
i=1 2i−1ai = a, and that
each ai is either 0 or 1. For convenience, we number the
output wires 1, . . . , k and the input wire k + 1.
In our mini-QAP, let t(x) = (x − r) ∏k

i=1(x − ri) where

r, r1, . . . , rk are distinct roots. We set:

•

vi(r) = 2i−1

v0(r) = 0,
w0(r) = 1, wi(r) = 0
yi(r) = 0
y0(r) = 0,

for 1 ≤ i ≤ k, vk+1(r) = 0,
for 1 ≤ i ≤ k, wk+1(r) = 0,
for 1 ≤ i ≤ k, yk+1(r) = 1;

• For 1 ≤ j ≤ k: v j(r j) = 1, vi(r j) = 0 for all i (cid:54)= j,

w0(r j) = 1, w j(r j) = −1, wi(r j) = 0 for all i (cid:54)= 0, j,
and yi(r j) = 0 for all i.

k=1 ak · vk(x)) · (w0(x) + ∑m

If (v0(x) + ∑m
k=1 ak · wk(x)) −
(y0(x) + ∑m
k=1 ak · yk(x)) is divisible by t(x), it must evaluate
to 0 at r, and therefore the ﬁrst set of equations guarantee that
∑k
i=1 2i−1ai − a = 0. This guarantees that if all a1, . . . , ak are
binary, then they are the binary digits of a. The second set of
equations guarantees that each ai is either 0 or 1. In particu-
lar, for each 1 ≤ j ≤ k, the above polynomial evaluates to 0 at
r j if and only if a j · (1 − a j) = 0.

Equality-Assertion Gate. For some computations, we re-
quire the value on two circuit wires to be equal. For example,
in many signature schemes, the veriﬁcation function checks
for equality between two values. Thus when we use signature
veriﬁcation as part of a larger computation, we want to guar-
antee that the computation succeeds only if the veriﬁcation is
successful.

For such cases, we augment the QAP such that it forces
two wires, i1 and i2, to have the same value. Let T (x),

3QSPs still have smaller proofs, since they require only two sets of poly-

nomials (V ,W ) vs. three (V ,W ,Y ).

i=1 , {Yi(x)}k+1
{Vi(x)}k+1
the construction of the initial QAP.

i=1 , {Wi(x)}k+1

i=1 be the polynomials from

i=1 , {wi(x)}k+1

We construct an augmented QAP with polynomials t(x),
{vi(x)}k+1
i=1 deﬁned as follows. Set
t(x) = T (x)(x − r) where r is different from the roots of T (x).
For the rest of the polynomials we have:

i=1 , {yi(x)}k+1

• Modulo T (x), the following hold for all 0 ≤ j ≤ k + 1:

v j(x) = Vj(x), w j(x) = Wj(x), and y j(x) = Yj(x).
• vi1(r) = 1, vi2 (r) = −1 , v j(r) = 0 for j (cid:54)= i1, i2,
w0(r) = 1, w j(r) = 0 for all 1 ≤ j ≤ k + 1,
y j(r) = 0 for all 0 ≤ j ≤ k + 1.

By the ﬁrst set of equations, our new QAP inherits all of the
constraints of the initial QAP. The second set of equations
ensures that the divisibility holds if and only if the values on
wires i1 and i2 are equal.
Zero-Equality Gate. Another useful type of comparison
functionality is checking whether a value is equal to zero,
e.g., Y = (X! = 0)?1 : 0. We use a prior observation [28] that
this is equivalent to satisfying the following two constraints:
X · M − Y = 0 and (1 − Y ) · X = 0 for some value M. We
construct the following QAP, which takes as input wire X (an
input from the client) and a wire M, an input from the worker.
The output wire will be Y . For distinct roots r1, r2, the mini-
QAP has a target polynomial t(x) = (x − r1)(x − r2), and the
rest of the polynomials are deﬁned as follows:

•

•

v1(r1) = 1,

v2(r1) = 0,

v3(r1) = 0;
v0(r1) = 0,
w0(r1) = 0, w1(r1) = 0, w2(r1) = 1, w3(r1) = 0;
y3(r1) = 1;
y0(r1) = 0,
v0(r2) = 1,
v3(r2) = −1;
w0(r2) = 0, w1(r2) = 1, w2(r2) = 0, w3(r2) = 0;
y3(r2) = 0.
y0(r2) = 0,

y1(r1) = 0,
v1(r2) = 0,

y2(r1) = 0,
v2(r2) = 0,

y1(r2) = 0,

y2(r2) = 0,

The value X will be applied to be polynomials with subscript
1, M to subscript 2, and Y to subscript 3. The ﬁrst set of equa-
tions provides that if t(x) divides (v0(x) + ∑m
k=1 ak · vk(x)) ·
(w0(x) + ∑m
k=1 ak · wk(x)) − (y0(x) + ∑m
k=1 ak · yk(x)), then X ·
M − Y = 0, and the second set of equations guarantees that
(1 −Y ) · X = 0.

4 Implementation
We implemented a compiler that takes a subset of C to an
equivalent arithmetic circuit (§4.1). Our veriﬁable compu-
tation suite then compiles the circuit representation to the
equivalent QAP, and generates code to run the VC protocol,
including key generation, proof computation, and proof ver-
iﬁcation (§4.2). The toolchain compiles a large collection of
applications and runs them with veriﬁcation (§4.3). Source
code for the toolchain is available [41].

4.1 Compiler Toolchain

The applications described below (§4.3) and evaluated in §5
are each compiled using qcc, our C-to-arithmetic-expression
compiler, a 3,525-line Python program [42]. They are also
compiled with gcc to produce the Native timings in Figures 7
and 8. A unit test validates that the gcc and 32-bit qcc exe-
cutables produce matching output on varying inputs.

7

int mat[SIZE*SIZE] = { 0x12, ... };
struct In { int vector[SIZE]; };
struct Out { int result[SIZE]; };

void compute(struct In *input, struct Out *output){

int i, j, k, t;
for (i=0; i<SIZE; i+=1) {

int t=0;
for (k=0; k<SIZE; k+=1) {

t = t + mat->[i*SIZE+k] * input->vector[k];

}
output->result[i] = t;

}

}

Figure 3: Fixed-Matrix Multiplication. The qcc compiler unrolls
the loops and decodes the struct and array references to generate an
arithmetic expression for Out in terms of In.

The compiler understands a substantial subset of C, in-
cluding global, function and block-scoped variables; arrays,
structs, and pointers; function calls, conditionals, loops; and
static initializers (Fig. 3). It also understands arithmetic and
bitwise Boolean operators and preprocessor syntax. The pro-
gram’s entry point is a function
void compute(struct In *in, struct Out *out)
whose parameters identify the set of input and output values.
Since the “target machine” (arithmetic circuits) supports
only expressions, not mutable state and iteration, we re-
strict the C program’s semantics accordingly. For example,
pointers and array dereferences must be compile-time con-
stants; otherwise, each dynamic reference would produce
conditional expressions of size proportional to the address-
able memory. Function calls are inlined, while preserving C
variable scope and pointer semantics.

Imperative conditionals compile to conditional expressions
that encode the imperative side effects. Static conditions are
collapsed at compile time. Similarly, loops with statically-
evaluatable termination conditions are automatically unrolled
completely. A loop with dynamic termination—depending
on an input value—requires a pragma unroll to inform
the compiler how far it should unroll.

The only scalar type presently supported is int; a compiler
ﬂag selects the integer size. The compiler inserts masking
expressions to ensure that a k-bit int behaves exactly as the
corresponding C type, including overﬂow. As described be-
low, our arithmetic circuits operate over a 254-bit ﬁeld; if the
program’s computation is known not to overﬂow 254 bits, the
programmer can disable masking with a compiler ﬂag. We
plan to extend our compiler to support ﬂoating point values
via standard techniques [28, 43].

These features (and limitations) are similar to a parallel ef-
fort [44] to compile C for the purposes of secure multiparty
computation, though they compile only to Boolean circuits.
Details. The compiler front-end tracks scopes and variable
values (as expressions), and unrolls imperative execution into
a ﬁnal program state that provides expressions for each output
value. The intermediate language is a set of expressions of C-
like operators, such as +, *, <=, ?:, &, and ˆ.

The compiler back-end expands each expression into the
arithmetic gate language of mul, add, const-mul, wire-split,
etc., eliminating common subexpressions. It carefully bounds
the bit-width of each wire value:

• inputs have the compiler-speciﬁed int width;
• each constant has a known width (e.g. 13 = 11012 has

bit width 4);

• a bitwise op produces the max of its arguments’ widths;
• add can produce max+1 bits (for a carry); and
• mul can produce 2 · max bits.

When the width nears the available bits in the crypto ﬁeld
(254), the compiler generates a split operation to truncate the
value back to the speciﬁed int width. Tracking bit width min-
imizes the cost of split gates.

Signed numbers are handled just as they are in C: a 32-
bit int is a twos-complement number with a sign bit at 1 <<
31. Each C expression value is treated either as an arithmetic
scalar wire or a Boolean expansion, e.g. 32 wires in {0, 1}
(§3.2). The format is translated only when values pass from
one operator type to the other; for example, in (aˆbˆc) +
z, the bitwise xor (ˆ) operators manipulate bitwise Booleans,
which are joined into a scalar for the addition +.

4.2 Quadratic Programs and Cryptographic Protocol

The next pipeline stage accepts a Boolean or arithmetic cir-
cuit and builds a QSP or QAP (§2). Then, per §3.1, it com-
piles the quadratic program into a set of cryptographic rou-
tines for the client (key generation and veriﬁcation) and the
worker (computation and proof generation). For comparison,
we also implement the original GGPR [30]; §5.4 shows that
Pinocchio’s enhancements reduce overhead by 18-64%.

The key-generation routine runs at the client, with se-
lectable public veriﬁcation and zero-knowledge features
(§5.3). The code transmits the evaluation key over the net-
work to the worker; to save bandwidth, the program transmits
as C and the worker compiles it locally.

The computation routine runs at the server, collecting in-
put from the client, using the evaluation key to produce the
proof, and transmitting the proof back to the client (or, if de-
sired, a different veriﬁer). The veriﬁcation routine uses the
veriﬁcation key and proof to determine if the worker cheated.
Our cryptographic code is single-threaded, but each stage
is embarrassingly parallel. Prior work [28] shows that stan-
dard techniques can parallelize work across cores, machines,
or GPUs.
For the cryptographic code, we use a high-
speed elliptic curve library [45] with a 256-bit BN-curve [46]
that provides 128 bits of security. The quadratic-program-
construction and protocol-execution code is 10,832 lines of C
and C++ [42].

4.2.1 Optimizing Operations

We summarize some of the key optimizations we imple-
mented, as well as lessons learned.
Faster Exponentiation. Generating the evaluation key EK
requires exponentiating the same base g to many different
powers. We optimize this operation by adapting Pippenger’s

multi-exponentiation [47] algorithm for use with a single
base. Essentially this means that we build a table of inter-
mediate powers of g, allowing us to compute any particular
exponent with only a few multiplications.

1g0

1g1

1g0

2, g1

2, g0

2, g1

In a similar vein, the worker’s largest source of overhead is
applying the coefﬁcients from the circuit “in the exponent” to
compute gY (s) etc. Here Pippenger’s algorithm is less directly
useful, since the worker does a handful of such operations
for a given work instance, but each operation involves hun-
dreds of thousands of different bases, i.e., given g1, . . . , gm,
e1, . . . , em, for very large m, the worker needs to compute
∏i gei
i . To optimize this operation, we use a sliding-window
technique to build a small table of powers for each pair of
bases. For example, for the ﬁrst two bases, with a window of
size 1, we compute {g0
1g1
2}. In this case, the
table only requires one multiply to build. We can then con-
sider the high order bit of both e1 and e2; together these bits
select one of four values in our table; we multiply that value
into our accumulator and proceed to the next pair of bases.
After all bases have been considered, we square the accumu-
lator (to “move” the portion of the exponent we’ve computed
into the next higher “slot”), and then repeat. In practice, these
tables can save 3-4x, even counting the time to build the ta-
bles in the ﬁrst place.
Polynomial Asymptotics. To generate a proof, the worker
must compute the polynomial h(x) such that t(x)·h(x) = P(x)
(§2). Since we store P(x) in terms of its evaluations at the
roots of the quadratic program (recall Figure 2), the worker
must ﬁrst interpolate to ﬁnd P(x) and then perform a polyno-
mial division to arrive at h(x).

Note that all of these computations take place in a normal
ﬁeld, whereas all of the worker’s other steps involve crypto-
graphic operations, which §5.1 shows are about three orders
of magnitude more expensive.

Thus, one might na¨ıvely conclude, as we did, that simple
polynomial algorithms, such as Lagrangian interpolation and
“high-school” polynomial multiplication, sufﬁce. However,
we quickly discovered that the O(n2) behavior of these algo-
rithms, at the scale required for veriﬁable computing, dwarfed
the linear number of cryptographic operations (§5.1). Hence
we implemented an FFT-based O(n log n) polynomial mul-
tiplication library and used a polynomial interpolation algo-
rithm [48] that builds a binary tree of polynomials, giving
total time O(n log2 n). Even so optimized, solving for h(x) is
the second largest source of worker overhead.
Preparing for the Future; Learning from the Past. In our
implementation and evaluation, we assume a worst case sce-
nario in which the client decides, without any warning, to
outsource a new function, and similarly that the worker only
ever computes a single instance for a given client. In prac-
tice, neither scenario is plausible. When the client ﬁrst installs
Pinocchio, the program, could, in theory, build the single base
exponent table discussed above. Further, it can choose a ran-
dom s and begins computing powers of s in the background,
since these are entirely independent of the computation.

8

Similarly, if the worker performs more than a single com-
putation for the client, he can hold onto the exponentiation
tables he built for the ﬁrst computation and save substantial
time on subsequent computations. He can also save the poly-
nomial tree used to accelerate the computation of h(x). None
of these values have any secret information, so workers could
potentially even share this information amongst themselves.
Working With Elliptic Curves. Our BN curve is deﬁned by
the equation y2 = x3 + b, in that each group element gi is a
point (x, y) on the curve. To speed operations, while comput-
ing on elliptic curve points, we represent them in projective
form, as three coordinates (x, y, z), which corresponds to the
afﬁne point (x/z2, y/z3). This is analogous to representing
a rational number as an integral numerator and denominator.
Projective coordinates reduce EC operation costs by ∼60%.
We save space in the cryptographic keys and proof by con-
verting points back to afﬁne form before storing or transmit-
ting them. Furthermore, rather than store (x, y), we store x
and a bit indicating which square root of x3 + b to use for y,
reducing key and proof size by another 50%.

4.3 Applications

Pinocchio runs several applications; each can be instantiated
with some static parameters, and then each instance can be
executed with dynamic inputs.

Fixed Matrix multiplies an n × n matrix parameter M by
an n-length input vector A, and outputs the resulting n-length
vector M · A. We choose ﬁve parameter settings that range
from |M| = 200 × 200 to |M| = 1000 × 1000.

Two Matrices has parameter n, takes as input two n × n
matrices M1 and M2, and outputs the n × n matrix M1 · M2.
Matrix operations are widely used, e.g., in collaborative ﬁl-
tering [49]. (|M| = 30 × 30 to |M| = 110 × 110)

MultiVar Poly evaluates a k-variable, m-degree multivariate
polynomial. The (m + 1)k coefﬁcients are parameters, the k
variables x1, . . . , xk are the inputs, and the polynomial’s scalar
value is the output. (k = 5, m = 6, 16,807 coeff. to k = 5,
m = 10; 644,170 coeff.)

Image Matching is parameterized by an iw × ih rectangular
image and parameters kw, kh. It takes as input a kw × kh im-
age kernel, and outputs the minimum difference and the point
(x, y) in the image where it occurs. (iw × ih = 25, kw × kh = 9
to iw × ih = 2025, kw × kh = 9)

Shortest Paths implements the Floyd-Warshall O(n3) graph
algorithm, useful for network routing and matrix inversion.
Its parameter n speciﬁes the number of vertices, its input is
an n × n edge matrix, and its output is an n × n matrix of all-
pairs shortest paths. (n = 8, e = 64 to n = 24, e = 576)

LGCA is a Lattice-Gas Cellular Automata implementation
that converges to Navier-Stokes [50]. It has parameter n, the
ﬂuid lattice size, and k, the iteration count. It inputs one n-cell
lattice and outputs another reﬂecting k steps. (n = 294, k = 5
to n = 294, k = 40)

SHA-1 has no parameters. Its input is a 13-word (416-bit)
input string, and it outputs its 5-word (160-bit) SHA-1 hash.

Op
Fixed Base Exp (naive)
Fixed Base Exp (opt)
Multi Exp, 254-bit exp (naive)
Multi Exp, 254-bit exp (opt)
Multi Exp, 32-bit exp (opt)
Multi Exp,
1-bit exp (opt)
Compress
Decompress

Base Curve
318.5µs
38.2µs
318.5µs
104.5µs
14.9µs
9.5µs
30.2µs
27.0µs

Twist Curve
1221.4µs
118.3µs
1221.5µs
401.0µs
56.8µs
36.4µs
2160.9µs
2168.3µs

Pairing
Field Add
Field Mul

0.9ms
50.2ns
361.1ns

Figure 4: Microbenchmarks. Breakdown of the main sources of
performance overhead in the larger protocol. (N = 100, σ ≤ 1%).

Poly Interp (naive)
Poly Interp (opt)
Poly Mul (naive)
Poly Mul (opt)

10
0.5ms
1.1ms
0.1ms
0.1ms

Degree
100
238.3ms
21.1ms
8.6ms
0.4ms

1000
202013.1ms
331.1ms
799.7ms
4.1ms

Figure 5: Cost of Polynomial Operations. Illustrates the impor-
tance of optimizing polynomial algorithms. (N = 500, σ ≤ 5%).

5 Evaluation

We experiment on a Lenovo X201 ThinkPad. We run on a
single core of a 2.67 GHz Intel Core i7 with 8 GB of RAM.
Pinocchio’s results use QAPs, since theory (§3.2) and practice
(§5.5) show they offer superior performance.

5.1 Microbenchmarks

We performed a series of microbenchmarks to quantify the
basic cost units of our protocol (Fig. 4). Field operations are
about three orders of magnitude cheaper than cryptographic
exponentiations or multiplications. As §3.1 explained, we use
an asymmetric pairing function, meaning that some group el-
ements live on a (relatively) cheap base curve, while others
live on the “twist” curve. Operations on the latter are 3-4×
as expensive, reinforcing the importance of our optimizations
to the VC protocol to move as many operations as possible
to the base curve. Ultimately, Pinocchio’s protocol requires
only the W polynomials to operate on the twist curve; all
other operations take place on the base curve.

Figures 4 and 5 also show the impact of the exponentiation
and polynomial optimizations described in §4.2.1, which re-
duce costs by two to three orders of magnitude for polynomial
operations, and factors of 3-10 for exponentiations.

5.2 Comparison With Previous Work

Figure 6 plots Pinocchio’s performance against that of pre-
vious general-purpose systems. We use the multiplication
of two matrices as our test application since it has ap-
peared in several prior papers [25, 27], though simpler, non-
cryptographic veriﬁcation procedures exist [51, §7.1]. Since

9

(a) Per-Instance Veriﬁcation Latency

(b) Worker Latency

Figure 6: Performance Relative to Prior Schemes. Pinocchio
reduces costs by orders of magnitude (note the log scale on the y-
axis). We graph the time necessary to (a) verify and (b) produce a
proof result for multiplying two NxN matrices.

all of these prior schemes are designated veriﬁer, we measure
against Pinocchio’s designated veriﬁer mode.

We compare against 1) a na¨ıve version of a PCP-based
scheme [52]; 2) GGP [22], an early scheme that deﬁned veri-
ﬁable computation, but which relies on fully-homomorphic-
encryption (FHE); 3) Pepper [27], an optimized reﬁnement of
(1); and 4) Ginger [28], a further reﬁnement of Pepper. See
Section 6 for more details on these schemes and the trade-
offs between them. Since most of these schemes are ridicu-
lously impractical, we model, rather than measure, their per-
formance. For GGP, we built a model of its performance
based on the latest performance results for FHE [53], while
for the others, we used previously published models [27, 28].
For Pinocchio, however, we use real numbers from our im-
plementation.

Figure 6 shows that Pinocchio continues the recent trend of
reducing costs by orders of magnitude. Early PCP and FHE-
based schemes are laughably impractical, taking hundreds to
trillions of years to produce or verify a single proof. Pepper
and Ginger have made huge improvements over prior work,
but, as we discuss in more detail in §6, they do not offer public
veriﬁcation or zero knowledge.

In addition to offering new properties, Pinocchio signif-
icantly improves performance and security. The systems
shown in Figure 6 amortize setup work across many work
instances,4 but the characteristics of the amortization differ.
To reach a break-even point, where the client does less work
verifying than performing the work locally, Pepper and Gin-
ger must batch work instances, whereas GGP and Pinocchio
must perform enough instances to amortize key setup costs.
These approaches have very different effects on latency. A
client cannot beneﬁt from Pepper or Ginger until it has accu-
mulated an entire batch of instances. In Pinocchio, key setup
can be precomputed, and henceforth every instance (includ-
ing the ﬁrst one) enjoys a better-than-break-even latency. Fig-
ure 6 shows the minimum latency achievable by each system.

4 In contrast, Pinocchio’s public veriﬁer (not shown) enables a client to

beneﬁt from a third party’s key setup work.

Figure 7: Cost of Veriﬁcation Vs. Local. Veriﬁcation must be
cheaper than native execution for outsourcing to make sense, though
for applications that want zero-knowledge, more expensive veriﬁca-
tion may be acceptable. All apps trend in the right direction, and
three apps cross the plane where veriﬁcation is cheaper than na-
tive. Error bars, often too small to see, represent 95% conﬁdence
intervals (N = 50, σ ≤ 2%).

Compared with Ginger, Pinocchio’s veriﬁer is ∼120,000× -
17,000,000× faster, and the worker is 19-60× faster. To im-
prove performance, Ginger’s parameters are chosen such that
the probability that the adversary can successfully cheat can
be as high as 1
220 [28, Figure 2], while in Pinocchio, the prob-
ability is roughly 1

2128 .

5.3 End-to-End Application Performance

We measure Pinocchio’s performance for the applications and
parameter settings described in Section 4.3. All applications
are written in C and compile to both QAPs and to native exe-
cutables. We measure performance using 32-bit input values,
so we can compare against the native C version. This ob-
viously makes things more challenging for Pinocchio, since
Pinocchio operates over a 254-bit ﬁeld using multi-precision
integers, whereas the local execution uses the CPU’s native
32-bit operations.

Figure 7 plots Pinocchio’s veriﬁcation time against the
time to execute the same app natively; each line represents
a parameterized app, and each point represents a particular
parameter setting. Our key ﬁnding is that, for sufﬁciently
large parameters, three apps cross the line where outsourc-
ing makes sense; i.e., verifying the results of an outsourced
computation is cheaper than local native execution. Note that
the slope of each app’s line is dictated by the size of the app
parameters we experimented with (e.g., we reached larger pa-
rameters for ﬁxed matrix than for two matrices).

On the downside, the other three apps, while trending in
the right direction, fail to cross the outsourcing threshold.
The difference is that these three apps perform large numbers
of inequality comparisons and/or bitwise operations. This
makes our circuit-based representation less efﬁcient relative

10

255075100Matrix Dimension (NxN)10-310-1101103105107109101110131015101710191021Time (s)PCPsGGPPepperGingerPinocchio255075100Matrix Dimension (NxN)100102104106108101010121014101610181020Time (s)0246810121416Native Execution (ms)0246810121416QAP DV Verify (ms)Cheaper to verifythan execute locallyShortest PathsImage MatchingLattice Gas SimTwo MatricesMultiVar PolyFixed Matrix0.00.10.20.30.40.59.69.810.010.210.410.610.8Fixed Matrix, Medium
Fixed Matrix, Large
Two Matrices, Medium
Two Matrices, Large
MultiVar Poly, Medium
MultiVar Poly, Large
Image Matching, Medium
Image Matching, Large
Shortest Paths, Medium
Shortest Paths, Large
Lattice Gas Sim, Medium
Lattice Gas Sim, Large
SHA-1

(MB)

|IO|
600
1,201
1,000
2,001
14,701
347,900
36,301 1,343,100
203,428
571,046
86,345
277,745
366,089
1,153 1,400,493
144,063
283,023
23,785

Mult KeyGen Compute Verify (ms) Circuit Native EvalKey VerKey Proof
(B)
Gates Pub (s)
288
0.7
288
1.5
288
79.8
288
299.3
288
41.9
288
127.1
288
26.4
288
67.0
288
85.4
288
317.5
288
38.2
288
75.6
288
12.0

Priv
(s) Pub
39.5
10.0
0.4
58.9 *10.1
0.9
12.1
269.4 340.7
1127.8 882.2 *15.4
10.0
11.6
246.1
711.6 *12.7 *11.1
9.9
11.1
41.1
10.1
11.4
144.4
10.0
25.5
198.0
10.8
48.9
850.2
9.9
10.9
76.4
9.8
10.9
165.8
9.9
11.1
15.7

(KB)
37.9
62.9
459.8
374.8 1134.8
0.6
0.6
0.8
0.8
16.4
36.4
1.1
1.1
1.1

(ms)
123.7
337.4
124.9
509.5
93.1
267.2
5.5
18.0
18.7
69.5
91.4
176.6
18.8

(ms)
4.3
12.4
4.0
15.5
4.5
12.9
0.1
0.4
0.1
0.3
0.2
0.4
0.0

55.9
156.8
23.6
75.8
99.6
381.4
39.6
77.7
6.5

7
7
13
13
513

0.3
0.5
97.9

21
21
22

Figure 8: Application Performance. Pinocchio’s performance for a sampling of the parameter settings (§4.3). All programs are compiled
directly from C. Private KeyGen is always within 0.4% of public KeyGen, and so is omitted. Veriﬁcation values in bold indicate veriﬁcation
is cheaper than computing the circuit locally; those with stars (*) indicate veriﬁcation is cheaper than native execution. (N = 50, σ ≤ 2%).

to native, and hence on our current experimental platform, we
cannot push the application parameter settings to the point
where they would beat local execution. Nonetheless, these
applications may still be useful in settings that require Pinoc-
chio’s zero-knowledge proofs.

Fortunately, additional experiments show that enabling
zero-knowledge proofs adds a negligible, ﬁxed cost to key
generation (213µs), and re-randomizing a proof to make it
zero-knowledge requires little effort (e.g., 300ms or 0.1% for
the multivariate polynomial app).

Figure 8 provides more details of Pinocchio’s performance.
For KeyGen, our experiments conservatively assume that the
client does no precomputation in anticipation of outsourcing
a function, and for Compute, we assume that the worker only
does a single work instance before throwing away all of its
state. As discussed in §4.2.1, in practice, we would take
advantage of both precomputation and caching of previous
work, which on average saves at least 43% of the effort for
KeyGen and 16% of the effort for Compute.

In Figure 8, we see again that three apps (starred) beat
native execution, including one in the public veriﬁer setting
(which requires more expensive operations per IO). The data
also reinforces the point that using a circuit representation
imposes a signiﬁcant cost on image matching, shortest paths,
and the lattice gas sim relative to native, suggesting a tar-
get for optimization. Relative to the circuit representation,
Pinocchio’s veriﬁcation is cheap: both the public and the des-
ignated veriﬁer “win” most of the time when compared to the
circuit execution. Speciﬁcally, the designated veriﬁer wins
in 12 of 13 (92%) application settings. Public veriﬁcation is
more expensive, particularly for large IO, but still wins in 9
of 13 (69%) settings.

Since Pinocchio offers public veriﬁcation, some clients
will beneﬁt from the KeyGen work of others, and hence only
care about the veriﬁcation costs. For example, a cellphone
carrier might perform the one-time KeyGen so that its cus-
tomers can verify computations done by arbitrary workers.

However, in other settings, e.g., a company outsourcing
work to the cloud, the key generator and veriﬁer may be the
same entity, and will wish to amortize the cost of key gen-
eration via the savings from veriﬁcation. Figure 8 shows
that most apps have a low “break even” point vs. circuit ex-
ecution:
the median for the designated veriﬁer is 555 in-
stances and for public veriﬁer is 500 instances,5 both with
a low of 5 instances for ﬁxed matrix. Every instance after-
wards is a net “win”, even for the key generator. The median
break-even points are higher (70K and 605K) when compared
against native execution, since the outsourcing margin is rel-
atively small for the current parameter settings. Larger pa-
rameter settings, improved veriﬁcation techniques, or com-
paring against a big integer library instead of native execu-
tion [27, 28] would all bring these values down.

Figure 8 holds more good news for Pinocchio:

the keys
it generates are reasonably sized, with the evaluation key
(which describes the entire computation) typically requiring
10s or 100s of MB. The weak veriﬁer’s key (which grows lin-
early with the I/O) is typically only a few KB, and even at its
largest, for two-matrix multiplication, it requires only slightly
more than 1 MB. This suggests that the keys are quite portable
and will not require excessive bandwidth to transmit.

Finally, from the client’s perspective, if the worker’s efforts
are free, then the worker’s additional overhead of generating a
proof is irrelevant, as long as it doesn’t hurt response latency.
Our results, combined with prior work on parallelization [28],
suggest that latency can be brought down to reasonable levels,
given enough hardware. And indeed in high-assurance sce-
narios, scenarios where the client is incapable of performing
the calculation itself (e.g., a power-limited device), or scenar-
ios where the worker’s resources are otherwise idle, the client
may very well view the worker as “free”.

However, in other scenarios, such as cloud computing, the
worker’s efforts are not free. Even here, however, Chen and

5The public veriﬁer’s median is lower, since it wins on fewer app settings.

11

KeyGen

Build table
Encode powers of s
Eval polys at s
Encode polys

Compute

Solve for h(x)
Apply coefﬁcients

Verify

Process I/O
Crypto checks
Evaluation Key Size
Veriﬁcation Key Size
Proof Size

GGPR [30]
108.7s
7.8s
28.4s
5.0s
67.2s
691.4s
252.3s
391.1s
15.2ms
456.5µs
14.8ms
105.5MB
640B
352B

This Paper
41.9s
7.9s
4.7s
1.7s
27.4s
246.1s
76.3s
154.7s
11.6ms
901.8µs
10.7ms
55.9MB
640B
288B

Reduction
61%
-2%
83%
66%
59%
64%
70%
60%
24%
-98%
28%
47%
0%
18%

Figure 9: Improving GGPR [30]. Performance for the multi-
variate polynomial application. Pinocchio’s high-level operations
are 2.6x, 2.8x, and 1.3x faster than the original. (N = 10, σ ≤ 2%).

Sion estimate that the cost of cloud computing is about 60×
cheaper than local computing for a small enterprise [54]. This
provides an approximate upper-bound for the amount of extra
work we should be willing to add to the worker’s overhead.
While we do not yet achieve this bound, we make substantial
progress on reducing the worker’s overhead, and the progress
shown in Figure 6(b) gives us hope.

5.4

Impact of Our Optimizations

In Figure 9, we break down Pinocchio’s protocol overhead for
the large multivariate polynomial example application, to bet-
ter identify the major bottlenecks. For comparison, we also
measure the performance of our implementation of GGPR’s
scheme [30], using the same underlying cryptographic and
polynomial libraries.

The results indicate that our protocol improvements had a
signiﬁcant impact. KeyGen and Compute are more than twice
as fast, and even veriﬁcation is 24% faster. Of Pinocchio’s re-
maining KeyGen overhead, the majority comes from encod-
ing the evaluations of the QAP’s polynomials in the gener-
ator’s exponent. For Compute, the multi-exponentiation re-
quired to compute the QAP’s polynomials in the exponent
still dominate, but the overhead of solving for h(x) is non-
trivial as well.

Pinocchio also drastically reduces the size of the evaluation
key and even manages to reduce the size of GGPR’s already
svelte 9 element proof to 8 elements.

5.5 QSPs versus QAPs

to conﬁrm our theoretical prediction that QAPs
Finally,
would outperform QSPs (§3.2), we compared the two on our
SHA-1 application, which performs numerous bitwise oper-
ations, and hence should favor QSPs. The resulting QSP’s
size was 38.6× that of the QAP, and the degree was 55.5×
as large. Not surprisingly, the QSP’s KeyGen took 35.2× and
Compute took 55.4× as long as those of the QAP; the veriﬁ-
cation times were comparable.

6 Related Work
Much of the prior work in this area focuses on verifying spe-
ciﬁc functions via auditing or special properties of the func-
tions [2–6]. Other systems rely on replication, and hence as-
sume failures are uncorrelated [1, 7, 8, 55]. A large body of
work veriﬁes computation by assuming the worker employs
secure hardware [9–15].

While the theory and cryptography community has long
studied the problem of general-purpose proof systems [16–
23], until recently, this work was largely regarded as highly
impractical, to the point where no one bothered to implement
it. Much of this work [16–20, 56] relied on Probabilisti-
cally Checkable Proofs (PCPs), which offer impressive the-
oretical performance, but which can take trillions of years to
verify in practice [27]. Other work [22, 23] relies on fully-
homomorphic encryption (FHE) [24], which, despite contin-
uing advances [53], remains highly impractical.

Recently, security and systems researchers have started to
develop techniques to make theoretical cryptographic proto-
cols practical. Secure multiparty computation, for example,
has seen tremendous progress [57–59]. However, since the
primary focus is on secrecy, not outsourcing, both parties typ-
ically perform work equal to evaluating the function.

With regard to implementing veriﬁed computation, in the
last year, two parallel efforts have emerged. One effort [25,
26] builds on the interactive proofs of Goldwasser et al. [20]
(GKR), which draw on many techniques from the PCP liter-
ature. They target a streaming setting where the client cannot
store all of the data it wishes to compute over; the system cur-
rently requires the function computed to be highly paralleliz-
able. On the plus side, it does not require cryptography, and
it is secure against computationally unbounded adversaries.

Setty et al. produced a line of PCP-based systems called
Pepper [27] and Ginger [28]. They build on a particular type
of PCP called a linear PCP [52], in which the proof can be
represented as a linear function. This allows the worker to
use a linearly-homomorphic encryption scheme to create a
commitment to its proof while relying only on standard cryp-
tographic assumptions. Through a combination of theoretical
and systems-level improvements, this work made tremendous
progress in making PCP-based systems practical. Indeed, for
applications that can tolerate large batch sizes, the amortized
costs of veriﬁcation can be quite low.

A few downsides remain, however. Because the work
builds on the Hadamard PCP [56], the setup time, network
overhead, and the prover’s work are quadratic in the size of
the original computation, unless the protocol is hand-tailored.
To achieve efﬁciency, the veriﬁer must outsource computa-
tions in batches, which means it cannot verify the results un-
til the full batch returns. The scheme is designated veriﬁer,
meaning that third parties cannot verify the results of out-
sourced computations without sharing the client’s secret key,
and hence opening the possibility for fraud. The scheme also
does not support zero-knowledge proofs.

12

Concurrent work [60] also builds on the quadratic pro-
grams of Gennaro et al [30]. They observe that QAPs can be
viewed as linear PCPs and hence can ﬁt into Ginger’s cryp-
tographic framework [28]. Their work shows worker com-
putation improvements similar to those of Pinocchio. Addi-
tional concurrent work [61] adapts previous GKR-based pro-
tocols [25, 26] to the batching model and develops a com-
piler that chooses amongst three PCP-based backends. Both
systems retain PCPs and Ginger’s cryptographic protocol, so
they rely on simpler cryptographic assumptions than Pinoc-
chio, but they must still batch computations to obtain an efﬁ-
cient veriﬁer. They also remain designated veriﬁer and do not
support zero-knowledge proofs.

Previous systems either did not offer a compiler [25–27], or
compiled from a subset of an academic language, SFDL [28,
60]. In contrast, we compile from a subset of C, which should
ease the development burden for verifying computation.

Several systems provide compilers for zero-knowledge
(ZK) proofs [62–64]. Both the systems of Almeida et al. [62]
and Meiklejohn et al. [63] adopt an approach based on Σ-
protocols [65]. The former provides functionality for prov-
ing knowledge in arbitrary groups, AND and OR composi-
tions, and linear relations. The latter focuses on functionali-
ties for cryptographic protocols, e.g., e-cash, blind signatures,
or veriﬁable encryption. The compiler of Backes et al. [64]
uses Groth-Sahai ZK proofs [66] and handles logical formu-
las. Rial and Danezis [32] propose a system for privacy-
preserving smart metering in which clients use a ZK protocol
to prove correctness of the billing computation they perform
on meter readings. In general, these systems are likely to ex-
hibit better performance than Pinocchio for their particular
subset of functionality, but they do not possess the same level
of efﬁcient generality.

7 Conclusion and Future Work

We have presented Pinocchio, a system for public veriﬁ-
able computing. Pinocchio uses quadratic programs, a new
method for encoding computation, combined with a highly
efﬁcient cryptographic protocol to achieve both asymptotic
and concrete efﬁciency. Pinocchio produces 288-byte proofs,
regardless of the size of the computation, and the proofs can
be veriﬁed rapidly, typically in tens of milliseconds, beating
native execution in several cases. This represents ﬁve to seven
orders of magnitude performance improvement over prior
work. The worker also produces the proof 19-60× faster.
Pinocchio even slashes the cost of its underlying protocol,
cutting the cost of both key and proof generation by more
than 60%. The end result is a natural cryptographic protocol
for efﬁciently signing computations. Combined with a com-
piler for real C programs, Pinocchio brings veriﬁable compu-
tation much closer to practicality.

Nonetheless gaps still remain. We hope that additional the-
oretic improvements, combined with efforts to expand our
toolchain, e.g., to support ﬂoating point or parallel execu-
tion (via standard techniques [25, 28, 43]), will continue to
advance us towards truly practical veriﬁable computing.

Acknowledgements

The authors gratefully thank: Peter Montgomery, Michael
Naehrig, and Patrick Longa for assisting us with the crypto-
graphic library used by Pinocchio; Chris Hawblitzel for his
sage guidance on compiler development; Rosario Gennaro
for valuable discussions; and the anonymous reviewers for
their helpful comments. Mariana Raykova was supported by
NSF Grant No. 1017660.

References

[1] D. P. Anderson, J. Cobb, E. Korpela, M. Lebofsky, and D. Werthimer,
“SETI@Home: An experiment in public-resource computing,” Com-
munications of the ACM, vol. 45, no. 11, 2002.

[2] F. Monrose, P. Wyckoff, and A. Rubin, “Distributed execution with

remote audit,” in Proc. of ISOC NDSS, 1999.

[3] P. Golle and S. G. Stubblebine, “Secure distributed computing in a
commercial environment,” in Proc. of Financial Cryptography, 2002.
[4] W. Du and M. T. Goodrich, “Searching for high-value rare events with

uncheatable grid computing,” in ACNS, 2005.

[5] P. Golle and I. Mironov, “Uncheatable distributed computations,” in

Proc. of CT-RSA, 2001.

[6] R. Sion, “Query execution assurance for outsourced databases,” in The

Very Large Databases Conference (VLDB), 2005.

[7] M. Castro and B. Liskov, “Practical Byzantine fault tolerance and

proactive recovery,” ACM Trans. on Comp. Sys., vol. 20, no. 4, 2002.

[8] B. Carbunar and R. Sion, “Uncheatable reputation for distributed com-

putation markets,” in Financial Cryptography, 2006.

[9] R. Sailer, X. Zhang, T. Jaeger, and L. van Doorn, “Design and im-
plementation of a TCG-based integrity measurement architecture,” in
Proc. of the USENIX Security, 2004.

[10] L. Chen, R. Landfermann, H. L¨ohr, M. Rohe, A.-R. Sadeghi, and
C. St¨uble, “A protocol for property-based attestation,” in Proc. of the
ACM Workshop on Scalable Trusted Computing (STC), 2006.

[11] B. Parno, J. M. McCune, and A. Perrig, Bootstrapping Trust in Modern

Computers. Springer, 2011.

[12] A. Seshadri, M. Luk, E. Shi, A. Perrig, L. VanDoorn, and P. Khosla,
“Pioneer: Verifying integrity and guaranteeing execution of code on
legacy platforms,” in Proc. of the ACM SOSP, 2005.

[13] R. B. Lee, P. Kwan, J. P. McGregor, J. Dwoskin, and Z. Wang, “Archi-
tecture for protecting critical secrets in microprocessors,” in Proc. of
the International Symposium on Computer Architecture (ISCA), 2005.
[14] D. Lie, C. A. Thekkath, M. Mitchell, P. Lincoln, D. Boneh, J. C.
Mitchell, and M. Horowitz, “Architectural support for copy and tamper
resistant software,” in Proc. of the ACM ASPLOS, 2000.

[15] A.-R. Sadeghi, T. Schneider, and M. Winandy, “Token-based cloud
computing: secure outsourcing of data and arbitrary computations with
lower latency,” in TRUST, 2010.

[16] S. Goldwasser, S. Micali, and C. Rackoff, “The knowledge complexity

of interactive proof systems,” SIAM J. Comput., vol. 18, no. 1, 1989.

[17] S. Arora and S. Safra, “Probabilistic checking of proofs: A new char-

acterization of NP,” J. ACM, vol. 45, no. 1, pp. 70–122, 1998.

[18] J. Kilian, “A note on efﬁcient zero-knowledge proofs and arguments

(extended abstract),” in STOC, 1992.

[19] S. Micali, “Computationally sound proofs,” SIAM J. Comput., vol. 30,

no. 4, pp. 1253–1298, 2000. Extended abstract in FOCS ’94.

[20] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum, “Delegating compu-

tation: Interactive proofs for muggles,” in STOC, 2008.

[21] J. Groth, “Short pairing-based non-interactive zero-knowledge argu-

ments,” in ASIACRYPT, 2010.

[22] R. Gennaro, C. Gentry, and B. Parno, “Non-interactive veriﬁable com-
puting: Outsourcing computation to untrusted workers,” 2010.
[23] K.-M. Chung, Y. T. Kalai, and S. P. Vadhan, “Improved delegation of
computation using fully homomorphic encryption,” in CRYPTO, 2010.
[24] C. Gentry, A fully homomorphic encryption scheme. PhD thesis, Stan-

ford University, 2009. crypto.stanford.edu/craig.

[25] J. Thaler, M. Roberts, M. Mitzenmacher, and H. Pﬁster, “Veriﬁable
computation with massively parallel interactive proofs,” in USENIX
HotCloud Workshop, 2012.

13

[26] G. Cormode, M. Mitzenmacher, and J. Thaler, “Practical veriﬁed com-

putation with streaming interactive proofs,” in ITCS, 2012.

[27] S. Setty, R. McPherson, A. J. Blumberg, and M. Walﬁsh, “Making ar-
gument systems for outsourced computation practical (sometimes),” in
Proceedings of the ISOC NDSS, 2012.

[28] S. Setty, V. Vu, N. Panpalia, B. Braun, A. J. Blumberg, and M. Wal-
ﬁsh, “Taking proof-based veriﬁed computation a few steps closer to
practicality,” in Proc. of USENIX Security, 2012.

[29] B. Parno, M. Raykova, and V. Vaikuntanathan, “How to delegate and
verify in public: Veriﬁable computation from attribute-based encryp-
tion,” in IACR Theory of Cryptography Conference (TCC), 2012.
[30] R. Gennaro, C. Gentry, B. Parno, and M. Raykova, “Quadratic span
programs and succinct NIZKs without PCPs,” in EUROCRYPT, 2013.
Originally published as Cryptology ePrint Archive, Report 2012/215.
[31] M. Blum, A. D. Santis, S. Micali, and G. Persiano, “Noninteractive
zero-knowledge,” SIAM J. on Computing, vol. 20, no. 6, 1991.
[32] A. Rial and G. Danezis, “Privacy-preserving smart metering,” in Proc.

of the ACM WPES, 2011.

[33] N. Pippenger and M. J. Fischer, “Relations among complexity mea-

sures,” J. ACM, vol. 26, no. 2, 1979.

[34] D. Boneh and M. Franklin, “Identity-based encryption from the Weil

pairing,” Proceedings of IACR CRYPTO, 2001.

[35] D. Boneh, X. Boyen, and E.-J. Goh, “Hierarchical identity based en-
cryption with constant size ciphertext,” in EUROCRYPT, 2005.
[36] D. Boneh, C. Gentry, and B. Waters, “Collusion resistant broadcast
encryption with short ciphertexts and private keys,” in CRYPTO, 2005.
[37] M. Naor, “On cryptographic assumptions and challenges,” in Proceed-

[57] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella, “Fairplay—a secure two-
party computation system,” in Proc. of USENIX Security, 2004.
[58] Y. Huang, D. Evans, J. Katz, and L. Malka, “Faster secure two-party
computation using garbled circuits,” in USENIX Security, 2011.
[59] B. Kreuter, abhi shelat, and C.-H. Shen, “Billion-gate secure computa-

tion with malicious adversaries,” in Proc. of USENIX Security, 2012.

[60] S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walﬁsh,
“Resolving the conﬂict between generality and plausibility in veriﬁed
computation,” in Proc. of the ACM European Conference on Computer
Systems (EuroSys), Apr. 2013.

[61] V. Vu, S. Setty, A. J. Blumberg, and M. Walﬁsh, “A hybrid architecture
for interactive veriﬁable computation,” in IEEE Symposium on Security
and Privacy, May 2013.

[62] J. B. Almeida, E. Bangerter, M. Barbosa, S. Krenn, A.-R. Sadeghi,
and T. Schneider, “A certifying compiler for zero-knowledge proofs of
knowledge based on σ-protocols,” in Proc. of ESORICS, 2010.
[63] S. Meiklejohn, C. C. Erway, A. K¨upc¸ ¨u, T. Hinkle, and A. Lysyanskaya,
“ZKPDL: A language-based system for efﬁcient zero-knowledge
proofs and electronic cash,” in Proc. of USENIX, 2010.

[64] M. Backes, M. Maffe, and K. Pecina, “Automated synthesis of privacy-
preserving distributed applications,” in Proc. of ISOC NDSS, 2012.
[65] R. Cramer, I. Damg˚ard, and B. Schoenmakers, “Proofs of partial
knowledge and simpliﬁed design of witness hiding protocols,” in Proc.
of CRYPTO, 1994.

[66] J. Groth and A. Sahai, “Efﬁcient non-interactive proof systems for bi-

linear groups,” in Proc. of EUROCRYPT, 2008.

[67] D. Boneh and X. Boyen, “Short signatures without random oracles,” in

ings of IACR CRYPTO, 2003.

EUROCRYPT, 2004.

[38] M. Bellare and A. Palacio, “The knowledge-of-exponent assumptions

and 3-round zero-knowledge protocols,” in CRYPTO, 2004.

[39] C. Gentry and D. Wichs, “Separating succinct non-interactive argu-

[68] R. Gennaro, “Multi-trapdoor commitments and their applications to
proofs of knowledge secure under concurrent man-in-the-middle at-
tacks,” in CRYPTO, 2004.

ments from all falsiﬁable assumptions,” in STOC, 2011.

[40] I. Damg˚ard, “Towards practical public key systems secure against cho-

sen ciphertext attacks,” in IACR CRYPTO, 1991.

[41] “Veriﬁable

computation:

Pinocchio.” http://research.

microsoft.com/verifcomp/, Mar. 2013.

[42] D. A. Wheeler, “SLOCCount.” http://www.dwheeler.com/

sloccount/.

[43] M. Aliasgari, M. Blanton, Y. Zhang, and A. Steele, “Secure computa-
tion on ﬂoating point numbers,” in Proc. of ISOC NDSS, 2013.
[44] A. Holzer, M. Franz, S. Katzenbeisser, and H. Veith, “Secure two-party

computations in ANSI C,” in Proc. of ACM CCS, 2012.

[45] M. Naehrig, R. Niederhagen, and P. Schwabe, “New software speed

records for cryptographic pairings,” in Proc. of LATINCRYPT, 2010.

[46] P. S. L. M. Barreto and M. Naehrig, “Pairing-friendly elliptic curves of

prime order,” in Selected Areas in Cryptography (SAC), 2006.

[47] N. Pippenger, “On the evaluation of powers and related problems (pre-

liminary version),” in Proc. of FOCS, 1976.

[48] A. Aho, J. Hopcroft, and J. Ulman, The Design and Analysis of Com-

puter Algorithms. Addison-Wesley, 1974.

[49] G. Adomavicius and A. Tuzhilin, “Toward the next generation of rec-
ommender systems: A survey of the state-of-the-art and possible exten-
sions,” Trans. Knowledge and Data Engineering, vol. 17, no. 6, 2005.
[50] D. A. Wolf-Gladrow, Lattice-Gas Cellular Automata and Lattice Boltz-

mann Models: An Introduction. Springer, 2005.

[51] R. Motwani and P. Raghavan, Randomized Algorithms. Cambridge

University Press, 1995.

[52] Y. Ishai, E. Kushilevitz, and R. Ostrovsky, “Efﬁcient arguments without
short PCPs,” in IEEE Conference on Computational Complexity, 2007.
[53] C. Gentry, S. Halevi, and N. Smart, “Homomorphic evaluation of the

AES circuit,” in Proceedings of CRYPTO, 2012.

[54] Y. Chen and R. Sion, “To cloud or not to cloud? Musings on costs and
viability,” in Proc. of the ACM Symposium on Cloud Computing, 2011.
[55] G. O. Karame, M. Strasser, and S. Capkun, “Secure remote execution
of sequential computations,” in Intl. Conf. on Information and Commu-
nications Security, 2009.

[56] S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy, “Proof ver-
iﬁcation and the hardness of approximation problems,” J. ACM, vol. 45,
no. 3, 1998.

A Cryptographic Assumptions
We deﬁne the hardness assumptions that we use in the secu-
rity proof of our optimized VC construction from Section 3.1.
Suppose (p, G, GT , e) ← G(1κ) outputs a description of a
cyclic bilinear group [34] of order p, a κ-bit prime, where
e : G × G → GT is the usual pairing (bilinear map) function.
Below, let κ be a security parameter, q = poly(κ), and let A
be a non-uniform probabilistic polynomial time adversary.
Assumption 1 (q-PDH [21]) The q-power Difﬁe-Hellman
(q-PDH) assumption holds for G if for all A we have
(p, G, GT , e) ← G(1κ) ; g ← G\{1} ; s ← Z∗
p ;
, gsq+2, . . . , gs2q
σ ← (p, G, GT , e, g, gs, . . . , gsq

Pr[

) ;

y ← A(σ) : y = gsq+1] = negl(κ).

Assumption 2 (q-PKE [21]) The q-power knowledge of ex-
ponent assumption holds for G if for all A there exists a non-
uniform probabilistic polynomial time extractor χA such that
(p, G, GT , e) ← G(1κ) ; g ← G\{1} ; α, s ← Z∗
p ;
σ ← (p, G, GT , e, g, gs, . . . , gsq
) ;

, gα, gαs, . . . , gαsq

Pr[

(c, ˆc ; a0, . . . , aq) ← (A (cid:107) χA)(σ, z) :
i=0 gaisi
q
ˆc = cα ∧ c (cid:54)= ∏
] = negl(κ)

for any auxiliary information z ∈ {0, 1}poly(κ) that is gener-
ated independently of α. Note that (y; z) ← (A (cid:107) χA)(x) sig-
niﬁes that on input x, A outputs y, and that χA, given the same
input x and A’s random tape, produces z.

14

Difﬁe-
Assumption 3 (q-SDH [67, 68]) The
Hellman (q-SDH) assumption holds for G if for all A:

q-strong

Pr[

(p, G, GT , e) ← G(1κ) ; g ← G\{1} ; s ← Z∗
p ;
σ ← (p, G, GT , e, g, gs, . . . , gsq

) ;

y ← A(σ) : y = e(g, g)

1
s+c , c ∈ Z∗

p] = negl(κ).

B Security Proof for Our VC Scheme
To prove Theorem 1, we assume there exists an adversary Avc
who returns a cheating proof, and we show how to construct
an adversary B that uses Avc and a d-PKE assumption knowl-
edge extractor [21] to break either the q-PDH assumption [21]
or the 2q-SDH assumption [67, 68], where q = 4d + 4. These
assumptions are deﬁned in Appendix A.

Let B be given a challenge g, gs, . . . , gsq

, gsq+2, . . . , gs2q
.
(This challenge can be interpreted as either a q-PDH in-
stance, or a subset (missing gsq+1
) of a 2q-SDH instance.)
Avc generates a function f with N input/output wires that has
a QAP Q f = (t(x),V ,W ,Y ) of size m and degree d. (So
that this proof covers the zero-knowledge variant of the VC
scheme, we include t(x) in each of the sets V ,W ,Y .) Let
Imid = {N + 1, ..., m}, i.e., the non-IO-related indices.

B provides evaluation and veriﬁcation keys to Avc, using

EK = ( {gvk(s)

}k∈Imid ,

}k∈Imid ,

{gwk(s)
w

v
{gαvvk(s)
v
{gsi
}i∈[d],

the same structure as in Protocol 2:
}k∈Imid ,

}k∈Imid , {gαwwk(s)
w
{gβvk(s)
v

{gyk(s)
y
}k∈Imid , {gαyyk(s)
y
gβyk(s))
gβwk(s)
}k∈Imid
y
w
V KF = (g, gαv, gαw, gαy, gγ, gβγ, {gvk(s)
, gwk(s)
w
gt(s)
),
y
v, r(cid:48)
where r(cid:48)
w, gv = gr(cid:48)
r(cid:48)
vr(cid:48)
y = r(cid:48)
and the values β and γ are set as described next.

w, αv, αw, and αy are chosen uniformly at random,
ys3(d+1)
ws2(d+1)
,

, and gy = gr(cid:48)

, gw = gr(cid:48)

}k∈{0}∪Iio ,

}k∈Imid ,

, gyk(s)
y

vsd+1

v

Regarding β, write the ﬁnal proof term with g as the base:

gβv(s)
v

gβw(s)
w

y = gβ(r(cid:48)
gβy(s)

vsd+1v(s)+r(cid:48)

ws2(d+1)w(s)+r(cid:48)

ys3(d+1)y(s)).

(3)

That is, in the exponent, β is multiplied with a certain poly-
nomial that is evaluated at s. B also generates β as a polyno-
mial evaluated at s. In particular, it sets β = sq−(4d+3)βpoly(s),
where βpoly(x) is a polynomial of degree at most 3d + 3
sampled uniformly at random such that βpoly(x) · (r(cid:48)
vvk(x) +
yx2(d+1)yk(x)) has a zero coefﬁcient in front
wxd+1wk(x) + r(cid:48)
r(cid:48)
of x3d+3 for all k. We know that such a polynomial βpoly(x)
exists by Lemma 10 of GGPR [30], which says (roughly)
that, given a set of polynomials {uk(x) ∈ F[x]} of degree at
most D, then there exists a nonzero polynomial a(x) of de-
gree D + 1 such that all of the polynomials a(x)uk(x) have a
nonzero coefﬁcient for xD+1, and moreover for any polyno-
mial u(x) not in the linear span of {uk(x)}, the coefﬁcient of
xD+1 in a(x)u(x) is uniformly random in F (when sampling
a(x) uniformly subject to the above restriction). By inspec-
tion, when we now write out β in terms of s, we see that the
exponent in Equation 3 has a zero in front of sq+1, and also

the powers of s only go up to degree q + 3d + 3 ≤ 2q. There-
fore, B can efﬁciently generate the terms in the evaluation
key that contain β using the elements given in his challenge.
Regarding γ, B generates γ(cid:48) uniformly at random from
F and sets γ = γ(cid:48)sq+2.
B can generate gγ efﬁciently
from its challenge, since gsq+2
is given. Also, βγ =
sq−(4d+3)βpoly(s)γ(cid:48)sq+2 does not have a term sq+1 and has de-
gree at most q − (4d + 3) + (3d + 3) + (q + 2) ≤ 2q, and so B
can generate gβγ from the elements in its challenge.

Similarly none of the other elements in the CRS contains a
term sq+1 in the exponent, since all of the polynomials vk(x),
wk(x) and yk(x) are of degree d and q ≥ 4d + 4. Hence, B can
generate them using the terms from its challenge.

Thus, the evaluation and veriﬁcations keys generated by B

have a distribution statistically identical to the real scheme.

v

v

W (cid:48)
, g
w

, gYmid
y

, gWmid
w

)αv = gV (cid:48)

V (cid:48)
, gH , g
mid
v

Since the veriﬁcation holds, we have that (gVmid

Given EKF and V KF , Avc can run the Compute and Verify
algorithms on its own. Let gVmid
mid
,
Y (cid:48)
, and gZ be a cheating proof that Avc provides for the
mid
g
y
result of the computation of f with input and output {ck}k∈[N].
mid .
We claim that B can run the d-PKE extractor χA to recover
a polynomial Vmid(x) of degree at most d such that Vmid =
Vmid(s). Though it may not be immediately recognizable as
such, the parameters received by Avc are a valid input (σ, z)
for the d-PKE assumption. In particular, a valid input con-
sists of σ = ({gsi
}i∈[0,d]) and z, where the auxil-
iary information z is independent of αv, and the other terms in
the CRS can be generated efﬁciently from (σ, z). The terms
{gvk(s)
} can indeed be efﬁciently generated from {gsi
v }, and
v
the auxiliary information z that Avc receives is indeed inde-
pendent of αv. Therefore, B can invoke the d-PKE extractor
χA to recover Vmid(x), which must be a polynomial of degree
at most d. Similarly, B recovers Wmid(x) and Ymid(x) such
that Wmid = Wmid(s) and Ymid = Ymid(s). Then, it sets H(x) =
((v0(x) +V (x))(w0(x) +W (x)) − (y0(x) +Y (x)))/t(x), where
V (x) = ∑k∈[N] ckvk(x) + Vmid(x) (and similarly for W (x) and
Y (x)).

v }i∈[0,d], {gαvsi

v

wx2(d+1)wk(x) + r(cid:48)

wx2(d+1)Wmid(x) + r(cid:48)

Since the proof veriﬁes, but the statement is false (and
therefore the extracted polynomials cannot actually be a
QAP solution), there are two possible cases: (1) H(x) has
a non-trivial denominator, or (2) The polynomial R(x) =
yx3(d+1)Ymid(x) is not in
vxd+1Vmid(x) + r(cid:48)
r(cid:48)
the linear subspace, S, generated by the polynomials {rk(x) =
vxd+1vk(x) + r(cid:48)
r(cid:48)
First, we show that these are the only two cases, if the proof
veriﬁes but the statement is false. We assume that neither
case 1 nor case 2 holds; i.e., H(x) has no non-trivial denom-
inator, and R(x) is in the linear subspace S. We will show
that V (x), W (x), and Y (x) are a solution for the QAP; i.e.,
they can be written as linear combinations of {vk(x)k∈[m]},
{wk(x)k∈[m]} and {yk(x)k∈[m]} using the same coefﬁcients,
and (v0(x) +V (x))(w0(x) +W (x)) − (y0(x) +Y (x)) is divisi-
ble by t(x).

yx3(d+1)yk(x)}k∈Imid .

),

15

a

is

in

the

linear

subspace

Each of

combination

there
such

Since R(x)

S,
{ck}k∈Imid

ex-
ists
that
Thus, we can write R(x) as
R(x) = ∑k∈Imid ckrk(x).
yx3(d+1)Y †(x), where
wx2(d+1)W †(x) + r(cid:48)
vxd+1V †(x) + r(cid:48)
r(cid:48)
V †(x) = ∑k∈Imid ckvk(x), W †(x) = ∑k∈Imid ckwk(x),
and
Y †(x) = ∑k∈Imid ckyk(x).
the polynomials
V †(x),W †(x),Y †(x) has degree at most d because they are in
the spans of {vk(x)k∈Imid }, {wk(x)k∈Imid } and {yk(x)k∈Imid }
respectively. Since Vmid(x), Wmid(x) and Ymid(x) also have
degree d, and since the linear subspaces {xd+1+i|i ∈ [0, d]},
{x2(d+1)+i|i ∈ [0, d]}, and {x3(d+1)+i|i ∈ [0, d]} are dis-
the origin), we conclude from R(x) =
joint (except at
yx3(d+1)Ymid(x) =
wx2(d+1)Wmid(x) + r(cid:48)
vxd+1Vmid(x) + r(cid:48)
r(cid:48)
vxd+1V †(x) + r(cid:48)
r(cid:48)
that we
can write Vmid(x) = V †(x) = ∑k∈Imid ckvk(x), Wmid(x) =
W †(x) = ∑k∈Imid ckwk(x), Ymid(x) = Y †(x) = ∑k∈Imid ckyk(x).
V (x) = ∑k∈[N] ckvk(x) + ∑k∈Imid ckvk(x),
Therefore,
and Y (x) =
W (x) = ∑k∈[N] ckwk(x) + ∑k∈Imid wkvk(x)
∑k∈[N] ckyk(x) + ∑k∈Imid ckyk(x).
Now we have that
V (x), W (x), and Y (x) indeed can be written as the
same linear combination {ck}k∈[m] of
their polynomial
sets, as required in a QAP. Since H(x) has no non-
t(x) evenly divides
trivial denominator,
it follows that
(v0(x) +V (x))(w0(x) +W (x)) − (y0(x) +Y (x)). Hence V (x),
W (x), and Y (x) constitute a QAP solution associated to
the input/output {ck}k∈[N], and hence to a true statement,
contradicting our initial assumption.

wx2(d+1)W †(x) + r(cid:48)

yx3(d+1)Y †(x)

Next we address the two cases from above.

In Case 1,
t(x) does not divide p(x) := (v0(x) +V (x))(w0(x) +W (x)) −
(y0(x) + Y (x)). Let (x − r) be a polynomial that divides
t(x) but not p(x), and let T (x) = t(x)/(x − r). Let d(x) =
gcd(t(x), p(x)). Since t(x) and p(x) have degrees at most d
and 2d respectively, B can use the extended Euclidean algo-
rithm for polynomials to ﬁnd polynomials a(x) and b(x) of
degrees 2d − 1 and d − 1 respectively such that a(x)t(x) +
b(x)p(x) = d(x). Set A(x) = a(x) · (T (x)/d(x)) and B(x) =
b(x) · (T (x)/d(x)); these polynomials have no denominator
since d(x) divides T (x). Then A(x)t(x) + B(x)p(x) = T (x).
Dividing by t(x), we have A(x)+B(x)H(x) = 1/(x−r). Since
A(x) and B(x) have degree at most 2d − 1 ≤ q, B can use
the terms in its challenge to compute e(gA(s), g)e(gB(s), gH ) =
e(g, g)1/(s−r), and thus solve 2q-SDH.

In Case 2,

there does not exist {ck}k∈Imid such that
Vmid(x) = ∑k∈Imid ckvk(x), Wmid(x) = ∑k∈Imid ckwk(x) and
Ymid(x) = ∑k∈Imid ckyk(x). By Lemma 10 [30], we have
vxd+1vk(x) +
that with high probability xq−(4d+3)βpoly(x) · (r(cid:48)
yx3(d+1)yk(x)) has a non-zero coefﬁ-
wx2(d+1)wk(x) + r(cid:48)
r(cid:48)
Now B can use gZ =
cient
gsq−(4d+3)βpoly(s)(sd+1Vmid (s)+s2(d+1)Wmid (s)+s3(d+1)Ymid (s))
to sub-
tract off all elements of the form gs j
where j (cid:54)= q + 1 and
to obtain gsq+1

. This breaks the q-PDH assumption.

the term xq+1.

for

16



=== Content from z.cash_f6cdc496_20250121_030610.html ===

[Skip to content](#content)

* [Home](/)
* [Zashi  wallet](/zashi/)
* [ECC roadmap](/roadmap/)
* [Blog](/blog/)
* [Zcash](https://z.cash)

Blog post

## [Electric Coin Company](https://electriccoin.co)

[ECC Blog](/blog/)

* [Technical](https://electriccoin.co/blog/category/technical/ "Technical")
* /
* Zcash Counterfeiting Vulnerability Successfully Remediated

# Zcash Counterfeiting Vulnerability Successfully Remediated

* Josh Swihart
* February 5, 2019

## Document Outline:

* [Summary](#summary)
* [Background](#background)
* [Counterfeiting Vulnerability Details](#counterfeiting-vulnerability-details)
* [Third Party Disclosure](#third-party-disclosure)
* [Timeline of Events](#timeline-of-events)
* [List of References](#list-of-references)
* [Technical Details of CVE-2019-7167](#technical-details)
* [Correspondence to Horizen and Komodo](#correspondence-horizen-komodo)

## Summary

Eleven months ago we discovered a counterfeiting vulnerability in the cryptography underlying some kinds of zero-knowledge proofs. This post provides details on the vulnerability, how we fixed it and the steps taken to protect Zcash users.

The counterfeiting vulnerability was fixed by the Sapling network upgrade that activated on October 28th, 2018. The vulnerability was specific to counterfeiting and did not affect user privacy in any way. Prior to its remediation, an attacker could have created fake Zcash without being detected. **The counterfeiting vulnerability has been fully remediated in Zcash and no action is required by Zcash users**.

The counterfeiting vulnerability was discovered by a cryptographer employed by the Zerocoin Electric Coin Company (aka The Zcash Company) on March 1st, 2018. It was not reported publicly at the time in order to protect against it being exploited prior to its remediation, and to provide information and remediated code to other projects that were also vulnerable. We employed stringent operational security measures to keep its existence a secret, even from our own engineers.

We believe that no one else was aware of the vulnerability and that no counterfeiting occurred in Zcash for the following reasons:

* Discovery of the vulnerability would have required a high level of technical and cryptographic sophistication that very few people possess.
* The vulnerability had existed for years but was undiscovered by numerous expert cryptographers, scientists, third-party auditors, and third-party engineering teams who initiated new projects based upon the Zcash code.
* The Zcash Company has seen no evidence that counterfeiting has occurred as might be discovered by monitoring the the total amount of Zcash held in Sprout addresses (i.e., the Sprout shielded pool). As long as the value in the shielded pools are greater than zero, no counterfeiting has been detected. Bitfly’s [Zcha.in displays these values on the network statistics page](https://zcha.in/statistics/network), and Zcash nodes report them in the output of the [getblockchaininfo command](https://zcash.readthedocs.io/en/latest/rtd_pages/sapling_turnstile.html).
* Upon discovering the vulnerability, the Zcash Company took extraordinary measures to minimize the possibility of exploitation. The specifics of our steps taken are documented in the detail below.
* The Zcash Company studied the blockchain for evidence of exploitation: An attack might leave a specific kind of footprint. We found no such footprint.

Although we believe that no counterfeiting occurred, we are monitoring pool totals and will act in accordance with our [published defense against counterfeiting](https://z.cash/blog/defense-against-counterfeiting-in-shielded-pools/) in an effort to preserve the monetary supply.

Zcash makes use of the most sophisticated and novel cryptography available on a public blockchain. Pushing cryptographic boundaries is inherently risky and user safety is of highest importance for the Zcash Company. We believe that the steps we have taken to mitigate the issue while working to ensure the safety of Zcash users has been successful. More information on the specific events that transpired from the initial discovery of the counterfeiting vulnerability through this disclosure will be covered in a future post.

### Key Points:

* A counterfeiting vulnerability was discovered in Zcash by a Zcash Company cryptographer.
* The counterfeiting vulnerability has been fully remediated in Zcash and no action is required by Zcash users.
* The successful remediation for Sprout addresses was introduced by the Zcash Company in the Zcash Sapling upgrade that occurred on the 28th of October, 2018.
* The vulnerability was specific to counterfeiting and its exploitation would not have impacted privacy.
* Zcash has not been susceptible to this attack since the Sapling activation.
* We have found no evidence that the vulnerability was discovered by anyone else or that counterfeiting occurred.
* The Zcash Company used best practices in operational security to keep this information private, and responsible disclosure to share it with two affected projects.

## Background

On March 1, 2018, Ariel Gabizon, a cryptographer employed by the Zcash Company at the time, discovered a subtle cryptographic flaw in the [[BCTV14](https://eprint.iacr.org/2013/879)] paper that describes the zk-SNARK construction used in the original launch of Zcash. The flaw allows an attacker to create counterfeit shielded value in any system that depends on parameters which are generated as described by the paper.

This vulnerability is so subtle that it evaded years of analysis by expert cryptographers focused on zero-knowledge proving systems and zk-SNARKs. In an analysis [[Parno15](https://eprint.iacr.org/2015/437)] in 2015, Bryan Parno from Microsoft Research discovered a different mistake in the paper. However, the vulnerability we discovered appears to have evaded his analysis. The vulnerability also appears in the subversion zero-knowledge SNARK scheme of [[Fuchsbauer17](https://eprint.iacr.org/2017/587)], where an adaptation of [[BCTV14](https://eprint.iacr.org/2013/879)] inherits the flaw. The vulnerability also appears in the ADSNARK construction described in [[BBFR14](https://eprint.iacr.org/2014/617)]. Finally, the vulnerability evaded the Zcash Company’s own cryptography team, which includes experts in the field that had [identified several flaws in other parts of the system](https://z.cash/blog/fixing-zcash-vulns/).

Importantly, the [[BCTV14](https://eprint.iacr.org/2013/879)] construction did not have a dedicated security proof, as noted in [[Parno15](https://eprint.iacr.org/2015/437)], and relied mainly on the [[PGHR13](https://eprint.iacr.org/2013/279)] security proof and the similarity between the two schemes. The Zcash Company team did attempt to write a security proof in [[BGG17](https://eprint.iacr.org/2017/602)], but it did not uncover this vulnerability. Zcash has since upgraded to a new proving system [[Groth16](https://eprint.iacr.org/2016/260)] which has multiple independent proofs and significantly better analysis.

After finding the vulnerability, Ariel immediately contacted another cryptographer at the Zcash Company, Sean Bowe. After Sean confirmed the existence of the vulnerability, Zooko Wilcox (CEO of the Zcash Company) and Nathan Wilcox (CTO of the Zcash Company) were briefed. Through careful coordination, the counterfeiting vulnerability was mitigated in the Zcash network without any known further disclosure outside this group of four people.

With the activation of Sapling, Sprout transactions were moved onto the new [[Groth16](https://eprint.iacr.org/2016/260)] proving system, fixing the issue on the Zcash network as described below.

To exploit the counterfeiting vulnerability, an attacker would have needed to possess information found in the large MPC protocol transcript that was made available shortly after the launch of Zcash. This transcript had not been widely downloaded and was removed from public availability immediately upon discovery of the vulnerability to make it more difficult to exploit. The Zcash Company adopted and maintained a cover story that the transcript was missing due to accidental deletion. The transcript was later reconstructed from DVDs collected from the participants of the original ceremony and posted following the Sapling activation.

We have been monitoring the total of funds in the Sprout pool against time and have not found any indication that any counterfeiting activity has taken place.

## Counterfeiting Vulnerability Details

The [[BCTV14](https://eprint.iacr.org/2013/879)] parameter setup algorithm, as described by the paper, mistakenly produces extra elements that violate the soundness of the proving system. The construction described by [[BCTV14](https://eprint.iacr.org/2013/879)] Appendix B is a variant of the [[PGHR13](https://eprint.iacr.org/2013/279)] zk-SNARK scheme with modifications to improve performance and adapt the scheme for the asymmetric pairing setting. This scheme was used in the original launch of Zcash and has been independently implemented by several other projects.

Ariel Gabizon, a cryptographer employed by the Zcash Company at the time of discovery, uncovered a soundness vulnerability. The key generation procedure of [[BCTV14](https://eprint.iacr.org/2013/879)], in step 3, produces various elements that are the result of evaluating polynomials related to the statement being proven. Some of these elements are unused by the prover and were included by mistake; but their presence allows a cheating prover to circumvent a consistency check, and thereby transform the proof of one statement into a valid-looking proof of a different statement. This breaks the soundness of the proving system.

The [[BGG17](https://eprint.iacr.org/2017/602)] multi-party computation (MPC) protocol that produced Sprout parameters for the [[BCTV14](https://eprint.iacr.org/2013/879)] construction follows the paper’s setup procedure, including the computation of the extra elements. These are not included in the actual parameters distributed to Zcash nodes since they are omitted from the parameter file format used by the proving routine implementation of [[BCTV14](https://eprint.iacr.org/2013/879)] in the libsnark library (used by Sprout). However, these elements do appear in the MPC ceremony transcript. Consequently, anyone with access to the ceremony transcript would have been able to create false proofs.

### What is affected?

While Zcash is no longer affected, any project that depends on the MPC ceremony used by the original Sprout system that was distributed in the initial launch of Zcash is vulnerable. This original Sprout system for shielded funds is comprised of the original Sprout circuit, the [[BCTV14](https://eprint.iacr.org/2013/879)] proving system using libsnark, and the parameters generated by an MPC ceremony [[BGG17](https://eprint.iacr.org/2017/602)]. It was used by the 1.x series of Zcash software (which also carried the “Sprout” name).

The algorithm described in [[BCTV14](https://eprint.iacr.org/2013/879)], before the update corresponding to this disclosure, is vulnerable (though its [libsnark](https://github.com/scipr-lab/libsnark) implementation, when used with its built-in parameter generation is not). The vulnerability was included in some independent implementations of [[BCTV14](https://eprint.iacr.org/2013/879)], such as [[snarkjs](https://github.com/iden3/snarkjs)], even though they do not require an MPC. Similar flaws can be found in the [[BBFR14](https://eprint.iacr.org/2014/617)] and [[Fuchsbauer17](https://eprint.iacr.org/2017/587)] zk-SNARK schemes.

We do not have an exhaustive list of all systems affected by this vulnerability, and we encourage all users, developers and maintainers of systems using [[BCTV14](https://eprint.iacr.org/2013/879)] to take the time to triage this issue and check if they are affected.

#### Resources:

[Original Sprout circuit implementation](https://github.com/zcash/zcash/tree/master/src/zcash/circuit)

Original Sprout zk-SNARK parameters: [proving key](https://z.cash/downloads/sprout-proving.key) and [verifying key](https://z.cash/downloads/sprout-verifying.key).

[Sprout proving and verifying routines](https://github.com/zcash/zcash/blob/master/src/zcash/JoinSplit.cpp)

[[BCTV14](https://eprint.iacr.org/2013/879)]

[libsnark proving system](https://github.com/scipr-lab/libsnark/tree/master/libsnark/zk_proof_systems/ppzksnark) and its [Zcash fork](https://github.com/zcash/zcash/tree/master/src/snark/libsnark/zk_proof_systems/ppzksnark/r1cs_ppzksnark)

### What is not affected?

The newer Sprout-on-Groth16 system used by Zcash mainnet for Sprout addresses ever since the Sapling activation (block 419200 at 28 Oct 2018) is not affected by the counterfeiting vulnerability. It uses a new Sprout circuit, that runs on the Groth16 proving system, with new parameters, and operates on the BLS12-381 curve implemented in the Bellman library. The newer Sapling system for shielded funds, activated at the same time and using a new address format, is not vulnerable either.

The vulnerability is not present in the algorithms of [[PGHR13](https://eprint.iacr.org/2013/279)] (which underlies [[BCTV14](https://eprint.iacr.org/2013/879)]), nor in [[BCGTV13](https://eprint.iacr.org/2013/507)], which used similar techniques. It is also not present in other zk-SNARKs constructions, such as [[GM17](https://eprint.iacr.org/2017/540.pdf)] or [[BG18](https://eprint.iacr.org/2018/187)], or in zero-knowledge proof systems that do not rely on a structured reference string. It is not present in libsnark when used with its built-in parameter generator.

#### Resources:

[New Sprout-on-Groth16 circuit implementation](https://github.com/zcash-hackworks/sapling-crypto/tree/master/src/circuit)

[New Sprout-on-Groth16 zk-SNARK parameters](https://z.cash/downloads/sprout-groth16.params)

[New Sprout-on-Groth16 proving and verifying routines](https://github.com/zcash/librustzcash)

[Groth16 proving system](https://github.com/zkcrypto/bellman)

## Third Party Disclosure

An analysis of the market cap of affected projects revealed that we could reach more than a two thirds majority of affected capital with only two disclosures: Horizen, with whom we already had a reciprocal vulnerability disclosure agreement, and Komodo who we worked with to form a disclosure agreement in order to disclose this issue to them privately.

We established a ninety-day maximum public disclosure timeline with both parties, and provided the conditions required for a workable solution.

Further disclosure would have significantly increased the risk of exploitation of the majority of capital for much smaller gains in terms of coverage of users and capital. To protect the shielded pools of these and other projects, exact details of the cause of the vulnerability were redacted from the private disclosures. It appears that both Horizen and Komodo have taken appropriate actions per our recommendation. We recommend that third parties including affected projects, wallets, and exchanges, carefully consider how best to work through the upgrades needed to fix this issue.

## Timeline of Events

### 01 March 2018

Ariel Gabizon, a cryptographer working for the Zcash Company, discovered the flaw while attending the Financial Cryptography 2018 conference, where he had been invited to present [[BGG17](https://eprint.iacr.org/2017/602)] to the Bitcoin’18 workshop. Sean Bowe, a cryptographer at the Zcash Company, and Zooko Wilcox, the CEO of the Zcash Company, were also attending the conference.

The issue was discovered by Ariel the night before his presentation, and he contacted Sean to confirm. Sean met Ariel in person and the two contacted Zooko immediately. Zooko then met Sean and Ariel in person to determine a response strategy. It was quickly determined that the transcript (which would allow an adversary to create false proofs) should be deleted from where it had been publicly made available by the company, since it appeared unlikely that many had downloaded it until that point. Zooko contacted Nathan Wilcox, the CTO of the Zcash Company, to ask him to delete the transcript.

### 02 March 2018 – 27 October 2018

Nathan deleted the transcript under a coinciding operational security cover story.

Sean had an additional backup of the transcript, which was later transferred into the dual possession of Sean and Zooko (Sean kept an encryption key, while Zooko deposited the USB in a safe deposit box) until it was later decided to destroy the backup entirely.

Two mitigation strategies were proposed. Ariel proposed a mitigation which involved an emergency hardfork that required users to switch to new zk-SNARK parameters that did not suffer from the vulnerability, by re-randomizing or replacing the existing parameters in a subsequent ceremony. Sean proposed that the mitigation be covertly included in the Sapling network upgrade by switching to the Groth16 proving system and parameters constructed in the upcoming Sapling ceremony. The team agreed to adopt Sean’s recommendation.

Covert mitigations were developed and deployed without further known disclosures beyond these four individuals.

### 28 October 2018

The Sapling network upgrade activated successfully on the Zcash mainnet, removing the counterfeiting vulnerability.

### 01 November 2018

The director of product security at the Zcash Company, Benjamin Winston, was briefed on the vulnerability and worked with the existing team to prepare disclosure packages for other affected projects.

### 09 November 2018

Josh Swihart, vice president of marketing and business development at the Zcash Company was briefed on the vulnerability in order to coordinate and prepare communications for two possible scenarios: full disclosure (this and related communications), or a leak by the parties to which information was initially released prior to the full disclosure date.

### 13 November 2018

The Zcash Company disclosed the impact and fix path of this issue to Horizen’s (previously known as ZenCash) security team ([[email protected]](/cdn-cgi/l/email-protection)) and Komodo ([[email protected]](/cdn-cgi/l/email-protection)) using PGP encrypted email.

The Zcash Company did not disclose the specifics of the vulnerability, only its existence and our recommendation to upgrade their proving system to Groth16. We also did not tell them who else was notified. The [complete message and disclosure sent to both Horizen and Komodo](#correspondence-horizen-komodo) is copied below.

Three hours later, Zencash responded to say that they had decrypted our message and that they were looking into the issue.

### 16 November 2018

Komodo responded to say that they’d received the notification. Later communication made it clear that they were working on a fix.

### 18 November 2018

Sean reconstructed the transcript from the DVDs collected from the participants of the original ceremony. Sean posted the reconstituted [transcript](https://s3.amazonaws.com/zcashfinalmpc/transcript).

### 10 December 2018

Zcash Company team members (Benjamin, Josh, Zooko) met with the Horizen team by video conference. The Horizen team members present were Alberto Garofollo, Dean Steinbeck, Maurizio Binello, Rob Viglione, Rosario Pabst. In the meeting we discussed the timeline for full disclosure. The Horizen team asked to be given the details of the full disclosure prior to posting. We did not agree to provide them these details.

### 20 December 2018

Zooko notified and briefed David Campbell, COO of the Zcash Company.

### 05 January 2019

Zooko notified and briefed Zcash founding scientists Eli-Ben Sasson, Eran Tromer, Madars Virza and Matthew Green. These founding scientists, along with Alessandro Chiesa, were the original authors of [[BCTV14](https://eprint.iacr.org/2013/879)] and [[BGG17](https://eprint.iacr.org/2017/602)].

### 08 January 2019

Zooko notified and briefed Zcash founding scientist Alessandro Chiesa.

### 25 January 2019

Benjamin and Josh briefed John O’Brien, partner at Strange Brew Strategies, who serves as the Zcash Company PR firm, in preparation for supporting press inquiries.

### 29 January 2019

Sean and Ariel briefed Zcash company cryptographers Daira Hopwood and Jack Grigg.

Benjamin filed for a CVE number for this issue, and received CVE-2019-7167 from mitre.org.

### 31 January 2019

Benjamin and Josh met with Steve Lee from Komodo to coordinate the public release of information.

### 01 February 2019

Benjamin and Josh briefed Zcash team members Brad Miller, Elise Hamdon and Paige Peterson for readiness and assistance in preparation for public disclosure. Andy Murray, Zcash Company CFO, was briefed by David Campbell.

### 04 February 2019

Jack Gavigan, head of product and regulatory relations was briefed.

The Zcash Foundation and its board members were briefed.

All employees and contractors working full time at the Zcash Company were briefed on a joint conference call.

Community member and forum moderator mineZcash (pseudonym) was briefed.

Sprout ceremony participants Derek Hinch of the NCC Group and John Dobbertin (pseudonym) were briefed.

CVE-2019-7167 details were updated.

### 05 February 2019

The Zcash Company public disclosure through the blog post, social media channels and direct contacts with other 3rd parties.

CVE-2019-7167 released with the text as shown in this post.

## List of References

[BCTV14] <https://eprint.iacr.org/2013/879>

[PGHR13] [https://eprint.iacr.org/2013/279](https://eprint.iacr.org/2013/279.pdf)

[BGG17] <https://eprint.iacr.org/2017/602>

[Parno15] <https://eprint.iacr.org/2015/437>

[snarkjs] <https://github.com/iden3/snarkjs>

[[Groth16](https://eprint.iacr.org/2016/260)] <https://eprint.iacr.org/2016/260>

### Papers inheriting the soundness vulnerability from [BCTV14]:

[BBFR14] [https://eprint.iacr.org/2014/617](https://web.archive.org/web/20231206230039/https%3A//eprint.iacr.org/2014/617)

[Fuchsbauer17] [https://eprint.iacr.org/2017/587](https://web.archive.org/web/20231206230039/https%3A//eprint.iacr.org/2017/587)

## Technical Details of CVE-2019-7167

Title
\*\*\*\*\*

BCTV14 setup produces elements that violate soundness leading to Counterfeiting Vulnerability in Zcash and others

Description
\*\*\*\*\*\*\*\*\*\*

The construction described by [BCTV14] in Appendix B, is a variant of the [PGHR13] zk-SNARK scheme with modifications to improve performance. This scheme was used in the original 2016 launch of Zcash and has been independently implemented by several other projects.

Ariel Gabizon, while working for the Zcash company, discovered a soundness bug in [BCTV14] that is described in this security notice:

The key generation procedure of [BCTV14], in step 3, produces various elements that are the result of evaluating polynomials related to the statement being proven. Some of these elements are unused by the prover and were included by mistake; but their presence allows a cheating prover to circumvent a consistency check, and thereby transform the proof of one statement into a valid-looking proof of a different statement. This breaks the soundness of the proof system. We refer to these elements as “bypass elements.”

The [BGG17] multi-party computation (MPC) protocol that produces parameters for the [BCTV14] construction follows the setup procedure closely, and so the bypass elements are produced. They are not included in the actual proving key distributed to Zcash nodes since they are explicitly excluded from the parameter file format used by the proving routine implementation of [BCTV14] in the “libsnark” library (used by Sprout). However, these elements do appear in the MPC ceremony transcript. Consequently, anyone with access to the ceremony transcript would have been able to create false proofs.

The vulnerability also affects an older MPC scheme [BCGTV15]. This vulnerability was also included in some independent implementations of [BCTV14], such as [snarkjs], even though they do not require an MPC. Similar flaws can be found in the [BBFR14] and [Fuchsbauer17] zk-SNARK schemes, which are adaptations of [BCTV14].

Impact
\*\*\*\*\*

The ability to break soundness in the proving system permits the creation of false proofs. Zero-knowledge proofs are used in a system like Zcash to ensure that transactions are valid, so this implies the ability to create an unlimited amount of shielded coins where the verifier is affected by this bug.

Credit
\*\*\*\*\*\*

This vulnerability was discovered by Ariel Gabizon while he was working for the Zerocoin Electric Coin Company.

What is affected?
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Any project that implements [BCTV14] and does not completely dispose of the bypass elements as part of the setup process.

That includes but is not limited to any project that depends on the trusted setup used by the original Sprout system that was distributed in the initial 2016 launch of Zcash. This original Sprout system for shielded funds is comprised of the original Sprout circuit, the [BCTV14] proving system using libsnark, and the parameters generated by an MPC ceremony [BGG17]. It was used by the 1.x series of Zcash software (which also carried the “Sprout” name).

[BCTV14] is available at [https://eprint.iacr.org/2013/879](https://web.archive.org/web/20231206230039/https%3A//eprint.iacr.org/2013/879)

The original Sprout circuit implementation is here: [https://github.com/zcash/zcash/tree/32d3a3352e45457f689585cc49d554599583bbd0/src/zcash/circuit](https://web.archive.org/web/20231206230039/https%3A//github.com/zcash/zcash/tree/32d3a3352e45457f689585cc49d554599583bbd0/src/zcash/circuit)

The original Sprout zk-SNARK parameters are here: [https://z.cash/downloads/sprout-proving.key](https://web.archive.org/web/20231206230039/https%3A//z.cash/downloads/sprout-proving.key) (sha256sum: 8bc20a7f013b2b58970cddd2e7ea028975c88ae7ceb9259a5344a16bc2c0eef7) and [https://z.cash/downloads/sprout-verifying.key](https://web.archive.org/web/20231206230039/https%3A//z.cash/downloads/sprout-verifying.key) (sha256sum: 4bd498dae0aacfd8e98dc306338d017d9c08dd0918ead18172bd0aec2fc5df82)

The Sprout proving and verifying routines are here: [https://github.com/zcash/zcash/blob/685c0ab07fd90b244dac5e2cb1f069ac6151ec5c/src/zcash/JoinSplit.cpp](https://web.archive.org/web/20231206230039/https%3A//github.com/zcash/zcash/blob/685c0ab07fd90b244dac5e2cb1f069ac6151ec5c/src/zcash/JoinSplit.cpp)

The BCTV14 proving system implementation (in libsnark) is here: [https://github.com/zcash/zcash/tree/c938fb1f179d9bdefc5bc7e55fc6330a8b8d3713/src/snark/libsnark/zk\_proof\_systems/ppzksnark/r1cs\_ppzksnark](https://web.archive.org/web/20231206230039/https%3A//github.com/zcash/zcash/tree/c938fb1f179d9bdefc5bc7e55fc6330a8b8d3713/src/snark/libsnark/zk_proof_systems/ppzksnark/r1cs_ppzksnark)

What is not affected?
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

The newer Sprout-on-Groth16 system used by Zcash mainnet for Sprout addresses ever since the Sapling activation (block 419200 at 28 Oct 2018) is not affected by the counterfeiting vulnerability. It uses a new Sprout circuit, that runs on the Groth16 proving system, with new parameters, and operates on the BLS12-381 curve implemented in the Bellman library. The newer Sapling system for shielded funds, activated at the same time and using a new address format, is not vulnerable either.

The vulnerability is not present in the algorithms of [PGHR13] (which underlies [BCTV14]), nor in [BCGTV13], which used similar techniques. It is also not present in other zk-SNARKs constructions, such as [GM17] or [BG18], or in zero-knowledge proof systems that do not rely on a structured reference string. It is not present in libsnark when used with its built-in parameter generator.

The new Sprout-on-Groth16 circuit implementation is located here at time of publishing this information: [https://github.com/zcash-hackworks/sapling-crypto/tree/master/src/circuit](https://web.archive.org/web/20231206230039/https%3A//github.com/zcash-hackworks/sapling-crypto/tree/master/src/circuit)

The new Sprout-on-Groth16 zk-SNARK parameters are located here at time of publishing this information: [https://z.cash/downloads/sprout-groth16.params](https://web.archive.org/web/20231206230039/https%3A//z.cash/downloads/sprout-groth16.params)

The new Sprout-on-Groth16 proving and verifying routines are located in the librustzcash library (at time of publishing): [https://github.com/zcash/librustzcash](https://web.archive.org/web/20231206230039/https%3A//github.com/zcash/librustzcash)

The Groth16 proving system is implemented in the Bellman Rust library: [https://github.com/zkcrypto/bellman](https://web.archive.org/web/20231206230039/https%3A//github.com/zkcrypto/bellman)

Mitigation
\*\*\*\*\*\*\*\*\*

Users of projects still affected by this issue should change the zk-SNARK parameters to some that are not affected by this bug. Zcash switched to new parameters using a new “Sprout-on-Groth16” proving system as of the Sapling network upgrade on October 28th 2018, and so is not affected by the bug.

Therefore, users of Zcash do not need to take any action.

Projects still affected by this vulnerability that do not wish to switch proving systems might instead wish to perform their own parameter setup to produce replacement parameters. Projects following this path are strongly encouraged to use a large, public MPC with thorough security analysis. In the interim, they are advised to disable functionality (e.g., shielded transactions) that relies on the affected proof system.

References
\*\*\*\*\*\*\*\*\*\*

[BCTV14] [https://eprint.iacr.org/2013/879](https://web.archive.org/web/20231206230039/https%3A//eprint.iacr.org/2013/879)

[PGHR13] [https://eprint.iacr.org/2013/279](https://web.archive.org/web/20231206230039/https%3A//eprint.iacr.org/2013/279.pdf)

[BGG17] [https://eprint.iacr.org/2017/602](https://web.archive.org/web/20231206230039/https%3A//eprint.iacr.org/2017/602)

[Parno15] [https://eprint.iacr.org/2015/437](https://web.archive.org/web/20231206230039/https%3A//eprint.iacr.org/2015/437)

[BCGTV15] [https://www.ieee-security.org/TC/SP2015/papers-archived/6949a287.pdf](https://web.archive.org/web/20231206230039/https%3A//www.ieee-security.org/TC/SP2015/papers-archived/6949a287.pdf)

[snarkjs] [https://github.com/iden3/snarkjs](https://web.archive.org/web/20231206230039/https%3A//github.com/iden3/snarkjs)

Papers inheriting this issue from [BCTV14]:

[BBFR14] [https://eprint.iacr.org/2014/617](https://web.archive.org/web/20231206230039/https%3A//eprint.iacr.org/2014/617)

[Fuchsbauer17] [https://eprint.iacr.org/2017/587](https://web.archive.org/web/20231206230039/https%3A//eprint.iacr.org/2017/587)

## Correspondence to Horizen and Komodo

Hello,

There is a serious vulnerability in your software. Enclosed is a private advisory with more detail about the vulnerability. We strongly recommend keeping the impact of this issue secret until your project is able to deploy mitigations, because of the associated risks to projects that are still affected and people who know the details.

The issue was discovered internally at Zcash and extreme caution has been exercised to protect its existence from premature disclosure, to avoid exploitation anywhere and to assure the availability of our network and the safety of our people. With the activation of Sapling, our network is no longer vulnerable to this bug, but we’d like to take the right steps to provide you a similar opportunity without putting any of our people at risk.

The vulnerability allows an attacker to create very large, virtually unlimited amounts of counterfeit shielded tokens without detection.

In order to mitigate this bug, we recommend a hardfork that adopts the newer Groth16 implementation of Sprout shielded transactions, which uses a more secure circuit implementation and parameters and is not affected by this bug.

This mitigation was successfully deployed in Zcash as part of the Sapling network upgrade. This mitigation has several advantages, but among them is that it does not require alerting anyone to the existence of a security bug in order to deploy, because the upgrade has legitimate performance and security benefits beyond fixing this bug.

Other possible mitigations for this bug have been analyzed and determined to be too expensive and risky to undertake. Further, revealing those considerations would make it harder for you to protect your users, given that other projects are also affected. Our best effort has been put into developing a strong mitigation to this bug in our own software, which we believe now presents you with a far simpler upgrade path than you might otherwise face.

We have disclosed this to the largest projects who use this code by market cap in order to protect the largest possible amount of capital, however we have decided not to alert all other affected projects yet.

I would like to assign a CVE to this issue, then publish the full details of this vulnerability publicly and notify all remaining affected projects no later than ninety days from today’s date: Today is Tuesday November 13th 2018, meaning I’d like to publicly disclose full details of this issue before Monday February 11th 2019 at the latest.

I will do my best to assist you in understanding the software upgrade path.

Benjamin Winston [[email protected]](/cdn-cgi/l/email-protection)
Director of Product Security, z.cash

Title
\*\*\*\*\*

Sprout shielded transaction bug allows for unlimited counterfeiting.

Description
\*\*\*\*\*\*\*\*\*\*\*

A fundamental cryptographic flaw exists that allows an attacker to create proofs that falsely convince the original Sprout zk-SNARK verifier of the correctness of a transaction.

Impact
\*\*\*\*\*\*

By exploiting this bug, an attacker could create fake Sprout shielded notes containing large amounts of counterfeit funds without being detected.

Credit
\*\*\*\*\*\*

We would like to include credit for this discovery in a coordinated public release after your software is fixed and your users are safe.

What is affected?
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Any project that depends on the original Sprout system that was distributed in the initial launch of Zcash.

The original Sprout zk-SNARK system is comprised of the original Sprout circuit and parameters on the [BCTV14] proving system using libsnark and was used by the 1.x series of Zcash software (which also carried the “Sprout” name).

The original Sprout circuit implementation is here:
[https://github.com/zcash/zcash/tree/master/src/zcash/circuit](https://web.archive.org/web/20231206230039/https%3A//github.com/zcash/zcash/tree/master/src/zcash/circuit)

The original Sprout zk-SNARK parameters are here:
[https://z.cash/downloads/sprout-proving.key](https://web.archive.org/web/20231206230039/https%3A//z.cash/downloads/sprout-proving.key)
[https://z.cash/downloads/sprout-verifying.key](https://web.archive.org/web/20231206230039/https%3A//z.cash/downloads/sprout-verifying.key)

The Sprout proving and verifying routines are here:
[https://github.com/zcash/zcash/blob/master/src/zcash/JoinSplit.cpp](https://web.archive.org/web/20231206230039/https%3A//github.com/zcash/zcash/blob/master/src/zcash/JoinSplit.cpp)

The BCTV14 proving system implementation (in libsnark) is here:
[https://github.com/zcash/zcash/tree/master/src/snark/libsnark/zk\_proof\_systems/ppzksnark/r1cs\_ppzksnark](https://web.archive.org/web/20231206230039/https%3A//github.com/zcash/zcash/tree/master/src/snark/libsnark/zk_proof_systems/ppzksnark/r1cs_ppzksnark)

What is not affected?
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

The newer Sprout-on-Groth16 system used by Zcash mainnet for Sprout transactions on and after block 419200 is not affected by this bug. It uses a new Sprout circuit, that runs on the Groth16 proving system, new parameters and operates on the BLS12-381 curve implemented in the Bellman library.

The new Sprout-on-Groth16 circuit implementation is located here:
[https://github.com/zcash-hackworks/sapling-crypto/tree/master/src/circuit](https://web.archive.org/web/20231206230039/https%3A//github.com/zcash-hackworks/sapling-crypto/tree/master/src/circuit)

The new Sprout-on-Groth16 zk-SNARK parameters are located here:
[https://z.cash/downloads/sprout-groth16.params](https://web.archive.org/web/20231206230039/https%3A//z.cash/downloads/sprout-groth16.params)

The new Sprout-on-Groth16 proving and verifying routines are located in the librustzcash library:
[https://github.com/zcash/librustzcash](https://web.archive.org/web/20231206230039/https%3A//github.com/zcash/librustzcash)

The Groth16 proving system is implemented in the Bellman Rust library:
[https://github.com/zkcrypto/bellman](https://web.archive.org/web/20231206230039/https%3A//github.com/zkcrypto/bellman)

Mitigation
\*\*\*\*\*\*\*\*\*\*

We strongly recommend that you switch to the newer Sprout-on-Groth16 zk-SNARK system, as it is not vulnerable to this bug.

Publication Timeline
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

We would like to publish this vulnerability publicly and notify all other affected projects who are not in our initial distribution list using Github’s security response system, and on our social media channels and website no later than 90 days from today’s date. Today is Tuesday November 13th 2018, meaning I’d like to publicly disclose full details of this issue before Monday February 11th 2019 at the latest.

References
\*\*\*\*\*\*\*\*\*\*

[BCTV14] [https://eprint.iacr.org/2013/879](https://web.archive.org/web/20231206230039/https%3A//eprint.iacr.org/2013/879)

* [Technical](https://electriccoin.co/blog/category/technical/)
* [Security Announcement](https://electriccoin.co/blog/tag/security-announcement/)

[Zcash Shielded Addresses are GDPR Compliant by Default](https://electriccoin.co/blog/zcash-shielded-addresses-are-gdpr-compliant-by-default/)

[People Behind Zcash Technology: Marshall Gaucher, Engineer](https://electriccoin.co/blog/people-behind-zcash-technology-marshall-gaucher-engineer/)

![](https://electriccoin.co/wp-content/uploads/2024/03/ec-co.svg)

## Recent blog posts:

* ### [ECC Transparency Report for Q2 2024](https://electriccoin.co/blog/ecc-transparency-report-for-q2-2024/)
* ### [Drumroll Please: Introducing Zashi-Keystone Hardware Wallet Integration for Shielded ZEC](https://electriccoin.co/blog/drumroll-please-introducing-zashi-keystone-hardware-wallet-integration-for-shielded-zec/)
* ### [Zashi-Flexa Integration is Here: Spend ZEC at Thousands of Retailers!](https://electriccoin.co/blog/zashi-flexa-integration-is-here-spend-zec-at-thousands-of-retailers/)
* ### [Zcash Halvening & NU6: Embracing the New Dev Fund](https://electriccoin.co/blog/zcash-halvening-nu6-embracing-the-new-dev-fund/)

* [See all](/blog/)

## Newsletter signup:

Email

Submit

[![ECC Logo](https://electriccoin.co/wp-content/uploads/2024/03/logo-ecc.svg)](/)

* [Zashi wallet](/zashi/)
* [ECC roadmap](/roadmap/)
* [Blog](/blog/)
* [Careers](/jobs/)
* [Zcash website](https://z.cash)
* [Copyright policy](/copyright-policy/)
* [Manage cookies](/manage-cookies/)

[X-twitter](https://twitter.com/electriccoinco)

[Linkedin](https://www.linkedin.com/company/electriccoinco)

[Youtube](https://www.youtube.com/zcashco)

##### Can we store cookies?

We sometimes use cookies to improve the performance of our website. Choose what you allow.

CustomizeNoYesConsent Preferences

Close

#### Our Features

We sometimes use cookies to improve the performance of our website. Choose what you allow.

Essential
 Essential

Always Enabled

This includes key features like page navigation and logging you in. The website cannot function without this.
**Who do we share data with?**

| Description |
| --- |
| [Google Analytics](https://www.google.com/intl/en/policies/privacy/) |
| [Google Optimize](https://policies.google.com/privacy?hl=en) |
| [Google Tag Manager](https://www.google.com/intl/en/policies/privacy/) |
| [New Relic](https://newrelic.com/privacy) |
| [Sendgrid](https://www.twilio.com/legal/privacy) |

**Does this policy need cookies to work?**
Yes.

Marketing

marketing

This tells us it's okay for us to use your information for marketing specifically.
**Who do we share data with?**

| Description |
| --- |
| [Hotjar](https://www.hotjar.com/legal/policies/privacy/) |

**Does this policy need cookies to work?**
Yes.

No Save My Preferences Yes



=== Content from eprint.iacr.org_f00db420_20250121_030555.html ===

# What a lovely hat

#### Is it made out of [tin foil](https://iacr.org/tinfoil.html)?

[![IACR Logo](/img/iacrlogo_small.png)](https://iacr.org/)

[Cryptology ePrint Archive](/)

* Papers
  Updates from the last:+ [7 days](/days/7)
  + [31 days](/days/31)
  + [6 months](/days/183)
  + [365 days](/days/365)
  + ---
  + [Listing by year](/byyear)
  + [All papers](/complete)
  + [Compact view](/complete/compact)
  + [Subscribe](https://www.iacr.org/news/subscribe)
  + ---
  + [How to cite](/citation.html)
  + ---
  + [Harvesting metadata](/rss)
* Submissions
  + [Submit a paper](/submit)
  + [Revise or withdraw a paper](/revise)
  + [Acceptance and publishing conditions](/operations.html)
* About
  + [Goals and history](/about.html)
  + [News](/news.html)
  + [Statistics](/stats)
  + [Contact](/contact.html)

![Search Button](/img/search.svg)

Search

[Advanced search](/search)

#### Paper 2017/587

### Subversion-zero-knowledge SNARKs

Georg Fuchsbauer

##### Abstract

Subversion zero knowledge for non-interactive proof systems demands that zero knowledge (ZK) be maintained even when the common reference string (CRS) is chosen maliciously. SNARKs are proof systems with succinct proofs, which are at the core of the cryptocurrency Zcash, whose anonymity relies on ZK-SNARKs; they are also used for ZK contingent payments in Bitcoin.
We show that under a plausible hardness assumption, the most efficient SNARK schemes proposed in the literature, including the one underlying Zcash and contingent payments, satisfy subversion ZK or can be made to at very little cost. In particular, we prove subversion ZK of the original SNARKs by Gennaro et al. and the almost optimal construction by Groth; for the Pinocchio scheme implemented in libsnark we show that it suffices to add 4 group elements to the CRS. We also argue informally that Zcash is anonymous even if its parameters were set up maliciously.

**Note:** This version incorporates the corrections of the BCTV14 scheme (ia.cr/2013/879, version 20190205) and some small fixes on p. 26.

##### Metadata

Available format(s)

[![](/img/file-pdf.svg)PDF](/2017/587.pdf)

Category
[Cryptographic protocols](/search?category=PROTOCOLS)
Publication info
A major revision of an IACR publication in PKC 2018
Keywords
[SNARKs](/search?q=SNARKs)[subversion-resistance](/search?q=subversion-resistance)[zero knowledge](/search?q=zero%20knowledge)[Zcash](/search?q=Zcash)
Contact author(s)
fuchsbau @ di ens fr

History
2020-05-16: last of 4 revisions
2017-06-20: received
[See all versions](/archive/versions/2017/587)
Short URL
<https://ia.cr/2017/587>
License
[![Creative Commons Attribution](/img/license/CC_BY.svg "Creative Commons Attribution")

CC BY](https://creativecommons.org/licenses/by/4.0/)

**BibTeX**
![](/img/copy-outline.svg)Copy to clipboard

```

@misc{cryptoeprint:2017/587,
      author = {Georg Fuchsbauer},
      title = {Subversion-zero-knowledge {SNARKs}},
      howpublished = {Cryptology {ePrint} Archive, Paper 2017/587},
      year = {2017},
      url = {https://eprint.iacr.org/2017/587}
}

```

[![IACR Logo](/img/iacrlogo_small.png)](https://iacr.org/)

Note: In order to protect the privacy of readers, eprint.iacr.org
does not use cookies or embedded third party content.


