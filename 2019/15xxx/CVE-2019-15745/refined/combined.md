=== Content from www.ckn.io_3f9db020_20250121_002421.html ===


* [whoami](/whoami.html)
* [home](/index.html)
* [category](/category.html)
* [archive](/blog/archives/index.html)

Exploiting the eques elf smart plug: Part three
##### Aug 27, 2019

In part two, we figured out how to discover the smart plugs in a network and their details. We were also able to send remote commands to ikonkek2.com and query details about specific smart plugs. This was made possible by the discovery of a hardcoded aes key used to encrypt messages. We however still cannot turn a smart plug on or off remotely. So let’s concentrate on that in this post.

We currently can:

* Decrypt messages between the phone, smart plug and server during plug discovery and port 9123 communication.
* Discover any smart plug in the network and its details.
* Communicate with ikonkek2.com server and query various details about a smart plug.

We cannot:

* Remotely control the smart plug – Turn it on or off.

# Part two: More secret keys, hooks and a debugger

Turning the smart plug on or off happens over an xmpp chat (port 5222). The phone uses the username “phone mac”eques@ikonkenk2.com while the username of the smart plug is “device mac”@ikonkek2.com.

The messages exchanged look like this:

| ``` 1 2  ``` | ``` "encryption:88fL6ftH5a/VVZrG4oNejdQ9GajxiNsSbvgVs8aR9inGr6gePzDWTU8IMejrHRxbhrtt27ImZpCvsN9MXbi42RKt2aQ4NsN EwNWwDj1OYLY=  ``` |
| --- | --- |

---

Let’s continue our analysis the dynamic way. Let’s start by using Android’s logging capability - logcat.

When we turn the plug on, this is what we observe on logcat:

![](/images/relayopen.png)

Clearer output:

| ``` 1  ``` | ``` E XMPPUtil: sendEncodeMessage:wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%f7HTEgDfZPLCyOqB4b2XZA==%relay to [[email protected]](/cdn-cgi/l/email-protection)  ``` |
| --- | --- |

And

| ``` 1  ``` | ``` E ==Main : com.kankunit.smartknorns.MainActivity$ServiceChatManagerListener$1@bba1c8b=======wan_device%dc-4f-22-25-xx-xx%nopassword%open%1563100747%rack  ``` |
| --- | --- |

---

When we turn the plug off

![](/images/relayclose.png)

Clearer output:

| ``` 1  ``` | ``` XMPPUtil: sendEncodeMessage:wan_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%1F6E1GyngNXKROGzGOmB4g==%relay to [[email protected]](/cdn-cgi/l/email-protection)  ``` |
| --- | --- |

And

| ``` 1  ``` | ``` E ==Main : com.kankunit.smartknorns.MainActivity$ServiceChatManagerListener$1@35ef906=======wan_device%dc-4f-22-25-xx-xx%nopassword%close%1563100818%rack  ``` |
| --- | --- |

---

We note that the function sendEncodeMessage is called when sending the XMPP message.

Let’s understand the process through dynamic analysis with Frida and GDB.

We start by running our frida-server on the phone, attach to the app and trace the “open” function:

frida-trace -i “open” -U -f “com.eques.plug”

We can see the app’s db is located at **/data/user/0/com.eques.plug/databases/afinal.db**

![](/images/db.png)

We can extract the db and open it with sqlitebrowser and see what is stored:

![](/images/ikonke_device.png)

From the frida output we can also see the native library libKonkeEncrypt.so being opened when we turn the plug on or off.

![](/images/konkeopen.png)

---

To give us more control we’ll use the frida’s scripting capability and its python bindings.

We can start by writing a script that prints out all the arguments and return values when the sendEncodeMessage function we discovered is called.

When we turn on the plug:

![](/images/sendEncode_open.png)

When we turn off the plug:

![](/images/sendEncode_close.png)

The output looks like what we had seen earlier on logcat with the word open or close replaced with some encrypted/encoded data.

Logcat message we had seen:

> E XMPPUtil: sendEncodeMessage:wan\_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%f7HTEgDfZPLCyOqB4b2XZA==%relay to dc-4f-22-25-xx-xx@ikonkek2.com

What we see from hooking the SendEncodeMessage() function:

> wan\_phone%88-c9-d0-da-xx-xxeques%Ki,,-sp6%open%relay

It looks like at some point, the words open (when turning on the plug) and close (when turning off the plug), have some encryption/encoding done to them.

---

So let’s go back to the reversed apk and figure out what happens. What we discover is that a timestamp is inserted into the message then some encryption/encoding done.

This is done by the function insertTimestampIntoMessage

![](/images/timestamp.png)

Let’s write another frida script to intercept and log this function:

![](/images/sendEncode_timestamp.png)

We can now confirm that indeed this is where the additional encryption/encoding is done. Also note **arg3** is set to true.

If we again look at the insertTimestampIntoMessage function Arg3 refers to the boolean value **needNewEncode**. When **needNewEncode** is set to true, the following operation is done:

cmd = EncryptUtil.newEncode(cmd.substring(1), deviceModel);

Let’s write another frida script to hook the newEncode() function.

![](/images/newEncode.png)

Here we see a timestamp is added to the word open and an encrypted/encoded result returned.

---

Back to the reversed apk code we can see that newEncode() uses KonkeEncrypt().encryptCmdString to encrypt the command:

![](/images/encryptcmdstring.png)

Let’s write one more frida script to hook the encryptCmdString()  function:

![](/images/konke_encrypt.png)

This confirms, we’re in the right path.

From there we discover that the function is loaded from a native library called KonkeEncrypt:

![](/images/konkeencrypt.png)

The library is packaged with the apk in the **lib/armeabi** folder:

![](/images/libKonke.png)

---

Let’s head back to Ghidra to see if we can figure out what exactly is happening during this encryption/encoding process.

The steps are basically the same as before:

We will open the libKonkeEncrypt.so file in Ghidra and then look for the encryptCmdString() function.

![](/images/encryptcmdghidra.png)

We can get an idea of the flow from the function call graph:

![](/images/encryptcmd_flow.png)

---

Let’s see if we can see the library in action. For this we’re going to debug the libKonkeEncrypt.so library using GEF (<https://github.com/hugsy/gef>) – An enhanced version of GDB.

First we’re going to copy an arm gdbserver to the phone in the **/data/local/tmp/** directory.

From an adb shell, we then start the gdbserver:

| ``` 1  ``` | ``` /data/local/tmp/gdbserver :1337 --attach $(ps | grep com.eques.plug | awk '{print $2}')  ``` |
| --- | --- |

Then we forward the remote port to our host using adb:

| ``` 1  ``` | ``` adb forward tcp:1337 tcp:1337  ``` |
| --- | --- |

Then we start GEF for remote debugging:

| ``` 1  ``` | ``` gef-remote :1337  ``` |
| --- | --- |

GEF first reads symbols from the phone’s libraries:

![](/images/gef-remote.png)

Once that is done, we let the app continue running:

![](/images/gef-connected.png)

When we turn the plug on or off from the app, we can see the libKonkeEncrypt.so library gets opened by the app:

![](/images/gef-konke.png)

By running the info functions gef command we can see the functions in our library of interest:

![](/images/gef-konke-functions.png)

---

From our earlier ghidra analysis, aes\_set\_key() sets the final encryption key in hex which is then used by EncryptData256() to encrypt the command. Let’s set breakpoints at these two function’s addresses and then continue running the app:

![](/images/gef-breaks.png)

When we hit the EncryptData256() break point we can inspect the registers, stack and function trace:

Registers:

![](/images/gef-encrypt-registers.png)

Stack:

![](/images/gef-encrypt-stack.png)

Function Trace:

![](/images/gef-encrypt-trace.png)

---

We do the same when we hit the aes\_set\_key() breakpoint:

Registers:

![](/images/gef-aes-registers.png)

Stack:

![](/images/gef-aes-stack.png)

Function Trace:

![](/images/gef-aes-trace.png)

Stepping through the execution flow till the end, we eventually get our key stored in the r1 register:

![](/images/gef-aes-r1.png)

The key is: 1c2f36737d07617a538f9f66659a2623.

---

We can convert it to hex and test it on some of our previously captured encrypted commands and confirm it is indeed the key:

![](/images/konke_key_test.png)

And it works!

---

Almost there, but not quite yet.

I tested the key against encrypted commands from other plugs, unfortunately it only worked for that one specific smart plug. We therefore need to figure out how the specific key for each smart power plug is generated.

After some more code analysis and debugging, the following is the function flow when encryptCmdString() is called:

=> encryptCmdString() calls EncryptData256()

=>>>>> EncryptData256() calls getKeyFromMethod2()

=>>>>>>>>>>> getKeyFromMethod2() calls cmd\_string\_parse()

=>>>>>>>>>>> getKeyFromMethod2() calls generateKey1FromString()

=>>>>>>>>>>>>>>>>> generateKey1FromString() calls generateKey2FromString()

=>>>>>>>>>>> getKeyFromMethod2() then calls dealKeyFromMethod2()

=>>>>>>>>>>>>>>>>> dealKeyFromMethod2() then returns the key

We are going to concentrate on the getKeyFromMethod2() function.
First it calls cmd\_string\_parse(). I spent a lot of time figuring out what it does, only to realise that all it does is remove the hyphens from the mac address with some fancy use of C pointers. So **dc-4f-22-25-xx-xx** would result in **dc4f2225xxxx**.

Next let’s move to generateKey1FromString(). We can either go the static way using Ghidra or the dynamic way using GEF. Let’s go with GEF.

We set breakpoints at generateKey1FromString() and generateKey2FromString() and then monitor the registers.

![](/images/gef-remote-gen2.png)

After some debugging we get what looks like a key: w5%45j!a,~j33in3lea^~rw2]ryxes8y generated and stored in the r3 register.

With this discovery we can go back to Ghidra and continue analysing the getKeyFromMethod2() function.

We notice that some manipulation is done on this key using the smart power plug’s password:

![](/images/keygen_devpass_or.png)

What is happening is that the first 8 bytes of the key are bitwise OR’ed with the smart power plug’s password. If the hex result of any of the bitwise ORs is 0x7e, it is replaced with 0x72. A quick python script can be written to reproduce this:

![](/images/keygen_device_pass_script.png)

The result is then passed on to dealKeyFromMethod2() together with the parsed mac address (hyphens removed).

The return value is what should be our final key!

Analysing and cleaning up the code, I was able to figure out and reproduce the functionality.

The key has some of its bytes replaced with some bytes from the mac address of the smart power plug. This is done in the following manner:

* The 15th byte of the key is replaced with the 6th byte of the mac address
* The 16th byte of the key is replaced with the 7th byte of the mac address
* The 19th byte of the key is replaced with the 8th byte of the mac address
* The 20th byte of the key is replaced with the 9th byte of the mac address
* The 21st byte of the key is replaced with the 10th byte of the mac address
* The 22nd byte of the key is replaced with the 11th byte of the mac address

The md5sum is then calculated to create the final key.

---

In summary, this is how the smart power plug specific key is generated:

* cmd\_string\_parse() removes hyphens from the mac address.
* generateKey1FromString() and generateKey2FromString() are used to produce the key: w5%45j!a,~j33in3lea^~rw2]ryxes8y.
* getKeyFromMethod2() bitwise ORs the first 8 bytes of the key with the device
  name/password.
* dealKeyFromMethod2() replaces some bytes of the key with some bytes of the mac
  address, the md5sum of the result is the final device specific key.

I tested this against more than one smart power plug with successful decryptions.

Now we have all we need to control any plug:

* The smart power plug’s mac address
* The smart power plug’s password
* The two encryption keys (one device specific and the other common to all smart power plugs)

---

With these details, we can use an xmpp client like pidgin to connect to the xmpp server (ikonkek2.com) using the username “phone macaddress”eques@ikonkek2.com.

Next we generate the smart plug specific encryption key.

We then use this key to encrypt either the open”timestamp” or close”timestamp” part of our command.

Finally we encrypt the full message using the common encryption key.

We will add the prefix **encryption:** to our encrypted message and send it to the device’s username “device macaddress@ikonkek2.com” over xmpp.

Note: The xmpp’s user passwords are just the same as the usernames.

---

I automated the whole process of key generation, message formatting and encryption to output the message to be sent:

![](/images/xmpp_commands.png)

Next I just copy the message and send it using pidgin:

![](/images/xmpp_control.png)

And there we have it! We can now control the plug remotely even when it’s behind a NAT network.

The frida scripts and exploit code can be found [**here.**](https://github.com/iamckn/eques)

---

In the final part, we will explore how this can be abused on a mass scale.

---

[« Exploiting the eques elf smart plug: Part two](/blog/2019/08/27/exploiting-the-eques-elf-smart-plug-part-two/ "Previous Post: Exploiting the eques elf smart plug: Part two")
<<<<+>>>>
[Exploiting the eques elf smart plug: Part four »](/blog/2019/08/27/exploiting-the-eques-elf-smart-plug-part-four/ "Next Post: Exploiting the eques elf smart plug: Part four")

The difficult we do immediately; the impossible takes a little longer



=== Content from www.ckn.io_3584cbea_20250121_002422.html ===


* [whoami](/whoami.html)
* [home](/index.html)
* [category](/category.html)
* [archive](/blog/archives/index.html)

Exploiting the eques elf smart plug: Part two
##### Aug 27, 2019

In part one, we concentrated on analysing the network communication when one turns the smart power plug on or off from the app.
We had noticed some form of encrypted/encoded communication happening on udp port 27431 between the smart plug and the app installed on the phone. We also noticed some form of encrypted/encoded communication on tcp ports 9123 and 5222(xmpp) between the app, smart plug and ikonkek2.com.

# Part two: Not so secret keys, some assembly and a reverse engineer

Let’s reverse the apk to see if the code can tell us what type of encryption/encoding was happening.
I have a preference for [**jadx-gui**](https://github.com/skylot/jadx) so that’s what I used.

First let’s search for the domains we had seen in the network traffic.
Searching for ikonke.us reveals the firmware download url. Note that it is http. This is under the UpdateFirmwareUtil class. About 15 different downloads are listed indicating the app supports multiple devices.

![](/images/firmware_url.png)

We can also see various variables are mapped to their values in the com.kankunit.smartknorns.commonutil.CommonMap file.

![](/images/commonmap.png)

This collaborates our earlier network traffic analysis related to port 9123 and XMPP(5222).
We can now also conclude that ikonkek2.com hosts an Apache Mina server listening on ports 9123 and 50003, and an XMPP server listening on port 5222.

---

We had earlier discovered that the app tries to discover the plug by sending some broadcast messages on port 27431. Let’s see if we can figure out what the exact messages are from the app.

Searching for this in the code reveals the class com.kankunit.smartknorns.service.BaseUdpBroadcastService.

![](/images/udp_broadcast.png)

The command sent is:

lan\_phone%mac%nopassword%“ + new SimpleDateFormat(DateTransformer.DATE\_FORMAT,
Locale.ENGLISH).format(new Date(System.currentTimeMillis())) + ”%heart

The sending method is PackageSendData:

byte[] cmd\_buf = BaseUdpBroadcastService.this.sj.PackageSendData(cmd, cmd.length());

This method is from the class smartplug.JniC

![](/images/PackageSendData.png)

The method is called from the native library CommunSmartPlug-jni.

The library is packaged with the app in the **lib/armeabi** folder

![](/images/libs.png)

We can access the file by unzipping the apk and navigating to the **lib/armeabi** folder.

Running the file command on it reveals it is a 32-bit ARM binary:

![](/images/file_libComm.png)

We can also run strings on it to gather more information. Sample output reveals we’re on the right path as we can see the string PackageSendData as part of the output.

![](/images/strings_libComm.png)

---

Time for Ghidra!

We open the native library in Ghidra and start by looking at the Symbol Tree to locate our function:

![](/images/ghidra_symbols.png)

Displaying the call graph, we note it calls the function EncryptData256, which in turn calls the functions aes\_set\_key and aes\_encrypt:

![](/images/senddata_call.png)

Let’s start by analysing the EncryptData256 function:

*Before analysis*

![](/images/encrypt_raw.png)

*After analysis and some cleanup*

![](/images/encrypt_analysed.png)

After some more analysis and cleaning up the code, we get to the following code snippet:

![](/images/aes_key.png)

We see the use of the the function get\_key to fetch the aes key in bytes, the function aes\_set\_key then sets the encryption key in hex.

The key is then used to encrypt the plaintext as below:

![](/images/aes_encrypt.png)

So what we need to find out is what the aes key is, we start by figuring out what the get\_key function does:

![](/images/get_key.png)

The function uses switch statements to set a character to each corresponding position in the key.

We can therefore reconstruct the key manually or by using Ghidra’s scripting functionality.

The final key is: fdsl;mewrjope456fds4fbvfnjwaugfo

Let’s confirm the key works!

---

Remember the messages we’d seen being broadcast by the app on udp port 27431? Let’s try decrypt one.

We first convert our key to hex then try decrypting one of the UDP messages we had captured:

![](/images/decryption_test.png)

Eureka! The key works!

The decrypted command confirms the format of the UDP messages as earlier discovered:

lan\_phone%mac%nopassword%“ + new SimpleDateFormat(DateTransformer.DATE\_FORMAT,
Locale.ENGLISH).format(new Date(System.currentTimeMillis())) + ”%heart

---

Let’s try our first attack - Discovering all smarts plug connected to a network and their details.

For this, we’re going to use go code to:

* Format the command and insert the current time as per the message specifications.
* Encrypt the message with the key.
* Send it to the broadcast address on UDP port 27431.
* Listen for responses.
* Decrypt the received messages.

Once we run our custom discovery tool, we get responses from all the smart plugs in the network and various details such as IP, mac address, device name/password, status, hardware and software versions:

![](/images/udp_plug_discovery.png)

---

We had also seen network communication between the app and the server (ikonkek2.com) on port 9123. Let’s try see if we can figure it out.

We can start with one of the first messages we saw:

| ``` 1 2  ``` | ``` synchroFriends:QL+o4atMbQYvmyopU7DwqU3xXKYQt/MfZtNrDZlA4oayAvVY+XoCTChO1Q00I5lR VRbu1j85/S6EtkuzlSnsNQ==  ``` |
| --- | --- |

We can look for this in our reversed apk:

![](/images/synchro.png)

What we see is that the minaEncode method base64 encodes the output from the PackageSendData method.

![](/images/minaencode.png)

This is the same method that is used to encrypt the UDP discovery messages. Good thing we already analysed that method and got the encryption key.

By further analysing the reversed apk we see that the message format takes the form of:

| ``` 1  ``` | ``` <cleartext description of the action>:<EncryptUtil.minaEncode(some message)>  ``` |
| --- | --- |

This is clearly visible in the following snippet:

![](/images/mina_Encode.png)

---

# Decryption test

Let’s try decryption of some of the messages we had captured in the network traffic.

Get device information

| ``` 1 2  ``` | ``` getDeviceInfo:8S6cW/8R2lxEiAF9Vq8maDQbEtAhNrSn1AO5aa9rV2fx7gFo+8WXHSEERZkoj0cI2kuhoJz/TMH4cOF0cH5luA== hEJJ9YjsfWTlB0j8h3xFVJSZPLiVeqXqwm2+VYc2hReeeuO61tEz+9XcaNZwJo3o7aPMxgJwsDDgFcH+HDwChklPvnRC5bPqrpHzLyZK9g0=  ``` |
| --- | --- |

![](/images/getDeviceInfo.png)

---

Get device status

| ``` 1 2  ``` | ``` getDeviceStatus:8S6cW/8R2lxEiAF9Vq8maDQbEtAhNrSn1AO5aa9rV2eOvkUKU+0kgmaR7hkY2JLP hEJJ9YjsfWTlB0j8h3xFVJSZPLiVeqXqwm2+VYc2hReUX1M+EvqrQUuw1Ag/eSc0  ``` |
| --- | --- |

![](/images/getdevicestatus.png)

---

# Running remote commands

Let’s try exploit this feature to perform remote query of various details about the smart plug from the ikonkek2.com server. We can do this from anywhere as long as we have an internet connection.

We are again going to write some go code to:

* Create commands and format the messages.
* Encrypt the messages with the key.
* Send the messages to ikonkek2.com on port 9123.
* Listen for responses.
* Decrypt the received messages.

All we need is the mac address of a smart plug

Get device information:

![](/images/deviceinfodemo.png)

---

Get device status:

![](/images/devicestatusdemo.png)

---

Get email linked to the device:

![](/images/deviceemailinfo.png)

The project files and code can be found [**here.**](https://github.com/iamckn/eques)

---

In part three, we will try to remotely control the smart power plug (turn it on and off).

---

[« Exploiting the eques elf smart plug: Part one](/blog/2019/08/27/exploiting-the-eques-elf-smart-plug-part-one/ "Previous Post: Exploiting the eques elf smart plug: Part one")
<<<<+>>>>
[Exploiting the eques elf smart plug: Part three »](/blog/2019/08/27/exploiting-the-eques-elf-smart-plug-part-three/ "Next Post: Exploiting the eques elf smart plug: Part three")

The difficult we do immediately; the impossible takes a little longer



=== Content from www.ckn.io_68a2221b_20250121_023210.html ===


* [whoami](/whoami.html)
* [home](/index.html)
* [category](/category.html)
* [archive](/blog/archives/index.html)

Exploiting the eques elf smart plug: Part one
##### Aug 27, 2019

I bought some smart power plugs and they were pretty awesome! These are the [**Eques Elf smart plugs.**](https://equeshome.com/products/elf-smart-plug) They can be controlled using an app through a connected Wi-Fi network, and remotely over the internet.

Everything was going on well till I noticed some strange urls on my home network monitoring system. It turns out it was the smart plug constantly communicating with some external hosts.

My smart plugs were not in my full control! Our journey therefore begins. It was time to void some warranties, figure out what was going on, and hopefully gain full control of the plug.

This is a walkthrough of the process I took and will be broken down into the following areas:

* Network traffic analysis
* Android app reversing
* Dynamic instrumentation
* Native library debugging
* Native library reversing
* Custom exploit tools/scripts
* Hardware teardown

The end goal will be to:

* Gain full control of the smart plug
* Discover any security vulnerabilities
* Develop exploitation techniques and tools

# Part One: The homesick elf, some packets and an analyst

I set up my network as below:

![](/images/mirror_setup.png)

The app and smart plug are connected to the same WIFI network. All traffic in the network is mirrored and sent to the Raspberry Pi, which has Zeek IDS set up. The logs are then analysed and visualised by a Graylog server.

We will then run the app and analyse the traffic.

First thing I noted were the following hosts communicating with the app:

* <https://cnctlife.com>
* <http://ikonke.us/>
* <https://ikonke.us:50003/>
* <https://router-a0-push.leancloud.cn>
* <http://ikonkek2.com:9123>
* <http://ikonkek2.com:5222>

And the follwoing communicating with the smart plug:

* <http://ikonkek2.com:9123>
* <http://ikonkek2.com:5222>

The first communication I noticed were repeated packets being sent to the broadcast address by the app on udp port 27431.

![](/images/udp_27431_2.png)

Following the udp stream, we can see that the data is sent repeatedly. The suspicion is that this is the plug discovery process by the app.

![](/images/udp_27431.png)

The app then starts communicating with ikonkek2.com on port 9123.

![](/images/synchofriends.png)

Some more of the sample data sent and the responses can be seen here:

---

| ``` 1 2  ``` | ``` getDeviceInfo:8S6cW/8R2lxEiAF9Vq8maDQbEtAhNrSn1AO5aa9rV2fx7gFo+8WXHSEERZkoj0cI2kuhoJz/TMH4cOF0cH5luA== hEJJ9YjsfWTlB0j8h3xFVJSZPLiVeqXqwm2+VYc2hReeeuO61tEz+9XcaNZwJo3o7aPMxgJwsDDgFcH+HDwChklPvnRC5bPqrpHzLyZK9g0=  ``` |
| --- | --- |

---

| ``` 1 2  ``` | ``` getDeviceStatus:8S6cW/8R2lxEiAF9Vq8maDQbEtAhNrSn1AO5aa9rV2eOvkUKU+0kgmaR7hkY2JLP hEJJ9YjsfWTlB0j8h3xFVJSZPLiVeqXqwm2+VYc2hReUX1M+EvqrQUuw1Ag/eSc0  ``` |
| --- | --- |

---

| ``` 1 2  ``` | ``` moduleReport:z8gm9VQHmkywT3J7rp2SUFUpHUkb3JTG8b/dcozM8q6cW6fwp40tS9YByPwuCUYqa+G4gNtEuPfLOJqf+mBdXF2Zw0dUEZLUaDsUiJxTepM= .hEJJ9YjsfWTlB0j8h3xFVFUpHUkb3JTG8b/dcozM8q6cW6fwp40tS9YByPwuCUYqW/Aap48EIhkq+31whfFKne06Nhp1WmLYxu89+vi0sqk=  ``` |
| --- | --- |

---

We will come to these messages later. For now note that port 9123 is commonly used by Apache Mina Servers.

When we turn the plug on or off from the app, an XMPP connection is initiated. The app first authenticates to the server using DIGEST-MD5 mechanism.

The app then initiates and xmpp chat to dc-4f-22-25-xx-xx@ikonkek2.com using the username [[email protected]](/cdn-cgi/l/email-protection)/android. Note that dc-4f-22-25-xx-xx is the mac address of the smart plug while d4-63-c6-8d-xx-xx is the mac address of the phone running the app.

| ``` 1 2 3 4 5 6 7 8 9  ``` | ``` XMPP Protocol     MESSAGE [id="26xzR-5" type="chat"]         from: [[email protected]](/cdn-cgi/l/email-protection)/android         id: 26xzR-5         to: [[email protected]](/cdn-cgi/l/email-protection)         type: chat         THREAD [value="bB3Fe0"]         BODY [value="encryption:88fL6ftH5a/VVZrG4oNejdQ9GajxiNsSbvgVs8aR9inGr6gePzDWTU8IMejrHRxbhrtt27ImZpCvsN9MXbi42RKt2aQ4NsNEwNWwDj1OYLY="]             value: encryption:88fL6ftH5a/VVZrG4oNejdQ9GajxiNsSbvgVs8aR9inGr6gePzDWTU8IMejrHRxbhrtt27ImZpCvsN9MXbi42RKt2aQ4NsNEwNWwDj1OYLY=  ``` |
| --- | --- |

---

The plug then responds to the message:

| ``` 1 2 3 4 5 6 7 8  ``` | ``` XMPP Protocol     MESSAGE [type="chat"]         from: [[email protected]](/cdn-cgi/l/email-protection)/device         to: [[email protected]](/cdn-cgi/l/email-protection)/android         type: chat         xml:lang: en         BODY [value="encryption:z8gm9VQHmkywT3J7rp2SUFUpHUkb3JTG8b/dcozM8q5RCCP4wzJPMrgxjWeeFZicog7NzWKq9DncBNIGR530/Q=="]             value: encryption:z8gm9VQHmkywT3J7rp2SUFUpHUkb3JTG8b/dcozM8q5RCCP4wzJPMrgxjWeeFZicog7NzWKq9DncBNIGR530/Q==  ``` |
| --- | --- |

Note that the chat messages start with the prefix *encryption:*.

---

# What we know so far

* The smart plug listens on UDP 27431. The app sends udp broadcast messages on this port to discover the plug and the ommunication looks encrypted/encoded.
* The app communicates with the host ikonkek2.com on ports:

  + 9123 (Apache Mina)

    -> Communication looks partially encrypted/encoded and happens regularly.

    -> Messages follow the format - *descriptive prefix*:*some encrypted/encoded message*.
  + 5222 (XMPP)

    -> Communication is initiated when the plug is turned on/off from the app.

    -> Communication looks to be through encrypted/encoded chat messages.

    -> The username of the phone is based on the phone mac address with the word eques appended.

    -> The username of the plug is just its mac address.

    -> Authentication with the xmpp server (ikonkek2.com) is DIGEST-MD5.

    -> XMPP Messages follow the format - *encryption*:*some encrypted/encoded message*.

---

In part two we are going to dig further by looking at the android application itself.

---

[« Wireguard VPN: Portable Raspberry Pi Setup](/blog/2017/12/28/wireguard-vpn-portable-raspberry-pi-setup/ "Previous Post: Wireguard VPN: Portable Raspberry Pi Setup")
<<<<+>>>>
[Exploiting the eques elf smart plug: Part two »](/blog/2019/08/27/exploiting-the-eques-elf-smart-plug-part-two/ "Next Post: Exploiting the eques elf smart plug: Part two")

The difficult we do immediately; the impossible takes a little longer



=== Content from www.ckn.io_784ee353_20250121_002420.html ===


* [whoami](/whoami.html)
* [home](/index.html)
* [category](/category.html)
* [archive](/blog/archives/index.html)

Exploiting the eques elf smart plug: Part four
##### Aug 27, 2019

In part three, we finally figured out how to remotely control the smart power plugs (turn them on or off). In this final part, we are going to see how inadequate security controls can be exploited for various purposes. We are also going to look at one more scenario where the smart power plugs have no internet access.

# Part four: Predictability, scanners and a hacker

As we have seen in most of the scenarios, all we need is the mac address of a smart power plug to be able to interact with it. So how do we figure out the mac address of a smart power plug if we’re not on the same network?

The thing is, mac addresses aren’t really random.

![](/images/mac_addresses.jpg)

The first 6 hex bytes are allocated to an organization. The organization then determines the full mac address to allocate to their devices by using the last 6 hex bytes.

Let us look at the mac addresses of two of my smart power plugs:

dc-4f-22-25-0x-xx

dc-4f-22-25-1x-xx

We can use the first 6 hex bytes to identify the manufacturer:

![](/images/espressif.png)

We can see the manufacturer is Espressif, a company that develops bluetooth and Wi-Fi chips for IOT applications.

In our case, we also see that we have an additional two hex bytes that are similar.

We can therefore assume that a lot of the devices have the first eight hex bytes common.
It is therefore straight forward to create a list that starts with those eight hex bytes (dc-4f-22-25-). This will result in a list of 65536 mac addresses.

Next step is to query the ikonkek2.com server for details about each of the mac addresses. We of course know if a mac address is valid, it’ll respond with its details.

We just need to tweak our code to create our scanner then leave it running.

So what did I find?

After querying that range of mac addresses, I got 4149 responses with details about devices. Some of them look like bulbs from the names:

![](/images/found.png)

Remember that with just the mac address, we can also query for the email address of the device owner. And the results prove it:

![](/images/emails.png)

We can continue querying for additional details, including whether a device is on, how many devices are linked to an email and so on.

---

So what Eques says about protecting this information:

![](/images/privacy.png)

We can see that there is a gap with their security measures. I therefore used the contact information on their website to ask about their disclosure process:

![](/images/eques_disclosure.png)

As of the writing of this post, a month has passed.

I am still waiting…

---

I am sure some of you have been wondering – Did I consider the scenario where the plugs were connected to a Wi-Fi network with no internet access?

More so being that what started all this was trying to have full control of my devices, without them communicating to external servers.

Turns out the smart plugs have a failover mode in case they cannot access the internet.
What happens is that all communication happens directly between the phone and smart plug on the local network.
The phone sends the query/commands to the plug’s IP address on the UDP port 27431, encrypted with the common encryption key.

The commands start with the word (lan\_phone) on the local network as opposed to (wan\_phone) when going through ikonkek2.com.

Everything happens over UDP port 27431 with no xmpp involved.

It was therefore much easier to code this functionality and control the plugs as desired. Exploiting the devices while on the same network becomes a trivial affair:

Here I check the status of a smart power plug, turn it off and on:

![](/images/local.png)

---

So what would have made my exploitation attempts more difficult?

* Obfuscate the app? - Would have slowed me down but dynamic analysis would still have worked.
* Use encrypted channels for all communication? - Would have slowed me further but dynamic analysis would still have worked.
* Avoid the use of hard-coded keys? - Would have slowed me further but dynamic analysis would still have worked.
* Use better authentication when querying details from the server? - Would have likely protected querying of device and user details from the server.

A determined attacker is probably going to figure out a way to beat almost every defence measure.
Luckily, if enough of these defence measures are applied together, most attackers will be kept out, or consider it not worth the investment of their time and resources.

---

So what next?

* Follow up on the disclosure process.
* Continue hardware tear down.
* Investigate more devices :)

The project files and code can be found [**here.**](https://github.com/iamckn/eques)

---

The vulnerabilities have been assigned **CVE-ID: CVE-2019-15745** - <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15745>

Till next time, happy hacking!

---

[« Exploiting the eques elf smart plug: Part three](/blog/2019/08/27/exploiting-the-eques-elf-smart-plug-part-three/ "Previous Post: Exploiting the eques elf smart plug: Part three")

The difficult we do immediately; the impossible takes a little longer



=== Content from github.com_8a429208_20250121_023209.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fiamckn%2Feques)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fiamckn%2Feques)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=iamckn%2Feques)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[iamckn](/iamckn)
/
**[eques](/iamckn/eques)**
Public

* [Notifications](/login?return_to=%2Fiamckn%2Feques) You must be signed in to change notification settings
* [Fork
  2](/login?return_to=%2Fiamckn%2Feques)
* [Star
   5](/login?return_to=%2Fiamckn%2Feques)

Exploit code/scripts for the eques elf smart plugs

[www.ckn.io/blog/2019/08/27/exploiting-the-eques-elf-smart-plug-part-one](https://www.ckn.io/blog/2019/08/27/exploiting-the-eques-elf-smart-plug-part-one "https://www.ckn.io/blog/2019/08/27/exploiting-the-eques-elf-smart-plug-part-one")

[5
stars](/iamckn/eques/stargazers) [2
forks](/iamckn/eques/forks) [Branches](/iamckn/eques/branches) [Tags](/iamckn/eques/tags) [Activity](/iamckn/eques/activity)
 [Star](/login?return_to=%2Fiamckn%2Feques)

 [Notifications](/login?return_to=%2Fiamckn%2Feques) You must be signed in to change notification settings

* [Code](/iamckn/eques)
* [Issues
  0](/iamckn/eques/issues)
* [Pull requests
  0](/iamckn/eques/pulls)
* [Actions](/iamckn/eques/actions)
* [Projects
  0](/iamckn/eques/projects)
* [Security](/iamckn/eques/security)
* [Insights](/iamckn/eques/pulse)

Additional navigation options

* [Code](/iamckn/eques)
* [Issues](/iamckn/eques/issues)
* [Pull requests](/iamckn/eques/pulls)
* [Actions](/iamckn/eques/actions)
* [Projects](/iamckn/eques/projects)
* [Security](/iamckn/eques/security)
* [Insights](/iamckn/eques/pulse)

# iamckn/eques

    master[Branches](/iamckn/eques/branches)[Tags](/iamckn/eques/tags)Go to fileCode
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit History[5 Commits](/iamckn/eques/commits/master/) | | |
| [exploit](/iamckn/eques/tree/master/exploit "exploit") | | [exploit](/iamckn/eques/tree/master/exploit "exploit") |  |  |
| [frida](/iamckn/eques/tree/master/frida "frida") | | [frida](/iamckn/eques/tree/master/frida "frida") |  |  |
| [libs](/iamckn/eques/tree/master/libs "libs") | | [libs](/iamckn/eques/tree/master/libs "libs") |  |  |
| [README.md](/iamckn/eques/blob/master/README.md "README.md") | | [README.md](/iamckn/eques/blob/master/README.md "README.md") |  |  |
| View all files | | |

## Repository files navigation

* README

This repo contains exploit code/scripts for the eques elf smart plugs - <https://equeshome.com/products/elf-smart-plug>.

Full details can be found in the following four part series - <https://www.ckn.io/blog/2019/08/27/exploiting-the-eques-elf-smart-plug-part-one/>

The vulnerabilities have been allocated CVE-2019-15745 - <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15745>

## Local attacks

To discover all smart plugs in a network:

```
go run equeslocal.go --command=discover

```

To check the status of a smart plug:

```
go run equeslocal.go --mac=<mac address of the plug> --pass=<password/name of the plug> --ip=<IP address of the plug> --command=status

```

To turn on a smart plug:

```
go run equeslocal.go --mac=<mac address of the plug> --pass=<password/name of the plug> --ip=<IP address of the plug> --command=on

```

To turn off a smart plug:

```
go run equeslocal.go --mac=<mac address of the plug> --pass=<password/name of the plug> --ip=<IP address of the plug> --command=off

```

## Remote attacks

To check the software and hardware version of a smart plug

```
go run equescommand.go --mac=<mac address of the plug> --command=version

```

To check the status of a smart plug

```
go run equescommand.go --mac=<mac address of the plug> --command=status

```

To get the email account linked to a smart plug

```
go run equescommand.go --mac=<mac address of the plug> --command=auth

```

To check if a timer is set on a smart plug

```
go run equescommand.go --mac=<mac address of the plug> --command=timer

```

To generate the message to turn the plug on over xmpp. The message can then be sent to "devicemac"@ikonkek2.com.

```
go run equesxmpp.go --devicemac=<mac address of the plug> --pass=<password/name of the plug> --command=on

```

To generate the message to turn the plug off over xmpp. The message can then be sent to "devicemac"@ikonkek2.com.

```
go run equesxmpp.go --devicemac=<mac address of the plug> --pass=<password/name of the plug> --command=off

```

## About

Exploit code/scripts for the eques elf smart plugs

[www.ckn.io/blog/2019/08/27/exploiting-the-eques-elf-smart-plug-part-one](https://www.ckn.io/blog/2019/08/27/exploiting-the-eques-elf-smart-plug-part-one "https://www.ckn.io/blog/2019/08/27/exploiting-the-eques-elf-smart-plug-part-one")

### Resources

[Readme](#readme-ov-file)

[Activity](/iamckn/eques/activity)
### Stars

[**5**
stars](/iamckn/eques/stargazers)
### Watchers

[**2**
watching](/iamckn/eques/watchers)
### Forks

[**2**
forks](/iamckn/eques/forks)
[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2Fiamckn%2Feques&report=iamckn+%28user%29)

## [Releases](/iamckn/eques/releases)

No releases published

## [Packages 0](/users/iamckn/packages?repo_name=eques)

No packages published

## Languages

* [Go
  66.8%](/iamckn/eques/search?l=go)
* [JavaScript
  26.7%](/iamckn/eques/search?l=javascript)
* [Python
  6.5%](/iamckn/eques/search?l=python)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


