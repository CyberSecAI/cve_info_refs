=== Content from tches.iacr.org_97c8e8dc_20250121_000028.html ===

[Skip to main content](#pkp_content_main)
[Skip to main navigation menu](#siteNav)
[Skip to site footer](#pkp_content_footer)

Open Menu

[![Ruhr-Universität Bochum](https://tches.iacr.org/public/journals/7/pageHeaderLogoImage_en_US.png)](https://tches.iacr.org/index.php/TCHES/index)

* [Home](https://tches.iacr.org/index.php/TCHES/index)
* [Current](https://tches.iacr.org/index.php/TCHES/issue/current)
* [Archives](https://tches.iacr.org/index.php/TCHES/issue/archive)
* [Submissions](https://tches.iacr.org/index.php/TCHES/submissions1)
  + [Call for Papers](https://tches.iacr.org/index.php/TCHES/cfp)
  + [Paper Submission](https://tches.iacr.org/index.php/TCHES/submission)
  + [Camera-ready Submission](https://tches.iacr.org/index.php/TCHES/camera-ready)
  + [Publication Ethics](https://tches.iacr.org/index.php/TCHES/ethics)
  + [Retraction Policy](https://tches.iacr.org/index.php/TCHES/retractions)
* [FAQ](https://tches.iacr.org/index.php/TCHES/faq)
* [Editorial Board](https://tches.iacr.org/index.php/TCHES/editorial)
* [Contact](https://tches.iacr.org/index.php/TCHES/contact)
* [CHES](https://ches.iacr.org/)

[Search](https://tches.iacr.org/index.php/TCHES/search)

* [Login](https://tches.iacr.org/index.php/TCHES/login)

1. [Home](https://tches.iacr.org/index.php/TCHES/index)
   /
2. [Archives](https://tches.iacr.org/index.php/TCHES/issue/archive)
   /
3. [Volume 2019, Issue 1](https://tches.iacr.org/index.php/TCHES/issue/view/86)
   /
4. Articles

# Return of the Hidden Number Problem.

## A Widespread and Novel Key Extraction Attack on ECDSA and DSA

## Authors

* Keegan Ryan

  NCC Group

## DOI:

<https://doi.org/10.13154/tches.v2019.i1.146-168>

## Keywords:

side-channel attacks, lattice attacks, key extraction, hidden number, problem, (EC)DSA cryptanalysis

## Abstract

Side channels have long been recognized as a threat to the security of cryptographic applications. Implementations can unintentionally leak secret information through many channels, such as microarchitectural state changes in processors, changes in power consumption, or electromagnetic radiation. As a result of these threats, many implementations have been hardened to defend against these attacks. Despite these mitigations, this work presents a novel side-channel attack against ECDSA and DSA. The attack targets a common implementation pattern that is found in many cryptographic libraries. In fact, about half of the libraries that were tested exhibited the vulnerable pattern. This pattern is exploited in a full proof of concept attack against OpenSSL, demonstrating that it is possible to extract a 256-bit ECDSA private key using a simple cache attack after observing only a few thousand signatures. The target of this attack is a previously unexplored part of (EC)DSA signature generation, which explains why mitigations are lacking and the issue is so widespread. Finally, estimates are provided for the minimum number of signatures needed to perform the attack, and countermeasures are suggested to protect against this attack.

## Downloads

* [PDF](https://tches.iacr.org/index.php/TCHES/article/view/7337/6509)
* [Video](https://tches.iacr.org/index.php/TCHES/article/view/7337/7913)
* [Slides](https://tches.iacr.org/index.php/TCHES/article/view/7337/7914)

## Published

2018-11-09

## Issue

[Volume 2019, Issue 1](https://tches.iacr.org/index.php/TCHES/issue/view/86)

## Section

Articles

## License

Copyright (c) 2018 Keegan Ryan

[![Creative Commons License](//i.creativecommons.org/l/by/4.0/88x31.png)](https://creativecommons.org/licenses/by/4.0/)

This work is licensed under a [Creative Commons Attribution 4.0 International License](https://creativecommons.org/licenses/by/4.0/).

## How to Cite

Ryan, K. (2018). Return of the Hidden Number Problem.: A Widespread and Novel Key Extraction Attack on ECDSA and DSA. *IACR Transactions on Cryptographic Hardware and Embedded Systems*, *2019*(1), 146-168. <https://doi.org/10.13154/tches.v2019.i1.146-168>

More Citation Formats

* [ACM](https://tches.iacr.org/index.php/TCHES/citationstylelanguage/get/acm-sig-proceedings?submissionId=7337&publicationId=820&issueId=86)
* [ACS](https://tches.iacr.org/index.php/TCHES/citationstylelanguage/get/acs-nano?submissionId=7337&publicationId=820&issueId=86)
* [APA](https://tches.iacr.org/index.php/TCHES/citationstylelanguage/get/apa?submissionId=7337&publicationId=820&issueId=86)
* [ABNT](https://tches.iacr.org/index.php/TCHES/citationstylelanguage/get/associacao-brasileira-de-normas-tecnicas?submissionId=7337&publicationId=820&issueId=86)
* [Chicago](https://tches.iacr.org/index.php/TCHES/citationstylelanguage/get/chicago-author-date?submissionId=7337&publicationId=820&issueId=86)
* [Harvard](https://tches.iacr.org/index.php/TCHES/citationstylelanguage/get/harvard-cite-them-right?submissionId=7337&publicationId=820&issueId=86)
* [IEEE](https://tches.iacr.org/index.php/TCHES/citationstylelanguage/get/ieee?submissionId=7337&publicationId=820&issueId=86)
* [MLA](https://tches.iacr.org/index.php/TCHES/citationstylelanguage/get/modern-language-association?submissionId=7337&publicationId=820&issueId=86)
* [Turabian](https://tches.iacr.org/index.php/TCHES/citationstylelanguage/get/turabian-fullnote-bibliography?submissionId=7337&publicationId=820&issueId=86)
* [Vancouver](https://tches.iacr.org/index.php/TCHES/citationstylelanguage/get/vancouver?submissionId=7337&publicationId=820&issueId=86)
* [AMA](https://tches.iacr.org/index.php/TCHES/citationstylelanguage/get/ama?submissionId=7337&publicationId=820&issueId=86)

Download Citation

* [Endnote/Zotero/Mendeley (RIS)](https://tches.iacr.org/index.php/TCHES/citationstylelanguage/download/ris?submissionId=7337&publicationId=820&issueId=86)
* [BibTeX](https://tches.iacr.org/index.php/TCHES/citationstylelanguage/download/bibtex?submissionId=7337&publicationId=820&issueId=86)

## iacr-logo

[![](/public/site/images/jwloka/iacrlogo_trans.png)](https://www.iacr.org "IACR logo")

[Imprint](/index.php/TCHES/impressum "Imprint") | [Personal Data Notice](https://ojs.ub.rub.de/index.php/index/PDN "Personal Data Notice")

[![More information about the publishing system, Platform and Workflow by OJS/PKP.](https://tches.iacr.org/templates/images/ojs_brand.png)](https://tches.iacr.org/index.php/TCHES/about/aboutThisPublishingSystem)



=== Content from www.openwall.com_2ac9af50_20250121_000022.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

[[<prev]](1) [[next>]](../../../2019/10/03/1) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <06a94797-a7f9-2b5e-855d-9e779914d36a@mail.muni.cz>
Date: Wed, 2 Oct 2019 23:00:22 +0200
From: Ján Jančár <445358@...l.muni.cz>
To: oss-security@...ts.openwall.com
Subject: Minerva: ECDSA key recovery from bit-length leakage

*Webpage*
=========

<https://minerva.crocs.fi.muni.cz/>

*Vulnerability*
===============

Minerva is a group of vulnerabilities in ECDSA/EdDSA implementations that allows
for practical recovery of the long-term private key.

We have found implementations which leak the bit-length of the scalar during
scalar multiplication on an elliptic curve. This leakage might seem minuscule as
the bit-length presents a very small amount of information present in the
scalar. However, in the case of ECDSA/EdDSA signature generation, the leaked
bit-length of the random nonce is enough for full recovery of the private key
used after observing a few hundreds to a few thousands of signatures on known
messages, due to the application of lattice techniques.

<https://minerva.crocs.fi.muni.cz/>

*Affected*
==========

 * Cards
   - Athena IDProtect
 * Libraries
   - libgcrypt upto 1.8.4, fixed in 1.8.5
   - wolfSSL/wolfCrypt upto 4.0.0, fixed in 4.1.0
   - MatrixSSL upto 4.2.1
   - SunEC/OpenJDK/OracleJDK upto JDK 12
   - Crypto++ upto 8.2.0
 * Other
   - <https://github.com/indutny/elliptic/> 875 stars,2670640 uses
   - <https://github.com/kjur/jsrsasign> 2015 stars,7406 uses

*CVEs*
======

 * CVE-2019-15809 - Athena IDProtect cards
 * CVE-2019-13627 - libgcrypt
 * CVE-2019-13628 - wolfSSL/wolfCrypt
 * CVE-2019-13629 - MatrixSSL
 * CVE-2019-2894  - SunEC/OpenJDK/OracleJDK
 * CVE-2019-14318 - Crypto++

Download attachment "[signature.asc](2/1)" of type "application/pgp-signature" (834 bytes)

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from github.com_7cc637f1_20250121_020832.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fkjur%2Fjsrsasign)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fkjur%2Fjsrsasign)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=kjur%2Fjsrsasign)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[kjur](/kjur)
/
**[jsrsasign](/kjur/jsrsasign)**
Public

* [Notifications](/login?return_to=%2Fkjur%2Fjsrsasign) You must be signed in to change notification settings
* [Fork
  645](/login?return_to=%2Fkjur%2Fjsrsasign)
* [Star
   3.3k](/login?return_to=%2Fkjur%2Fjsrsasign)

The 'jsrsasign' (RSA-Sign JavaScript Library) is an opensource free cryptography library supporting RSA/RSAPSS/ECDSA/DSA signing/validation, ASN.1, PKCS#1/5/8 private/public key, X.509 certificate, CRL, OCSP, CMS SignedData, TimeStamp, CAdES and JSON Web Signature/Token in pure JavaScript.

[kjur.github.io/jsrsasign](https://kjur.github.io/jsrsasign "https://kjur.github.io/jsrsasign")

### License

[View license](/kjur/jsrsasign/blob/master/LICENSE.txt)

[3.3k
stars](/kjur/jsrsasign/stargazers) [645
forks](/kjur/jsrsasign/forks) [Branches](/kjur/jsrsasign/branches) [Tags](/kjur/jsrsasign/tags) [Activity](/kjur/jsrsasign/activity)
 [Star](/login?return_to=%2Fkjur%2Fjsrsasign)

 [Notifications](/login?return_to=%2Fkjur%2Fjsrsasign) You must be signed in to change notification settings

* [Code](/kjur/jsrsasign)
* [Issues
  18](/kjur/jsrsasign/issues)
* [Pull requests
  8](/kjur/jsrsasign/pulls)
* [Discussions](/kjur/jsrsasign/discussions)
* [Actions](/kjur/jsrsasign/actions)
* [Projects
  0](/kjur/jsrsasign/projects)
* [Wiki](/kjur/jsrsasign/wiki)
* [Security](/kjur/jsrsasign/security)
* [Insights](/kjur/jsrsasign/pulse)

Additional navigation options

* [Code](/kjur/jsrsasign)
* [Issues](/kjur/jsrsasign/issues)
* [Pull requests](/kjur/jsrsasign/pulls)
* [Discussions](/kjur/jsrsasign/discussions)
* [Actions](/kjur/jsrsasign/actions)
* [Projects](/kjur/jsrsasign/projects)
* [Wiki](/kjur/jsrsasign/wiki)
* [Security](/kjur/jsrsasign/security)
* [Insights](/kjur/jsrsasign/pulse)

# kjur/jsrsasign

    master[Branches](/kjur/jsrsasign/branches)[Tags](/kjur/jsrsasign/tags)Go to fileCode
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit History[485 Commits](/kjur/jsrsasign/commits/master/) | | |
| [.github](/kjur/jsrsasign/tree/master/.github ".github") | | [.github](/kjur/jsrsasign/tree/master/.github ".github") |  |  |
| [api](/kjur/jsrsasign/tree/master/api "api") | | [api](/kjur/jsrsasign/tree/master/api "api") |  |  |
| [ext](/kjur/jsrsasign/tree/master/ext "ext") | | [ext](/kjur/jsrsasign/tree/master/ext "ext") |  |  |
| [min](/kjur/jsrsasign/tree/master/min "min") | | [min](/kjur/jsrsasign/tree/master/min "min") |  |  |
| [mobile](/kjur/jsrsasign/tree/master/mobile "mobile") | | [mobile](/kjur/jsrsasign/tree/master/mobile "mobile") |  |  |
| [npm](/kjur/jsrsasign/tree/master/npm "npm") | | [npm](/kjur/jsrsasign/tree/master/npm "npm") |  |  |
| [npm\_util](/kjur/jsrsasign/tree/master/npm_util "npm_util") | | [npm\_util](/kjur/jsrsasign/tree/master/npm_util "npm_util") |  |  |
| [sample](/kjur/jsrsasign/tree/master/sample "sample") | | [sample](/kjur/jsrsasign/tree/master/sample "sample") |  |  |
| [sample\_node](/kjur/jsrsasign/tree/master/sample_node "sample_node") | | [sample\_node](/kjur/jsrsasign/tree/master/sample_node "sample_node") |  |  |
| [src](/kjur/jsrsasign/tree/master/src "src") | | [src](/kjur/jsrsasign/tree/master/src "src") |  |  |
| [test](/kjur/jsrsasign/tree/master/test "test") | | [test](/kjur/jsrsasign/tree/master/test "test") |  |  |
| [tool](/kjur/jsrsasign/tree/master/tool "tool") | | [tool](/kjur/jsrsasign/tree/master/tool "tool") |  |  |
| [ChangeLog.txt](/kjur/jsrsasign/blob/master/ChangeLog.txt "ChangeLog.txt") | | [ChangeLog.txt](/kjur/jsrsasign/blob/master/ChangeLog.txt "ChangeLog.txt") |  |  |
| [ChangeLog\_jws322.txt](/kjur/jsrsasign/blob/master/ChangeLog_jws322.txt "ChangeLog_jws322.txt") | | [ChangeLog\_jws322.txt](/kjur/jsrsasign/blob/master/ChangeLog_jws322.txt "ChangeLog_jws322.txt") |  |  |
| [LICENSE.txt](/kjur/jsrsasign/blob/master/LICENSE.txt "LICENSE.txt") | | [LICENSE.txt](/kjur/jsrsasign/blob/master/LICENSE.txt "LICENSE.txt") |  |  |
| [Makefile](/kjur/jsrsasign/blob/master/Makefile "Makefile") | | [Makefile](/kjur/jsrsasign/blob/master/Makefile "Makefile") |  |  |
| [README.md](/kjur/jsrsasign/blob/master/README.md "README.md") | | [README.md](/kjur/jsrsasign/blob/master/README.md "README.md") |  |  |
| [index.html](/kjur/jsrsasign/blob/master/index.html "index.html") | | [index.html](/kjur/jsrsasign/blob/master/index.html "index.html") |  |  |
| [index\_alg.html](/kjur/jsrsasign/blob/master/index_alg.html "index_alg.html") | | [index\_alg.html](/kjur/jsrsasign/blob/master/index_alg.html "index_alg.html") |  |  |
| [index\_jws.html](/kjur/jsrsasign/blob/master/index_jws.html "index_jws.html") | | [index\_jws.html](/kjur/jsrsasign/blob/master/index_jws.html "index_jws.html") |  |  |
| [index\_jws\_gen.png](/kjur/jsrsasign/blob/master/index_jws_gen.png "index_jws_gen.png") | | [index\_jws\_gen.png](/kjur/jsrsasign/blob/master/index_jws_gen.png "index_jws_gen.png") |  |  |
| [index\_jws\_genjs.png](/kjur/jsrsasign/blob/master/index_jws_genjs.png "index_jws_genjs.png") | | [index\_jws\_genjs.png](/kjur/jsrsasign/blob/master/index_jws_genjs.png "index_jws_genjs.png") |  |  |
| [index\_jwsmat.html](/kjur/jsrsasign/blob/master/index_jwsmat.html "index_jwsmat.html") | | [index\_jwsmat.html](/kjur/jsrsasign/blob/master/index_jwsmat.html "index_jwsmat.html") |  |  |
| [index\_jwsut.html](/kjur/jsrsasign/blob/master/index_jwsut.html "index_jwsut.html") | | [index\_jwsut.html](/kjur/jsrsasign/blob/master/index_jwsut.html "index_jwsut.html") |  |  |
| [index\_oldnews.html](/kjur/jsrsasign/blob/master/index_oldnews.html "index_oldnews.html") | | [index\_oldnews.html](/kjur/jsrsasign/blob/master/index_oldnews.html "index_oldnews.html") |  |  |
| [jsrsasign-all-min.js](/kjur/jsrsasign/blob/master/jsrsasign-all-min.js "jsrsasign-all-min.js") | | [jsrsasign-all-min.js](/kjur/jsrsasign/blob/master/jsrsasign-all-min.js "jsrsasign-all-min.js") |  |  |
| [jsrsasign-jwths-min.js](/kjur/jsrsasign/blob/master/jsrsasign-jwths-min.js "jsrsasign-jwths-min.js") | | [jsrsasign-jwths-min.js](/kjur/jsrsasign/blob/master/jsrsasign-jwths-min.js "jsrsasign-jwths-min.js") |  |  |
| [jsrsasign-rsa-min.js](/kjur/jsrsasign/blob/master/jsrsasign-rsa-min.js "jsrsasign-rsa-min.js") | | [jsrsasign-rsa-min.js](/kjur/jsrsasign/blob/master/jsrsasign-rsa-min.js "jsrsasign-rsa-min.js") |  |  |
| [sample-rsasign.png](/kjur/jsrsasign/blob/master/sample-rsasign.png "sample-rsasign.png") | | [sample-rsasign.png](/kjur/jsrsasign/blob/master/sample-rsasign.png "sample-rsasign.png") |  |  |
| View all files | | |

## Repository files navigation

* README
* License
# jsrsasign

[![license](https://camo.githubusercontent.com/04071de71e73da18948e5541a8790a8bc88a9631bed43bc160542516961e7da5/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d4d49542d677265656e2e7376673f7374796c653d666c6174)](https://github.com/kjur/jsrsasign/blob/master/LICENSE.txt)
[![npm version](https://camo.githubusercontent.com/4853053a8af238d64a7a02e7878524cf75efd47e4423f22fb7cffca7622412c2/68747470733a2f2f62616467652e667572792e696f2f6a732f6a737273617369676e2e737667)](https://badge.fury.io/js/jsrsasign)
[![npm downloads](https://camo.githubusercontent.com/a8f1c5701d307802f248a6df043617a3abc94ffa5ba774cbb7302ceacdfb07ca/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f646d2f6a737273617369676e2e737667)](https://www.npmjs.com/package/jsrsasign)
[![jsdeliver downloads](https://camo.githubusercontent.com/f262d4cad93ccb79227928b73ebc0b1e032eb5b34ab2e895c1758bdbf1d76748/68747470733a2f2f646174612e6a7364656c6976722e636f6d2f76312f7061636b6167652f6e706d2f6a737273617369676e2f6261646765)](https://www.jsdelivr.com/package/npm/jsrsasign)
[![CDNJS](https://camo.githubusercontent.com/ecbd35cd3b0f99a75183be55a12a0f0e8899c1ca8bcbbbc9991cc941c956af38/68747470733a2f2f696d672e736869656c64732e696f2f63646e6a732f762f6a737273617369676e2e737667)](https://cdnjs.com/libraries/jsrsasign)
[![githubsponsors](https://camo.githubusercontent.com/a7b21795f3e7b3b7a138447f611c65c24ccb80de3ed6e7b9773d5f6c0624e1f0/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6769746875622d646f6e6174652d79656c6c6f772e737667)](https://github.com/sponsors/kjur)
[![cryptocurrency](https://camo.githubusercontent.com/608d136687544ecf66bc5dc2c730f92012607569a85977513dcb2bd80fd21b72/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f63727970746f2d646f6e6174652d79656c6c6f772e737667)](https://github.com/kjur/jsrsasign#cryptocurrency)

jsrsasign [TOP](https://kjur.github.io/jsrsasign/) | [github](https://github.com/kjur/jsrsasign) | [Wiki](https://github.com/kjur/jsrsasign/wiki) | [DOWNLOADS](https://github.com/kjur/jsrsasign/releases) | [TUTORIALS](https://github.com/kjur/jsrsasign/wiki#programming-tutorial) | [API REFERENCE](https://kjur.github.io/jsrsasign/api/) | [Online Tool](https://github.com/kjur/jsrsasign/wiki/jsrsasign-Online-Tools) | [DEMO](https://github.com/kjur/jsrsasign/wiki/jsrsasign-Demo) | [NODE TOOL](https://github.com/kjur/jsrsasign/wiki/Sample-Node-Tool-List) | [AddOn](https://github.com/kjur/jsrsasign/wiki/jsrsasign-Add-On) | [DONATE](https://github.com/kjur/jsrsasign#donations)

The 'jsrsasign' (RSA-Sign JavaScript Library) is an opensource free cryptography library supporting RSA/RSAPSS/ECDSA/DSA signing/validation, ASN.1, PKCS#1/5/8 private/public key, X.509 certificate, CRL, OCSP, CMS SignedData, TimeStamp, CAdES JSON Web Signature/Token/Key in pure JavaScript.

Public page is <https://kjur.github.io/jsrsasign> .

Your bugfix and pull request contribution are always welcomed :)

## NOTICE FOR COMMING 11.0.0 RELEASE

The "jsrsasign" library is a long lived JavaScript library from 2010 developed with old JavaScript style and backword compatibility. From coming release 11.0.0, following are planed and suport them gradually:

* Stop to support Internet Explorer.
* Stop to support bower.
* Modern ECMA functions will be introduced such as Promise, let, Array methods or class.
* API document generator will be changed from Jsdoc Toolkit to JSDoc3.
* Module bandler will be used such as browserify or webpack.
* Not to use YUI compressor.
* Unit test framework will be changed from QUnit and mocha to jest.
* W3C Web Crypto API support.
* split into some modules besides jsrsasign have been all in package before 11.0.0.

## NEWS

* 2024-Jan-16: [Security advisory](https://github.com/kjur/jsrsasign/security/advisories/GHSA-rh63-9qcf-83gf) and [update](https://github.com/kjur/jsrsasign/releases/tag/11.0.0) for Marvin attack vulnerability published. Due to this vulnerability, RSA PKCS#1.5 and RSAOAEP encryption/decryption no longer be supported.
* 2023-Mar-12: [10.7.0 Release](https://github.com/kjur/jsrsasign/releases/tag/10.7.0). Now supports custom X.509 extension and custom OIDs by new "Add-on" architecture. ([See here in detail](https://github.com/kjur/jsrsasign/wiki/jsrsasign-Add-On2))
* 2021-Nov-21: [10.5.0 Release](https://github.com/kjur/jsrsasign/releases/tag/10.5.0). Now supports secp521r1(P-521) ECDSA.
* 2021-Apr-14: [Security advisory](https://github.com/kjur/jsrsasign/security/advisories/GHSA-27fj-mc8w-j9wg) and [update](https://github.com/kjur/jsrsasign/releases/tag/10.2.0) for CVE-2021-30246 RSA signature validation vulnerability published
* 2020-Oct-05: jsrsasign won [Google Open Source Peer Bonus Award](https://opensource.googleblog.com/2020/10/announcing-latest-google-open-source.html). Thank you Google.
* 2020-Sep-23: 10.0.0 released for CMS SignedData related class including timestamp and CAdES architecture update
* 2020-Aug-24: 9.1.0 released to new CRL APIs align with certificate
* 2020-Aug-19: 9.0.0 released for major update of certificate and CSR generation and parsing without backward compatibility. Please see [migration guide](https://github.com/kjur/jsrsasign/wiki/NOTE-jsrsasign-8.0.x-to-9.0.0-Certificate-and-CSR-API-migration-guide) in detail.
* 2020-Aug-02: twitter account [@jsrsasign](https://twitter.com/jsrsasign) started for announcement. please follow.

## HIGHLIGHTS

* Swiss Army Knife style all in one package crypto and PKI library
* available on [Node.js](https://www.npmjs.com/package/jsrsasign) and browsers
* Long live open source software from 2010
* very easy API to use
* powerful various format key loader and ASN.1 API
* rich document and samples
* no dependency to other library
* no dependency to [W3C Web Cryptography API](https://www.w3.org/TR/WebCryptoAPI/) nor [OpenSSL](https://www.openssl.org/)
* no dependency on newer ECMAScirpt function. So old browsers also supported.
* very popular crypto library with [1M+ npm downloads/month](https://npm-stat.com/charts.html?package=jsrsasign&from=2016-05-01&to=2023-04-20)
* supports "Add-on" architecture

## INSTALL

### Node NPM

```
> npm install jsrsasign jsrsasign-util

```

### Bower

```
> bower install jsrsasign

```

### Or include in HTML from many CDN sites

```
> <script src="https://cdnjs.cloudflare.com/ajax/libs/jsrsasign/8.0.20/jsrsasign-all-min.js"></script>

```

## USAGE

Loading encrypted PKCS#5 private key:

```
> var rs = require('jsrsasign');
> var rsu = require('jsrsasign-util');
> var pem = rsu.readFile('z1.prv.p5e.pem');
> var prvKey = rs.KEYUTIL.getKey(pem, 'passwd');

```

Sign string 'aaa' with the loaded private key:

```
> var sig = new a.Signature({alg: 'SHA1withRSA'});
> sig.init(prvKey);
> sig.updateString('aaa');
> var sigVal = sig.sign();
> sigVal
'd764dcacb...'

```

## MORE TUTORIALS AND SAMPLES

* [Tutorials in GitHub Wiki](https://github.com/kjur/jsrsasign/wiki)
* [Sample Node Scripts](https://github.com/kjur/jsrsasign/tree/master/sample_node)

## RECENT SECURITY ADVISORY

| published | fixed version | title/advisory | CVE | CVSS |
| --- | --- | --- | --- | --- |
| 2024Jan16 | 11.0.0 | [Marvin attack vulnerability for RSA and RSAOAEP decryption](https://github.com/kjur/jsrsasign/security/advisories/GHSA-rh63-9qcf-83gf) | CVE-2024-21484 | 7.5 |
| 2022Jun24 | 10.5.25 | [JWS and JWT signature validation vulnerability with special characters](https://github.com/kjur/jsrsasign/security/advisories/GHSA-3fvg-4v2m-98jf) | CVE-2022-25898 | ? |
| 2021Apr14 | 10.2.0 | [RSA signature validation vulnerability on maleable encoded message](https://github.com/kjur/jsrsasign/security/advisories/GHSA-27fj-mc8w-j9wg) | CVE-2021-30246 | 9.1 |
| 2020Jun22 | 8.0.19 | [ECDSA signature validation vulnerability by accepting wrong ASN.1 encoding](https://github.com/kjur/jsrsasign/security/advisories/GHSA-p8c3-7rj8-q963) | CVE-2020-14966 | 5.5 |
| 2020Jun22 | 8.0.18 | [RSA RSAES-PKCS1-v1\_5 and RSA-OAEP decryption vulnerability with prepending zeros](https://github.com/kjur/jsrsasign/security/advisories/GHSA-xxxq-chmp-67g4) | CVE-2020-14967 | 4.8 |
| 2020Jun22 | 8.0.17 | [RSA-PSS signature validation vulnerability by prepending zeros](https://github.com/kjur/jsrsasign/security/advisories/GHSA-q3gh-5r98-j4h3) | CVE-2020-14968 | 4.2 |

Here is [full published security advisory list](https://github.com/kjur/jsrsasign/security/advisories?state=published).

## DONATIONS

If you like jsrsasign and my other project, you can support their development by donation through any of the platform/services below. Thank you as always.

### Github Sponsors

You can sponsor jsrsasign with the [GitHub Sponsors](https://github.com/sponsors/kjur) program.

### Cryptocurrency

You can donate cryptocurrency to jsrsasign using the following addresses:

* Bitcoin(BTC): [34vSRe7XHoMy78HKgps9YJ5BrBLYJLeM22](https://en.cryptobadges.io/donate/34vSRe7XHoMy78HKgps9YJ5BrBLYJLeM22)
* Ethereum(ETH): [0x9c4cdbb531e5b84796ff5f91a9f652704761e64e](https://en.cryptobadges.io/donate/0x9c4cdbb531e5b84796ff5f91a9f652704761e64e)
* Litecoin(LTC): [LPf3VDJVamwPcNJNjjVtrUQuJQ17ZyWzeU](https://en.cryptobadges.io/donate/LPf3VDJVamwPcNJNjjVtrUQuJQ17ZyWzeU)
* Bitcoin Cash(BCH): bitcoincash:pq3hy08pc9vm57q6ddgsc06cqdffmfzwwqxd9yejyf

## About

The 'jsrsasign' (RSA-Sign JavaScript Library) is an opensource free cryptography library supporting RSA/RSAPSS/ECDSA/DSA signing/validation, ASN.1, PKCS#1/5/8 private/public key, X.509 certificate, CRL, OCSP, CMS SignedData, TimeStamp, CAdES and JSON Web Signature/Token in pure JavaScript.

[kjur.github.io/jsrsasign](https://kjur.github.io/jsrsasign "https://kjur.github.io/jsrsasign")

### Topics

[cms](/topics/cms "Topic: cms")
[encryption](/topics/encryption "Topic: encryption")
[certificate](/topics/certificate "Topic: certificate")
[aes](/topics/aes "Topic: aes")
[signature](/topics/signature "Topic: signature")
[rsa](/topics/rsa "Topic: rsa")
[sha2](/topics/sha2 "Topic: sha2")
[x509](/topics/x509 "Topic: x509")
[asn1](/topics/asn1 "Topic: asn1")
[ecdsa](/topics/ecdsa "Topic: ecdsa")
[sha1](/topics/sha1 "Topic: sha1")
[timestamp](/topics/timestamp "Topic: timestamp")
[crl](/topics/crl "Topic: crl")
[decryption](/topics/decryption "Topic: decryption")
[ocsp](/topics/ocsp "Topic: ocsp")
[3des](/topics/3des "Topic: 3des")
[dsa](/topics/dsa "Topic: dsa")

### Resources

[Readme](#readme-ov-file)
### License

[View license](#License-1-ov-file)

[Activity](/kjur/jsrsasign/activity)
### Stars

[**3.3k**
stars](/kjur/jsrsasign/stargazers)
### Watchers

[**92**
watching](/kjur/jsrsasign/watchers)
### Forks

[**645**
forks](/kjur/jsrsasign/forks)
[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2Fkjur%2Fjsrsasign&report=kjur+%28user%29)

## [Releases 152](/kjur/jsrsasign/releases)

[restore KJUR.crypto.Cipher class without RSA/RSAOAEP support
Latest

Feb 1, 2024](/kjur/jsrsasign/releases/tag/11.1.0)
[+ 151 releases](/kjur/jsrsasign/releases)

## Sponsor this project

 Sponsor

[Learn more about GitHub Sponsors](/sponsors)

## [Packages 0](/users/kjur/packages?repo_name=jsrsasign)

No packages published

## [Used by 29.2k](/kjur/jsrsasign/network/dependents)

[* ![@GemachDAO](https://avatars.githubusercontent.com/u/85832265?s=64&v=4)
* ![@Vicolee](https://avatars.githubusercontent.com/u/37021321?s=64&v=4)
* ![@Abelmekonn](https://avatars.githubusercontent.com/u/123172904?s=64&v=4)
* ![@ISPLab](https://avatars.githubusercontent.com/u/8803512?s=64&v=4)
* ![@Ramwsh221282](https://avatars.githubusercontent.com/u/172474742?s=64&v=4)
* ![@sherlockedhzoi](https://avatars.githubusercontent.com/u/78630956?s=64&v=4)
* ![@AqilJaafree](https://avatars.githubusercontent.com/u/73504832?s=64&v=4)
* ![@RahulNavneeth](https://avatars.githubusercontent.com/u/50259284?s=64&v=4)

+ 29,180](/kjur/jsrsasign/network/dependents)

## [Contributors 38](/kjur/jsrsasign/graphs/contributors)

[+ 24 contributors](/kjur/jsrsasign/graphs/contributors)

## Languages

* [HTML
  88.9%](/kjur/jsrsasign/search?l=html)
* [JavaScript
  11.1%](/kjur/jsrsasign/search?l=javascript)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from www.ssi.gouv.fr_2a4c78d9_20250121_000028.html ===
![](/.well-known/baleen/challengejs/assets/logo.svg)Le JavaScript n'est pas activÃ© sur votre navigateur.Le JavaScript n'est pas activÃ© sur votre navigateur. Pour vous permettre de naviguer correctement sur notre site, il est nÃ©cessaire qu'il soit activÃ©.Comment activer le JavaScript ?Chrome<https://support.google.com/chrome>Mozilla Firefox<https://support.mozilla.org/fr/home>Safari<https://www.apple.com/support/safari/>Opera<https://support.google.com/adsense/answer/12654?hl=fr>Internet Explorer<https://support.microsoft.com/product/internet-explorer>

=== Content from eprint.iacr.org_b4190235_20250121_000026.html ===
Remote Timing Attacks are Still Practical(cid:63)

Billy Bob Brumley and Nicola Tuveri

Aalto University School of Science, Finland
{bbrumley,ntuveri}@tcs.hut.fi

Abstract. For over two decades, timing attacks have been an active
area of research within applied cryptography. These attacks exploit cryp-
tosystem or protocol implementations that do not run in constant time.
When implementing an elliptic curve cryptosystem with a goal to pro-
vide side-channel resistance, the scalar multiplication routine is a critical
component. In such instances, one attractive method often suggested in
the literature is Montgomery’s ladder that performs a ﬁxed sequence of
curve and ﬁeld operations. This paper describes a timing attack vulnera-
bility in OpenSSL’s ladder implementation for curves over binary ﬁelds.
We use this vulnerability to steal the private key of a TLS server where
the server authenticates with ECDSA signatures. Using the timing of
the exchanged messages, the messages themselves, and the signatures,
we mount a lattice attack that recovers the private key. Finally, we de-
scribe and implement an eﬀective countermeasure.

Keywords: Side-channel attacks, timing attacks, elliptic curve cryptog-
raphy, lattice attacks.

1

Introduction

Side-channel attacks utilize information leaked during the execution of a pro-
tocol. These attacks diﬀer from traditional cryptanalysis attacks since side-
channels are not part of the rigorous mathematical description of a cryptosystem:
they are introduced by implementation aspects and are not modeled as input
and/or output of the cryptosystem. A timing attack is a side-channel attack that
recovers key material by exploiting cryptosystem implementations that do not
run in constant time: their execution time measured by the attacker is somehow
state-dependent and hence key-dependent.

In light of these attacks, implementations of elliptic curve cryptosystems that
execute in environments where side-channels are a threat seek to ﬁx the execution
time of various components in said implementation. Perhaps the most critical
is that of scalar multiplication that computes the k-fold sum of a point with
itself. Leaking any internal algorithm state during this computation can reveal
information about some of the inputs, some of which should critically remain
secret.

(cid:63) Supported in part by the European Commission’s Seventh Framework Programme

(FP7) under contract number ICT-2007-216499 (CACE).

As a practical example of utilizing said key material, consider lattice attacks.
Lattices are mathematical objects that have many uses in cryptography from
cryptographic primitives to attacking schemes with partially known secret data.
They are generally useful for ﬁnding small solutions to underdetermined systems
of equations. Lattice methods are an eﬀective endgame for many side-channel
attacks: combining public information with (private) partial key material derived
in the analysis phase, i.e., procured from the signal, to recover the complete
private key. Repeatedly leaking even a small amount of ephemeral key material
can allow these attacks to succeed at recovering long-term private keys.

Montgomery’s ladder is a scalar multiplication algorithm that has great po-
tential to resist side-channel analysis. The algorithm is very regular in the sense
that it always executes the same sequence of curve and ﬁeld operations, regard-
less of the value that a key bit takes. Contrast this with, for example, a basic
right-to-left double-and-add scalar multiplication algorithm that only performs
point additions on non-zero key bits.

This paper describes a timing attack vulnerability in OpenSSL’s ladder im-
plementation for elliptic curves over binary ﬁelds. The timings are procured
by measuring the execution time of parts of the TLS handshake between an
attacker client and OpenSSL’s own TLS server where the server provides an
ECDSA signature on a number of exchanged messages. We utilize this timing
information to mount a lattice attack that exploits this vulnerability and recov-
ers the ECDSA private key given a small number of signatures along with said
timing data. We provide extensive experiment results that help characterize the
vulnerability. Lastly, we propose, implement, and evaluate a simple and eﬃcient
countermeasure to the attack that proves eﬀective.

The remainder of the paper is organized as follows. Section 2 reviews the
concept of timing attacks and selective related literature. Section 3 contains
background on elliptic curve cryptography and its implementation in OpenSSL.
Section 4 identiﬁes said vulnerability and describes all stages of the proposed
attack. Section 5 contains the experiment and attack implementation results. We
close in Section 6 with a discussion on countermeasures and draw conclusions.

2 Timing Attacks

P. Kocher gives a number of remarkably simple timing attacks in his seminal
work [Koc96]. Consider a right-to-left square-and-multiply algorithm for expo-
nentiation. If the exponent bit is a 1, the algorithm performs the assignments
B := B · A then A := A2. Otherwise, a 0-bit and the algorithm performs only
the assignment A := A2. The attacker chooses operand A hence its value in each
iteration is known. To mount a timing attack, the attacker is tasked with ﬁnding
input A that distinguishes former cases from the latter. This could be done by
choosing A such that the former case incurs measurably increased execution time
over the entire exponentiation yet the latter case does not. Varying the number
of computer words in A could be one method to induce this behavior. Starting
with the least signiﬁcant bit, the attacker repeats this process to recover the key

iteratively. In this manner, the attacker traces its way through the states of the
exponentiation algorithm using the timings as evidence. The author gives further
examples of software mechanisms that lead to timing vulnerabilities as well as
attack experiment results. The work mostly concerns public key cryptosystems
with a static key such as RSA and static Diﬃe-Hellman.

D. Brumley and D. Boneh [BB03,BB05] present ground breaking results,
demonstrating that timing attacks apply to general software systems, defying
contemporary common belief. They mount a timing attack against OpenSSL’s
implementation of RSA decryption based on (counteracting but exploitable) time
dependencies introduced by the Montgomery reduction and the multiplication
routines used by the OpenSSL implementation. The key relevant fact about the
Montgomery reduction is that an extra reduction step may be required depend-
ing on the input, while for the multi-precision integer multiplication routines
(heavily used in RSA computation) the relevant fact is that one of two algo-
rithms with diﬀerent performances (Karatsuba and schoolbook) is used depend-
ing on the number of words used to represent the two operands. Exploiting these
two facts and adapting the attack to work even when using the sliding window
modular exponentiation algorithm, the authors devise an attack that is capable
of retrieving the complete factorization of the key pair modulus.

The authors mount a real-world attack through a client that measures the
time an OpenSSL server takes to respond to RSA decryption queries during the
SSL handshake. The attack is eﬀective between two processes running on the
same machine and two virtual machines on the same computer, in local network
environments and in case of lightly loaded servers. The authors also analyze
experiments over a WAN and a wireless link to evaluate the eﬀects of noise on the
attacks. Finally, they devise three possible defenses and as a consequence several
cryptography libraries including OpenSSL feature RSA blinding by default as a
countermeasure. As a tangible result of their work:

– OpenSSL issued1 a security advisory;
– CVE assigned2 the name CAN-2003-0147 to the issue;
– CERT issued3 vulnerability note VU#997481.

3 Elliptic Curve Cryptography

In the mid 1980s, Miller [Mil85] and Koblitz [Kob87] independently proposed
the use of elliptic curves in cryptography. Elliptic curves are a popular choice for
public key cryptography because no sub-exponential time algorithm to solve dis-
crete logarithms is known in this setting for well-chosen parameters. This aﬀords
Elliptic Curve Cryptography (ECC) comparatively smaller keys and signatures.
For the purposes of this paper, it suﬃces to restrict to curves of the form

E(IF2m) : y2 + xy = x3 + a2x2 + a6

1 http://www.openssl.org/news/secadv_20030317.txt
2 http://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2003-0147
3 http://www.kb.cert.org/vuls/id/997481

where ai ∈ IF2m and a2 = 1 is common. NIST standardizes two types of curves
for each m ∈ {163, 233, 283, 409, 571}:

1. a6 is chosen pseudo-randomly: i.e., B-163.
2. a6 = 1 and a2 ∈ {0, 1}: Koblitz curves [Kob91], i.e., K-163.

With Intel’s recent pclmulqdq carry-less multiplication instruction facilitat-
ing multiplication in IF2[x], curves over binary ﬁelds are likely to become the
standard choice for high-speed ECC implementations in software.

3.1 Digital Signatures

We use the following notation for the ECDSA. The parameters include a hash
function h and point G ∈ E that generates a subgroup of prime order n. In fact
#E = cn where c ∈ {2, 4} for the standard curves considered in this paper. A
common current choice for these would be roughly a 160-bit n, i.e., computations
on B-163 or K-163. Parties select a private key d uniformly from 0 < d < n and
publish the corresponding public key D = [d]G. To sign a message m, parties
select nonce k uniformly from 0 < k < n then compute the signature (r, s) by

r = ([k]G)x mod n
s = (h(m) + dr)k−1 mod n.

(1)

(2)

This work omits the details of signature veriﬁcation as they are not particularly
relevant here. The performance bottleneck for generating these signatures is
the scalar multiplication in (1). Extensive literature exists on speeding up said
operation: a description of one common method follows.

3.2 Scalar Multiplication

The speed of an ECC implementation is essentially governed by the scalar mul-
tiplication operation that, for an integer k and point P ∈ E, computes the point
[k]P . There are many methods to carry out this computation, but we focus
on the Montgomery power ladder, originally proposed for speeding up integer
factorization using the elliptic curve method [Mon87, Sect. 10.3.1].

L´opez and Dahab improve the algorithm eﬃciency for curves over binary
ﬁelds [LD99]. Fig. 1 illustrates the main parts of the algorithm and is an excerpt
from the implementation in OpenSSL 0.9.8o. The nested for loop is where the
majority of the work takes place and performs one point doubling and one point
addition to process one bit of k in each iteration; assume ki = 1. The point
addition formula, i.e. implemented in the gf2m_Madd function called in Fig. 1, is

(Z0, X0) = ((X0 · Z1 + X1 · Z0)2, x · Z0 + (X0 · Z1) · (X1 · Z0))

and point doubling, i.e. implemented in the gf2m_Mdouble function called in
Fig. 1, is

(Z1, X1) = ((X1 · Z1)2, X 4

1 + a6 · Z 4

1 ).

An intriguing feature is that when ki = 0, the same steps are performed: only
the operands are transposed. That is, replacing Z1 with Z0 and X1 with X0
describes the above formulae for a zero bit. This means the cost per bit is ﬁxed
at an impressive six ﬁeld multiplications, one involving a constant. For curves
over binary ﬁelds, OpenSSL uses this algorithm as the default for any single
scalar multiplication, e.g., in signature generation, and in fact iterates it twice
for the sum of two scalar multiplications, e.g., in signature veriﬁcation.

/* find top most bit and go one past it */
i = scalar - > top - 1; j = BN_BITS2 - 1;
mask = BN_TBIT ;
while (!( scalar - > d [ i ] & mask )) { mask > >= 1; j - -; }
mask > >= 1; j - -;
/* if top most bit was at word break , go to next word */
if (! mask )

{
i - -; j = BN_BITS2 - 1;
mask = BN_TBIT ;
}

for (; i >= 0; i - -)

{
for (; j >= 0; j - -)

{
if ( scalar - > d [ i ] & mask )

{
if (! gf2m_Madd ( group , & point - >X , x1 , z1 , x2 , z2 , ctx )) goto err ;
if (! gf2m_Mdouble ( group , x2 , z2 , ctx )) goto err ;
}
else
{
if (! gf2m_Madd ( group , & point - >X , x2 , z2 , x1 , z1 , ctx )) goto err ;
if (! gf2m_Mdouble ( group , x1 , z1 , ctx )) goto err ;
}

mask > >= 1;
}

j = BN_BITS2 - 1;
mask = BN_TBIT ;
}

Fig. 1. Montgomery’s ladder scalar multiplication for curves over binary ﬁelds as im-
plemented in OpenSSL 0.9.8o at crypto/ec/ec2 mult.c.

The ladder applied to ECC has numerous advantages: fast computation, no
large memory overhead, and a ﬁxed sequence of curve operations. This last
feature is particularly attractive as a side-channel countermeasure. The following
quote concisely captures this [HMV04, p. 103].

Another advantage is that the same operations are performed in every
iteration of the main loop, thereby potentially increasing resistance to
timing attacks and power analysis attacks.

While this feature cannot be denied, the quoted authors duly qualify the state-
ment with potentially: the side-channel properties are those of the algorithm

implementation, not the algorithm itself. It should be noted that the ladder was
originally proposed only for eﬃcient computation. Its potential to resist side-
channel analysis seems to be an unintentional consequence.

4 A Timing Attack

The ladder implementation in Fig. 1 introduces a timing attack vulnerability.
Denote the time required to process one scalar bit and compute one ladder step
as t: that is, one iteration of the nested for loop that performs the double and
add steps. Said time is (reasonably) independent of, for example, any given bit ki
or the Hamming weight of k. On the other hand, consider the preceding while
loop: its purpose is to ﬁnd the index of the most signiﬁcant set bit of k and
optimize the number of iterations of the nested for loop. As a result, there are
exactly (cid:100)lg(k)(cid:101)−1 ladder step executions and the time required for the algorithm
to execute is precisely t((cid:100)lg(k)(cid:101) − 1). This shows that there is a direct correlation
between the time to compute a scalar multiplication and the logarithm of k.

This section describes an attack exploiting this vulnerability. The attack

consists of two phases.

1. The attacker collects a certain amount of signatures and exploits the de-
scribed time dependency to ﬁlter a smaller set of signatures. The signatures
in the ﬁltered set will have an high probability of being generated using se-
cret nonces (k) having a leading zero bits sequence whose length is greater
or equal to a ﬁxed threshold.

2. The attacker mounts a lattice attack using the set of signatures ﬁltered in
the collection phase to recover the secret key used to generate the ECDSA
signatures.

For this attack to succeed, we assume to be able to collect a suﬃcient amount of
ECDSA signatures made under the same ECDSA key, and to be able to measure,
with reasonably good accuracy, the wall clock execution time of each collected
sign operation. For concreteness we focus on the NIST curve B-163, but the
concepts can be more generally applied for any curve over a binary ﬁeld, and
furthermore to any scalar multiplication implementation with a main loop that
has a constant iteration time but not a constant number of iterations.

4.1 Overview of the collection phase

To verify and evaluate the actual exploitability of the described time dependency
for mounting a practical side-channel attack, we implemented two diﬀerent ver-
sions of the collection phase that share the same basic structure and diﬀer only
for the sequence of operations used to perform a signature:

– a “local” attack, where the collecting process directly uses the OpenSSL
ECDSA routines, accurately measuring the time required by each sign op-
eration; this version models the collection phase in ideal conditions, where
noise caused by external sources is reduced to the minimum;

– a “remote” attack, where the collecting process uses the OpenSSL library
to perform TLS handshakes using the ECDHE ECDSA suite; this version
models a real-world use case for this vulnerability and allows to evaluate
how practical the attack is over diﬀerent network scenarios.

In general, regardless of the internal implementation, the sign routines of
both versions simply return a signature, a measure of the time that was required
to generate it, and the digest value fed to the sign algorithm. The collecting
process repeatedly invokes the sign routine and stores the results in memory
using a ﬁxed-length binary tree heap data structure, where the weight of each
element is represented by the measured time and the root element contains the
maximum, using the following algorithm:

Heap h=Heap.new(s); //fixed size=s
from 1 to t:

Result res=sign_rtn(dgst, privk);
if ( !h.is_full() ):

h.insert(res); //O(log n) time

else if ( res.t < h.root().t ):
h.root()<-res; //O(1) time
h.percolate_down();//O(log n) time

else:

; //discard res

With this algorithm we are able to store the smallest (in terms of time) s
results using a ﬁxed amount of memory and less than O(t(1 + lg(s))) time in the
worst case; the total number of signatures collected (t) and the size of the ﬁltered
set (s) are the two parameters that characterize the collection process. As we
expect the fastest signatures to be related to nonces with a higher number of
leading zeros, we can use the ratio t/s to ﬁlter those signatures associated with
leading zero bits sequences longer than a certain threshold.

Statistically for a random 1 ≤ k < n with overwhelming probability the most
signiﬁcant bit will be set to zero since n for B-163 (and indeed many curves over
binary ﬁelds) is only negligibly over a power of two. For the next leading bits the
probability of having a sequence of zero bits of length j is equal to 2−j. Hence if
the total amount of collected signatures t is large enough, the set composed of
the quickest s results should contain signatures related to nonces with leading
zero bits sequences of length longer than lg(t/s), that are then fed to the lattice
attack phase.

4.2 Collection phase in ideal conditions

This version of the collecting process was implemented to verify that the de-
scribed time dependency is actually exploitable for mounting a side-channel at-
tack. We directly invoked the OpenSSL ECDSA routines from within the collect-
ing process to generate ECDSA signatures of random data, accurately measuring
the time required by each sign operation.

The high resolution timings were taken using the rdtsc instruction provided
in recent Pentium-compatible processors. As the host CPU used for testing was
dual core and supported frequency scaling, to ensure accuracy of the measure-
ments we disabled frequency scaling and forced the execution of the collecting
process on just one core.

As the time needed to generate a signature does not depend on the value of
the message digest, for simplicity and to speed up the experiments we chose to
generate multiple signatures on the same message, precalculating the message
digest just once to avoid generating a new random message for each signature.
The implemented sign routine takes as input the digest of the message to be
signed and the private key, and returns the computed signature, the time required
to compute the ECDSA signature and the number of leading zero bits in the
nonce. The latter value is obviously not used to mount the actual attack, but
used only to verify the dependency between the execution time of the signature
computation and the number of leading zero bits in the nonce.

4.3 Collection phase over TLS

This implementation of the collecting process was developed to show a rele-
vant real-world use case for this vulnerability and to evaluate its practicality in
diﬀerent network scenarios.

Fig. 2. TLS Handshake using the ECDHE ECDSA suite described in RFC 4492.

Here the signatures collected are those generated during the TLS handshake
using the ECDHE ECDSA cipher suite illustrated by Fig. 2. We brieﬂy high-

ClientHelloServerHelloCertificateServerKeyExchangeServerHelloDoneClientKeyExchange[ChangeCipherSpec]Finished[ChangeCipherSpec]FinishedClientServertimetimelight the relevant features of the messages exchanged during the portion of the
handshake targeted by this attack, referring to RFC 4492 [BWBG+06] for the
normative and detailed technical description of the full protocol handshake:

– The Client initiates the handshake sending a ClientHello message to the
Server; this is a regular TLS ClientHello message, proposing the ECDHE EC-
DSA cipher suite and intended to inform the Server about the supported
curves and point formats. This message contains a random nonce generated
by the Client.

– The Server replies with a ServerHello message, selecting the proposed EC-
DHE ECDSA cipher suite and using an extension to enumerate the point
formats it is able to parse. This message contains a random nonce generated
by the Server.

– The Server sends a Certiﬁcate message, conveying an ECDSA-signed certiﬁ-
cate containing the ECDSA-capable public key of the Server, and possibly
a certiﬁcate chain.

– The Server sends a ServerKeyExchange message, conveying the ephemeral
ECDH public key of the Server (and the relative elliptic curve domain pa-
rameters) to the Client. This message is divided in two halves, the ﬁrst
one containing the Server ECDH parameters (namely the EC domain pa-
rameters and the ephemeral ECDH public key, consisting of an EC point)
and the latter consisting of a digitally signed digest of the exchanged pa-
rameters. The digest is actually computed as SHA(ClientHello.random +
ServerHello.random + ServerKeyExchange.params), and the signature is an
ECDSA signature generated using the Server’s private key associated with
the certiﬁcate conveyed in the previous message.

– The handshake then continues, but other messages do not inﬂuence the im-

plemented attack.

This version of the collecting process uses the OpenSSL library to perform
an ECDHE ECDSA TLS handshake every time a signature is requested. The
sign routine creates a new TLS socket to the targeted IP address, conﬁgured to
negotiate only connections using ECDHE ECDSA and setting a message callback
function that is used to observe each TLS protocol message. After creating the
TLS socket the sign routine simply performs the TLS handshake and then closes
the TLS connection. During the handshake the message callback inspects each
TLS protocol message, starting a high resolution timer when the ClientHello
message is sent and then stopping it upon receiving the ServerKeyExchange
message, which is then parsed to compute the digest fed to the sign algorithm
and to retrieve the generated signature.

In designing this attack, we assumed to be unable to directly measure the
actual execution time of the server-side signature generation, hence we are forced
to use the time elapsed between the ClientHello message and the ServerKeyEx-
change message as an approximation. To assess the quality of this approximation,
the collecting process takes the private key as an optional argument. If provided,
the message callback will also extrapolate the nonce used internally by the server
to generate the signature and will report the number of leading zero bits in it.

Lastly, at ﬁrst glance it seems possible that the Server’s computation of its
ECDHE key also inﬂuences the measured time. When creating an SSL context
within an application, the default behavior of OpenSSL is to generate a key
pair and buﬀer it for use before any handshake begins. This is done to improve
eﬃciency. OpenSSL’s internal s_server used in these experiments behaves ac-
cordingly, so in practice that step of the handshake does not aﬀect the measured
time since only one scalar multiplication takes place server-side during these
handshake steps, namely that corresponding to the ECDSA signature. Appli-
cations can modify this behavior by passing options to the SSL context when
creating it.

4.4 The Lattice Attack

Using lattice methods, Howgrave-Graham and Smart show how to recover a DSA
key from a number of signatures under the same key where parts of the nonces
are known [HGS01]. For completeness, a discussion on implementing the lattice
attack follows. Observing j signatures, rearranging (2) yields j equations of the
form

mi − siki + dri ≡ 0

(mod n)

(3)

for 1 ≤ i ≤ j where here mi are message digests to simplify notation. Using one
such (3) to eliminating the private key yields j − 1 equations of the form

ki + Aikj + Bi ≡ 0

(mod n)

(4)

for 1 ≤ i < j and some 0 ≤ Ai, Bi < n. From here, the equations in [HGS01]
simplify greatly since all the known bits are in the most signiﬁcant positions and
are in fact all zeros: (4) should be considered the same as Equation 3 of [HGS01].
That is, express the nonces as ki = z(cid:48)
in their notation but all
λi are zero setting all z(cid:48)
i to zero and from the timings deducing all µi = 156
(for example) setting all z(cid:48)(cid:48)
i to zero, leaving zi as the only unknown on the
right where in fact ki = zi. This is nothing more than a rather laborious way
of expressing the simple fact that we know lg(ki) falls below a set threshold.
Consider a j-dimensional lattice with basis consisting of rows of the following
matrix.

i + 2λizi + 2µiz(cid:48)(cid:48)
i








−1 A1 A2 . . . Aj−1
0
0 n 0 . . .
...
...
. . .
0 . . . . . . . . . n








From here, the implementation uses the Sage software system to produce a
reduced basis for this lattice using the LLL algorithm [LLL82], orthogonalize
this basis by the Gram-Schmidt process, and approximate the closest vector
problem given input vector (0, B1, B2, . . . , Bj−1) using Babai rounding [Bab86].
This hopefully ﬁnds the desired solutions to the unknown portions of the ki.

Figure 3 contains experiment results of running the lattice attack with dif-
ferent parameters based on B-163, assuming upper bounds on (cid:100)lg(ki)(cid:101) of µi ∈

{156, 157}. The x-axis is the signature count (j) and the y-axis the observed
lattice attack success probability. It shows that as the amount of known key ma-
terial decreases (µi increases), this mandates an increase in the lattice dimension
j (the number of such required signatures j increases), and the approximations
are less likely to hold. To eﬀectively apply this as part of the timing attack, on
one hand the lower we set µi the less likely it is that a ki will satisfy the bound
and more signatures must be collected. On the other hand, collecting more sig-
natures increases the probability of error in the measurements, i.e., incorrectly
inferring a given signature with a low timing has a ki that satisﬁes the bound
and the lattice attack is more likely to fail. An interesting property of this par-
ticular lattice attack is that in fact µi does not feature in the equations used to
populate the basis matrix. In practice, this means that even if some ki does not
satisfy the bound there is still a chance the attack will succeed.

Fig. 3. Selective lattice attack parameters and observed success probabilities.

5 Results

5.1 Collection phase parameters

Using the ﬁrst implementation of the collecting process, we were able to empiri-
cally verify the dependency between the length of the leading zero bits sequence
in the nonce and the execution time of the signature operation. Figure 4 com-
pares the distributions of the execution time required by signatures generated

 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 30 40 50 60 70 80Success probabilitySignature countbound: 156bound: 157using nonces with diﬀerent leading zero bit sequence lengths. In the lattice at-
tack notation, seven leading zero bits corresponds to µi = 156 and six leading
zero bits µi = 157.

Fig. 4. Dependency between number of leading zero bits and wall clock execution time
of the signature operation.

We then evaluated the eﬀectiveness of the method used for ﬁltering the signa-
tures related to nonces with longer leading zero bit sequences by using diﬀerent
values for the collection phase parameters. The lattice attack phase, which takes
as input the output of the collecting process, determines the size of the ﬁltered
set and the minimum length of the leading zero bit sequence of the nonce associ-
ated with the signature. Fixing the ﬁltered set size to 64 signatures and varying
the total number of signatures collected by the collecting process, we evaluated
the number of “false positives” over multiple iterations, i.e., those signatures in
the ﬁltered set generated using nonces whose leading zero bit sequence length is
below the threshold determined by the tuning of the lattice attack phase. Table 1
summarizes the obtained results and shows that the eﬀectiveness of the ﬁltering
method may be adjusted by varying the t/s ratio.

The number of “false positives” in the ﬁltered set is an important parameter
of the attack. The lattice attack phase has a higher success probability if all the
signatures used to populate the matrix satisfy the constraint on the number of
leading zero bits. But as mentioned in Sec. 4, even in the presence of limited
“false positives” the lattice attack still succeeds with a small probability.

 0 500 1000 1500 2000 2500FrequencyTime<= 345678910>= 11Table 1. Observed results of the local attack.

Collected signatures count (t)
Filtered set size (s)
Average “false positives” count

4096
64
17.92

8192
64
1.48

16384
64
0.05

Consulting Fig. 3, setting the threshold on the minimum number of leading
zero bits to 7 we only needed 43 valid signatures to successfully perform the
lattice attack with high probability. Na¨ıvely, this allows up to 21 “false positives”
in the ﬁltered set obtained from the collecting process using the lattice attack
in a more fault-tolerant way:

Signatures[] filtered_set; // <-- collection_phase()
EC_point known_pubkey; // <-- server certificate

while(True)
{

tentative_privkey=lattice_attack(filtered_set[0:43]);
tentative_pubkey=generate_pub_key(tentative_priv_key);
if ( tentative_pub_key == known_pubkey )

break; // successfully retrieved the priv key

randomly_shuffle(filtered_set);

}

What follows is a rough estimate for the number of required lattice attack
iterations in the presence of “false positives”. The number of iterations, and thus
the computation time, needed to correctly retrieve the private key is inversely
proportional to the probability of selecting a subset of the ﬁltered set without
“false positives”:

Pr[subset without “false positives”] =

(cid:1)

(cid:0)64−e
43
(cid:1)
(cid:0)64
43

where e is the number of “false positives” in the ﬁltered set, 43 is the size of the
subsets, 64 is the size of the ﬁltered set, the numerator is the number of possible
subsets without “false positives” in the ﬁltered set, and the denominator is the
number of possible subsets in the ﬁltered set. Figure 5 shows how this probability
varies with e.

5.2 Remote attack

We used the described “remote” implementation of the collecting process to
attack TLS servers over two diﬀerent network scenarios. As a reference server
we used the OpenSSL s_server conﬁgured to emulate a TLS-aware web server
using an ECDSA-capable private key. In theory, any server using the OpenSSL
ECDSA implementation to support ECDHE ECDSA TLS can be vulnerable.

Fig. 5. Probability of selecting a subset without “false positives” in a ﬁltered set with
e “false positives”.

The ﬁrst scenario we considered consists of a collecting process running on
the same host as the server process. The messages are exchanged over the OS
TCP/IP stack using the localhost address on the loopback interface. In this sce-
nario we successfully retrieved the server private key, even repeating the tests
using diﬀerent private keys, randomly generated using OpenSSL itself, and tar-
geting both the OpenSSL 0.9.8o and 1.0.0a versions of the reference server.

Table 2 shows that, even if unable to directly measure the execution time
of the signature computation, using the measure of the time elapsed between
the ClientHello and the ServerKeyExchange messages as an approximation and
tuning the total number of collected signatures, the attacker is able to ﬁlter a
set of signatures with a low average of “false positives”.

We also note that in the “remote” attack, only the collection phase is per-
formed online, as the lattice attack phase does not require the attacker to ex-
change messages with the attacked server, and that even collecting a total of
16384 signatures is not particularly time consuming, requiring just a few min-
utes.

Table 2. Observed results of the remote attack over the loopback interface.

Collected signatures count (t)
Filtered set size (s)
Average “false positives” count

4096
64
17.06

8192
64
4.01

16384
64
0.90

 1e-18 1e-16 1e-14 1e-12 1e-10 1e-08 1e-06 0.0001 0.01 1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21Pr (subset without ’false positives’)Number of ’false positives’ in the filtered set. (e)Once veriﬁed that the attack is practical when run over the loopback interface
on the same host of the attacked server, we performed the same attack in a
slightly more complex network scenario: the attacker collects the signatures from
a host connected to the same network switch of the server. The tests were run
between two hosts residing in the same room in time frames with reasonably low
network loads, trying to minimize the noise introduced by external causes in the
time measures.

From Table 3 we see that the time dependency is still observable. The av-
erage rates of “false positives” in the ﬁltered sets increases, but from Fig. 5
this is still easily within reach. The lattice attack can take hours to run in this
case, but again the work is oﬄine and can be distributed. In some cases we
achieved success in only a few minutes. We also note that in this particular net-
work environment we cannot arbitrarily decrease the “false positives” rate by
increasing the parameter t, as already with t = 16384 the average number of
“false positives” starts to increase.

Table 3. Observed results of the remote attack over a switched network segment.

Collected signatures count (t)
Filtered set size (s)
Average “false positives” count

4096
64
19.40

8192
64
8.96

16384
64
11.81

This demonstrates the feasibility of the attack in a remote scenario. Natu-
rally, individual results will vary due to diﬀerent network characteristics. The
attack success rate decreases dramatically with the increase of “false positives”.
Regardless, a vulnerability exploitable to perform a successful attack from the
same host where the targeted server is run poses a threat even for remote at-
tacks. For example, in virtual hosting or cloud computing scenarios an attacker
may be able to obtain access to run code on the same physical machine hosting
the target server, as suggested by [RTSS09].

6 Conclusion

This paper identiﬁes a timing attack vulnerability in OpenSSL’s implementation
of Montgomery’s ladder for scalar multiplication of points on elliptic curves over
binary ﬁelds. This is used to mount a full key recovery attack against a TLS
server authenticating with ECDSA signatures. In response to this work, CERT
issued4 vulnerability note VU#536044. Ironically, in the end it is the regular
execution of the ladder that causes this side-channel vulnerability. For example,
a dependency on the weight of k (that might leak from, say, a simple binary
scalar multiplication method) seems much more diﬃcult to exploit than that of
the length of k that led to full key recovery here.

4 http://www.kb.cert.org/vuls/id/536044

The work of D. Brumley and D. Boneh [BB03,BB05] and this work are related
in that both exploit implementation features that cause variable time execution,
and that both demonstrate full key recovery in both local and remote scenar-
ios. However, the fundamental diﬀerence with the former is that the attacker
can leverage well-established statistical techniques and repeat measurements to
compensate for noise because the secret inputs are not changing, i.e., the RSA
exponent. Contrasting with the latter, the secret inputs are always distinct, i.e.,
the nonces in ECDSA. The former is a stronger attack than the latter in this
respect.

Lastly, a brief discussion on countermeasures follows. One way to prevent

this attack is by computing [k]G using the equivalent value [ˆk]G where

ˆk =

(cid:40)

k + 2n if (cid:100)lg(k + n)(cid:101) = (cid:100)lg n(cid:101),
k + n

otherwise.

With #(cid:104)G(cid:105) = n then [k]G = [ˆk]G holds and the signature remains valid. This
essentially changes (cid:100)lg(ˆk)(cid:101) to a ﬁxed value. We implemented this approach as
a patch to OpenSSL and experiment results show that applying said padding
thwarts this particular attack and does not entail any performance overhead to
speak of. Note that the scope of this paper does not include microarchitecture
attacks for which additional speciﬁc countermeasures are needed.

This work further stresses the importance of constant time implementations
and rigorous code auditing, adding yet another entry to an already long list of
cautionary tales surrounding cryptography engineering.

References

[Bab86]

[BB03]

[BB05]

L. Babai. On Lov´asz’ lattice reduction and the nearest lattice point prob-
lem. Combinatorica, 6(1):1–13, 1986.
David Brumley and Dan Boneh. Remote timing attacks are practical. In
Proceedings of the 12th USENIX Security Symposium, 2003.
David Brumley and Dan Boneh. Remote timing attacks are practical.
Computer Networks, 48(5):701–716, 2005.

[HGS01]

[HMV04]

[BWBG+06] S. Blake-Wilson, N. Bolyard, V. Gupta, C. Hawk, and B. Moeller. Elliptic
Curve Cryptography (ECC) Cipher Suites for Transport Layer Security
(TLS). RFC 4492 (Informational), May 2006. Updated by RFC 5246.
Nick Howgrave-Graham and Nigel P. Smart. Lattice attacks on digital
signature schemes. Des. Codes Cryptography, 23(3):283–290, 2001.
D. Hankerson, A. Menezes, and S. Vanstone. Guide to Elliptic Curve
Cryptography. Springer, 2004.
Neal Koblitz. Elliptic curve cryptosystems. Math. Comp., 48(177):203–
209, 1987.
Neal Koblitz. CM-curves with good cryptographic properties. In Joan
Feigenbaum, editor, CRYPTO, volume 576 of Lecture Notes in Computer
Science, pages 279–287. Springer, 1991.
Paul C. Kocher. Timing attacks on implementations of Diﬃe-Hellman,
RSA, DSS, and other systems. In Neal Koblitz, editor, CRYPTO, volume
1109 of Lecture Notes in Computer Science, pages 104–113. Springer, 1996.

[Kob91]

[Kob87]

[Koc96]

[LD99]

[LLL82]

[Mil85]

[Mon87]

[RTSS09]

Julio L´opez and Ricardo Dahab. Fast multiplication on elliptic curves
over GF (2m) without precomputation. In C¸ etin Kaya Ko¸c and Christof
Paar, editors, CHES, volume 1717 of Lecture Notes in Computer Science,
pages 316–327. Springer, 1999.
A. K. Lenstra, H. W. Lenstra, Jr., and L. Lov´asz. Factoring polynomials
with rational coeﬃcients. Math. Ann., 261(4):515–534, 1982.
Victor S. Miller. Use of elliptic curves in cryptography.
In Hugh C.
Williams, editor, CRYPTO, volume 218 of Lecture Notes in Computer
Science, pages 417–426. Springer, 1985.
Peter L. Montgomery. Speeding the Pollard and elliptic curve methods
of factorization. Math. Comp., 48(177):243–264, 1987.
T. Ristenpart, E. Tromer, H. Shacham, and S. Savage. Hey, you, get
oﬀ of my cloud: exploring information leakage in third-party compute
clouds.
In Proceedings of the 16th ACM conference on Computer and
communications security, pages 199–212. ACM, 2009.

A Countermeasure as OpenSSL Source Code Patch

--- openssl-0.9.8o-orig/crypto/ecdsa/ecs_ossl.c 2009-12-01 19:32:16.000000000 +0200
+++ openssl-0.9.8o-patch/crypto/ecdsa/ecs_ossl.c 2011-06-08 11:23:41.188104470 +0300
@@ -144,6 +144,13 @@

}
while (BN_is_zero(k));

+ /* We do not want timing information to leak the length of k,
+ * so we compute G*k using an equivalent scalar of fixed
+ * bit-length. */
+ if (!BN_add(k, k, order)) goto err;
+ if (BN_num_bits(k) <= BN_num_bits(order))
+ if (!BN_add(k, k, order)) goto err;
+

/* compute r the x-coordinate of generator * k */
if (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))
{



=== Content from github.com_d773a7e3_20250121_020831.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Findutny%2Felliptic%2F)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Findutny%2Felliptic%2F)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=indutny%2Felliptic)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[indutny](/indutny)
/
**[elliptic](/indutny/elliptic)**
Public

* [Notifications](/login?return_to=%2Findutny%2Felliptic) You must be signed in to change notification settings
* [Fork
  457](/login?return_to=%2Findutny%2Felliptic)
* [Star
   1.7k](/login?return_to=%2Findutny%2Felliptic)

Fast Elliptic Curve Cryptography in plain javascript

[1.7k
stars](/indutny/elliptic/stargazers) [457
forks](/indutny/elliptic/forks) [Branches](/indutny/elliptic/branches) [Tags](/indutny/elliptic/tags) [Activity](/indutny/elliptic/activity)
 [Star](/login?return_to=%2Findutny%2Felliptic)

 [Notifications](/login?return_to=%2Findutny%2Felliptic) You must be signed in to change notification settings

* [Code](/indutny/elliptic)
* [Issues
  113](/indutny/elliptic/issues)
* [Pull requests
  29](/indutny/elliptic/pulls)
* [Actions](/indutny/elliptic/actions)
* [Projects
  0](/indutny/elliptic/projects)
* [Wiki](/indutny/elliptic/wiki)
* [Security](/indutny/elliptic/security)
* [Insights](/indutny/elliptic/pulse)

Additional navigation options

* [Code](/indutny/elliptic)
* [Issues](/indutny/elliptic/issues)
* [Pull requests](/indutny/elliptic/pulls)
* [Actions](/indutny/elliptic/actions)
* [Projects](/indutny/elliptic/projects)
* [Wiki](/indutny/elliptic/wiki)
* [Security](/indutny/elliptic/security)
* [Insights](/indutny/elliptic/pulse)

# indutny/elliptic

    master[Branches](/indutny/elliptic/branches)[Tags](/indutny/elliptic/tags)Go to fileCode
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit History[342 Commits](/indutny/elliptic/commits/master/) | | |
| [benchmarks](/indutny/elliptic/tree/master/benchmarks "benchmarks") | | [benchmarks](/indutny/elliptic/tree/master/benchmarks "benchmarks") |  |  |
| [dist](/indutny/elliptic/tree/master/dist "dist") | | [dist](/indutny/elliptic/tree/master/dist "dist") |  |  |
| [lib](/indutny/elliptic/tree/master/lib "lib") | | [lib](/indutny/elliptic/tree/master/lib "lib") |  |  |
| [test](/indutny/elliptic/tree/master/test "test") | | [test](/indutny/elliptic/tree/master/test "test") |  |  |
| [.codeclimate.yml](/indutny/elliptic/blob/master/.codeclimate.yml ".codeclimate.yml") | | [.codeclimate.yml](/indutny/elliptic/blob/master/.codeclimate.yml ".codeclimate.yml") |  |  |
| [.eslintignore](/indutny/elliptic/blob/master/.eslintignore ".eslintignore") | | [.eslintignore](/indutny/elliptic/blob/master/.eslintignore ".eslintignore") |  |  |
| [.eslintrc.js](/indutny/elliptic/blob/master/.eslintrc.js ".eslintrc.js") | | [.eslintrc.js](/indutny/elliptic/blob/master/.eslintrc.js ".eslintrc.js") |  |  |
| [.gitignore](/indutny/elliptic/blob/master/.gitignore ".gitignore") | | [.gitignore](/indutny/elliptic/blob/master/.gitignore ".gitignore") |  |  |
| [.npmignore](/indutny/elliptic/blob/master/.npmignore ".npmignore") | | [.npmignore](/indutny/elliptic/blob/master/.npmignore ".npmignore") |  |  |
| [.travis.yml](/indutny/elliptic/blob/master/.travis.yml ".travis.yml") | | [.travis.yml](/indutny/elliptic/blob/master/.travis.yml ".travis.yml") |  |  |
| [Gruntfile.js](/indutny/elliptic/blob/master/Gruntfile.js "Gruntfile.js") | | [Gruntfile.js](/indutny/elliptic/blob/master/Gruntfile.js "Gruntfile.js") |  |  |
| [README.md](/indutny/elliptic/blob/master/README.md "README.md") | | [README.md](/indutny/elliptic/blob/master/README.md "README.md") |  |  |
| [package-lock.json](/indutny/elliptic/blob/master/package-lock.json "package-lock.json") | | [package-lock.json](/indutny/elliptic/blob/master/package-lock.json "package-lock.json") |  |  |
| [package.json](/indutny/elliptic/blob/master/package.json "package.json") | | [package.json](/indutny/elliptic/blob/master/package.json "package.json") |  |  |
| View all files | | |

## Repository files navigation

* README
# Elliptic [Build Status](http://travis-ci.org/indutny/elliptic) [Coverage Status](https://coveralls.io/github/indutny/elliptic?branch=master) [Code Climate](https://codeclimate.com/github/indutny/elliptic)

[![Saucelabs Test Status](https://camo.githubusercontent.com/1d92dcd81ff2e7e605a90b6792c0202b1ce36a618e85045e78acfa552035acee/68747470733a2f2f73617563656c6162732e636f6d2f62726f777365722d6d61747269782f67682d696e6475746e792d656c6c69707469632e737667)](https://saucelabs.com/u/gh-indutny-elliptic)

Fast elliptic-curve cryptography in a plain javascript implementation.

NOTE: Please take a look at <http://safecurves.cr.yp.to/> before choosing a curve
for your cryptography operations.

## Incentive

ECC is much slower than regular RSA cryptography, the JS implementations are
even more slower.

## Benchmarks

```
$ node benchmarks/index.js
Benchmarking: sign
elliptic#sign x 262 ops/sec ±0.51% (177 runs sampled)
eccjs#sign x 55.91 ops/sec ±0.90% (144 runs sampled)
------------------------
Fastest is elliptic#sign
========================
Benchmarking: verify
elliptic#verify x 113 ops/sec ±0.50% (166 runs sampled)
eccjs#verify x 48.56 ops/sec ±0.36% (125 runs sampled)
------------------------
Fastest is elliptic#verify
========================
Benchmarking: gen
elliptic#gen x 294 ops/sec ±0.43% (176 runs sampled)
eccjs#gen x 62.25 ops/sec ±0.63% (129 runs sampled)
------------------------
Fastest is elliptic#gen
========================
Benchmarking: ecdh
elliptic#ecdh x 136 ops/sec ±0.85% (156 runs sampled)
------------------------
Fastest is elliptic#ecdh
========================
```

## API

### ECDSA

```
var EC = require('elliptic').ec;

// Create and initialize EC context
// (better do it once and reuse it)
var ec = new EC('secp256k1');

// Generate keys
var key = ec.genKeyPair();

// Sign the message's hash (input must be an array, or a hex-string)
var msgHash = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
var signature = key.sign(msgHash);

// Export DER encoded signature in Array
var derSign = signature.toDER();

// Verify signature
console.log(key.verify(msgHash, derSign));

// CHECK WITH NO PRIVATE KEY

var pubPoint = key.getPublic();
var x = pubPoint.getX();
var y = pubPoint.getY();

// Public Key MUST be either:
// 1) '04' + hex string of x + hex string of y; or
// 2) object with two hex string properties (x and y); or
// 3) object with two buffer properties (x and y)
var pub = pubPoint.encode('hex');                                 // case 1
var pub = { x: x.toString('hex'), y: y.toString('hex') };         // case 2
var pub = { x: x.toBuffer(), y: y.toBuffer() };                   // case 3
var pub = { x: x.toArrayLike(Buffer), y: y.toArrayLike(Buffer) }; // case 3

// Import public key
var key = ec.keyFromPublic(pub, 'hex');

// Signature MUST be either:
// 1) DER-encoded signature as hex-string; or
// 2) DER-encoded signature as buffer; or
// 3) object with two hex-string properties (r and s); or
// 4) object with two buffer properties (r and s)

var signature = '3046022100...'; // case 1
var signature = new Buffer('...'); // case 2
var signature = { r: 'b1fc...', s: '9c42...' }; // case 3

// Verify signature
console.log(key.verify(msgHash, signature));
```

### EdDSA

```
var EdDSA = require('elliptic').eddsa;

// Create and initialize EdDSA context
// (better do it once and reuse it)
var ec = new EdDSA('ed25519');

// Create key pair from secret
var key = ec.keyFromSecret('693e3c...'); // hex string, array or Buffer

// Sign the message's hash (input must be an array, or a hex-string)
var msgHash = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
var signature = key.sign(msgHash).toHex();

// Verify signature
console.log(key.verify(msgHash, signature));

// CHECK WITH NO PRIVATE KEY

// Import public key
var pub = '0a1af638...';
var key = ec.keyFromPublic(pub, 'hex');

// Verify signature
var signature = '70bed1...';
console.log(key.verify(msgHash, signature));
```

### ECDH

```
var EC = require('elliptic').ec;
var ec = new EC('curve25519');

// Generate keys
var key1 = ec.genKeyPair();
var key2 = ec.genKeyPair();

var shared1 = key1.derive(key2.getPublic());
var shared2 = key2.derive(key1.getPublic());

console.log('Both shared secrets are BN instances');
console.log(shared1.toString(16));
console.log(shared2.toString(16));
```

three and more members:

```
var EC = require('elliptic').ec;
var ec = new EC('curve25519');

var A = ec.genKeyPair();
var B = ec.genKeyPair();
var C = ec.genKeyPair();

var AB = A.getPublic().mul(B.getPrivate())
var BC = B.getPublic().mul(C.getPrivate())
var CA = C.getPublic().mul(A.getPrivate())

var ABC = AB.mul(C.getPrivate())
var BCA = BC.mul(A.getPrivate())
var CAB = CA.mul(B.getPrivate())

console.log(ABC.getX().toString(16))
console.log(BCA.getX().toString(16))
console.log(CAB.getX().toString(16))
```

NOTE: `.derive()` returns a [BN](https://github.com/indutny/bn.js) instance.

## Supported curves

Elliptic.js support following curve types:

* Short Weierstrass
* Montgomery
* Edwards
* Twisted Edwards

Following curve 'presets' are embedded into the library:

* `secp256k1`
* `p192`
* `p224`
* `p256`
* `p384`
* `p521`
* `curve25519`
* `ed25519`

NOTE: That `curve25519` could not be used for ECDSA, use `ed25519` instead.

### Implementation details

ECDSA is using deterministic `k` value generation as per [RFC6979](http://tools.ietf.org/html/rfc6979). Most of
the curve operations are performed on non-affine coordinates (either projective
or extended), various windowing techniques are used for different cases.

All operations are performed in reduction context using [bn.js](https://github.com/indutny/bn.js), hashing is
provided by [hash.js](https://github.com/indutny/hash.js)

### Related projects

* [eccrypto](https://github.com/bitchan/eccrypto): isomorphic implementation of ECDSA, ECDH and ECIES for both
  browserify and node (uses `elliptic` for browser and [secp256k1-node](https://github.com/wanderer/secp256k1-node) for
  node)

#### LICENSE

This software is licensed under the MIT License.

Copyright Fedor Indutny, 2014.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to permit
persons to whom the Software is furnished to do so, subject to the
following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

## About

Fast Elliptic Curve Cryptography in plain javascript

### Resources

[Readme](#readme-ov-file)

[Activity](/indutny/elliptic/activity)
### Stars

[**1.7k**
stars](/indutny/elliptic/stargazers)
### Watchers

[**54**
watching](/indutny/elliptic/watchers)
### Forks

[**457**
forks](/indutny/elliptic/forks)
[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2Findutny%2Felliptic&report=indutny+%28user%29)

## [Releases](/indutny/elliptic/releases)

[90
tags](/indutny/elliptic/tags)

## [Packages 0](/users/indutny/packages?repo_name=elliptic)

No packages published

## [Used by 10.5m](/indutny/elliptic/network/dependents)

[* ![@vsenadev](https://avatars.githubusercontent.com/u/108312851?s=64&v=4)
* ![@JaeKwang](https://avatars.githubusercontent.com/u/10448935?s=64&v=4)
* ![@tinonavarrodiaz](https://avatars.githubusercontent.com/u/16297079?s=64&v=4)
* ![@christophehaight0307](https://avatars.githubusercontent.com/u/169203801?s=64&v=4)
* ![@kkirrin](https://avatars.githubusercontent.com/u/96535291?s=64&v=4)
* ![@LazyBoyJgn99](https://avatars.githubusercontent.com/u/40264751?s=64&v=4)
* ![@jturbide](https://avatars.githubusercontent.com/u/4306188?s=64&v=4)
* ![@jturbide](https://avatars.githubusercontent.com/u/4306188?s=64&v=4)

+ 10,539,450](/indutny/elliptic/network/dependents)

## [Contributors 28](/indutny/elliptic/graphs/contributors)

* [![@indutny](https://avatars.githubusercontent.com/u/238531?s=64&v=4)](https://github.com/indutny)
* [![@fanatid](https://avatars.githubusercontent.com/u/2633065?s=64&v=4)](https://github.com/fanatid)
* [![@sublimator](https://avatars.githubusercontent.com/u/525211?s=64&v=4)](https://github.com/sublimator)
* [![@calvinmetcalf](https://avatars.githubusercontent.com/u/1128607?s=64&v=4)](https://github.com/calvinmetcalf)
* [![@Kagami](https://avatars.githubusercontent.com/u/533383?s=64&v=4)](https://github.com/Kagami)
* [![@gnarula](https://avatars.githubusercontent.com/u/1399686?s=64&v=4)](https://github.com/gnarula)
* [![@oberien](https://avatars.githubusercontent.com/u/4820508?s=64&v=4)](https://github.com/oberien)
* [![@Markus-MS](https://avatars.githubusercontent.com/u/45643263?s=64&v=4)](https://github.com/Markus-MS)
* [![@eordano](https://avatars.githubusercontent.com/u/42750?s=64&v=4)](https://github.com/eordano)
* [![@ljharb](https://avatars.githubusercontent.com/u/45469?s=64&v=4)](https://github.com/ljharb)
* [![@ryanxcharles](https://avatars.githubusercontent.com/u/63740?s=64&v=4)](https://github.com/ryanxcharles)
* [![@wanderer](https://avatars.githubusercontent.com/u/158211?s=64&v=4)](https://github.com/wanderer)
* [![@evilaliv3](https://avatars.githubusercontent.com/u/217034?s=64&v=4)](https://github.com/evilaliv3)
* [![@ChALkeR](https://avatars.githubusercontent.com/u/291301?s=64&v=4)](https://github.com/ChALkeR)

[+ 14 contributors](/indutny/elliptic/graphs/contributors)

## Languages

* [JavaScript
  99.3%](/indutny/elliptic/search?l=javascript)
* [HTML
  0.7%](/indutny/elliptic/search?l=html)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from minerva.crocs.fi.muni.cz_8c51df89_20250121_000027.html ===


Minerva

Minerva
[Affected](#affected)
[Secure](#secure-impl)
[Q&A](#qa)
[PoC](#poc)
[Details](#details)
[Leakage](#details-leakage)
[Hidden Number Problem](#details-hnp)
[Attack improvements](#details-improvements)
[Root causes](#details-reasons)

[Disclosure](#disclosure)
[Team](#team)
[Updates](#timeline)
[Media](#media)
[Acknowledgements](#acknowledgements)
[References](#references)

![Minerva: Leaky loops](assets/img/Leaky_loops_mid.webp)

Minerva

[![CRoCS logo](assets/img/crocs.svg)](https://crocs.fi.muni.cz "Visit the CRoCS website")

This page describes our discovery of a group of side-channel vulnerabilities in implementations of
ECDSA
in programmable smart cards and cryptographic software libraries. Our attack allows for practical
recovery of the long-term private key. We have found implementations which leak
the bit-length of the scalar during scalar multiplication on an elliptic curve. This leakage might seem minuscule
as the bit-length presents a very small amount of information present in the scalar. However, in the case of
ECDSA signature generation, the leaked bit-length of the random
nonce is enough for full recovery of the private key used after observing a few hundreds to a few thousands of signatures
on known messages, due to the application of lattice techniques.

We have verified our attack against
an Athena IDProtect card, running on an Inside Secure AT90SC chip,
for more affected devices see the [next section](#affected). The attack required 2100
signatures to recover the private key on the standard secp256r1 curve, using an off-the-shelf
smart card reader, running on an ordinary Linux laptop with a runtime of a few minutes after the collection of
signatures. The total time for the attack, including the collection of signatures was around 30 minutes.

We propose two new methods to recover the full private key
requiring just 500 signatures for simulated leakage data, 1200 for real cryptographic
library data, and 2100 for smartcard data. Our attack and proof-of-concept code is inspired by the method of [Brumley & Tuveri [3]](#remote),
for more details, see the [section](#details) on the attack.

The paper, containing our improvements and systematic analysis of lattice attacks on ECDSA appeared at CHES 2020.
The paper also received the Best Paper Award at CHES 2020! ![](assets/img/tada.png)

 [Pre-print](assets/Minerva.pdf)

 [ePrint](https://eprint.iacr.org/2020/728)

 [TCHES 2020](https://tches.iacr.org/index.php/TCHES/article/view/8684)

 [Code & data](https://github.com/crocs-muni/minerva)

```

@article{tches2020-Minerva,
  author    = {Jan Jancar and Vladimir Sedlacek and Petr Svenda and Marek Sys},
  title     = {Minerva: The curse of {ECDSA} nonces (Systematic analysis of lattice
               attacks on noisy leakage of bit-length of {ECDSA} nonces)},
  journal   = {IACR Transactions on Cryptographic Hardware and Embedded Systems},
  volume    = {2020},
  number    = {4},
  pages     = {281--308},
  year      = {2020},
  doi       = {10.13154/tches.v2020.i4.281-308}
}

```

**Primary contact:** Jan Jancar ENABLE@JAVASCRIPT

**Update** Added a [list](#secure-impl) of libraries and cards tested and deemed not vulnerable.

**Update** This page originally claimed an attack also applicable to EdDSA, due to the leakage
also being present in the EdDSA implementation in libgcrypt. However, an attack path for
EdDSA is not clear, as the leakage does not represent the bit-length of the random nonce modulo the curve order,
but a full SHA-512 bit hash. Without the implementation reducing this modulo the curve order (which is not required by the protocol),
the leakage does not seem to be exploitable. We have thus removed EdDSA mentions from this page.

### Affected devices and libraries

We have tested our attack on an Athena IDProtect card with CPLC data `010b.0352.0005`.
We further believe the following devices and cryptographic libraries to be affected:

#### Devices

* Athena IDProtect with card CPLC data:
   [leakage plots](#leakage-athena-head "Navigate to leakage plots.") [CVE-2019-15809](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15809)
  + `010b.0352.0005`: FIPS 140-2 certificate [1711](https://csrc.nist.gov/Projects/cryptographic-module-validation-program/Certificate/1711), CC certificate [ANSSI-CC-2012/23](https://www.ssi.gouv.fr/certification_cc/athena-os755idprotect-v6-sscd/) (tested)
  + `010e.1245.0002`: FIPS 140-2 certificate [1749](https://csrc.nist.gov/Projects/cryptographic-module-validation-program/Certificate/1749)
  + `0106.0130.0401`: FIPS 140-2 certificate [1750](https://csrc.nist.gov/Projects/cryptographic-module-validation-program/Certificate/1750)
  + `010e.1245.0002`: FIPS 140-2 certificate [1764](https://csrc.nist.gov/Projects/cryptographic-module-validation-program/Certificate/1764)

#### Likely affected devices

* Valid S/A IDflex V with card CPLC data:
  + `010b.0352.0005`: FIPS 140-2 certificate [1781](https://csrc.nist.gov/Projects/Cryptographic-Module-Validation-Program/Certificate/1781) (assumed, not tested)
* SafeNet eToken 4300 with card CPLC data:
  + `010e.1245.0002`: FIPS 140-2 certificate [1800](https://csrc.nist.gov/Projects/Cryptographic-Module-Validation-Program/Certificate/1800) (assumed, not tested)
* TecSec Armored Card with card CPLC data:
  + `010e.0264.0001`: FIPS 140-2 certificate [1986](https://csrc.nist.gov/Projects/Cryptographic-Module-Validation-Program/Certificate/1986) (assumed, not tested)
  + `0108.0264.0001`: FIPS 140-2 certificate [1992](https://csrc.nist.gov/Projects/Cryptographic-Module-Validation-Program/Certificate/1992) (assumed, not tested)

#### Libraries

* libgcrypt:
   [leakage
  plots](#leakage-gcrypt-head "Navigate to leakage plots.") [CVE-2019-13627](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13627) [source](https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=blob;f=mpi/ec.c;h=89077cd94b4647a2a432f117c28d848f114fd68d;hb=refs/tags/libgcrypt-1.8.4#l1312) [fix](https://git.gnupg.org/cgi-bin/gitweb.cgi?p=libgcrypt.git;a=commit;h=b9577f7c89b4327edc09f2231bc8b31521102c79)
  + ECDSA: all versions including 1.8.4, introduced in 1.3.0, fixed in 1.8.5
  + ~~EdDSA: all versions including 1.8.4, introduced in 1.6.0, fixed in 1.8.5~~

    **Update**: The EdDSA scalar multiplication code in libgcrypt was leaking, however due to the way it was used, it was likely not exploitable.
    It did not reduce the scalar which was a SHA512 digest by the curve order, but used the digest directly, thus the leakage did not represent the bit-length of the reduced scalar.
    Thanks to Daniel J. Bernstein for the note.
* wolfSSL/wolfCrypt:
   [leakage plots](#leakage-wolfcrypt-head "Navigate to leakage plots.") [CVE-2019-13628](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13628) [source](https://github.com/wolfSSL/wolfssl/blob/21f2beca9f320199fcea4a96df3e19967804144b/wolfcrypt/src/ecc.c#L2774) [fix](https://github.com/wolfSSL/wolfssl/pull/2353)
  + ECDSA: all versions including 4.0.0, fixed in 4.1.0

    The leakage in wolfSSL/wolfCrypt is minuscule and would be very hard to exploit.
* MatrixSSL:
   [leakage plots](#leakage-matrixssl-head "Navigate to leakage plots.") [CVE-2019-13629](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13629) [source](https://github.com/matrixssl/matrixssl/blob/91fd0f130294629fe6f17078c5306af42ca6cfa5/crypto/pubkey/ecc_math.c#L209) no fix
  + ECDSA: all versions including 4.2.1
* SunEC/OpenJDK/Oracle JDK:
   [leakage
  plots](#leakage-sunec-head "Navigate to leakage plots.") [CVE-2019-2894](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-2894) [source](http://hg.openjdk.java.net/jdk/jdk13/file/31b7274c7b9e/src/jdk.crypto.ec/share/native/libsunec/impl/ec2_mont.c#l225) no fix [our patch](assets/jdk.patch)
  + ECDSA over binary field curves: all versions including JDK 12, introduced in JDK 7
* Crypto++:
   [leakage
  plots](#leakage-cryptopp-head "Navigate to leakage plots.") [CVE-2019-14318](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-14318) [fix](https://github.com/weidai11/cryptopp/commit/f68f00f5601f6e4aade302e92cb1a7f8e85c250f)
  + ECDSA over binary field curves: all versions including 8.2.0
  + ECDSA over prime field curves: all versions including 8.2.0, significantly smaller leakage.
* GnuTLS:
  [CVE-2024-28834](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-28834)
  + ECDSA on secp521r1: Found and reported by [Alicja Kario and George Pantelakis](https://gitlab.com/gnutls/gnutls/-/issues/1516) (04.12.2023).

#### Other software

* jsrsasign:  [source](https://github.com/kjur/jsrsasign) [fix](https://github.com/kjur/jsrsasign/commit/9dcb89c57408a3d4b5b66aa9138426bd92819e73) 2015 stars, 7406 uses
* elliptic:  [source](https://github.com/indutny/elliptic/) 875 stars, 2 670 640 uses
* python-ecdsa:  [source](https://github.com/warner/python-ecdsa) [CVE-2024-23342](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-23342) 497 stars
* easy-ecc:  [source](https://github.com/esxgx/easy-ecc/) 122 stars
* fastecdsa:  [source](https://github.com/AntonKueltz/fastecdsa) 100 stars
* ruby\_ecdsa:  [source](https://github.com/DavidEGrayson/ruby_ecdsa) 78 stars

We believe all of the cards above are affected because they share a common ECDSA component (FIPS
module
[214](https://csrc.nist.gov/Projects/Cryptographic-Algorithm-Validation-Program/details?source=ECDSA&number=214))
, which is described as Athena OS755 ECDSA2 Component on
Inside Secure AT90SC A1.0 (Firmware). We have tested the vulnerability only on the Athena IDProtect card with CPLC data
`010b.0352.0005` and ATR
`3bd518ff8191fe1fc38073c8211309`.

We believe that the source of the vulnerability of the aforementioned cards utilizing the Athena ECDSA component is
the Atmel Toolbox 00.03.11.05 with the Common Criteria certificate DCSSI-CC-2009/11
([security target](https://commoncriteriaportal.org/files/epfiles/dcssi-cible2009_11en.pdf),
[certification report](https://commoncriteriaportal.org/files/epfiles/dcssi-2009_11fr.pdf), [info page](https://www.ssi.gouv.fr/certification_cc/bibliotheque-cryptographique-atmel-toolbox-00-03-11-05/)).
The security target states the following under security functions (on pages 48 and 49):

```

- M10.6 the TSF shall provide digital signature confirming to EC-DSA standard.
    - Secure digital signature generate
    - Secure digital signature verify
    - Fast digital signature generate (see note*)
    - Fast digital signature verify (see note*)

- M10.7 the TSF shall provide point multiplication on an elliptical curve, conforming to EC-DSA standard.
    - Secure multiply
    - Fast multiply (see note*)

    * The Fast functions of M10.3, M10.4, M10.5, M10.7, M10.8, M10.9, do not
    offer any DPA/SPA protection and must not be used for secure data.
```

We assume that the vulnerable Athena cards used the fast and insecure functions. Our hypothesis was confirmed to us after discussions
with the vendor, see more in the [responsible disclosure](#disclosure) section.

### Tested implementations deemed secure

Most implementations we analyzed during this research did not show any leakage and are thus likely secure.
We cannot be sure of this, as our tests might not be exhaustive due to the complexity of the implementations.

The libraries usually have multiple scalar multiplication algorithms and choose from them based on build options, runtime configuration,
curve used, cryptosystem used and operation being performed. Thus, our testing might just not have caught a particular configuration that could still
be vulnerable. Below, we list libraries we tested and found not vulnerable:

#### Libraries

* OpenSSL 1.1.1d
* BouncyCastle 1.58
* BoringSSL 974f4dddf
* libtomcrypt 1.18.2
* Botan 2.11.0
* Microsoft CNG
* mbedTLS 2.16.0
* Intel IPP-Crypto
* IAIK ECCelerate 6.0.1

#### Cards

* ACS ACOSJ 40K
* Feitian A22CR
* G&D SmartCafe 6.0
* G&D SmartCafe 7.0
* Infineon CJTOP 80K INF SLJ 52GLA080AL M8.4
* Infineon SLE78 Universal JCard
* NXP JCOP31 v2.4.1
* NXP JCOP CJ2A081
* NXP JCOP v2.4.2 R2
* NXP JCOP v2.4.2 R3
* TaiSYS SIMoME VAULT

#### Devices

* YubiKey HSM 2 v2.102\*
* ellipticsecure MIRkey\*

\* Thanks to John Hughes for testing.

See the ECTester [documentation](https://github.com/crocs-muni/ECTester/blob/master/docs/LIBS.md) for more information about tested libraries.

### Questions & Answers

* **Is my device affected?**

  See the section on [affected devices](#affected),
  also if you have access to an unlocked JavaCard, you can test its
  vulnerability using our [proof-of-concept](#poc) and other testing tools.
  If you found a device or a library that is affected but is not present in the list above,
  please contact us.
* **Is my library affected?**

  See the section on [affected devices](#affected),
  if it is not there and it is supported by the
  [ECTester](https://crocs-muni.github.io/ECTester/) tool
  then it is probably not affected, as we tested it ([list
  of supported libraries](https://github.com/crocs-muni/ECTester/blob/master/docs/LIBS.md)). If it is not supported, we did not check.
  Furthermore, even if it is listed and we have tested it, it still may be vulnerable as
  cryptographic libraries often
  contain more than one scalar multiplication algorithm implementation, which can be enabled
  either by build options or
  sometimes even at runtime, where different algorithms are used for different classes of curves.
  We have usually tested the libraries
  in only one configuration and on a few curves (secp256r1, sect233r1...).
* **Are other devices running on the AT90SC chip affected?**

  The AT90SC chip was sold along with the Atmel Toolbox, a cryptographic toolbox
  utilizing the functionality of the Ad-X cryptographic coprocessor to provide some higher/level cryptographic
  functionality, such as ECDSA or RSA. This toolbox evolved, as the underlying intellectual property was
  sold from Atmel to Inside Secure (now called Verimatrix) and finally to WiseKey. The vulnerability is
  known to be present in one concrete version of the toolbox, the
  Atmel Toolbox 00.03.11.05 on the AT90SC Family of Devices, as specified in the
  Common Criteria [security target](https://commoncriteriaportal.org/files/epfiles/dcssi-cible2009_11en.pdf) of the toolbox.
  This version of the toolbox contains two versions of ECDSA functionality, secure and fast, the device
  using the toolbox is affected if it uses the fast version of the primitive, as the above-specified cards do.
  We do not know if other versions of this toolbox, and the renamed INSIDE Toolbox or
  WiseKey Toolbox contain the insecure functionality or if they are vulnerable.
* **Why did the Atmel Toolbox contain explicitly insecure functionality?**

  We have no idea. Having functions that perform signing or encryption, but are explicitly marked as insecure is possibly faster but also pointless and dangerous as can be seen from the resulting vulnerabilities.
* **Is there a proof of concept?**

  Yes, see the [next section](#poc).
* **Are there any CVEs for Minerva?**

  Yes, the following:
  + [CVE-2019-15809](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15809):
    Vulnerability in Athena-based cards.
  + [CVE-2019-13627](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13627):
    Vulnerability in libgcrypt.
  + [CVE-2019-13628](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13628):
    Vulnerability in wolfSSL/wolfCrypt.
  + [CVE-2019-13629](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13629):
    Vulnerability in MatrixSSL.
  + [CVE-2019-2894](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-2894):
    Vulnerability in SunEC/OpenJDK/Oracle JDK.
  + [CVE-2019-14318](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-14318):
    Vulnerability in Crypto++.
* **What is required to perform the attack?**

  The attacker needs to be able to measure the duration of hundreds to thousands of signing operations
  of known messages. The less noise in the measurement is present, the less signatures the attacker needs.
  The computation of the private key is then a matter of seconds or minutes.
* **Is this exploitable locally?**

  Definitely, if the runtime of signing operations performed by an affected device or library is measurable,
  locally the amount of noise is not enough to stop the attack. We have verified this against the affected libraries,
  and the code to do so is present in the [PoC](#poc).
* **Is this exploitable remotely?**

  Maybe, [Brumley & Tuveri [3]](#remote) demonstrate the attack using the loopback interface of the same machine
  and even between two machines sharing the same network switch. We think this could be extended by collection of a larger amount
  of signatures and an increase in computation time.

  Furthermore, the [TPM-Fail [14]](#tpm-fail) paper demonstrates the attack using two machines sharing the same network switch.
  We do not consider this really remote though, as the noise introduced by such a switch can be even smaller than noise naturally present in
  a leaking but noisy implementation, such as a smartcard.
* **I own a vulnerable device, can I fix it?**

  Probably not, the vulnerability is present in the underlying firmware, which is
  inaccessible to the user/administrator of the device. However, the firmware might be updateable by the
  manufacturer. In the case of a vulnerable library, updating it to the newest version should fix it, as most libraries we notified
  fixed the issue and released a new version.
* **How did this happen? The devices are certified.**

  The FIPS 140-2 certification scheme specifically does not require side-channel resistance to be tested by
  the lab performing the assessment (see [[12]](#fips) page 12 on *Mitigation of other attacks*). So even though the FIPS security targets of the aforementioned cards specify
  resistance against side-channel attacks, no such testing had to be performed. The case of Common Criteria certificate
  [ANSSI-CC-2012/23](https://www.ssi.gouv.fr/certification_cc/athena-os755idprotect-v6-sscd/) can be answered
  easily as well, the ECDSA functionality of the card is explicitly mentioned to be out of the security requirements.
  The original Common Criteria certificate DCSSI-CC-2009/11 that introduced the vulnerable functionality did so by
  stating the functionality is explicitly not protected against SPA/DPA attacks and should not be used on secure data.

  As for the libraries, preventing leakage of the bit-length is surprisingly hard as we analyzed in the section on [root causes](#details-reasons).
* **Why is it called Minerva?**

  We discovered this vulnerability on cards from the Athena SCS manufacturer,
  which was named after the greek goddess
  [Athena](https://en.wikipedia.org/wiki/Athena "Wikipedia:Athena").
  [Minerva](https://en.wikipedia.org/wiki/Minerva "Wikipedia:Minerva")
  is the Roman equivalent.
* **Why the logo?**

  Why not? An owl was one of the main symbols of the Roman goddess Minerva. You can download it
  [here](assets/img/logo.svg) in svg (or [here](assets/img/logo.png) in png), it is [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/) licensed.

### Proof of Concept

The tools and data can be downloaded from this page and also our  [github](https://github.com/crocs-muni/minerva).

| Content | zip | signature | tar.gz | signature |
| --- | --- | --- | --- | --- |
| Proof-of-Concept | [poc.zip](assets/poc.zip "poc.zip") | [sig](assets/poc.zip.asc "poc.zip.asc") | [poc.tar.gz](assets/poc.tar.gz "poc.tar.gz") | [sig](assets/poc.tar.gz.asc "poc.tar.gz.asc") |
| CPLC checker | [cplc.zip](assets/cplc.zip "cplc.zip") | [sig](assets/cplc.zip.asc "cplc.zip.asc") | [cplc.tar.gz](assets/cplc.tar.gz "cplc.tar.gz") | [sig](assets/cplc.tar.gz.asc "cplc.tar.gz.asc") |
| ECDH tester | [tester.zip](assets/tester.zip "tester.zip") | [sig](assets/tester.zip.asc "tester.zip.asc") | [tester.tar.gz](assets/tester.tar.gz "tester.tar.gz") | [sig](assets/tester.tar.gz.asc "tester.tar.gz.asc") |
| Datasets | [data.zip](assets/data.zip "data.zip") | [sig](assets/data.zip.asc "data.zip.asc") | [data.tar.gz](assets/data.tar.gz "data.tar.gz") | [sig](assets/data.tar.gz.asc "data.tar.gz.asc") |
| All of the above | [all.zip](assets/all.zip) | [sig](assets/all.zip.asc) | [all.tar.gz](assets/all.tar.gz) | [sig](assets/all.tar.gz.asc) |

The above archives were signed by the [PGP key](https://neuromancer.sk/static/johny.asc) of Jan Jancar, one of the discoverers.
#### Proof-of-Concept

The Minerva proof-of-concept contains code that exploits the vulnerability against a JavaCard with a target applet,
or against targets using several vulnerable libraries.

##### Contents

`applet/` contains code of the two target JavaCard applets, the `CollectApplet` and the `POCApplet`.
The applets are very similar, the only difference is that the `POCApplet` will never export its private key, so it can
be used for full verification of the attack (if the private key is recovered and the device never exported it). It generates an ECC keypair on the
`secp256r1` curve in the `PREPARE` command and exports the public key in the response as well as the data
that will be signed. Then, in the `SIGN` command it signs the data using ECDSA with SHA256 and responds
with the signature. See `build.xml` for the ant build script.

`attack/` contains two attack scripts. An online one against a JavaCard target in `poc.py` and
an offline one in `attack.py`. Both are written in Python 3 and use the
`pyscard` library for communication and `fpylll` library for lattice reduction
and CVP solving required for the attack. Both take parameters in the form of a JSON
file, which specified what kind of attack is to be performed, see the description in `attack.py`.
The offline attack takes as input a csv file produced by one of the targets or the collection
script in `collect/` for the target JavaCard applet. The `params.json` file can
be used as a template to change some parameters internal to the attack or the PoC.

`build/` is a directory created by the ant build which contains the CAP file with the
built JavaCard applet.

`collect/` contains a Python script which collects signatures from the target JavaCard applet
and outputs it in a format ready for the offline attack script `attack/attack.py`.

`ext/` contains some third party content, such as the ant-javacard extension
(`ant-javacard.jar`) for the ant build system, which is used to build the
applet as well as a version of the JavaCard SDK 2.2.2 (`jckit_222`).

`target/` contains target apps which perform ECDSA signatures using the vulnerable libraries
and export the signatures with timing information in format ready for the offline attack script
`attack/attack.py`. See the Makefile for information on building.

##### Usage with JavaCard (PoC)

1. Build the applet via `ant build`.
2. Install the applet (`build/poc_applet.cap`) on the card. For example
   using [GlobalPlatformPro](https://github.com/martinpaljak/GlobalPlatformPro), so
   doing `gp --install build/poc_applet.cap`.
3. Install Python packages from `requirements.txt` (into a virtualenv).
   Starting with `pip install Cython` first, as it is a build dependency of
   `fpylll`. `fpylll` has a somewhat more involved install process, see
   <https://github.com/fplll/fpylll>,
   you will need the current master version of `fpylll`.
4. Run `./attack/poc.py`. If a USB reader is used, not using other
   USB devices during the attack makes it more reliable. Also, not using the machine
   for other computations during the attack limits the noise and makes it more reliable.
5. Observe a new keypair being generated (the public key is exported from
   the card and printed) and the attack starting. Observe the reconstructed
   private key after around 10k-25k signatures. If the attack did not succeed
   after this time, it is likely that that particular run of the attack will
   not succeed at all, likely due to noise during the timing measurement.

##### Usage with JavaCard (Collect)

1. Build the applet via `ant build`.
2. Install the applet (`build/collect_applet.cap`) on the card. For example
   using [GlobalPlatformPro](https://github.com/martinpaljak/GlobalPlatformPro), so
   doing `gp --install build/collect_applet.cap`.
3. Install Python packages from `requirements.txt` (into a virtualenv).
   Starting with `pip install Cython` first, as it is a build dependency of
   `fpylll`. `fpylll` has a somewhat more involved install process, see
   <https://github.com/fplll/fpylll>,
   you will need the current master version of `fpylll`.
4. Run `./attack/collect.py`. If a USB reader is used, not using other
   USB devices during the attack makes it more reliable. Also, not using the machine
   for other computations during the attack limits the noise and makes it more reliable.
5. Observe a new keypair being generated and signatures being performed
   (the public key is exported from the card and printed, the private key is also exported in this mode).
   Save the output of the `collect.py` script somewhere, it is in csv.
6. Run `./attack/attack.py` passing the arguments `secp256r1 sha256` and a path to the collected file.
   Observe the reconstructed private key.

##### Usage with libraries

1. Build the particular target app using the Makefile in the `target/` directory.
2. Run the target, possibly with [frequency scaling](https://wiki.archlinux.org/index.php/CPU_frequency_scaling "CPU frequency scaling") off,
   passing the arguments: the chosen curve, hash algorithm and amount of signatures requested. Save the
   output to a file.
3. Install Python packages from `requirements.txt` (into a virtualenv).
   Starting with `pip install Cython` first, as it is a build dependency of
   `fpylll`. `fpylll` has a somewhat more involved install process, see
   <https://github.com/fplll/fpylll>,
   you will need the current master version of `fpylll`.
4. Run `./attack/attack.py`, again passing the arguments: chosen curve, hash algorithm and filename
   containing the signatures from the target. Observe the reconstructed private key.

##### Usage with simulated data

1. Run `./attack/simulate.py <curve> <hash> <count>` with optional parameters specifying the
   leakage properties of the simulated target (`base`, `iter-time` and `sdev`) as modelled in the paper.
2. Run `./attack/attack.py`, again passing the arguments: chosen curve, hash algorithm and filename containing the signatures from the target.
   Observe the reconstructed private key.

#### CPLC checker

The Minerva CPLC checker uses the Card Production Life Cycle (CPLC) data present on
cards under the GlobalPlatform standard to identify vulnerable cards based on a list of
known or suspected vulnerable devices.

To run this tool, install the Python requirements from the `requirements.txt` file,
then simply insert the tested card into your reader and run the `./check.py` script.

#### ECDH tester

The Minerva tester is a testing tool for JavaCards which uses ECDH to assess the presence
of timing leakage of bit-length in scalar-multiplication. Since it has to use ECDH to control
the scalar (the ECDSA API in JavaCard does not allow to choose the random nonce = the scalar) the presence
of leakage in ECDH cannot be used to prove the presence of leakage in ECDSA, as the two might
be implemented differently and have different side-channel protections. We have observed both
cards which leaked in ECDH but not in ECDSA and those that leaked in ECDH and ECDSA.

##### Contents

`applet/` contains code of a target applet. The applet creates an ECC keypair and sets the `secp256r1`
curve parameters. In the `PREPARE` command, the applet prepares a private key for ECDH, with bit-length
set in the command, the private key simply has the form `1 << (bit_length - 1)`. In the `KEX` command
the applet performs ECDH with the prepared private key. See `build.xml` for the ant build script.

`build/` is a directory created by the ant build which contains the CAP file with the
built JavaCard applet.

`reader/` contains code of the tester. It is written in Python 3 and uses the
`pyscard` library for communication.

`ext/` contains some third party content, such as the ant-javacard extension
(`ant-javacard.jar`) for the ant build system, which is used to build the
applet as well as a version of the JavaCard SDK 2.2.2 (`jckit_222`).

##### Usage

1. Build the applet via `ant build`.
2. Install the applet (`build/applet.cap`) on the card. For example
   using [GlobalPlatformPro](https://github.com/martinpaljak/GlobalPlatformPro), so
   doing `gp --install build/applet.cap`.
3. Install Python packages from `requirements.txt` (into a virtualenv).
4. Run `./reader/test.py`.
5. Observe ECDH being performed, with private keys of varying bit-length, after
   all of the measurements are done a plot will display, showing the dependency
   of ECDH duration on bit-length (if any), and the correlation of the two. This
   dependency cannot be directly connected to ECDSA, since a different algorithm
   might be used for scalar multiplication there (as we observed with one card), but
   can be taken as guidance that if ECDH leaks, ECDSA might as well (as is the case with
   another card).

#### Datasets

The datasets collected and used in the paper are available. They contain timing data collected from leaking implementations.
The files `data_*.csv` contain data in a CSV-like format (only the first line is not CSV):

```

<public key> <data> <private key>
<r1>,<s1>,<time1>
<r2>,<s2>,<time2>
...
<r>,<s>,<time>

```

Time is in nanoseconds. All of the datasets contain at least 50 000 signatures.

The `time_*.csv` files contain the processed data in a CSV format:

```

<time>,<lzb>

```

In it, each line represents a signature which has `lzb` leading-zero bits and took `time` nanoseconds.

### Technical details

Our attack is a lattice attack on the timing leakage of the bit-length of nonces used in ECDSA and other
similar signature algorithms, as presented in [[3]](#remote), with minor adaptations. The vulnerable devices and libraries trivially leak the bit-length of the
scalar used in scalar multiplication in ECDH, ECDSA and key generation (see the [next subsection](#details-leakage)).
The leakage is insignificant for ECDH and key generation as only the bit-length of the private key
is leaked, which represents a small amount of always the same information about the private key.

However, in the case of ECDSA or other signature schemes with random nonces, the bit-length of the random nonces is leaked. This is
much more significant as each signature then presents new usable information on the private key. The way this information
is used to recover the private key is via first converting the problem to an instance of the Hidden Number Problem, which we describe in [a section](#details-hnp) and
solving it via lattice reduction techniques.

#### Leakage

The following images were generated using our tool [ECTester](https://crocs-muni.github.io/ECTester/).

The images contain heatmaps demonstrating the dependency of signing duration and nonce bit-length, or in general, the dependency of
the duration of scalar multiplication on certain bits of the scalar. The example group of images shown first shows a well-behaving implementation
with no leakage.

For three out of five affected libraries (libgcrypt, MatrixSSL, SunEC) and
the affected smartcard (Athena IDProtect), the signing runtime directly depends on the bit-length
of the nonce linearly: each additional bit represents one more iteration of a loop in
scalar multiplication, which increases the runtime. The leakage can be clearly seen from
powertraces of the card performing ECDSA signing in Figure [a6](#athena-fig6).

For implementations leaking just the noisy bit-length (libgcrypt, SunEC, Athena IDProtect) the
leakage can be modeled using three parameters: duration of constant time processing in
signing (e.g., hashing) (\(base\)), duration of one iteration of the scalar multiplication loop
(\(iter\\_time\)) and the standard deviation of the noise (\(sdev\)). For the secp256r1 curve, the
leakage \(\mathbf{L}\) can be modelled as a random variable:

\[
\begin{aligned}
\mathbf{L} &= base + iter\\_time \cdot \mathbf{B} + \mathbf{N} \\
\mathbf{B} &\sim \textbf{Geom}(p=1/2, (256, 255, \ldots, 0)) \\
\mathbf{N} &\sim \textbf{Norm}(0, sdev^2)
\end{aligned}
\]

where \(\mathbf{B}\) represents the bit-length with a truncated geometric distribution and \(\mathbf{N}\) the noise.
Only two of the above parameters, \(iter\\_time\) and \(sdev\), affect how much the implementation leaks;
we will use them to assess how easy it is to mount an attack.

##### Example (no leakage)

Data collected from 500k signatures on secp256r1.

These images come from OpenSSL, contain no leakage and show how a well-behaving implementation
looks like in these types of heatmaps.

[![Heatmap of nonce MSB and signature time.](assets/img/example/example_msb.png)](assets/img/example/example_msb.png)
[Figure e1:](#example-fig1 "Permanent link") Heatmap of nonce MSB and signature time.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/example/example_hw.png)](assets/img/example/example_hw.png)
[Figure e2:](#example-fig2 "Permanent link") Heatmap of nonce Hamming weight and signature time.
[![Heatmap of nonce bit-length and signature time.](assets/img/example/example_bitlength.png)](assets/img/example/example_bitlength.png)
[Figure e3:](#example-fig3 "Permanent link") Heatmap of nonce bit-length and signature time.

##### Athena IDProtect

Figures below are from data collected from 500k signatures on secp256r1.

[![Plot of private key bit-length and scalar multiplication time.](assets/img/athena/linear_time.png)](assets/img/athena/linear_time.png)
[Figure a1:](#athena-fig1 "Permanent link") Clear linear dependency of the length of scalar multiplication on private key bit-length.
[![Heatmap of nonce MSB and signature time.](assets/img/athena/msb_hist.png)](assets/img/athena/msb_hist.png)
[Figure a2:](#athena-fig2 "Permanent link") Time dependency on bit-length visible in nonce MSB heatmap.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/athena/hw_hist.png)](assets/img/athena/hw_hist.png)
[Figure a3:](#athena-fig3 "Permanent link") Time dependency on bit-length somewhat visible in nonce Hamming weight heatmap.
[![Heatmap of nonce bit-length and signature time.](assets/img/athena/bit_length_hist.png)](assets/img/athena/bit_length_hist.png)
[Figure a4:](#athena-fig4 "Permanent link") Clear time dependency on nonce bit-length, disturbed by the geometric distribution of bit-length.
[![Histograms of nonce bit-length and signature time.](assets/img/athena/length_hists.png)](assets/img/athena/length_hists.png)
[Figure a5:](#athena-fig5 "Permanent link") Time dependency clearly visible in grouping of signatures by bit-length.
[![Powertrace of an ECDSA signing operation.](assets/img/athena/athena_powertrace_leak.png)](assets/img/athena/athena_powertrace_leak.png)
[Figure a6:](#athena-fig6 "Permanent link") Clear dynamic bound on the number of loops in scalar multiplication is visible in a powertrace of an ECDSA signing operation.

##### libgcrypt

Figures below are from data collected from 200k signatures on secp256r1 using libgcrypt 1.8.4.

[![Heatmap of nonce MSB and signature time.](assets/img/gcrypt/msb_hist.png)](assets/img/gcrypt/msb_hist.png)
[Figure g1:](#gcrypt-fig1 "Permanent link") Time dependency on bit-length visible in nonce MSB heatmap.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/gcrypt/hw_hist.png)](assets/img/gcrypt/hw_hist.png)
[Figure g2:](#gcrypt-fig2 "Permanent link") Time dependency on bit-length somewhat visible in nonce Hamming weight heatmap.
[![Heatmap of nonce bit-length and signature time.](assets/img/gcrypt/bit_length_hist.png)](assets/img/gcrypt/bit_length_hist.png)
[Figure g3:](#gcrypt-fig3 "Permanent link") Clear time dependency on nonce bit-length, disturbed by the geometric distribution of bit-length.

##### wolfSSL

The leakage in wolfCrypt was very small, and potentially not exploitable. Figures
below are from data collected from 500k signatures on secp256r1 using wolfSSL 4.0.0.

[![Heatmap of nonce MSB and signature time.](assets/img/wolfcrypt/msb_hist.png)](assets/img/wolfcrypt/msb_hist.png)
[Figure w1:](#wolfcrypt-fig1 "Permanent link") Time dependency on bit-length visible in nonce MSB heatmap.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/wolfcrypt/hw_hist.png)](assets/img/wolfcrypt/hw_hist.png)
[Figure w2:](#wolfcrypt-fig2 "Permanent link") Time dependency on bit-length not visible, because it is very small.
[![Heatmap of nonce bit-length and signature time.](assets/img/wolfcrypt/bit_length_hist.png)](assets/img/wolfcrypt/bit_length_hist.png)
[Figure w3:](#wolfcrypt-fig3 "Permanent link") Time dependency on bit-length not visible, because it is very small.

##### MatrixSSL

Figures below are from data collected from 120k signatures on secp256r1 using MatrixSSL 4.2.1.

[![Heatmap of nonce MSB and signature time.](assets/img/matrixssl/msb_hist.png)](assets/img/matrixssl/msb_hist.png)
[Figure m1:](#matrixssl-fig1 "Permanent link") Time dependency on bit-length visible in nonce MSB heatmap.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/matrixssl/hw_hist.png)](assets/img/matrixssl/hw_hist.png)
[Figure m2:](#matrixssl-fig2 "Permanent link") Time dependency on bit-length somewhat visible in nonce Hamming weight heatmap. Time dependency on Hamming weight is also visible.
[![Heatmap of nonce bit-length and signature time.](assets/img/matrixssl/bit_length_hist.png)](assets/img/matrixssl/bit_length_hist.png)
[Figure m3:](#matrixssl-fig3 "Permanent link") Clear time dependency on nonce bit-length, disturbed by the geometric distribution of bit-length.

##### SunEC

Figures below are from data collected from 500k signatures on sect233r1 using JDK 8 SunEC provider.

[![Heatmap of nonce MSB and signature time.](assets/img/sunec/msb_hist.png)](assets/img/sunec/msb_hist.png)
[Figure s1:](#sunec-fig1 "Permanent link") Time dependency on bit-length visible in nonce MSB heatmap.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/sunec/hw_hist.png)](assets/img/sunec/hw_hist.png)
[Figure s2:](#sunec-fig2 "Permanent link") Time dependency on bit-length somewhat visible in nonce Hamming weight heatmap.
[![Heatmap of nonce bit-length and signature time.](assets/img/sunec/bit_length_hist.png)](assets/img/sunec/bit_length_hist.png)
[Figure s3:](#sunec-fig3 "Permanent link") Clear time dependency on nonce bit-length, disturbed by the geometric distribution of bit-length.

##### Crypto++

Figures below are from data collected from 100k signatures on sect233r1 using Crypto++ 8.2.0.

[![Heatmap of nonce MSB and signature time.](assets/img/cryptopp/msb_hist.png)](assets/img/cryptopp/msb_hist.png)
[Figure c1:](#cryptopp-fig1 "Permanent link") Time dependency on bit-length visible in nonce MSB heatmap.
[![Heatmap of nonce Hamming weight and signature time.](assets/img/cryptopp/hw_hist.png)](assets/img/cryptopp/hw_hist.png)
[Figure c2:](#cryptopp-fig2 "Permanent link") Time dependency on bit-length somewhat visible in nonce Hamming weight heatmap.
[![Heatmap of nonce bit-length and signature time.](assets/img/cryptopp/bit_length_hist.png)](assets/img/cryptopp/bit_length_hist.png)
[Figure c3:](#cryptopp-fig3 "Permanent link") Clear time dependency on nonce bit-length, disturbed by the geometric distribution of bit-length.

#### Hidden Number Problem

[Boneh & Venkatesan [1]](#hardness) introduced the *Hidden Number Problem* (HNP),
for proving the hardness of computing the most significant bits of keys in the Diffie-Hellman
scheme. They also showed a way to solve it by transforming it into a lattice *Closest Vector Problem* (CVP) solvable via lattice reduction and Babai's nearest plane algorithm. This is useful to us, because in the cases
of DSA/ECDSA/EdDSA and even attestation systems such as
EPID [[8]](#cachequote) or ECDAA [[9]](#fido-ecdaa), knowledge of the most significant bits of nonces with the goal of computing the private key can be turned into a Hidden Number Problem
instance, which can be turned into an instance of the Closest Vector Problem and solved using the methods of
lattice reduction. Next we will introduce the HNP and show how knowledge of most significant bits of nonces can be
turned into one for ECDSA.

**Notation:** In the following text:

* \( \lfloor x \rfloor\_n \) denotes the reduction to \( x \gmod{n} \).
* \( \lvert x \rvert\_n = \min\_{aÂ \in \mathbb{Z}} \lvert x - an \rvert\) denotes the distance to the nearest integer multiple of \( n \).
* \( pÂ \) denotes a prime number, \( g \) is a generator of \( \mathbb{Z}\_n \).
* \( G \) denotes a point of order \( n \) on an elliptic curve, usually the generator.
* \( d \) denotes the private key, and \( eÂ \)the amount of signatures.
* \( H(m) \) denotes the leftmost \( \log\_2(n)Â \) bits of the hash of the message \( m \), interpreted as an integer \( \gmod{n} \).
* \( k \) denotes the nonce used in signing.

**Definition 1 (Approximations):** By \(\mathrm{APP}\_{l,n}(y)\), we will denote any \(u\in\mathbb{Q}\) satisfying
\[\lvert y - u\rvert\_n \leq n/2^{l}.\]
Note that generally there are many such \(u\).

**Definition 2 (Most Significant Modular Bits):** The \(l>0\) most significant modular bits of an element \(y\in\mathbb{Z}\_n\) (regarded as an integer in \([0, n-1]\)) are the unique integer \(\mathrm{MSMB}\_{l,n}(y)\) such that
\[0 \leq y - \mathrm{MSMB}\_{l,n}(y)\cdot n/2^l < n/2^l.\]

It is worth observing that the most significant modular bits give rise to a specific approximation of \(y\). We can see directly from [definition 2](#def-msmb) that

\[\lvert y - \mathrm{MSMB}\_{l,n}(y)\cdot n/2^l \rvert < n/2^{l},\]
and since the absolute value argument already lies in \([-n/2, n/2]\), it is equivalent to
\[\lvert y - \mathrm{MSMB}\_{l,n}(y)\cdot n/2^l \rvert\_n < n/2^{l}.\]
Thus \(\mathrm{MSMB}\_{l,n}(y)\cdot n/2^l\) may be taken as \(\mathrm{APP}\_{l,n}(y)\). Also, after recentering the bits, \(\mathrm{MSMB}\_{l,n}(y) \cdot n/2^l - n/2^{l + 1}\) may be taken as \(\mathrm{APP}\_{l+1,n}(y)\).
**Definition 3 (Hidden Number Problem):** Given \( e \) approximations \(a\_i = \mathrm{APP}\_{l\_i,n}(k\_i)\), where \(k\_i = \lfloor \alpha t\_i - u\_i \rfloor\_n\),
for many known \(t\_i\) that are uniformly and independently distributed in \(\mathbb{Z}\_n^\*\), known \(u\_i\) and a fixed secret \(\alpha\in \mathbb{Z}\_n\), find \(\alpha\).

This general problem can be equivalently stated as, given \( e \) inequalities as below, with known \( a\_i \) and \( l\_i \) and with unknown \( \alpha \), find it:
\[
\lvert k\_i - a\_i\rvert\_n < n/2^{l\_i}
\]
##### ECDSA

In case of ECDSA, given the signature \( (r, s) \in \mathbb{Z}\_n \times \mathbb{Z}\_n \) on message
\( m \):
\[
\begin{aligned}
r &= ([k]G)\_x \pmod{n} \\
s &= k^{-1} (H(m) + r d) \pmod{n}
\end{aligned}
\]
Rewriting we have:
\[
\begin{aligned}
k &= s^{-1} (H(m) + r d) \pmod{n} \\
k &= s^{-1} H(m) + s^{-1} r d \pmod{n}
\end{aligned}
\]
Information about the most significant bits of \( k \), the nonce, can be used to construct an instance of the HNP.
**Definition 4 (ECDSA Hidden Number Problem):** Given \( e \) approximations \(a\_i = \mathrm{APP}\_{l\_i,n}(k\_i)\) of the nonces \( k\_i \) of known messages \( m\_i \),
find \( d \) (private key).

This gives us \( e \) inequalitites of the form:
\[
\begin{aligned}
\lfloor k\_i - a\_i \rfloor\_n &< n/2^{l\_i} \\
%\lvert \lfloor k\_i \rfloor\_n - n/2^{l\_i + 1} - a\_i \rvert &< n/2^{l\_i + 1} \\
%\lvert \lfloor k\_i \rfloor\_n - n/2^{l\_i + 1} - a\_i \rvert\_n &< n/2^{l\_i + 1}
\lvert s\_i^{-1} \left(d r\_i + H(m\_i)\right) - a\_i \rvert\_n &< n/2^{l\_i}\\
\lvert d\lfloor s\_i^{-1}r\_i \rfloor\_n + \lfloor s\_i^{-1} H(m\_i)\rfloor\_n - a\_i\rvert\_n &< n/2^{l\_i}
\end{aligned}
\]
The above gives the HNP inequality with \(t\_i = s\_i^{-1} r\_i\) and \(u\_i = - s\_i^{-1} H(m\_i)\) as per [definition 3](#def-hnp). However, in this
case \(t\) is not completely uniform in \( \mathbb{Z}\_n^{\star} \), its distribution is just close enough that we do not have
to care about it [[2]](#insecurity). In our case of bit-length leakage, we will only ever create HNP inequalities with \( a\_i = MSMB\_{l\_i,n}(k\_i) = 0 \),
which simplifies the above equation to:
\[
\lvert t\_i d - u\_i \rvert\_n \lt n/2^{l\_i}
\]
##### Solving

Given \( e \) HNP inequalities of the form \( \lvert t\_i d - u\_i \rvert\_n \lt n/2^{l\_i} \), we can construct a lattice given by the rows of the matrix \( \mathbf{M} \)
[[7]](#rohnp):
\[
\mathbf{M} = \begin{pmatrix}
2^{l\_1 + 1}n & 0 & 0 & \ldots & 0 & 0 \\
0 & 2^{l\_2 +1}n & 0 & \ldots & 0 & 0 \\
& \vdots & & & \vdots & \\
0 & 0 & 0 & \ldots & 2^{l\_e +1}n & 0 \\
2^{l\_1 + 1}t\_1 & 2^{l\_2 +1}t\_2 & 2^{l\_3 +1}t\_3 & \ldots & 2^{l\_e +1}t\_e & 1
\end{pmatrix}
\]
Where \( l\_i \) is the amount of known most significant bits of \( k\_i \) from the i-th signature.
Then, by our construction from the HNP inequalities above, the vector \(\mathbf{u} = ( 2^{l\_1 + 1}u\_1, \ldots, 2^{l\_e + 1}u\_e, 0) \) is a vector unusually close to a
lattice point. The closest lattice point often has a form \( \mathbf{v} = ( 2^{l\_1 + 1} t\_1 d, \ldots, 2^{l\_e + 1} t\_e d, d )
\), finding this lattice point then reveals the private key \( d \). To do so, one needs to solve the Closest Vector Problem.
There are several algorithms for solving the CVP, the original paper used Babai's nearest plane algorithm with LLL for lattice reduction.
One could also use BKZ for lattice reduction and then solve CVP by enumeration. There is also a technique of transforming an instance of CVP to a Shortest Vector Problem (SVP) by embedding the matrix and the target vector:
\[
C = \begin{pmatrix}
\mathbf{M} & 0 \\
\mathbf{u} & n
\end{pmatrix}
\]

Then, one can solve SVP by lattice reduction and either looking directly at basis vectors or by further enumeration to find the shortest vector.
Our construction contained a number of heuristic arguments, such as "often has a form", or "is unusually close to a lattice point", this shows that
the technique is not exact. We also never stated how many HNP inequalities with what \(l\_i\) need to be included in the lattice to find the correct private key.

Generally, each inequality adds \( l\_i \) bits of information and the problem starts to be solvable (theoretically) as soon as the lattice contains more information
than the unknown information in the private key. The number of leading zero bits, which is equal to the used information in a signature in our attack, follows a truncated geometric
distribution with \(p = \frac{1}{2}\). Due to this, the expected amount of information in \(N\) signatures can be computed as
\(N \cdot \sum\_{i=2}^{\lceil \log\_2(n) \rceil} 2^{-l\_i-1} \cdot l\_i \approx \frac{3}{4}N\) assuming only signatures with \( l\_i \geq 2 \) are used.
Adding inequalities with \(l\_i < 2\) generally does not help, as those will not lead to the desired vector being unusually close to a lattice point.

Using the above formula, we obtain the expected minimum of around \(N = 342\) signatures for a 256-bit private key.
Since the amount of information is linear in \(N\) it can be computed as \(N \approx \frac{4}{3} \cdot |K|\) for size \(|K|\) of the private key.
Adding dimensions is also not for free, as the runtime of lattice algorithms grows significantly with an increase in the number of dimensions.
However, adding some overhead of information, such that the lattice contains around \( 1.3 \) times the information of the private key, was shown to improve the success rate [[7]](#rohnp).

#### Attack improvements

The nonces \(k\_i\) are generated uniformly at random; we can thus expect that the number of most significant zero bits follows
a truncated geometric distribution when \(n\) is close to a power of two. Thus roughly for one-half of the nonces \(l\_i=0\),
for one-quarter of nonces \(l\_i=1\), and so on. Assuming a one-to-one linear dependency between the bit-length of \(k\_i\) and
the duration of signing, we would obtain a clear method of assigning bounds to the signatures, sort them by duration and
apply the above distribution. However, the real timing leakage is noisy and the distributions of duration for signatures
with different bit-lengths overlap (see Figures [a4](#athena-fig4),[g3](#gcrypt-fig3),[m3](#matrixssl-fig3) and [s3](#sunec-fig3)).

Our main improvement to the attack calculates bounds according to the above truncated geometric distribution based on \(N\),
the number of signatures collected. One half of signatures has \(l\_i=0\), one quarter has \(l\_i=1\), etc.
Then simply the fastest \(e\) signatures are taken with their calculated bounds.

[![Residuals](assets/img/geomN_residuals.png)](assets/img/geomN_residuals.png)
[Figure x1:](#geom-residuals-fig "Permanent link")
Plot of the geometric bounds (**geom**) with \(N = 2000\) and \(e = 100\), along with a
random sample of the true leading zero bits from simulated data (**sim**) and
boxplots of the distribution of the difference of the simulated data and the
bounds (**sim - geom**). Negative values imply an error; positive implies some
available information is unused.
##### Evaluation

We evaluated our improvements using four separate data sets (denoted as sim, sw, card,
tpm) with varying levels of noise. All the datasets used consist of at least 50 000 ECDSA
signatures over the secp256r1 curve from which we randomly sample \(N\) signatures for the
evaluation of our attacks.

| Dataset | \(base (\mu s)\) | \(iter\\_time (\mu s)\) | \(sdev (\mu s)\) |
| --- | --- | --- | --- |
| sim | 0 | 1 | 0 |
| sw | 453.4 | 12.7 | 17.2 |
| tpm | 27047.3 | 236.1 | 211.3 |
| card | 43578.4 | 371.5 | 451.3 |

* The sim dataset contains simulated data for which there is an exact one-to-one
  correspondence between the signing duration and the bit-length of the random nonce
  with no systematic noise. However, these simulated signatures were still generated
  by uniformly randomly selecting the random nonce and computing the number of
  most-signifcant zero bits. A given sample is thus a result of a random process and
  varies naturally.
* The sw dataset contains data from a vulnerable version of the software cryptographic
  library libgcrypt collected from a simple C program on an ordinary Linux laptop.
* The tpm dataset contains data from the recent work of Moghimi et al. [[14]](#tpm-fail)
  collected from a vulnerable STMicroelectronics TPM (Trusted Platform Module).
  The data was collected via a custom Linux kernel module and contained a relatively
  small amount of noise.
* The card dataset contains data from the vulnerable Athena IDProtect smartcard,
  collected by a Python script running on an ordinary Linux laptop with a standard
  standalone smartcard reader connected. Such measurements are particularly noisy
  due to the complex software stack and hardware components between the script and
  a card.

##### Heatmaps of success rate

[![Heatmap of success rate (out of 5 tries) for constant bounds with c = 3](assets/img/const3.png)](assets/img/const3.png)
[Figure x2:](#heatmap-const-fig "Permanent link") Heatmap of success rate (out of 5 tries) for constant bounds with \(\forall i: l\_i = 3\).
[![Heatmap of success rate (out of 5 tries) for our geometric bounds.](assets/img/geomN.png)](assets/img/geomN.png)
[Figure x3:](#heatmap-geom-fig "Permanent link") Heatmap of success rate (out of 5 tries) for our geometric bounds.

#### Root causes of the vulnerability

We consider there to be several root causes for this group of vulnerabilities. One of them is that knowledge of the
fragility of DSA nonces to lattice attacks does not seem to be widespread amongst developers of
cryptographic software. There are four issues regarding nonce use in DSA:
nonce reuse, bias in nonce randomness, nonce bit-length leaks and other leaks of partial information about nonces. Due
to the aforementioned lattice attacks and their variants, all of these issues might lead to a private key recovery attack.

Deterministic generation of nonces, as done in EdDSA or RFC6979 mitigates
the issues of nonce reuse and nonce bias. However, it does not address the latter two in any significant way.
Deterministic generation of nonces might actually help the attacker in case the attacker has a noisy side-channel
leaking nonce bit-length or other information about the nonce. If the attacker can observe the signing of the same
message multiple times, they might use the fact that the same nonce was used to significantly reduce the noise in the side-channel.

Another cause for this group of vulnerabilities is that not leaking the bit-length of the scalar used in scalar
multiplication is surprisingly hard. Take almost any algorithm that processes the scalar in a left to right fashion, the
Montgomery ladder for example, and instantiate it with addition formulas that are incomplete (cannot correctly compute
\( \mathcal{O} + P \) or \( 2\mathcal{O} \) in a side-channel indistinguishable way from \( P + Q \) and \( 2P \)), then
a side-channel leaking the bit-length will be present.

At the start of the ladder for computing a multiple of point
\( G\), the two ladder variables are initialized either as \( R\_0 = \mathcal{O} \) and \( R\_1 = G \) or as
\( R\_0 = G \) and \( R\_1 = 2G \). In the first case, the computation might start at any bit larger that the most
significant set bit in the scalar, i.e. it can be a fixed loop bound, for example on the bit-length of the order of the
generator, as seen in [algorithm 1](#montgomery-complete). However, until the first set bit is encountered,
all of the additions and doublings will involve the point at
infinity and because of our assumption that the formulas used are incomplete, they will leak this through some side-channel.
This leak might have the form of short-circuiting addition formulas, which check whether the point at infinity was input and short circuit accordingly to satisfy
\( \mathcal{O} + P = P \) and \( 2\mathcal{O} = \mathcal{O} \). This is the case in libgcrypt
for example, and was the reason why simply fixing a loop bound in scalar multiplication was not enough to fix the issue.
The formulas might leak the fact that the point at infinity is present through different channels than timing: power or
EM side-channels come to mind, as the point at infinity is often represented using only \( 0 \) or \( 1 \) values, which
can often be distinguishable in multiplication and addition on a power trace.

```

                \begin{algorithm}
                \caption{Montgomery ladder (complete)}
                \begin{algorithmic}
                \PROCEDURE{Ladder}{$G, k = (k_{l}, \ldots, k_0)_2$}
                    \STATE $R_0 = \mathcal{O}$; $R_1 = G$
                    \FOR{$i = l$ \DOWNTO 0}
                        \STATE $R_{\neg k_i} = R_0 + R_1$; $R_{k_i} = 2R_{k_i}$
                    \ENDFOR
                    \RETURN $R_0$
                \ENDPROCEDURE
                \end{algorithmic}
                \end{algorithm}

```

In the second case, the most significant bit of the scalar must be explicitly found, as seen in
[algorithm 2](#montgomery-incomplete) and the ladder must start at that bit, because the variables were
initialized into a state such that the point at infinity will not appear so that incomplete formulas could be used and no
infinity ever handled. If the loop started at some fixed bit past the most significant bit set, this algorithm would compute an incorrect result.
However, this clearly leaks the bit-length through timing alone, because of the loop bound on the bit-length of the
scalar.

```

                \begin{algorithm}
                \caption{Montgomery ladder (incomplete)}
                \begin{algorithmic}
                \PROCEDURE{Ladder}{$G, k = (k_{l}, \ldots, k_0)_2$}
                    \STATE $R_0 = G$; $R_1 = 2G$
                    \FOR{$i = \vert k \vert - 1$ \DOWNTO 0}
                        \STATE $R_{\neg k_i} = R_0 + R_1$; $R_{k_i} = 2R_{k_i}$
                    \ENDFOR
                    \RETURN $R_0$
                \ENDPROCEDURE
                \end{algorithmic}
                \end{algorithm}

```

Furthermore, in the name of performance, cryptographic libraries often include multiple optimized scalar
multiplication algorithms that are either chosen at compile time or even at runtime, for specific classes
of curves, or for use by a specific cryptosystem. This increases the effort necessary to test and verify that all of
the possible configurations are constant time and not vulnerable. As mentioned before, there are interactions
between the individual components such as addition formulas, coordinate systems and the scalar multiplication algorithm,
a change in one of those can make an implementation vulnerable, like using incomplete formulas that short circuit
the special cases. The configurations in libraries are often behind many define guards that enable parts of
functions, such that even figuring out which scalar multiplication function using which coordinate model and
addition formulas gets executed by a library for a particular operation on a particular curve is non-trivial.

Taking the example of the ECC implementation in SunEC/OpenJDK, in the
latest version, it contains both a Java implementation of ECC and a native one. The Java one is chosen if one of the
secp256r1, secp384r1, secp521r1 curves is
detected. The native implementation contains arithmetic for affine, Jacobian and Modified Jacobian coordinates. It
contains 4 scalar multiplication algorithms for prime field curves and three wrapper functions which dispatch to
appropriate functions. For some reason, the simple
scalar multiplication in ECDSA is performed through a call to a multi-scalar multiplication
wrapper, which dispatches it to a multi-scalar multiplication function which short circuits to a single-scalar
multiplication wrapper, because some of the arguments are null, this wrapper then finally dispatches to the appropriate
scalar multiplication function.

The cause of the vulnerability in cards using the Atmel Toolbox 00.03.11.05 is obvious, the toolbox
included functionality explicitly marked as not protected against SPA/DPA and timing attacks, which the vulnerable cards decided to use.

### Responsible disclosure

##### Athena IDProtect

We have discovered the vulnerability on 18.03.2019 in the Athena IDProtect card. To confirm its
exploitablity we have investigated it in more
detail in the following days and constructed a proof-of-concept which can be downloaded [above](#poc).
Following this, we have contacted the responsible party: NXP Semiconductors,
on 15.04.2019 at `ENABLE@JAVASCRIPT`. We
chose to contact NXP because the Athena Smart Card Solutions company, which produced the Athena
IDProtect cards, no longer exists, as it was bought by NXP in 2015 [[11]](#athena).

NXP Semiconductors confirmed the existence of the vulnerability on 19.04.2019 and stated that they
had migrated the former Athena IDProtect product line to
their hardware shortly after the acquisition, which effectively mitigated the vulnerability in newer products
based on the IDProtect line, long before our discovery, as it was present in the underlying cryptographic
library which was replaced along with the hardware. Furthermore, NXP discontinued the former Athena IDProtect line of
products a few years after the acquisition.

NXP Semiconductors was able to confirm that the Athena IDProtect card on the AT90SC chip indeed did use
the fast and insecure version of the ECDSA functionality from the Atmel Toolbox. Quoting the reply from
NXP Semiconductors:

> The vulnerability you found is in the Atmel crypto library that implements the ECC cryptography on the affected product.
> The Athena SCS product affected here is a legacy product which is no longer promoted by NXP.

##### WiseKey

After communicating with NXP Semiconductors, we contacted WiseKey, the current holder of the intellectual property of
the AT90 chip, cryptographic toolbox and associated items, and notified them of the vulnerability in the past versions of the Atmel toolbox.
We then explained details of the vulnerability during a call with the WiseKey cryptography team. We have no information on
whether current versions of the chip and toolbox are vulnerable.

##### Libgcrypt

After discovering the vulnerability on a smart-card, we analyzed many open-source cryptographic
libraries, we discovered the vulnerability in libgcrypt
on 09.07.2019, and notified the libgcrypt security team at `ENABLE@JAVASCRIPT`
on 12.07.2019. We coordinated on mitigating the issue and arrived at a final working patch on 18.07.2019, which was
merged on 07.08.2019.

##### wolfSSL

We discovered the leakage in wolfSSL on 09.07.2019 and notified wolfSSL at `ENABLE@JAVASCRIPT` on 11.07.2019. We received a patch
for testing on 12.07.2019, which fixed the issue. The fix for the issue was merged to the master branch on 17.07.2019.

##### MatrixSSL

We discovered the vulnerability in MatrixSSL on 11.07.2019, we notified MatrixSSL support at
`ENABLE@JAVASCRIPT` on 11.07.2019 and
at `ENABLE@JAVASCRIPT` (which looked like the maintainer's address from github commits) on
12.07.2019. We have not heard back from any of the addresses. MatrixSSL had a release in the meantime, which fixed some issues
but this vulnerability remains unpatched as of 02.10.2019.

##### Crypto++

We discovered the leakage in Crypto++ on 22.07.2019 and notified the Crypto++ team
on 25.07.2019. The main parts of the fix for the issue were merged to the master branch on 29.07.2019 and 05.08.2019.

##### SunEC

We discovered the leakage in SunEC on 22.07.2019 and notified Oracle at `ENABLE@JAVASCRIPT` on 26.07.2019. We provided Oracle with a patch
mitigating the issue on 14.08.2019. Furthermore, we notified the OpenJDK vulnerability group on 15.09.2019 at `ENABLE@JAVASCRIPT`. The vulnerability remains unpatched in the
public [jdk](https://hg.openjdk.java.net/jdk/jdk) repository as of 02.10.2019.

### Team

The vulnerability was discovered by a team at the [Centre for Research on Cryptography and
Security](https://crocs.fi.muni.cz) at Masaryk University in Czech Republic, using the self-developed and open-source [ECTester](https://crocs-muni.github.io/ECTester/) toolkit:

* [Jan Jancar](https://neuromancer.sk/about): ENABLE@JAVASCRIPT  [j08ny](https://twitter.com/j08ny)
* [Petr Svenda](https://crocs.fi.muni.cz/people/svenda): ENABLE@JAVASCRIPT  [rngsec](https://twitter.com/rngsec)
* [Vladimir Sedlacek](https://www.muni.cz/en/people/408178-vladimir-sedlacek): ENABLE@JAVASCRIPT  [vlada\_sedlacek](https://twitter.com/vlada_sedlacek)

### Timeline & Updates

* **18.03.2019** - Vulnerability discovered.
* **15.04.2019** - Vulnerability reported to NXP.
* **11.07.2019** - Vulnerability reported to wolfSSL and MatrixSSL.
* **12.07.2019** - Vulnerability reported to libgcrypt.
* **25.07.2019** - Vulnerability reported to Crypto++.
* **26.07.2019** - Vulnerability reported to Oracle.
* **13.09.2019** - We published a SHA256 [hash](https://twitter.com/CRoCS_MUNI/status/1172499426931302402) of an earlier version of this page to twitter.
* **02.10.2019** -  Release This website was published and the vulnerability disclosed on [our twitter](https://twitter.com/CRoCS_MUNI/status/1179392832299253761).
* **03.10.2019** - Fixed an issue in the PoC which required the `g6k` package, which is not available for Python 3.
* **03.10.2019** - Added a list of implementations we checked and deem secure.
* **04.10.2019** - Fixed the status of EdDSA in libgcrypt.
* **15.10.2019** - Oracle released a [Critical Patch Update](https://www.oracle.com/technetwork/security-advisory/cpuoct2019-5072832.html) which claims to fix the issue in SunEC,
  it does not, it disables the used of binary field curves by default in the Java TLS/SSL server. However,
  users of the SunEC library through the default Java Cryptography Provider remain vulnerable
  as well as users that setup their TLS/SSL server to allow and use binary field curves.
* **02.12.2019** - Removed EdDSA mentions from the page and added a disclaimer about its exploitability.
* **15.06.2020** - Added a pre-print version of the paper. Updated the page to better align with the more polished content in the paper.
* **27.08.2020** - Added the TCHES 2020 version of the paper. Added additional implementations deemed secure.
* **16.09.2020** - Added the BibTeX data and a note about the Best Paper Award.
* **14.12.2024** - Added CVEs for vulnerability in python-ecdsa and GnuTLS found by Alicja Kario and George Pantelakis.

### Media

* **ZDNet**: [Minerva attack can recover private keys from smart cards, cryptographic libraries](https://www.zdnet.com/article/minerva-attack-can-recover-private-keys-from-smart-cards-cryptographic-libraries/)
* **Golem.de**: [Minerva-Angriff zielt auf zertifizierte Krypto-Chips](https://www.golem.de/news/elliptische-kurven-minerva-angriff-zielt-auf-zertifizierte-krypto-chips-1910-144256.html)
* **Daniel J. Bernstein**: [Why EdDSA held up better than ECDSA against Minerva](https://blog.cr.yp.to/20191024-eddsa.html)
* **Feisty Duck**: [Elliptic curve implementations vulnerable to Minerva timing attack](https://www.feistyduck.com/bulletproof-tls-newsletter/issue_58_elliptic_curve_implementations_vulnerable_to_minerva_timing_attack)
* **Trail of Bits**: [ECDSA: Handle with Care](https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/)

### Acknowledgements

Computational resources were supplied by the project "e-Infrastruktura CZ" (e-INFRA LM2018140) [[13]](#metacentrum) provided within the program Projects of Large Research, Development and Innovations Infrastructures. This access was greatly appreciated.
Vladimir Sedlacek was supported by the Brno Ph.D. Talent Scholarship (funded by the Brno City Municipality).

---

### References

1. Dan Boneh, Ramarathnam Venkatesan: Hardness of computing the most
   significant bits of secret keys in Diffie-Hellman and related schemes (1996) [[pdf]](https://crypto.stanford.edu/~dabo/abstracts/dhmsb.html)
2. Phong Q. Nguyen, Igor E. Shparlinski: The Insecurity of the Digital
   Signature Algorithm with Partially Known Nonces (2002) [[DOI]](https://doi.org/10.1007/s00145-002-0021-3)
3. Billy B. Brumley, Nicola Tuveri: Remote Timing Attacks are Still
   Practical (2011) [[ePrint]](https://eprint.iacr.org/2011/232)
4. Phong Q. Nguyen: The Dark Side of the Hidden Number Problem: Lattice Attacks
   on DSA (2001) [[DOI]](https://doi.org/10.1007/978-3-0348-8295-8_23)
5. Naomi Benger, Joop van de Pol, Nigel P. Smart, Yuval Yarom:
   "Ooh Aah... Just a Little Bit" : A small amount of side channel can go a long way (2014)
   [[ePrint]](https://eprint.iacr.org/2014/161)
6. Joop van de Pol, Nigel P. Smart, Yuval Yarom: Just a Little Bit More
   (2015) [[ePrint]](https://eprint.iacr.org/2014/434)
7. Keegan Ryan: Return of the Hidden Number Problem: A widespread and novel key
   extraction attack on ECDSA and DSA (2018) [[DOI]](https://doi.org/10.13154/tches.v2019.i1.146-168)
8. Fergus Dall, Gabrielle De Micheli, Thomas Eisenbarth, Daniel Genkin,
   Nadia Heninger, Ahmad Moghimi, Yuval Yarom: CacheQuote: Efficiently Recovering Long-term Secrets of SGX EPID via Cache Attacks (2018)
   [[DOI]](https://doi.org/10.13154/tches.v2018.i2.171-191)
9. FIDO Alliance: FIDO ECDAA Algorithm (2018)
   [[spec]](https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-ecdaa-algorithm-v2.0-id-20180227.html)
10. The FPLLL development team: fplll, a lattice reduction library (2016) [[github]](https://github.com/fplll/fplll)
11. NXP Semiconductors: NXP Acquires Athena SCS (2015) [[release]](https://media.nxp.com/news-releases/news-release-details/nxp-acquires-athena-scs/)
12. NIST: FIPS PUB 140-2: SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC
    MODULES (2001) [[pdf]](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf)
13. Metacentrum NGI [[web]](https://www.metacentrum.cz/en/)
14. Daniel Moghimi, Berk Sunar, Thomas Eisenbarth, Nadia Heninger: TPM-Fail: TPM meets Timing and Lattice Attacks (2019) [[web]](https://tpm.fail)

---

Last update on 16.09.2020 | 2019-2020 Â© [CRoCS](https://crocs.fi.muni.cz) | [Logo](assets/img/logo.svg) is [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/), font is [OFL](https://scripts.sil.org/OFL)
licensed.


