```
{
  "cve": "CVE-2019-15543",
  "description": "Affected versions of this crate entered a corrupted state if mem::size_of::() % allocation_granularity() != 0 and a specific allocation pattern was used: sufficiently shifting the deque elements over the mirrored page boundary.\n\nThis allows an attacker that controls controls both element insertion and removal to corrupt the deque, such that reading elements from it would read bytes corresponding to other elements in the deque. (e.g. a read of T could read some bytes from one value and some bytes from an adjacent one, resulting in a T whose value representation is not meaningful). This is undefined behavior.",
  "affected_versions": "< 0.2.0",
  "patched_versions": "0.2.0",
  "root_cause": "The vulnerability is caused by a flaw in how the `slice-deque` crate tracked the head and tail of the deque using indices, which could lead to a corrupted state under specific conditions.",
  "vulnerabilities": [
    "Out-of-bounds write due to incorrect index calculation when shifting deque elements over a mirrored page boundary. This can lead to memory corruption, where reads from the deque return data from other elements or arbitrary memory locations."
   ],
  "impact": "Memory corruption leads to undefined behavior, where reads from the deque could produce meaningless values by combining data from adjacent elements. In the worst case, this could potentially lead to remote code execution (RCE).",
  "attack_vectors": "The vulnerability can be triggered remotely, as stated by CVSS:3.0/AV:N, since it is a logical flaw that could be exposed in network applications using the affected component.",
  "attacker_capabilities": "An attacker needs to control both element insertion and removal from the deque to trigger the vulnerability."
}
```