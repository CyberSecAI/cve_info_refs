=== Content from github.com_a8c9cb8a_20250120_231406.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd91ed5fa42ea0f32e4422a3c562e7b045a17da40%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_parser.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd91ed5fa42ea0f32e4422a3c562e7b045a17da40%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_parser.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

## Files

 d91ed5f
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)
2. /[features](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source)
/
# sn\_coap\_parser.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARMmbed/mbed-os/commits/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c)807 lines (655 loc) · 32.1 KB d91ed5f
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)
2. /[features](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source)
/
# sn\_coap\_parser.c

Top
## File metadata and controls

* Code
* Blame

807 lines (655 loc) · 32.1 KB[Raw](https://github.com/ARMmbed/mbed-os/raw/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806/\* \* Copyright (c) 2011-2015 ARM Limited. All rights reserved. \* SPDX-License-Identifier: Apache-2.0 \* Licensed under the Apache License, Version 2.0 (the License); you may \* not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an AS IS BASIS, WITHOUT \* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
/\*\* \*\file sn\_coap\_parser.c \* \* \brief CoAP Header parser \* \* Functionality: Parses CoAP Header \* \*/
/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* INCLUDE FILES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
#include <stdio.h>#include <string.h> /\* For memset() and memcpy() \*/
#include "ns\_types.h"#include "mbed-coap/sn\_coap\_header.h"#include "mbed-coap/sn\_coap\_protocol.h"#include "sn\_coap\_header\_internal.h"#include "sn\_coap\_protocol\_internal.h"#include "mbed-trace/mbed\_trace.h"
#define TRACE\_GROUP "coap"/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* LOCAL FUNCTION PROTOTYPES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr);static int8\_t sn\_coap\_parser\_options\_parse(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, uint8\_t \*packet\_data\_start\_ptr, uint16\_t packet\_len);static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, uint16\_t packet\_left\_len, uint8\_t \*\*dst\_pptr, uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len);static int16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(const uint8\_t \*packet\_data\_ptr, uint16\_t packet\_left\_len, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len);static int8\_t sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_start\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr);
sn\_coap\_hdr\_s \*sn\_coap\_parser\_init\_message(sn\_coap\_hdr\_s \*coap\_msg\_ptr){ /\* \* \* \* Check given pointer \* \* \* \*/ if (coap\_msg\_ptr == NULL) { tr\_error("sn\_coap\_parser\_init\_message - message null!"); return NULL; }
 /\* XXX not technically legal to memset pointers to 0 \*/ memset(coap\_msg\_ptr, 0x00, sizeof(sn\_coap\_hdr\_s));
 coap\_msg\_ptr->content\_format = COAP\_CT\_NONE;
 return coap\_msg\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser\_alloc\_message\_with\_options(struct coap\_s \*handle){ // check the handle just as in any other place if (handle == NULL) { return NULL; }
 sn\_coap\_hdr\_s \*coap\_msg\_ptr = sn\_coap\_parser\_alloc\_message(handle);
 sn\_coap\_options\_list\_s \*options\_list\_ptr = sn\_coap\_parser\_alloc\_options(handle, coap\_msg\_ptr);
 if ((coap\_msg\_ptr == NULL) || (options\_list\_ptr == NULL)) {
 // oops, out of memory free if got already any handle->sn\_coap\_protocol\_free(coap\_msg\_ptr); handle->sn\_coap\_protocol\_free(options\_list\_ptr);
 coap\_msg\_ptr = NULL; }
 return coap\_msg\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser\_alloc\_message(struct coap\_s \*handle){ sn\_coap\_hdr\_s \*returned\_coap\_msg\_ptr;
 /\* \* \* \* Check given pointer \* \* \* \*/ if (handle == NULL) { return NULL; }
 /\* \* \* \* Allocate memory for returned CoAP message and initialize allocated memory with with default values \* \* \* \*/ returned\_coap\_msg\_ptr = handle->sn\_coap\_protocol\_malloc(sizeof(sn\_coap\_hdr\_s));
 return sn\_coap\_parser\_init\_message(returned\_coap\_msg\_ptr);}
sn\_coap\_options\_list\_s \*sn\_coap\_parser\_alloc\_options(struct coap\_s \*handle, sn\_coap\_hdr\_s \*coap\_msg\_ptr){ sn\_coap\_options\_list\_s \*options\_list\_ptr;
 /\* \* \* \* Check given pointers \* \* \* \*/ if (handle == NULL || coap\_msg\_ptr == NULL) { return NULL; }
 /\* \* \* \* If the message already has options, return them \* \* \* \*/ if (coap\_msg\_ptr->options\_list\_ptr) { return coap\_msg\_ptr->options\_list\_ptr; }
 /\* \* \* \* Allocate memory for options and initialize allocated memory with with default values \* \* \* \*/ /\* XXX not technically legal to memset pointers to 0 \*/ options\_list\_ptr = sn\_coap\_protocol\_calloc(handle, sizeof(sn\_coap\_options\_list\_s));
 if (options\_list\_ptr == NULL) { tr\_error("sn\_coap\_parser\_alloc\_options - failed to allocate options list!"); return NULL; }
 coap\_msg\_ptr->options\_list\_ptr = options\_list\_ptr;
 options\_list\_ptr->uri\_port = COAP\_OPTION\_URI\_PORT\_NONE; options\_list\_ptr->observe = COAP\_OBSERVE\_NONE; options\_list\_ptr->accept = COAP\_CT\_NONE; options\_list\_ptr->block2 = COAP\_OPTION\_BLOCK\_NONE; options\_list\_ptr->block1 = COAP\_OPTION\_BLOCK\_NONE;
 return options\_list\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser(struct coap\_s \*handle, uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_ptr, coap\_version\_e \*coap\_version\_ptr){ uint8\_t \*data\_temp\_ptr = packet\_data\_ptr; sn\_coap\_hdr\_s \*parsed\_and\_returned\_coap\_msg\_ptr = NULL;
 /\* \* \* \* Check given pointer \* \* \* \*/ if (packet\_data\_ptr == NULL || packet\_data\_len < 4 || handle == NULL) { return NULL; }
 /\* \* \* \* Allocate and initialize CoAP message \* \* \* \*/ parsed\_and\_returned\_coap\_msg\_ptr = sn\_coap\_parser\_alloc\_message(handle);
 if (parsed\_and\_returned\_coap\_msg\_ptr == NULL) { tr\_error("sn\_coap\_parser - failed to allocate message!"); return NULL; }
 /\* \* \* \* Header parsing, move pointer over the header... \* \* \* \*/ sn\_coap\_parser\_header\_parse(&data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr, coap\_version\_ptr);
 /\* \* \* \* Options parsing, move pointer over the options... \* \* \* \*/ if (sn\_coap\_parser\_options\_parse(handle, &data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr, packet\_data\_ptr, packet\_data\_len) != 0) { parsed\_and\_returned\_coap\_msg\_ptr->coap\_status = COAP\_STATUS\_PARSER\_ERROR\_IN\_HEADER; return parsed\_and\_returned\_coap\_msg\_ptr; }
 /\* \* \* \* Payload parsing \* \* \* \*/ if (sn\_coap\_parser\_payload\_parse(packet\_data\_len, packet\_data\_ptr, &data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr) == -1) { parsed\_and\_returned\_coap\_msg\_ptr->coap\_status = COAP\_STATUS\_PARSER\_ERROR\_IN\_HEADER; return parsed\_and\_returned\_coap\_msg\_ptr; }
 /\* \* \* \* Return parsed CoAP message \* \* \* \* \*/ return parsed\_and\_returned\_coap\_msg\_ptr;}
void sn\_coap\_parser\_release\_allocated\_coap\_msg\_mem(struct coap\_s \*handle, sn\_coap\_hdr\_s \*freed\_coap\_msg\_ptr){ if (handle == NULL) { return; }
 if (freed\_coap\_msg\_ptr != NULL) {
 // As there are multiple sequential calls to the protocol\_free, caching pointer to it // saves one instruction per call. void (\*local\_free)(void \*) = handle->sn\_coap\_protocol\_free;
 local\_free(freed\_coap\_msg\_ptr->uri\_path\_ptr); local\_free(freed\_coap\_msg\_ptr->token\_ptr);
 // same here, caching the struct start saves a bit. sn\_coap\_options\_list\_s \*options\_list\_ptr = freed\_coap\_msg\_ptr->options\_list\_ptr;
 if (options\_list\_ptr != NULL) {
 local\_free(options\_list\_ptr->proxy\_uri\_ptr);
 local\_free(options\_list\_ptr->etag\_ptr);
 local\_free(options\_list\_ptr->uri\_host\_ptr);
 local\_free(options\_list\_ptr->location\_path\_ptr);
 local\_free(options\_list\_ptr->location\_query\_ptr);
 local\_free(options\_list\_ptr->uri\_query\_ptr);
 local\_free(options\_list\_ptr); }
 local\_free(freed\_coap\_msg\_ptr); }}
/\*\* \* \fn static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr) \* \* \brief Parses CoAP message's Header part from given Packet data \* \* \param \*\*packet\_data\_ptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \param \*coap\_version\_ptr is destination for parsed CoAP specification version \*/static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr){ /\* Parse CoAP Version and message type\*/ \*coap\_version\_ptr = (coap\_version\_e)(\*\*packet\_data\_pptr & COAP\_HEADER\_VERSION\_MASK); dst\_coap\_msg\_ptr->msg\_type = (sn\_coap\_msg\_type\_e)(\*\*packet\_data\_pptr & COAP\_HEADER\_MSG\_TYPE\_MASK); (\*packet\_data\_pptr) += 1;
 /\* Parse Message code \*/ dst\_coap\_msg\_ptr->msg\_code = (sn\_coap\_msg\_code\_e) \*\*packet\_data\_pptr; (\*packet\_data\_pptr) += 1;
 /\* Parse Message ID \*/ dst\_coap\_msg\_ptr->msg\_id = \*(\*packet\_data\_pptr + 1); dst\_coap\_msg\_ptr->msg\_id += \*\*packet\_data\_pptr << COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT; (\*packet\_data\_pptr) += 2;
}
/\*\* \* \brief Parses a variable-length uint value from an option \* \* \param \*\*packet\_data\_pptr is source of option data to be parsed \* \param option\_len is length of option data (will be 0-4) \* \* \return Return value is value of uint \*/static uint32\_t sn\_coap\_parser\_options\_parse\_uint(uint8\_t \*\*packet\_data\_pptr, uint8\_t option\_len){ uint32\_t value = 0; while (option\_len--) { value <<= 8; value |= \*(\*packet\_data\_pptr)++; } return value;}
/\*\* \* \fn static uint8\_t sn\_coap\_parser\_options\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr) \* \* \brief Parses CoAP message's Options part from given Packet data \* \* \param \*\*packet\_data\_pptr is source of Packet data to be parsed to CoAP message \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \return Return value is 0 in ok case and -1 in failure case \*/static int8\_t sn\_coap\_parser\_options\_parse(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, uint8\_t \*packet\_data\_start\_ptr, uint16\_t packet\_len){ uint8\_t previous\_option\_number = 0; uint8\_t i = 0; int8\_t ret\_status = 0; uint16\_t message\_left = 0;
 /\* Parse token, if exists \*/ dst\_coap\_msg\_ptr->token\_len = \*packet\_data\_start\_ptr & COAP\_HEADER\_TOKEN\_LENGTH\_MASK;
 if (dst\_coap\_msg\_ptr->token\_len) { if ((dst\_coap\_msg\_ptr->token\_len > 8) || dst\_coap\_msg\_ptr->token\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - token not valid!"); return -1; }
 dst\_coap\_msg\_ptr->token\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, dst\_coap\_msg\_ptr->token\_len);
 if (dst\_coap\_msg\_ptr->token\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - failed to allocate token!"); return -1; }
 (\*packet\_data\_pptr) += dst\_coap\_msg\_ptr->token\_len; }
 message\_left = packet\_len - ((\*packet\_data\_pptr) - packet\_data\_start\_ptr);
 /\* Loop all Options \*/ while (message\_left && (\*\*packet\_data\_pptr != 0xff)) {
 /\* Get option length WITHOUT extensions \*/ uint16\_t option\_len = (\*\*packet\_data\_pptr & 0x0F);
 /\* Resolve option delta \*/ uint16\_t option\_number = (\*\*packet\_data\_pptr >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT);
 if (option\_number == 13) { option\_number = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_number == 14) { option\_number = \*(\*packet\_data\_pptr + 2); option\_number += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } /\* Option number 15 reserved for payload marker. This is handled as a error! \*/ else if (option\_number == 15) { tr\_error("sn\_coap\_parser\_options\_parse - invalid option number(15)!"); return -1; }
 /\* Add previous option to option delta and get option number \*/ option\_number += previous\_option\_number;
 /\* Add possible option length extension to resolve full length of the option \*/ if (option\_len == 13) { option\_len = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_len == 14) { option\_len = \*(\*packet\_data\_pptr + 2); option\_len += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } /\* Option number length 15 is reserved for the future use - ERROR \*/ else if (option\_len == 15) { tr\_error("sn\_coap\_parser\_options\_parse - invalid option len(15)!"); return -1; }
 message\_left = packet\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 /\* \* \* Parse option itself \* \* \*/ /\* Some options are handled independently in own functions \*/ previous\_option\_number = option\_number; /\* Allocate options\_list\_ptr if needed \*/ switch (option\_number) { case COAP\_OPTION\_MAX\_AGE: case COAP\_OPTION\_PROXY\_URI: case COAP\_OPTION\_ETAG: case COAP\_OPTION\_URI\_HOST: case COAP\_OPTION\_LOCATION\_PATH: case COAP\_OPTION\_URI\_PORT: case COAP\_OPTION\_LOCATION\_QUERY: case COAP\_OPTION\_OBSERVE: case COAP\_OPTION\_URI\_QUERY: case COAP\_OPTION\_BLOCK2: case COAP\_OPTION\_BLOCK1: case COAP\_OPTION\_ACCEPT: case COAP\_OPTION\_SIZE1: case COAP\_OPTION\_SIZE2: if (sn\_coap\_parser\_alloc\_options(handle, dst\_coap\_msg\_ptr) == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - failed to allocate options!"); return -1; } break; }
 /\* Parse option \*/ switch (option\_number) { case COAP\_OPTION\_CONTENT\_FORMAT: if ((option\_len > 2) || (dst\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE)) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_CONTENT\_FORMAT not valid!"); return -1; } (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->content\_format = (sn\_coap\_content\_format\_e) sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_MAX\_AGE: if (option\_len > 4) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_MAX\_AGE not valid!"); return -1; } (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->max\_age = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_PROXY\_URI: if ((option\_len > 1034) || (option\_len < 1) || dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_PROXY\_URI not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_len = option\_len; (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, option\_len);
 if (dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_PROXY\_URI allocation failed!"); return -1; }
 (\*packet\_data\_pptr) += option\_len;
 break;
 case COAP\_OPTION\_ETAG: /\* This is managed independently because User gives this option in one character table \*/
 ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->etag\_ptr, (uint16\_t \*)&dst\_coap\_msg\_ptr->options\_list\_ptr->etag\_len, COAP\_OPTION\_ETAG, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_ETAG not valid!"); return -1; } break;
 case COAP\_OPTION\_URI\_HOST: if ((option\_len > 255) || (option\_len < 1) || dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_HOST not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_len = option\_len; (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, option\_len);
 if (dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_HOST allocation failed!"); return -1; } (\*packet\_data\_pptr) += option\_len;
 break;
 case COAP\_OPTION\_LOCATION\_PATH: if (dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_PATH exists!"); return -1; } /\* This is managed independently because User gives this option in one character table \*/ ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_len, COAP\_OPTION\_LOCATION\_PATH, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_PATH not valid!"); return -1; }
 break;
 case COAP\_OPTION\_URI\_PORT: if ((option\_len > 2) || dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_PORT not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_port = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_LOCATION\_QUERY: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_query\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_query\_len, COAP\_OPTION\_LOCATION\_QUERY, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_QUERY not valid!"); return -1; }
 break;
 case COAP\_OPTION\_URI\_PATH: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->uri\_path\_ptr, &dst\_coap\_msg\_ptr->uri\_path\_len, COAP\_OPTION\_URI\_PATH, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_PATH not valid!"); return -1; }
 break;
 case COAP\_OPTION\_OBSERVE: if ((option\_len > 2) || dst\_coap\_msg\_ptr->options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_OBSERVE not valid!"); return -1; }
 (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->observe = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_URI\_QUERY: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_query\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_query\_len, COAP\_OPTION\_URI\_QUERY, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_QUERY not valid!"); return -1; }
 break;
 case COAP\_OPTION\_BLOCK2: if ((option\_len > 3) || dst\_coap\_msg\_ptr->options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_BLOCK2 not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->block2 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_BLOCK1: if ((option\_len > 3) || dst\_coap\_msg\_ptr->options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_BLOCK1 not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->block1 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_ACCEPT: if ((option\_len > 2) || (dst\_coap\_msg\_ptr->options\_list\_ptr->accept != COAP\_CT\_NONE)) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_ACCEPT not valid!"); return -1; }
 (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->accept = (sn\_coap\_content\_format\_e) sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_SIZE1: if ((option\_len > 4) || dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size1) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_SIZE1 not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size1 = true; (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->size1 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_SIZE2: if ((option\_len > 4) || dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_SIZE2 not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size2 = true; (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->size2 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 default: tr\_error("sn\_coap\_parser\_options\_parse - unknown option!"); return -1; }
 /\* Check for overflow \*/ if ((\*packet\_data\_pptr - packet\_data\_start\_ptr) > packet\_len) { return -1; }
 message\_left = packet\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 }
 return 0;}
/\*\* \* \fn static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(uint8\_t \*\*packet\_data\_pptr, uint8\_t options\_count\_left, uint8\_t \*previous\_option\_number\_ptr, uint8\_t \*\*dst\_pptr, \* uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len) \* \* \brief Parses CoAP message's Uri-query options \* \* \param \*\*packet\_data\_pptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \param options\_count\_left tells how many options are unhandled in Packet data \* \* \param \*previous\_option\_number\_ptr is pointer to used and returned previous Option number \* \* \return Return value is count of Uri-query optios parsed. In failure case -1 is returned.\*/static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, uint16\_t packet\_left\_len, uint8\_t \*\*dst\_pptr, uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len){ int16\_t uri\_query\_needed\_heap = sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(\*packet\_data\_pptr, packet\_left\_len, option, option\_number\_len); uint8\_t \*temp\_parsed\_uri\_query\_ptr = NULL; uint8\_t returned\_option\_counter = 0;
 if (uri\_query\_needed\_heap == -1) { return -1; }
 if (uri\_query\_needed\_heap) { \*dst\_pptr = (uint8\_t \*) handle->sn\_coap\_protocol\_malloc(uri\_query\_needed\_heap);
 if (\*dst\_pptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse\_multiple\_options - failed to allocate options!"); return -1; } }
 \*dst\_len\_ptr = uri\_query\_needed\_heap;
 temp\_parsed\_uri\_query\_ptr = \*dst\_pptr;
 /\* Loop all Uri-Query options \*/ while ((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) < uri\_query\_needed\_heap) { /\* Check if this is first Uri-Query option \*/ if (returned\_option\_counter > 0) { /\* Uri-Query is modified to following format: temp1'\0'temp2'\0'temp3 i.e. \*/ /\* Uri-Path is modified to following format: temp1\temp2\temp3 i.e. \*/ if (option == COAP\_OPTION\_URI\_QUERY || option == COAP\_OPTION\_LOCATION\_QUERY || option == COAP\_OPTION\_ETAG || option == COAP\_OPTION\_ACCEPT) { \*temp\_parsed\_uri\_query\_ptr = '&'; } else if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { \*temp\_parsed\_uri\_query\_ptr = '/'; }
 temp\_parsed\_uri\_query\_ptr++; }
 returned\_option\_counter++;
 (\*packet\_data\_pptr)++;
 if (((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) + option\_number\_len) > uri\_query\_needed\_heap) { return -1; }
 memcpy(temp\_parsed\_uri\_query\_ptr, \*packet\_data\_pptr, option\_number\_len);
 (\*packet\_data\_pptr) += option\_number\_len; temp\_parsed\_uri\_query\_ptr += option\_number\_len;
 if ((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) >= uri\_query\_needed\_heap || ((\*\*packet\_data\_pptr >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT) != 0)) { return returned\_option\_counter; }
 option\_number\_len = (\*\*packet\_data\_pptr & 0x0F); if (option\_number\_len == 13) { option\_number\_len = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_number\_len == 14) { option\_number\_len = \*(\*packet\_data\_pptr + 2); option\_number\_len += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } }
 return returned\_option\_counter;}
/\*\* \* \fn static uint16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(uint8\_t \*packet\_data\_ptr, uint8\_t options\_count\_left, uint8\_t previous\_option\_number, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len) \* \* \brief Counts needed memory for uri query option \* \* \param \*packet\_data\_ptr is start of source for Packet data to be parsed to CoAP message \* \* \param options\_count\_left tells how many options are unhandled in Packet data \* \* \param previous\_option\_number is previous Option number \* \* \param sn\_coap\_option\_numbers\_e option option number to be calculated \* \* \param uint16\_t option\_number\_len length of the first option part \*/static int16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(const uint8\_t \*packet\_data\_ptr, uint16\_t packet\_left\_len, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len){ uint16\_t ret\_value = 0; uint16\_t i = 1;
 /\* Loop all Uri-Query options \*/ while (i <= packet\_left\_len) { if (option == COAP\_OPTION\_LOCATION\_PATH && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_URI\_PATH && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_URI\_QUERY && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_LOCATION\_QUERY && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_ACCEPT && option\_number\_len > 2) { return -1; } if (option == COAP\_OPTION\_ETAG && option\_number\_len > 8) { return -1; }
 i += option\_number\_len; ret\_value += option\_number\_len + 1; /\* + 1 is for separator \*/
 if( i == packet\_left\_len ) { break; } else if( i > packet\_left\_len ) { return -1; }
 if ((\*(packet\_data\_ptr + i) >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT) != 0) { return (ret\_value - 1); /\* -1 because last Part path does not include separator \*/ }
 option\_number\_len = (\*(packet\_data\_ptr + i) & 0x0F);
 if (option\_number\_len == 13) {
 if(i + 1 >= packet\_left\_len) { return -1; }
 i++; option\_number\_len = \*(packet\_data\_ptr + i) + 13; } else if (option\_number\_len == 14) {
 if(i + 2 >= packet\_left\_len) { return -1; }
 option\_number\_len = \*(packet\_data\_ptr + i + 2); option\_number\_len += (\*(packet\_data\_ptr + i + 1) << 8) + 269; i += 2; } else if (option\_number\_len == 15) { return -1; } i++;
 }
 if (ret\_value != 0) { return (ret\_value - 1); /\* -1 because last Part path does not include separator \*/ } else { return 0; }}
/\*\* \* \fn static void sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr) \* \* \brief Parses CoAP message's Payload part from given Packet data \* \* \param packet\_data\_len is length of given Packet data to be parsed to CoAP message \* \* \param \*packet\_data\_ptr is start of source for Packet data to be parsed to CoAP message \* \* \param \*\*packet\_data\_pptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/static int8\_t sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_start\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr){ /\* If there is payload \*/ if ((\*packet\_data\_pptr - packet\_data\_start\_ptr) < packet\_data\_len) { if (\*\*packet\_data\_pptr == 0xff) { (\*packet\_data\_pptr)++; /\* Parse Payload length \*/ dst\_coap\_msg\_ptr->payload\_len = packet\_data\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 /\* The presence of a marker followed by a zero-length payload MUST be processed as a message format error \*/ if (dst\_coap\_msg\_ptr->payload\_len == 0) { return -1; }
 /\* Parse Payload by setting CoAP message's payload\_ptr to point Payload in Packet data \*/ dst\_coap\_msg\_ptr->payload\_ptr = \*packet\_data\_pptr; } /\* No payload marker.. \*/ else { tr\_error("sn\_coap\_parser\_payload\_parse - payload marker not found!"); return -1; } } return 0;}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_011f445c_20250120_231412.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd91ed5fa42ea0f32e4422a3c562e7b045a17da40%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_parser.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd91ed5fa42ea0f32e4422a3c562e7b045a17da40%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_parser.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

## Files

 d91ed5f
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)
2. /[features](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source)
/
# sn\_coap\_parser.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARMmbed/mbed-os/commits/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c)807 lines (655 loc) · 32.1 KB d91ed5f
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)
2. /[features](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source)
/
# sn\_coap\_parser.c

Top
## File metadata and controls

* Code
* Blame

807 lines (655 loc) · 32.1 KB[Raw](https://github.com/ARMmbed/mbed-os/raw/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806/\* \* Copyright (c) 2011-2015 ARM Limited. All rights reserved. \* SPDX-License-Identifier: Apache-2.0 \* Licensed under the Apache License, Version 2.0 (the License); you may \* not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an AS IS BASIS, WITHOUT \* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
/\*\* \*\file sn\_coap\_parser.c \* \* \brief CoAP Header parser \* \* Functionality: Parses CoAP Header \* \*/
/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* INCLUDE FILES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
#include <stdio.h>#include <string.h> /\* For memset() and memcpy() \*/
#include "ns\_types.h"#include "mbed-coap/sn\_coap\_header.h"#include "mbed-coap/sn\_coap\_protocol.h"#include "sn\_coap\_header\_internal.h"#include "sn\_coap\_protocol\_internal.h"#include "mbed-trace/mbed\_trace.h"
#define TRACE\_GROUP "coap"/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* LOCAL FUNCTION PROTOTYPES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr);static int8\_t sn\_coap\_parser\_options\_parse(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, uint8\_t \*packet\_data\_start\_ptr, uint16\_t packet\_len);static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, uint16\_t packet\_left\_len, uint8\_t \*\*dst\_pptr, uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len);static int16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(const uint8\_t \*packet\_data\_ptr, uint16\_t packet\_left\_len, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len);static int8\_t sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_start\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr);
sn\_coap\_hdr\_s \*sn\_coap\_parser\_init\_message(sn\_coap\_hdr\_s \*coap\_msg\_ptr){ /\* \* \* \* Check given pointer \* \* \* \*/ if (coap\_msg\_ptr == NULL) { tr\_error("sn\_coap\_parser\_init\_message - message null!"); return NULL; }
 /\* XXX not technically legal to memset pointers to 0 \*/ memset(coap\_msg\_ptr, 0x00, sizeof(sn\_coap\_hdr\_s));
 coap\_msg\_ptr->content\_format = COAP\_CT\_NONE;
 return coap\_msg\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser\_alloc\_message\_with\_options(struct coap\_s \*handle){ // check the handle just as in any other place if (handle == NULL) { return NULL; }
 sn\_coap\_hdr\_s \*coap\_msg\_ptr = sn\_coap\_parser\_alloc\_message(handle);
 sn\_coap\_options\_list\_s \*options\_list\_ptr = sn\_coap\_parser\_alloc\_options(handle, coap\_msg\_ptr);
 if ((coap\_msg\_ptr == NULL) || (options\_list\_ptr == NULL)) {
 // oops, out of memory free if got already any handle->sn\_coap\_protocol\_free(coap\_msg\_ptr); handle->sn\_coap\_protocol\_free(options\_list\_ptr);
 coap\_msg\_ptr = NULL; }
 return coap\_msg\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser\_alloc\_message(struct coap\_s \*handle){ sn\_coap\_hdr\_s \*returned\_coap\_msg\_ptr;
 /\* \* \* \* Check given pointer \* \* \* \*/ if (handle == NULL) { return NULL; }
 /\* \* \* \* Allocate memory for returned CoAP message and initialize allocated memory with with default values \* \* \* \*/ returned\_coap\_msg\_ptr = handle->sn\_coap\_protocol\_malloc(sizeof(sn\_coap\_hdr\_s));
 return sn\_coap\_parser\_init\_message(returned\_coap\_msg\_ptr);}
sn\_coap\_options\_list\_s \*sn\_coap\_parser\_alloc\_options(struct coap\_s \*handle, sn\_coap\_hdr\_s \*coap\_msg\_ptr){ sn\_coap\_options\_list\_s \*options\_list\_ptr;
 /\* \* \* \* Check given pointers \* \* \* \*/ if (handle == NULL || coap\_msg\_ptr == NULL) { return NULL; }
 /\* \* \* \* If the message already has options, return them \* \* \* \*/ if (coap\_msg\_ptr->options\_list\_ptr) { return coap\_msg\_ptr->options\_list\_ptr; }
 /\* \* \* \* Allocate memory for options and initialize allocated memory with with default values \* \* \* \*/ /\* XXX not technically legal to memset pointers to 0 \*/ options\_list\_ptr = sn\_coap\_protocol\_calloc(handle, sizeof(sn\_coap\_options\_list\_s));
 if (options\_list\_ptr == NULL) { tr\_error("sn\_coap\_parser\_alloc\_options - failed to allocate options list!"); return NULL; }
 coap\_msg\_ptr->options\_list\_ptr = options\_list\_ptr;
 options\_list\_ptr->uri\_port = COAP\_OPTION\_URI\_PORT\_NONE; options\_list\_ptr->observe = COAP\_OBSERVE\_NONE; options\_list\_ptr->accept = COAP\_CT\_NONE; options\_list\_ptr->block2 = COAP\_OPTION\_BLOCK\_NONE; options\_list\_ptr->block1 = COAP\_OPTION\_BLOCK\_NONE;
 return options\_list\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser(struct coap\_s \*handle, uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_ptr, coap\_version\_e \*coap\_version\_ptr){ uint8\_t \*data\_temp\_ptr = packet\_data\_ptr; sn\_coap\_hdr\_s \*parsed\_and\_returned\_coap\_msg\_ptr = NULL;
 /\* \* \* \* Check given pointer \* \* \* \*/ if (packet\_data\_ptr == NULL || packet\_data\_len < 4 || handle == NULL) { return NULL; }
 /\* \* \* \* Allocate and initialize CoAP message \* \* \* \*/ parsed\_and\_returned\_coap\_msg\_ptr = sn\_coap\_parser\_alloc\_message(handle);
 if (parsed\_and\_returned\_coap\_msg\_ptr == NULL) { tr\_error("sn\_coap\_parser - failed to allocate message!"); return NULL; }
 /\* \* \* \* Header parsing, move pointer over the header... \* \* \* \*/ sn\_coap\_parser\_header\_parse(&data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr, coap\_version\_ptr);
 /\* \* \* \* Options parsing, move pointer over the options... \* \* \* \*/ if (sn\_coap\_parser\_options\_parse(handle, &data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr, packet\_data\_ptr, packet\_data\_len) != 0) { parsed\_and\_returned\_coap\_msg\_ptr->coap\_status = COAP\_STATUS\_PARSER\_ERROR\_IN\_HEADER; return parsed\_and\_returned\_coap\_msg\_ptr; }
 /\* \* \* \* Payload parsing \* \* \* \*/ if (sn\_coap\_parser\_payload\_parse(packet\_data\_len, packet\_data\_ptr, &data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr) == -1) { parsed\_and\_returned\_coap\_msg\_ptr->coap\_status = COAP\_STATUS\_PARSER\_ERROR\_IN\_HEADER; return parsed\_and\_returned\_coap\_msg\_ptr; }
 /\* \* \* \* Return parsed CoAP message \* \* \* \* \*/ return parsed\_and\_returned\_coap\_msg\_ptr;}
void sn\_coap\_parser\_release\_allocated\_coap\_msg\_mem(struct coap\_s \*handle, sn\_coap\_hdr\_s \*freed\_coap\_msg\_ptr){ if (handle == NULL) { return; }
 if (freed\_coap\_msg\_ptr != NULL) {
 // As there are multiple sequential calls to the protocol\_free, caching pointer to it // saves one instruction per call. void (\*local\_free)(void \*) = handle->sn\_coap\_protocol\_free;
 local\_free(freed\_coap\_msg\_ptr->uri\_path\_ptr); local\_free(freed\_coap\_msg\_ptr->token\_ptr);
 // same here, caching the struct start saves a bit. sn\_coap\_options\_list\_s \*options\_list\_ptr = freed\_coap\_msg\_ptr->options\_list\_ptr;
 if (options\_list\_ptr != NULL) {
 local\_free(options\_list\_ptr->proxy\_uri\_ptr);
 local\_free(options\_list\_ptr->etag\_ptr);
 local\_free(options\_list\_ptr->uri\_host\_ptr);
 local\_free(options\_list\_ptr->location\_path\_ptr);
 local\_free(options\_list\_ptr->location\_query\_ptr);
 local\_free(options\_list\_ptr->uri\_query\_ptr);
 local\_free(options\_list\_ptr); }
 local\_free(freed\_coap\_msg\_ptr); }}
/\*\* \* \fn static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr) \* \* \brief Parses CoAP message's Header part from given Packet data \* \* \param \*\*packet\_data\_ptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \param \*coap\_version\_ptr is destination for parsed CoAP specification version \*/static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr){ /\* Parse CoAP Version and message type\*/ \*coap\_version\_ptr = (coap\_version\_e)(\*\*packet\_data\_pptr & COAP\_HEADER\_VERSION\_MASK); dst\_coap\_msg\_ptr->msg\_type = (sn\_coap\_msg\_type\_e)(\*\*packet\_data\_pptr & COAP\_HEADER\_MSG\_TYPE\_MASK); (\*packet\_data\_pptr) += 1;
 /\* Parse Message code \*/ dst\_coap\_msg\_ptr->msg\_code = (sn\_coap\_msg\_code\_e) \*\*packet\_data\_pptr; (\*packet\_data\_pptr) += 1;
 /\* Parse Message ID \*/ dst\_coap\_msg\_ptr->msg\_id = \*(\*packet\_data\_pptr + 1); dst\_coap\_msg\_ptr->msg\_id += \*\*packet\_data\_pptr << COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT; (\*packet\_data\_pptr) += 2;
}
/\*\* \* \brief Parses a variable-length uint value from an option \* \* \param \*\*packet\_data\_pptr is source of option data to be parsed \* \param option\_len is length of option data (will be 0-4) \* \* \return Return value is value of uint \*/static uint32\_t sn\_coap\_parser\_options\_parse\_uint(uint8\_t \*\*packet\_data\_pptr, uint8\_t option\_len){ uint32\_t value = 0; while (option\_len--) { value <<= 8; value |= \*(\*packet\_data\_pptr)++; } return value;}
/\*\* \* \fn static uint8\_t sn\_coap\_parser\_options\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr) \* \* \brief Parses CoAP message's Options part from given Packet data \* \* \param \*\*packet\_data\_pptr is source of Packet data to be parsed to CoAP message \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \return Return value is 0 in ok case and -1 in failure case \*/static int8\_t sn\_coap\_parser\_options\_parse(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, uint8\_t \*packet\_data\_start\_ptr, uint16\_t packet\_len){ uint8\_t previous\_option\_number = 0; uint8\_t i = 0; int8\_t ret\_status = 0; uint16\_t message\_left = 0;
 /\* Parse token, if exists \*/ dst\_coap\_msg\_ptr->token\_len = \*packet\_data\_start\_ptr & COAP\_HEADER\_TOKEN\_LENGTH\_MASK;
 if (dst\_coap\_msg\_ptr->token\_len) { if ((dst\_coap\_msg\_ptr->token\_len > 8) || dst\_coap\_msg\_ptr->token\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - token not valid!"); return -1; }
 dst\_coap\_msg\_ptr->token\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, dst\_coap\_msg\_ptr->token\_len);
 if (dst\_coap\_msg\_ptr->token\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - failed to allocate token!"); return -1; }
 (\*packet\_data\_pptr) += dst\_coap\_msg\_ptr->token\_len; }
 message\_left = packet\_len - ((\*packet\_data\_pptr) - packet\_data\_start\_ptr);
 /\* Loop all Options \*/ while (message\_left && (\*\*packet\_data\_pptr != 0xff)) {
 /\* Get option length WITHOUT extensions \*/ uint16\_t option\_len = (\*\*packet\_data\_pptr & 0x0F);
 /\* Resolve option delta \*/ uint16\_t option\_number = (\*\*packet\_data\_pptr >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT);
 if (option\_number == 13) { option\_number = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_number == 14) { option\_number = \*(\*packet\_data\_pptr + 2); option\_number += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } /\* Option number 15 reserved for payload marker. This is handled as a error! \*/ else if (option\_number == 15) { tr\_error("sn\_coap\_parser\_options\_parse - invalid option number(15)!"); return -1; }
 /\* Add previous option to option delta and get option number \*/ option\_number += previous\_option\_number;
 /\* Add possible option length extension to resolve full length of the option \*/ if (option\_len == 13) { option\_len = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_len == 14) { option\_len = \*(\*packet\_data\_pptr + 2); option\_len += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } /\* Option number length 15 is reserved for the future use - ERROR \*/ else if (option\_len == 15) { tr\_error("sn\_coap\_parser\_options\_parse - invalid option len(15)!"); return -1; }
 message\_left = packet\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 /\* \* \* Parse option itself \* \* \*/ /\* Some options are handled independently in own functions \*/ previous\_option\_number = option\_number; /\* Allocate options\_list\_ptr if needed \*/ switch (option\_number) { case COAP\_OPTION\_MAX\_AGE: case COAP\_OPTION\_PROXY\_URI: case COAP\_OPTION\_ETAG: case COAP\_OPTION\_URI\_HOST: case COAP\_OPTION\_LOCATION\_PATH: case COAP\_OPTION\_URI\_PORT: case COAP\_OPTION\_LOCATION\_QUERY: case COAP\_OPTION\_OBSERVE: case COAP\_OPTION\_URI\_QUERY: case COAP\_OPTION\_BLOCK2: case COAP\_OPTION\_BLOCK1: case COAP\_OPTION\_ACCEPT: case COAP\_OPTION\_SIZE1: case COAP\_OPTION\_SIZE2: if (sn\_coap\_parser\_alloc\_options(handle, dst\_coap\_msg\_ptr) == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - failed to allocate options!"); return -1; } break; }
 /\* Parse option \*/ switch (option\_number) { case COAP\_OPTION\_CONTENT\_FORMAT: if ((option\_len > 2) || (dst\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE)) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_CONTENT\_FORMAT not valid!"); return -1; } (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->content\_format = (sn\_coap\_content\_format\_e) sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_MAX\_AGE: if (option\_len > 4) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_MAX\_AGE not valid!"); return -1; } (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->max\_age = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_PROXY\_URI: if ((option\_len > 1034) || (option\_len < 1) || dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_PROXY\_URI not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_len = option\_len; (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, option\_len);
 if (dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_PROXY\_URI allocation failed!"); return -1; }
 (\*packet\_data\_pptr) += option\_len;
 break;
 case COAP\_OPTION\_ETAG: /\* This is managed independently because User gives this option in one character table \*/
 ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->etag\_ptr, (uint16\_t \*)&dst\_coap\_msg\_ptr->options\_list\_ptr->etag\_len, COAP\_OPTION\_ETAG, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_ETAG not valid!"); return -1; } break;
 case COAP\_OPTION\_URI\_HOST: if ((option\_len > 255) || (option\_len < 1) || dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_HOST not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_len = option\_len; (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, option\_len);
 if (dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_HOST allocation failed!"); return -1; } (\*packet\_data\_pptr) += option\_len;
 break;
 case COAP\_OPTION\_LOCATION\_PATH: if (dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_PATH exists!"); return -1; } /\* This is managed independently because User gives this option in one character table \*/ ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_len, COAP\_OPTION\_LOCATION\_PATH, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_PATH not valid!"); return -1; }
 break;
 case COAP\_OPTION\_URI\_PORT: if ((option\_len > 2) || dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_PORT not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_port = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_LOCATION\_QUERY: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_query\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_query\_len, COAP\_OPTION\_LOCATION\_QUERY, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_QUERY not valid!"); return -1; }
 break;
 case COAP\_OPTION\_URI\_PATH: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->uri\_path\_ptr, &dst\_coap\_msg\_ptr->uri\_path\_len, COAP\_OPTION\_URI\_PATH, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_PATH not valid!"); return -1; }
 break;
 case COAP\_OPTION\_OBSERVE: if ((option\_len > 2) || dst\_coap\_msg\_ptr->options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_OBSERVE not valid!"); return -1; }
 (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->observe = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_URI\_QUERY: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_query\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_query\_len, COAP\_OPTION\_URI\_QUERY, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_QUERY not valid!"); return -1; }
 break;
 case COAP\_OPTION\_BLOCK2: if ((option\_len > 3) || dst\_coap\_msg\_ptr->options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_BLOCK2 not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->block2 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_BLOCK1: if ((option\_len > 3) || dst\_coap\_msg\_ptr->options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_BLOCK1 not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->block1 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_ACCEPT: if ((option\_len > 2) || (dst\_coap\_msg\_ptr->options\_list\_ptr->accept != COAP\_CT\_NONE)) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_ACCEPT not valid!"); return -1; }
 (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->accept = (sn\_coap\_content\_format\_e) sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_SIZE1: if ((option\_len > 4) || dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size1) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_SIZE1 not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size1 = true; (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->size1 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_SIZE2: if ((option\_len > 4) || dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_SIZE2 not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size2 = true; (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->size2 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 default: tr\_error("sn\_coap\_parser\_options\_parse - unknown option!"); return -1; }
 /\* Check for overflow \*/ if ((\*packet\_data\_pptr - packet\_data\_start\_ptr) > packet\_len) { return -1; }
 message\_left = packet\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 }
 return 0;}
/\*\* \* \fn static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(uint8\_t \*\*packet\_data\_pptr, uint8\_t options\_count\_left, uint8\_t \*previous\_option\_number\_ptr, uint8\_t \*\*dst\_pptr, \* uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len) \* \* \brief Parses CoAP message's Uri-query options \* \* \param \*\*packet\_data\_pptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \param options\_count\_left tells how many options are unhandled in Packet data \* \* \param \*previous\_option\_number\_ptr is pointer to used and returned previous Option number \* \* \return Return value is count of Uri-query optios parsed. In failure case -1 is returned.\*/static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, uint16\_t packet\_left\_len, uint8\_t \*\*dst\_pptr, uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len){ int16\_t uri\_query\_needed\_heap = sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(\*packet\_data\_pptr, packet\_left\_len, option, option\_number\_len); uint8\_t \*temp\_parsed\_uri\_query\_ptr = NULL; uint8\_t returned\_option\_counter = 0;
 if (uri\_query\_needed\_heap == -1) { return -1; }
 if (uri\_query\_needed\_heap) { \*dst\_pptr = (uint8\_t \*) handle->sn\_coap\_protocol\_malloc(uri\_query\_needed\_heap);
 if (\*dst\_pptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse\_multiple\_options - failed to allocate options!"); return -1; } }
 \*dst\_len\_ptr = uri\_query\_needed\_heap;
 temp\_parsed\_uri\_query\_ptr = \*dst\_pptr;
 /\* Loop all Uri-Query options \*/ while ((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) < uri\_query\_needed\_heap) { /\* Check if this is first Uri-Query option \*/ if (returned\_option\_counter > 0) { /\* Uri-Query is modified to following format: temp1'\0'temp2'\0'temp3 i.e. \*/ /\* Uri-Path is modified to following format: temp1\temp2\temp3 i.e. \*/ if (option == COAP\_OPTION\_URI\_QUERY || option == COAP\_OPTION\_LOCATION\_QUERY || option == COAP\_OPTION\_ETAG || option == COAP\_OPTION\_ACCEPT) { \*temp\_parsed\_uri\_query\_ptr = '&'; } else if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { \*temp\_parsed\_uri\_query\_ptr = '/'; }
 temp\_parsed\_uri\_query\_ptr++; }
 returned\_option\_counter++;
 (\*packet\_data\_pptr)++;
 if (((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) + option\_number\_len) > uri\_query\_needed\_heap) { return -1; }
 memcpy(temp\_parsed\_uri\_query\_ptr, \*packet\_data\_pptr, option\_number\_len);
 (\*packet\_data\_pptr) += option\_number\_len; temp\_parsed\_uri\_query\_ptr += option\_number\_len;
 if ((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) >= uri\_query\_needed\_heap || ((\*\*packet\_data\_pptr >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT) != 0)) { return returned\_option\_counter; }
 option\_number\_len = (\*\*packet\_data\_pptr & 0x0F); if (option\_number\_len == 13) { option\_number\_len = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_number\_len == 14) { option\_number\_len = \*(\*packet\_data\_pptr + 2); option\_number\_len += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } }
 return returned\_option\_counter;}
/\*\* \* \fn static uint16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(uint8\_t \*packet\_data\_ptr, uint8\_t options\_count\_left, uint8\_t previous\_option\_number, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len) \* \* \brief Counts needed memory for uri query option \* \* \param \*packet\_data\_ptr is start of source for Packet data to be parsed to CoAP message \* \* \param options\_count\_left tells how many options are unhandled in Packet data \* \* \param previous\_option\_number is previous Option number \* \* \param sn\_coap\_option\_numbers\_e option option number to be calculated \* \* \param uint16\_t option\_number\_len length of the first option part \*/static int16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(const uint8\_t \*packet\_data\_ptr, uint16\_t packet\_left\_len, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len){ uint16\_t ret\_value = 0; uint16\_t i = 1;
 /\* Loop all Uri-Query options \*/ while (i <= packet\_left\_len) { if (option == COAP\_OPTION\_LOCATION\_PATH && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_URI\_PATH && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_URI\_QUERY && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_LOCATION\_QUERY && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_ACCEPT && option\_number\_len > 2) { return -1; } if (option == COAP\_OPTION\_ETAG && option\_number\_len > 8) { return -1; }
 i += option\_number\_len; ret\_value += option\_number\_len + 1; /\* + 1 is for separator \*/
 if( i == packet\_left\_len ) { break; } else if( i > packet\_left\_len ) { return -1; }
 if ((\*(packet\_data\_ptr + i) >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT) != 0) { return (ret\_value - 1); /\* -1 because last Part path does not include separator \*/ }
 option\_number\_len = (\*(packet\_data\_ptr + i) & 0x0F);
 if (option\_number\_len == 13) {
 if(i + 1 >= packet\_left\_len) { return -1; }
 i++; option\_number\_len = \*(packet\_data\_ptr + i) + 13; } else if (option\_number\_len == 14) {
 if(i + 2 >= packet\_left\_len) { return -1; }
 option\_number\_len = \*(packet\_data\_ptr + i + 2); option\_number\_len += (\*(packet\_data\_ptr + i + 1) << 8) + 269; i += 2; } else if (option\_number\_len == 15) { return -1; } i++;
 }
 if (ret\_value != 0) { return (ret\_value - 1); /\* -1 because last Part path does not include separator \*/ } else { return 0; }}
/\*\* \* \fn static void sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr) \* \* \brief Parses CoAP message's Payload part from given Packet data \* \* \param packet\_data\_len is length of given Packet data to be parsed to CoAP message \* \* \param \*packet\_data\_ptr is start of source for Packet data to be parsed to CoAP message \* \* \param \*\*packet\_data\_pptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/static int8\_t sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_start\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr){ /\* If there is payload \*/ if ((\*packet\_data\_pptr - packet\_data\_start\_ptr) < packet\_data\_len) { if (\*\*packet\_data\_pptr == 0xff) { (\*packet\_data\_pptr)++; /\* Parse Payload length \*/ dst\_coap\_msg\_ptr->payload\_len = packet\_data\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 /\* The presence of a marker followed by a zero-length payload MUST be processed as a message format error \*/ if (dst\_coap\_msg\_ptr->payload\_len == 0) { return -1; }
 /\* Parse Payload by setting CoAP message's payload\_ptr to point Payload in Packet data \*/ dst\_coap\_msg\_ptr->payload\_ptr = \*packet\_data\_pptr; } /\* No payload marker.. \*/ else { tr\_error("sn\_coap\_parser\_payload\_parse - payload marker not found!"); return -1; } } return 0;}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_41698ad4_20250120_231417.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd91ed5fa42ea0f32e4422a3c562e7b045a17da40%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_parser.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd91ed5fa42ea0f32e4422a3c562e7b045a17da40%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_parser.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

## Files

 d91ed5f
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)
2. /[features](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source)
/
# sn\_coap\_parser.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARMmbed/mbed-os/commits/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c)807 lines (655 loc) · 32.1 KB d91ed5f
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)
2. /[features](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source)
/
# sn\_coap\_parser.c

Top
## File metadata and controls

* Code
* Blame

807 lines (655 loc) · 32.1 KB[Raw](https://github.com/ARMmbed/mbed-os/raw/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806/\* \* Copyright (c) 2011-2015 ARM Limited. All rights reserved. \* SPDX-License-Identifier: Apache-2.0 \* Licensed under the Apache License, Version 2.0 (the License); you may \* not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an AS IS BASIS, WITHOUT \* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
/\*\* \*\file sn\_coap\_parser.c \* \* \brief CoAP Header parser \* \* Functionality: Parses CoAP Header \* \*/
/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* INCLUDE FILES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
#include <stdio.h>#include <string.h> /\* For memset() and memcpy() \*/
#include "ns\_types.h"#include "mbed-coap/sn\_coap\_header.h"#include "mbed-coap/sn\_coap\_protocol.h"#include "sn\_coap\_header\_internal.h"#include "sn\_coap\_protocol\_internal.h"#include "mbed-trace/mbed\_trace.h"
#define TRACE\_GROUP "coap"/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* LOCAL FUNCTION PROTOTYPES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr);static int8\_t sn\_coap\_parser\_options\_parse(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, uint8\_t \*packet\_data\_start\_ptr, uint16\_t packet\_len);static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, uint16\_t packet\_left\_len, uint8\_t \*\*dst\_pptr, uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len);static int16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(const uint8\_t \*packet\_data\_ptr, uint16\_t packet\_left\_len, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len);static int8\_t sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_start\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr);
sn\_coap\_hdr\_s \*sn\_coap\_parser\_init\_message(sn\_coap\_hdr\_s \*coap\_msg\_ptr){ /\* \* \* \* Check given pointer \* \* \* \*/ if (coap\_msg\_ptr == NULL) { tr\_error("sn\_coap\_parser\_init\_message - message null!"); return NULL; }
 /\* XXX not technically legal to memset pointers to 0 \*/ memset(coap\_msg\_ptr, 0x00, sizeof(sn\_coap\_hdr\_s));
 coap\_msg\_ptr->content\_format = COAP\_CT\_NONE;
 return coap\_msg\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser\_alloc\_message\_with\_options(struct coap\_s \*handle){ // check the handle just as in any other place if (handle == NULL) { return NULL; }
 sn\_coap\_hdr\_s \*coap\_msg\_ptr = sn\_coap\_parser\_alloc\_message(handle);
 sn\_coap\_options\_list\_s \*options\_list\_ptr = sn\_coap\_parser\_alloc\_options(handle, coap\_msg\_ptr);
 if ((coap\_msg\_ptr == NULL) || (options\_list\_ptr == NULL)) {
 // oops, out of memory free if got already any handle->sn\_coap\_protocol\_free(coap\_msg\_ptr); handle->sn\_coap\_protocol\_free(options\_list\_ptr);
 coap\_msg\_ptr = NULL; }
 return coap\_msg\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser\_alloc\_message(struct coap\_s \*handle){ sn\_coap\_hdr\_s \*returned\_coap\_msg\_ptr;
 /\* \* \* \* Check given pointer \* \* \* \*/ if (handle == NULL) { return NULL; }
 /\* \* \* \* Allocate memory for returned CoAP message and initialize allocated memory with with default values \* \* \* \*/ returned\_coap\_msg\_ptr = handle->sn\_coap\_protocol\_malloc(sizeof(sn\_coap\_hdr\_s));
 return sn\_coap\_parser\_init\_message(returned\_coap\_msg\_ptr);}
sn\_coap\_options\_list\_s \*sn\_coap\_parser\_alloc\_options(struct coap\_s \*handle, sn\_coap\_hdr\_s \*coap\_msg\_ptr){ sn\_coap\_options\_list\_s \*options\_list\_ptr;
 /\* \* \* \* Check given pointers \* \* \* \*/ if (handle == NULL || coap\_msg\_ptr == NULL) { return NULL; }
 /\* \* \* \* If the message already has options, return them \* \* \* \*/ if (coap\_msg\_ptr->options\_list\_ptr) { return coap\_msg\_ptr->options\_list\_ptr; }
 /\* \* \* \* Allocate memory for options and initialize allocated memory with with default values \* \* \* \*/ /\* XXX not technically legal to memset pointers to 0 \*/ options\_list\_ptr = sn\_coap\_protocol\_calloc(handle, sizeof(sn\_coap\_options\_list\_s));
 if (options\_list\_ptr == NULL) { tr\_error("sn\_coap\_parser\_alloc\_options - failed to allocate options list!"); return NULL; }
 coap\_msg\_ptr->options\_list\_ptr = options\_list\_ptr;
 options\_list\_ptr->uri\_port = COAP\_OPTION\_URI\_PORT\_NONE; options\_list\_ptr->observe = COAP\_OBSERVE\_NONE; options\_list\_ptr->accept = COAP\_CT\_NONE; options\_list\_ptr->block2 = COAP\_OPTION\_BLOCK\_NONE; options\_list\_ptr->block1 = COAP\_OPTION\_BLOCK\_NONE;
 return options\_list\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser(struct coap\_s \*handle, uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_ptr, coap\_version\_e \*coap\_version\_ptr){ uint8\_t \*data\_temp\_ptr = packet\_data\_ptr; sn\_coap\_hdr\_s \*parsed\_and\_returned\_coap\_msg\_ptr = NULL;
 /\* \* \* \* Check given pointer \* \* \* \*/ if (packet\_data\_ptr == NULL || packet\_data\_len < 4 || handle == NULL) { return NULL; }
 /\* \* \* \* Allocate and initialize CoAP message \* \* \* \*/ parsed\_and\_returned\_coap\_msg\_ptr = sn\_coap\_parser\_alloc\_message(handle);
 if (parsed\_and\_returned\_coap\_msg\_ptr == NULL) { tr\_error("sn\_coap\_parser - failed to allocate message!"); return NULL; }
 /\* \* \* \* Header parsing, move pointer over the header... \* \* \* \*/ sn\_coap\_parser\_header\_parse(&data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr, coap\_version\_ptr);
 /\* \* \* \* Options parsing, move pointer over the options... \* \* \* \*/ if (sn\_coap\_parser\_options\_parse(handle, &data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr, packet\_data\_ptr, packet\_data\_len) != 0) { parsed\_and\_returned\_coap\_msg\_ptr->coap\_status = COAP\_STATUS\_PARSER\_ERROR\_IN\_HEADER; return parsed\_and\_returned\_coap\_msg\_ptr; }
 /\* \* \* \* Payload parsing \* \* \* \*/ if (sn\_coap\_parser\_payload\_parse(packet\_data\_len, packet\_data\_ptr, &data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr) == -1) { parsed\_and\_returned\_coap\_msg\_ptr->coap\_status = COAP\_STATUS\_PARSER\_ERROR\_IN\_HEADER; return parsed\_and\_returned\_coap\_msg\_ptr; }
 /\* \* \* \* Return parsed CoAP message \* \* \* \* \*/ return parsed\_and\_returned\_coap\_msg\_ptr;}
void sn\_coap\_parser\_release\_allocated\_coap\_msg\_mem(struct coap\_s \*handle, sn\_coap\_hdr\_s \*freed\_coap\_msg\_ptr){ if (handle == NULL) { return; }
 if (freed\_coap\_msg\_ptr != NULL) {
 // As there are multiple sequential calls to the protocol\_free, caching pointer to it // saves one instruction per call. void (\*local\_free)(void \*) = handle->sn\_coap\_protocol\_free;
 local\_free(freed\_coap\_msg\_ptr->uri\_path\_ptr); local\_free(freed\_coap\_msg\_ptr->token\_ptr);
 // same here, caching the struct start saves a bit. sn\_coap\_options\_list\_s \*options\_list\_ptr = freed\_coap\_msg\_ptr->options\_list\_ptr;
 if (options\_list\_ptr != NULL) {
 local\_free(options\_list\_ptr->proxy\_uri\_ptr);
 local\_free(options\_list\_ptr->etag\_ptr);
 local\_free(options\_list\_ptr->uri\_host\_ptr);
 local\_free(options\_list\_ptr->location\_path\_ptr);
 local\_free(options\_list\_ptr->location\_query\_ptr);
 local\_free(options\_list\_ptr->uri\_query\_ptr);
 local\_free(options\_list\_ptr); }
 local\_free(freed\_coap\_msg\_ptr); }}
/\*\* \* \fn static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr) \* \* \brief Parses CoAP message's Header part from given Packet data \* \* \param \*\*packet\_data\_ptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \param \*coap\_version\_ptr is destination for parsed CoAP specification version \*/static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr){ /\* Parse CoAP Version and message type\*/ \*coap\_version\_ptr = (coap\_version\_e)(\*\*packet\_data\_pptr & COAP\_HEADER\_VERSION\_MASK); dst\_coap\_msg\_ptr->msg\_type = (sn\_coap\_msg\_type\_e)(\*\*packet\_data\_pptr & COAP\_HEADER\_MSG\_TYPE\_MASK); (\*packet\_data\_pptr) += 1;
 /\* Parse Message code \*/ dst\_coap\_msg\_ptr->msg\_code = (sn\_coap\_msg\_code\_e) \*\*packet\_data\_pptr; (\*packet\_data\_pptr) += 1;
 /\* Parse Message ID \*/ dst\_coap\_msg\_ptr->msg\_id = \*(\*packet\_data\_pptr + 1); dst\_coap\_msg\_ptr->msg\_id += \*\*packet\_data\_pptr << COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT; (\*packet\_data\_pptr) += 2;
}
/\*\* \* \brief Parses a variable-length uint value from an option \* \* \param \*\*packet\_data\_pptr is source of option data to be parsed \* \param option\_len is length of option data (will be 0-4) \* \* \return Return value is value of uint \*/static uint32\_t sn\_coap\_parser\_options\_parse\_uint(uint8\_t \*\*packet\_data\_pptr, uint8\_t option\_len){ uint32\_t value = 0; while (option\_len--) { value <<= 8; value |= \*(\*packet\_data\_pptr)++; } return value;}
/\*\* \* \fn static uint8\_t sn\_coap\_parser\_options\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr) \* \* \brief Parses CoAP message's Options part from given Packet data \* \* \param \*\*packet\_data\_pptr is source of Packet data to be parsed to CoAP message \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \return Return value is 0 in ok case and -1 in failure case \*/static int8\_t sn\_coap\_parser\_options\_parse(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, uint8\_t \*packet\_data\_start\_ptr, uint16\_t packet\_len){ uint8\_t previous\_option\_number = 0; uint8\_t i = 0; int8\_t ret\_status = 0; uint16\_t message\_left = 0;
 /\* Parse token, if exists \*/ dst\_coap\_msg\_ptr->token\_len = \*packet\_data\_start\_ptr & COAP\_HEADER\_TOKEN\_LENGTH\_MASK;
 if (dst\_coap\_msg\_ptr->token\_len) { if ((dst\_coap\_msg\_ptr->token\_len > 8) || dst\_coap\_msg\_ptr->token\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - token not valid!"); return -1; }
 dst\_coap\_msg\_ptr->token\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, dst\_coap\_msg\_ptr->token\_len);
 if (dst\_coap\_msg\_ptr->token\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - failed to allocate token!"); return -1; }
 (\*packet\_data\_pptr) += dst\_coap\_msg\_ptr->token\_len; }
 message\_left = packet\_len - ((\*packet\_data\_pptr) - packet\_data\_start\_ptr);
 /\* Loop all Options \*/ while (message\_left && (\*\*packet\_data\_pptr != 0xff)) {
 /\* Get option length WITHOUT extensions \*/ uint16\_t option\_len = (\*\*packet\_data\_pptr & 0x0F);
 /\* Resolve option delta \*/ uint16\_t option\_number = (\*\*packet\_data\_pptr >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT);
 if (option\_number == 13) { option\_number = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_number == 14) { option\_number = \*(\*packet\_data\_pptr + 2); option\_number += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } /\* Option number 15 reserved for payload marker. This is handled as a error! \*/ else if (option\_number == 15) { tr\_error("sn\_coap\_parser\_options\_parse - invalid option number(15)!"); return -1; }
 /\* Add previous option to option delta and get option number \*/ option\_number += previous\_option\_number;
 /\* Add possible option length extension to resolve full length of the option \*/ if (option\_len == 13) { option\_len = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_len == 14) { option\_len = \*(\*packet\_data\_pptr + 2); option\_len += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } /\* Option number length 15 is reserved for the future use - ERROR \*/ else if (option\_len == 15) { tr\_error("sn\_coap\_parser\_options\_parse - invalid option len(15)!"); return -1; }
 message\_left = packet\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 /\* \* \* Parse option itself \* \* \*/ /\* Some options are handled independently in own functions \*/ previous\_option\_number = option\_number; /\* Allocate options\_list\_ptr if needed \*/ switch (option\_number) { case COAP\_OPTION\_MAX\_AGE: case COAP\_OPTION\_PROXY\_URI: case COAP\_OPTION\_ETAG: case COAP\_OPTION\_URI\_HOST: case COAP\_OPTION\_LOCATION\_PATH: case COAP\_OPTION\_URI\_PORT: case COAP\_OPTION\_LOCATION\_QUERY: case COAP\_OPTION\_OBSERVE: case COAP\_OPTION\_URI\_QUERY: case COAP\_OPTION\_BLOCK2: case COAP\_OPTION\_BLOCK1: case COAP\_OPTION\_ACCEPT: case COAP\_OPTION\_SIZE1: case COAP\_OPTION\_SIZE2: if (sn\_coap\_parser\_alloc\_options(handle, dst\_coap\_msg\_ptr) == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - failed to allocate options!"); return -1; } break; }
 /\* Parse option \*/ switch (option\_number) { case COAP\_OPTION\_CONTENT\_FORMAT: if ((option\_len > 2) || (dst\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE)) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_CONTENT\_FORMAT not valid!"); return -1; } (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->content\_format = (sn\_coap\_content\_format\_e) sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_MAX\_AGE: if (option\_len > 4) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_MAX\_AGE not valid!"); return -1; } (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->max\_age = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_PROXY\_URI: if ((option\_len > 1034) || (option\_len < 1) || dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_PROXY\_URI not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_len = option\_len; (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, option\_len);
 if (dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_PROXY\_URI allocation failed!"); return -1; }
 (\*packet\_data\_pptr) += option\_len;
 break;
 case COAP\_OPTION\_ETAG: /\* This is managed independently because User gives this option in one character table \*/
 ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->etag\_ptr, (uint16\_t \*)&dst\_coap\_msg\_ptr->options\_list\_ptr->etag\_len, COAP\_OPTION\_ETAG, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_ETAG not valid!"); return -1; } break;
 case COAP\_OPTION\_URI\_HOST: if ((option\_len > 255) || (option\_len < 1) || dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_HOST not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_len = option\_len; (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, option\_len);
 if (dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_HOST allocation failed!"); return -1; } (\*packet\_data\_pptr) += option\_len;
 break;
 case COAP\_OPTION\_LOCATION\_PATH: if (dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_PATH exists!"); return -1; } /\* This is managed independently because User gives this option in one character table \*/ ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_len, COAP\_OPTION\_LOCATION\_PATH, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_PATH not valid!"); return -1; }
 break;
 case COAP\_OPTION\_URI\_PORT: if ((option\_len > 2) || dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_PORT not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_port = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_LOCATION\_QUERY: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_query\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_query\_len, COAP\_OPTION\_LOCATION\_QUERY, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_QUERY not valid!"); return -1; }
 break;
 case COAP\_OPTION\_URI\_PATH: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->uri\_path\_ptr, &dst\_coap\_msg\_ptr->uri\_path\_len, COAP\_OPTION\_URI\_PATH, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_PATH not valid!"); return -1; }
 break;
 case COAP\_OPTION\_OBSERVE: if ((option\_len > 2) || dst\_coap\_msg\_ptr->options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_OBSERVE not valid!"); return -1; }
 (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->observe = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_URI\_QUERY: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_query\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_query\_len, COAP\_OPTION\_URI\_QUERY, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_QUERY not valid!"); return -1; }
 break;
 case COAP\_OPTION\_BLOCK2: if ((option\_len > 3) || dst\_coap\_msg\_ptr->options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_BLOCK2 not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->block2 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_BLOCK1: if ((option\_len > 3) || dst\_coap\_msg\_ptr->options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_BLOCK1 not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->block1 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_ACCEPT: if ((option\_len > 2) || (dst\_coap\_msg\_ptr->options\_list\_ptr->accept != COAP\_CT\_NONE)) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_ACCEPT not valid!"); return -1; }
 (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->accept = (sn\_coap\_content\_format\_e) sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_SIZE1: if ((option\_len > 4) || dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size1) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_SIZE1 not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size1 = true; (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->size1 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_SIZE2: if ((option\_len > 4) || dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_SIZE2 not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size2 = true; (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->size2 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 default: tr\_error("sn\_coap\_parser\_options\_parse - unknown option!"); return -1; }
 /\* Check for overflow \*/ if ((\*packet\_data\_pptr - packet\_data\_start\_ptr) > packet\_len) { return -1; }
 message\_left = packet\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 }
 return 0;}
/\*\* \* \fn static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(uint8\_t \*\*packet\_data\_pptr, uint8\_t options\_count\_left, uint8\_t \*previous\_option\_number\_ptr, uint8\_t \*\*dst\_pptr, \* uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len) \* \* \brief Parses CoAP message's Uri-query options \* \* \param \*\*packet\_data\_pptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \param options\_count\_left tells how many options are unhandled in Packet data \* \* \param \*previous\_option\_number\_ptr is pointer to used and returned previous Option number \* \* \return Return value is count of Uri-query optios parsed. In failure case -1 is returned.\*/static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, uint16\_t packet\_left\_len, uint8\_t \*\*dst\_pptr, uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len){ int16\_t uri\_query\_needed\_heap = sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(\*packet\_data\_pptr, packet\_left\_len, option, option\_number\_len); uint8\_t \*temp\_parsed\_uri\_query\_ptr = NULL; uint8\_t returned\_option\_counter = 0;
 if (uri\_query\_needed\_heap == -1) { return -1; }
 if (uri\_query\_needed\_heap) { \*dst\_pptr = (uint8\_t \*) handle->sn\_coap\_protocol\_malloc(uri\_query\_needed\_heap);
 if (\*dst\_pptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse\_multiple\_options - failed to allocate options!"); return -1; } }
 \*dst\_len\_ptr = uri\_query\_needed\_heap;
 temp\_parsed\_uri\_query\_ptr = \*dst\_pptr;
 /\* Loop all Uri-Query options \*/ while ((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) < uri\_query\_needed\_heap) { /\* Check if this is first Uri-Query option \*/ if (returned\_option\_counter > 0) { /\* Uri-Query is modified to following format: temp1'\0'temp2'\0'temp3 i.e. \*/ /\* Uri-Path is modified to following format: temp1\temp2\temp3 i.e. \*/ if (option == COAP\_OPTION\_URI\_QUERY || option == COAP\_OPTION\_LOCATION\_QUERY || option == COAP\_OPTION\_ETAG || option == COAP\_OPTION\_ACCEPT) { \*temp\_parsed\_uri\_query\_ptr = '&'; } else if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { \*temp\_parsed\_uri\_query\_ptr = '/'; }
 temp\_parsed\_uri\_query\_ptr++; }
 returned\_option\_counter++;
 (\*packet\_data\_pptr)++;
 if (((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) + option\_number\_len) > uri\_query\_needed\_heap) { return -1; }
 memcpy(temp\_parsed\_uri\_query\_ptr, \*packet\_data\_pptr, option\_number\_len);
 (\*packet\_data\_pptr) += option\_number\_len; temp\_parsed\_uri\_query\_ptr += option\_number\_len;
 if ((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) >= uri\_query\_needed\_heap || ((\*\*packet\_data\_pptr >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT) != 0)) { return returned\_option\_counter; }
 option\_number\_len = (\*\*packet\_data\_pptr & 0x0F); if (option\_number\_len == 13) { option\_number\_len = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_number\_len == 14) { option\_number\_len = \*(\*packet\_data\_pptr + 2); option\_number\_len += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } }
 return returned\_option\_counter;}
/\*\* \* \fn static uint16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(uint8\_t \*packet\_data\_ptr, uint8\_t options\_count\_left, uint8\_t previous\_option\_number, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len) \* \* \brief Counts needed memory for uri query option \* \* \param \*packet\_data\_ptr is start of source for Packet data to be parsed to CoAP message \* \* \param options\_count\_left tells how many options are unhandled in Packet data \* \* \param previous\_option\_number is previous Option number \* \* \param sn\_coap\_option\_numbers\_e option option number to be calculated \* \* \param uint16\_t option\_number\_len length of the first option part \*/static int16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(const uint8\_t \*packet\_data\_ptr, uint16\_t packet\_left\_len, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len){ uint16\_t ret\_value = 0; uint16\_t i = 1;
 /\* Loop all Uri-Query options \*/ while (i <= packet\_left\_len) { if (option == COAP\_OPTION\_LOCATION\_PATH && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_URI\_PATH && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_URI\_QUERY && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_LOCATION\_QUERY && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_ACCEPT && option\_number\_len > 2) { return -1; } if (option == COAP\_OPTION\_ETAG && option\_number\_len > 8) { return -1; }
 i += option\_number\_len; ret\_value += option\_number\_len + 1; /\* + 1 is for separator \*/
 if( i == packet\_left\_len ) { break; } else if( i > packet\_left\_len ) { return -1; }
 if ((\*(packet\_data\_ptr + i) >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT) != 0) { return (ret\_value - 1); /\* -1 because last Part path does not include separator \*/ }
 option\_number\_len = (\*(packet\_data\_ptr + i) & 0x0F);
 if (option\_number\_len == 13) {
 if(i + 1 >= packet\_left\_len) { return -1; }
 i++; option\_number\_len = \*(packet\_data\_ptr + i) + 13; } else if (option\_number\_len == 14) {
 if(i + 2 >= packet\_left\_len) { return -1; }
 option\_number\_len = \*(packet\_data\_ptr + i + 2); option\_number\_len += (\*(packet\_data\_ptr + i + 1) << 8) + 269; i += 2; } else if (option\_number\_len == 15) { return -1; } i++;
 }
 if (ret\_value != 0) { return (ret\_value - 1); /\* -1 because last Part path does not include separator \*/ } else { return 0; }}
/\*\* \* \fn static void sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr) \* \* \brief Parses CoAP message's Payload part from given Packet data \* \* \param packet\_data\_len is length of given Packet data to be parsed to CoAP message \* \* \param \*packet\_data\_ptr is start of source for Packet data to be parsed to CoAP message \* \* \param \*\*packet\_data\_pptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/static int8\_t sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_start\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr){ /\* If there is payload \*/ if ((\*packet\_data\_pptr - packet\_data\_start\_ptr) < packet\_data\_len) { if (\*\*packet\_data\_pptr == 0xff) { (\*packet\_data\_pptr)++; /\* Parse Payload length \*/ dst\_coap\_msg\_ptr->payload\_len = packet\_data\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 /\* The presence of a marker followed by a zero-length payload MUST be processed as a message format error \*/ if (dst\_coap\_msg\_ptr->payload\_len == 0) { return -1; }
 /\* Parse Payload by setting CoAP message's payload\_ptr to point Payload in Packet data \*/ dst\_coap\_msg\_ptr->payload\_ptr = \*packet\_data\_pptr; } /\* No payload marker.. \*/ else { tr\_error("sn\_coap\_parser\_payload\_parse - payload marker not found!"); return -1; } } return 0;}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_e427874d_20250120_231414.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd91ed5fa42ea0f32e4422a3c562e7b045a17da40%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_parser.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd91ed5fa42ea0f32e4422a3c562e7b045a17da40%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_parser.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

## Files

 d91ed5f
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)
2. /[features](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source)
/
# sn\_coap\_parser.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARMmbed/mbed-os/commits/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c)807 lines (655 loc) · 32.1 KB d91ed5f
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)
2. /[features](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source)
/
# sn\_coap\_parser.c

Top
## File metadata and controls

* Code
* Blame

807 lines (655 loc) · 32.1 KB[Raw](https://github.com/ARMmbed/mbed-os/raw/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806/\* \* Copyright (c) 2011-2015 ARM Limited. All rights reserved. \* SPDX-License-Identifier: Apache-2.0 \* Licensed under the Apache License, Version 2.0 (the License); you may \* not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an AS IS BASIS, WITHOUT \* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
/\*\* \*\file sn\_coap\_parser.c \* \* \brief CoAP Header parser \* \* Functionality: Parses CoAP Header \* \*/
/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* INCLUDE FILES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
#include <stdio.h>#include <string.h> /\* For memset() and memcpy() \*/
#include "ns\_types.h"#include "mbed-coap/sn\_coap\_header.h"#include "mbed-coap/sn\_coap\_protocol.h"#include "sn\_coap\_header\_internal.h"#include "sn\_coap\_protocol\_internal.h"#include "mbed-trace/mbed\_trace.h"
#define TRACE\_GROUP "coap"/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* LOCAL FUNCTION PROTOTYPES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr);static int8\_t sn\_coap\_parser\_options\_parse(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, uint8\_t \*packet\_data\_start\_ptr, uint16\_t packet\_len);static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, uint16\_t packet\_left\_len, uint8\_t \*\*dst\_pptr, uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len);static int16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(const uint8\_t \*packet\_data\_ptr, uint16\_t packet\_left\_len, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len);static int8\_t sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_start\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr);
sn\_coap\_hdr\_s \*sn\_coap\_parser\_init\_message(sn\_coap\_hdr\_s \*coap\_msg\_ptr){ /\* \* \* \* Check given pointer \* \* \* \*/ if (coap\_msg\_ptr == NULL) { tr\_error("sn\_coap\_parser\_init\_message - message null!"); return NULL; }
 /\* XXX not technically legal to memset pointers to 0 \*/ memset(coap\_msg\_ptr, 0x00, sizeof(sn\_coap\_hdr\_s));
 coap\_msg\_ptr->content\_format = COAP\_CT\_NONE;
 return coap\_msg\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser\_alloc\_message\_with\_options(struct coap\_s \*handle){ // check the handle just as in any other place if (handle == NULL) { return NULL; }
 sn\_coap\_hdr\_s \*coap\_msg\_ptr = sn\_coap\_parser\_alloc\_message(handle);
 sn\_coap\_options\_list\_s \*options\_list\_ptr = sn\_coap\_parser\_alloc\_options(handle, coap\_msg\_ptr);
 if ((coap\_msg\_ptr == NULL) || (options\_list\_ptr == NULL)) {
 // oops, out of memory free if got already any handle->sn\_coap\_protocol\_free(coap\_msg\_ptr); handle->sn\_coap\_protocol\_free(options\_list\_ptr);
 coap\_msg\_ptr = NULL; }
 return coap\_msg\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser\_alloc\_message(struct coap\_s \*handle){ sn\_coap\_hdr\_s \*returned\_coap\_msg\_ptr;
 /\* \* \* \* Check given pointer \* \* \* \*/ if (handle == NULL) { return NULL; }
 /\* \* \* \* Allocate memory for returned CoAP message and initialize allocated memory with with default values \* \* \* \*/ returned\_coap\_msg\_ptr = handle->sn\_coap\_protocol\_malloc(sizeof(sn\_coap\_hdr\_s));
 return sn\_coap\_parser\_init\_message(returned\_coap\_msg\_ptr);}
sn\_coap\_options\_list\_s \*sn\_coap\_parser\_alloc\_options(struct coap\_s \*handle, sn\_coap\_hdr\_s \*coap\_msg\_ptr){ sn\_coap\_options\_list\_s \*options\_list\_ptr;
 /\* \* \* \* Check given pointers \* \* \* \*/ if (handle == NULL || coap\_msg\_ptr == NULL) { return NULL; }
 /\* \* \* \* If the message already has options, return them \* \* \* \*/ if (coap\_msg\_ptr->options\_list\_ptr) { return coap\_msg\_ptr->options\_list\_ptr; }
 /\* \* \* \* Allocate memory for options and initialize allocated memory with with default values \* \* \* \*/ /\* XXX not technically legal to memset pointers to 0 \*/ options\_list\_ptr = sn\_coap\_protocol\_calloc(handle, sizeof(sn\_coap\_options\_list\_s));
 if (options\_list\_ptr == NULL) { tr\_error("sn\_coap\_parser\_alloc\_options - failed to allocate options list!"); return NULL; }
 coap\_msg\_ptr->options\_list\_ptr = options\_list\_ptr;
 options\_list\_ptr->uri\_port = COAP\_OPTION\_URI\_PORT\_NONE; options\_list\_ptr->observe = COAP\_OBSERVE\_NONE; options\_list\_ptr->accept = COAP\_CT\_NONE; options\_list\_ptr->block2 = COAP\_OPTION\_BLOCK\_NONE; options\_list\_ptr->block1 = COAP\_OPTION\_BLOCK\_NONE;
 return options\_list\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser(struct coap\_s \*handle, uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_ptr, coap\_version\_e \*coap\_version\_ptr){ uint8\_t \*data\_temp\_ptr = packet\_data\_ptr; sn\_coap\_hdr\_s \*parsed\_and\_returned\_coap\_msg\_ptr = NULL;
 /\* \* \* \* Check given pointer \* \* \* \*/ if (packet\_data\_ptr == NULL || packet\_data\_len < 4 || handle == NULL) { return NULL; }
 /\* \* \* \* Allocate and initialize CoAP message \* \* \* \*/ parsed\_and\_returned\_coap\_msg\_ptr = sn\_coap\_parser\_alloc\_message(handle);
 if (parsed\_and\_returned\_coap\_msg\_ptr == NULL) { tr\_error("sn\_coap\_parser - failed to allocate message!"); return NULL; }
 /\* \* \* \* Header parsing, move pointer over the header... \* \* \* \*/ sn\_coap\_parser\_header\_parse(&data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr, coap\_version\_ptr);
 /\* \* \* \* Options parsing, move pointer over the options... \* \* \* \*/ if (sn\_coap\_parser\_options\_parse(handle, &data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr, packet\_data\_ptr, packet\_data\_len) != 0) { parsed\_and\_returned\_coap\_msg\_ptr->coap\_status = COAP\_STATUS\_PARSER\_ERROR\_IN\_HEADER; return parsed\_and\_returned\_coap\_msg\_ptr; }
 /\* \* \* \* Payload parsing \* \* \* \*/ if (sn\_coap\_parser\_payload\_parse(packet\_data\_len, packet\_data\_ptr, &data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr) == -1) { parsed\_and\_returned\_coap\_msg\_ptr->coap\_status = COAP\_STATUS\_PARSER\_ERROR\_IN\_HEADER; return parsed\_and\_returned\_coap\_msg\_ptr; }
 /\* \* \* \* Return parsed CoAP message \* \* \* \* \*/ return parsed\_and\_returned\_coap\_msg\_ptr;}
void sn\_coap\_parser\_release\_allocated\_coap\_msg\_mem(struct coap\_s \*handle, sn\_coap\_hdr\_s \*freed\_coap\_msg\_ptr){ if (handle == NULL) { return; }
 if (freed\_coap\_msg\_ptr != NULL) {
 // As there are multiple sequential calls to the protocol\_free, caching pointer to it // saves one instruction per call. void (\*local\_free)(void \*) = handle->sn\_coap\_protocol\_free;
 local\_free(freed\_coap\_msg\_ptr->uri\_path\_ptr); local\_free(freed\_coap\_msg\_ptr->token\_ptr);
 // same here, caching the struct start saves a bit. sn\_coap\_options\_list\_s \*options\_list\_ptr = freed\_coap\_msg\_ptr->options\_list\_ptr;
 if (options\_list\_ptr != NULL) {
 local\_free(options\_list\_ptr->proxy\_uri\_ptr);
 local\_free(options\_list\_ptr->etag\_ptr);
 local\_free(options\_list\_ptr->uri\_host\_ptr);
 local\_free(options\_list\_ptr->location\_path\_ptr);
 local\_free(options\_list\_ptr->location\_query\_ptr);
 local\_free(options\_list\_ptr->uri\_query\_ptr);
 local\_free(options\_list\_ptr); }
 local\_free(freed\_coap\_msg\_ptr); }}
/\*\* \* \fn static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr) \* \* \brief Parses CoAP message's Header part from given Packet data \* \* \param \*\*packet\_data\_ptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \param \*coap\_version\_ptr is destination for parsed CoAP specification version \*/static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr){ /\* Parse CoAP Version and message type\*/ \*coap\_version\_ptr = (coap\_version\_e)(\*\*packet\_data\_pptr & COAP\_HEADER\_VERSION\_MASK); dst\_coap\_msg\_ptr->msg\_type = (sn\_coap\_msg\_type\_e)(\*\*packet\_data\_pptr & COAP\_HEADER\_MSG\_TYPE\_MASK); (\*packet\_data\_pptr) += 1;
 /\* Parse Message code \*/ dst\_coap\_msg\_ptr->msg\_code = (sn\_coap\_msg\_code\_e) \*\*packet\_data\_pptr; (\*packet\_data\_pptr) += 1;
 /\* Parse Message ID \*/ dst\_coap\_msg\_ptr->msg\_id = \*(\*packet\_data\_pptr + 1); dst\_coap\_msg\_ptr->msg\_id += \*\*packet\_data\_pptr << COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT; (\*packet\_data\_pptr) += 2;
}
/\*\* \* \brief Parses a variable-length uint value from an option \* \* \param \*\*packet\_data\_pptr is source of option data to be parsed \* \param option\_len is length of option data (will be 0-4) \* \* \return Return value is value of uint \*/static uint32\_t sn\_coap\_parser\_options\_parse\_uint(uint8\_t \*\*packet\_data\_pptr, uint8\_t option\_len){ uint32\_t value = 0; while (option\_len--) { value <<= 8; value |= \*(\*packet\_data\_pptr)++; } return value;}
/\*\* \* \fn static uint8\_t sn\_coap\_parser\_options\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr) \* \* \brief Parses CoAP message's Options part from given Packet data \* \* \param \*\*packet\_data\_pptr is source of Packet data to be parsed to CoAP message \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \return Return value is 0 in ok case and -1 in failure case \*/static int8\_t sn\_coap\_parser\_options\_parse(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, uint8\_t \*packet\_data\_start\_ptr, uint16\_t packet\_len){ uint8\_t previous\_option\_number = 0; uint8\_t i = 0; int8\_t ret\_status = 0; uint16\_t message\_left = 0;
 /\* Parse token, if exists \*/ dst\_coap\_msg\_ptr->token\_len = \*packet\_data\_start\_ptr & COAP\_HEADER\_TOKEN\_LENGTH\_MASK;
 if (dst\_coap\_msg\_ptr->token\_len) { if ((dst\_coap\_msg\_ptr->token\_len > 8) || dst\_coap\_msg\_ptr->token\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - token not valid!"); return -1; }
 dst\_coap\_msg\_ptr->token\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, dst\_coap\_msg\_ptr->token\_len);
 if (dst\_coap\_msg\_ptr->token\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - failed to allocate token!"); return -1; }
 (\*packet\_data\_pptr) += dst\_coap\_msg\_ptr->token\_len; }
 message\_left = packet\_len - ((\*packet\_data\_pptr) - packet\_data\_start\_ptr);
 /\* Loop all Options \*/ while (message\_left && (\*\*packet\_data\_pptr != 0xff)) {
 /\* Get option length WITHOUT extensions \*/ uint16\_t option\_len = (\*\*packet\_data\_pptr & 0x0F);
 /\* Resolve option delta \*/ uint16\_t option\_number = (\*\*packet\_data\_pptr >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT);
 if (option\_number == 13) { option\_number = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_number == 14) { option\_number = \*(\*packet\_data\_pptr + 2); option\_number += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } /\* Option number 15 reserved for payload marker. This is handled as a error! \*/ else if (option\_number == 15) { tr\_error("sn\_coap\_parser\_options\_parse - invalid option number(15)!"); return -1; }
 /\* Add previous option to option delta and get option number \*/ option\_number += previous\_option\_number;
 /\* Add possible option length extension to resolve full length of the option \*/ if (option\_len == 13) { option\_len = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_len == 14) { option\_len = \*(\*packet\_data\_pptr + 2); option\_len += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } /\* Option number length 15 is reserved for the future use - ERROR \*/ else if (option\_len == 15) { tr\_error("sn\_coap\_parser\_options\_parse - invalid option len(15)!"); return -1; }
 message\_left = packet\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 /\* \* \* Parse option itself \* \* \*/ /\* Some options are handled independently in own functions \*/ previous\_option\_number = option\_number; /\* Allocate options\_list\_ptr if needed \*/ switch (option\_number) { case COAP\_OPTION\_MAX\_AGE: case COAP\_OPTION\_PROXY\_URI: case COAP\_OPTION\_ETAG: case COAP\_OPTION\_URI\_HOST: case COAP\_OPTION\_LOCATION\_PATH: case COAP\_OPTION\_URI\_PORT: case COAP\_OPTION\_LOCATION\_QUERY: case COAP\_OPTION\_OBSERVE: case COAP\_OPTION\_URI\_QUERY: case COAP\_OPTION\_BLOCK2: case COAP\_OPTION\_BLOCK1: case COAP\_OPTION\_ACCEPT: case COAP\_OPTION\_SIZE1: case COAP\_OPTION\_SIZE2: if (sn\_coap\_parser\_alloc\_options(handle, dst\_coap\_msg\_ptr) == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - failed to allocate options!"); return -1; } break; }
 /\* Parse option \*/ switch (option\_number) { case COAP\_OPTION\_CONTENT\_FORMAT: if ((option\_len > 2) || (dst\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE)) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_CONTENT\_FORMAT not valid!"); return -1; } (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->content\_format = (sn\_coap\_content\_format\_e) sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_MAX\_AGE: if (option\_len > 4) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_MAX\_AGE not valid!"); return -1; } (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->max\_age = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_PROXY\_URI: if ((option\_len > 1034) || (option\_len < 1) || dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_PROXY\_URI not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_len = option\_len; (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, option\_len);
 if (dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_PROXY\_URI allocation failed!"); return -1; }
 (\*packet\_data\_pptr) += option\_len;
 break;
 case COAP\_OPTION\_ETAG: /\* This is managed independently because User gives this option in one character table \*/
 ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->etag\_ptr, (uint16\_t \*)&dst\_coap\_msg\_ptr->options\_list\_ptr->etag\_len, COAP\_OPTION\_ETAG, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_ETAG not valid!"); return -1; } break;
 case COAP\_OPTION\_URI\_HOST: if ((option\_len > 255) || (option\_len < 1) || dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_HOST not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_len = option\_len; (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, option\_len);
 if (dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_HOST allocation failed!"); return -1; } (\*packet\_data\_pptr) += option\_len;
 break;
 case COAP\_OPTION\_LOCATION\_PATH: if (dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_PATH exists!"); return -1; } /\* This is managed independently because User gives this option in one character table \*/ ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_len, COAP\_OPTION\_LOCATION\_PATH, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_PATH not valid!"); return -1; }
 break;
 case COAP\_OPTION\_URI\_PORT: if ((option\_len > 2) || dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_PORT not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_port = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_LOCATION\_QUERY: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_query\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_query\_len, COAP\_OPTION\_LOCATION\_QUERY, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_QUERY not valid!"); return -1; }
 break;
 case COAP\_OPTION\_URI\_PATH: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->uri\_path\_ptr, &dst\_coap\_msg\_ptr->uri\_path\_len, COAP\_OPTION\_URI\_PATH, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_PATH not valid!"); return -1; }
 break;
 case COAP\_OPTION\_OBSERVE: if ((option\_len > 2) || dst\_coap\_msg\_ptr->options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_OBSERVE not valid!"); return -1; }
 (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->observe = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_URI\_QUERY: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_query\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_query\_len, COAP\_OPTION\_URI\_QUERY, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_QUERY not valid!"); return -1; }
 break;
 case COAP\_OPTION\_BLOCK2: if ((option\_len > 3) || dst\_coap\_msg\_ptr->options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_BLOCK2 not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->block2 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_BLOCK1: if ((option\_len > 3) || dst\_coap\_msg\_ptr->options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_BLOCK1 not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->block1 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_ACCEPT: if ((option\_len > 2) || (dst\_coap\_msg\_ptr->options\_list\_ptr->accept != COAP\_CT\_NONE)) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_ACCEPT not valid!"); return -1; }
 (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->accept = (sn\_coap\_content\_format\_e) sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_SIZE1: if ((option\_len > 4) || dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size1) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_SIZE1 not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size1 = true; (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->size1 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_SIZE2: if ((option\_len > 4) || dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_SIZE2 not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size2 = true; (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->size2 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 default: tr\_error("sn\_coap\_parser\_options\_parse - unknown option!"); return -1; }
 /\* Check for overflow \*/ if ((\*packet\_data\_pptr - packet\_data\_start\_ptr) > packet\_len) { return -1; }
 message\_left = packet\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 }
 return 0;}
/\*\* \* \fn static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(uint8\_t \*\*packet\_data\_pptr, uint8\_t options\_count\_left, uint8\_t \*previous\_option\_number\_ptr, uint8\_t \*\*dst\_pptr, \* uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len) \* \* \brief Parses CoAP message's Uri-query options \* \* \param \*\*packet\_data\_pptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \param options\_count\_left tells how many options are unhandled in Packet data \* \* \param \*previous\_option\_number\_ptr is pointer to used and returned previous Option number \* \* \return Return value is count of Uri-query optios parsed. In failure case -1 is returned.\*/static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, uint16\_t packet\_left\_len, uint8\_t \*\*dst\_pptr, uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len){ int16\_t uri\_query\_needed\_heap = sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(\*packet\_data\_pptr, packet\_left\_len, option, option\_number\_len); uint8\_t \*temp\_parsed\_uri\_query\_ptr = NULL; uint8\_t returned\_option\_counter = 0;
 if (uri\_query\_needed\_heap == -1) { return -1; }
 if (uri\_query\_needed\_heap) { \*dst\_pptr = (uint8\_t \*) handle->sn\_coap\_protocol\_malloc(uri\_query\_needed\_heap);
 if (\*dst\_pptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse\_multiple\_options - failed to allocate options!"); return -1; } }
 \*dst\_len\_ptr = uri\_query\_needed\_heap;
 temp\_parsed\_uri\_query\_ptr = \*dst\_pptr;
 /\* Loop all Uri-Query options \*/ while ((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) < uri\_query\_needed\_heap) { /\* Check if this is first Uri-Query option \*/ if (returned\_option\_counter > 0) { /\* Uri-Query is modified to following format: temp1'\0'temp2'\0'temp3 i.e. \*/ /\* Uri-Path is modified to following format: temp1\temp2\temp3 i.e. \*/ if (option == COAP\_OPTION\_URI\_QUERY || option == COAP\_OPTION\_LOCATION\_QUERY || option == COAP\_OPTION\_ETAG || option == COAP\_OPTION\_ACCEPT) { \*temp\_parsed\_uri\_query\_ptr = '&'; } else if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { \*temp\_parsed\_uri\_query\_ptr = '/'; }
 temp\_parsed\_uri\_query\_ptr++; }
 returned\_option\_counter++;
 (\*packet\_data\_pptr)++;
 if (((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) + option\_number\_len) > uri\_query\_needed\_heap) { return -1; }
 memcpy(temp\_parsed\_uri\_query\_ptr, \*packet\_data\_pptr, option\_number\_len);
 (\*packet\_data\_pptr) += option\_number\_len; temp\_parsed\_uri\_query\_ptr += option\_number\_len;
 if ((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) >= uri\_query\_needed\_heap || ((\*\*packet\_data\_pptr >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT) != 0)) { return returned\_option\_counter; }
 option\_number\_len = (\*\*packet\_data\_pptr & 0x0F); if (option\_number\_len == 13) { option\_number\_len = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_number\_len == 14) { option\_number\_len = \*(\*packet\_data\_pptr + 2); option\_number\_len += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } }
 return returned\_option\_counter;}
/\*\* \* \fn static uint16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(uint8\_t \*packet\_data\_ptr, uint8\_t options\_count\_left, uint8\_t previous\_option\_number, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len) \* \* \brief Counts needed memory for uri query option \* \* \param \*packet\_data\_ptr is start of source for Packet data to be parsed to CoAP message \* \* \param options\_count\_left tells how many options are unhandled in Packet data \* \* \param previous\_option\_number is previous Option number \* \* \param sn\_coap\_option\_numbers\_e option option number to be calculated \* \* \param uint16\_t option\_number\_len length of the first option part \*/static int16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(const uint8\_t \*packet\_data\_ptr, uint16\_t packet\_left\_len, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len){ uint16\_t ret\_value = 0; uint16\_t i = 1;
 /\* Loop all Uri-Query options \*/ while (i <= packet\_left\_len) { if (option == COAP\_OPTION\_LOCATION\_PATH && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_URI\_PATH && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_URI\_QUERY && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_LOCATION\_QUERY && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_ACCEPT && option\_number\_len > 2) { return -1; } if (option == COAP\_OPTION\_ETAG && option\_number\_len > 8) { return -1; }
 i += option\_number\_len; ret\_value += option\_number\_len + 1; /\* + 1 is for separator \*/
 if( i == packet\_left\_len ) { break; } else if( i > packet\_left\_len ) { return -1; }
 if ((\*(packet\_data\_ptr + i) >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT) != 0) { return (ret\_value - 1); /\* -1 because last Part path does not include separator \*/ }
 option\_number\_len = (\*(packet\_data\_ptr + i) & 0x0F);
 if (option\_number\_len == 13) {
 if(i + 1 >= packet\_left\_len) { return -1; }
 i++; option\_number\_len = \*(packet\_data\_ptr + i) + 13; } else if (option\_number\_len == 14) {
 if(i + 2 >= packet\_left\_len) { return -1; }
 option\_number\_len = \*(packet\_data\_ptr + i + 2); option\_number\_len += (\*(packet\_data\_ptr + i + 1) << 8) + 269; i += 2; } else if (option\_number\_len == 15) { return -1; } i++;
 }
 if (ret\_value != 0) { return (ret\_value - 1); /\* -1 because last Part path does not include separator \*/ } else { return 0; }}
/\*\* \* \fn static void sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr) \* \* \brief Parses CoAP message's Payload part from given Packet data \* \* \param packet\_data\_len is length of given Packet data to be parsed to CoAP message \* \* \param \*packet\_data\_ptr is start of source for Packet data to be parsed to CoAP message \* \* \param \*\*packet\_data\_pptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/static int8\_t sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_start\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr){ /\* If there is payload \*/ if ((\*packet\_data\_pptr - packet\_data\_start\_ptr) < packet\_data\_len) { if (\*\*packet\_data\_pptr == 0xff) { (\*packet\_data\_pptr)++; /\* Parse Payload length \*/ dst\_coap\_msg\_ptr->payload\_len = packet\_data\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 /\* The presence of a marker followed by a zero-length payload MUST be processed as a message format error \*/ if (dst\_coap\_msg\_ptr->payload\_len == 0) { return -1; }
 /\* Parse Payload by setting CoAP message's payload\_ptr to point Payload in Packet data \*/ dst\_coap\_msg\_ptr->payload\_ptr = \*packet\_data\_pptr; } /\* No payload marker.. \*/ else { tr\_error("sn\_coap\_parser\_payload\_parse - payload marker not found!"); return -1; } } return 0;}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_aac9417f_20250120_231408.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd91ed5fa42ea0f32e4422a3c562e7b045a17da40%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_parser.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd91ed5fa42ea0f32e4422a3c562e7b045a17da40%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_parser.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

## Files

 d91ed5f
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)
2. /[features](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source)
/
# sn\_coap\_parser.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARMmbed/mbed-os/commits/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c)807 lines (655 loc) · 32.1 KB d91ed5f
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)
2. /[features](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source)
/
# sn\_coap\_parser.c

Top
## File metadata and controls

* Code
* Blame

807 lines (655 loc) · 32.1 KB[Raw](https://github.com/ARMmbed/mbed-os/raw/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806/\* \* Copyright (c) 2011-2015 ARM Limited. All rights reserved. \* SPDX-License-Identifier: Apache-2.0 \* Licensed under the Apache License, Version 2.0 (the License); you may \* not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an AS IS BASIS, WITHOUT \* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
/\*\* \*\file sn\_coap\_parser.c \* \* \brief CoAP Header parser \* \* Functionality: Parses CoAP Header \* \*/
/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* INCLUDE FILES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
#include <stdio.h>#include <string.h> /\* For memset() and memcpy() \*/
#include "ns\_types.h"#include "mbed-coap/sn\_coap\_header.h"#include "mbed-coap/sn\_coap\_protocol.h"#include "sn\_coap\_header\_internal.h"#include "sn\_coap\_protocol\_internal.h"#include "mbed-trace/mbed\_trace.h"
#define TRACE\_GROUP "coap"/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* LOCAL FUNCTION PROTOTYPES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr);static int8\_t sn\_coap\_parser\_options\_parse(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, uint8\_t \*packet\_data\_start\_ptr, uint16\_t packet\_len);static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, uint16\_t packet\_left\_len, uint8\_t \*\*dst\_pptr, uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len);static int16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(const uint8\_t \*packet\_data\_ptr, uint16\_t packet\_left\_len, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len);static int8\_t sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_start\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr);
sn\_coap\_hdr\_s \*sn\_coap\_parser\_init\_message(sn\_coap\_hdr\_s \*coap\_msg\_ptr){ /\* \* \* \* Check given pointer \* \* \* \*/ if (coap\_msg\_ptr == NULL) { tr\_error("sn\_coap\_parser\_init\_message - message null!"); return NULL; }
 /\* XXX not technically legal to memset pointers to 0 \*/ memset(coap\_msg\_ptr, 0x00, sizeof(sn\_coap\_hdr\_s));
 coap\_msg\_ptr->content\_format = COAP\_CT\_NONE;
 return coap\_msg\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser\_alloc\_message\_with\_options(struct coap\_s \*handle){ // check the handle just as in any other place if (handle == NULL) { return NULL; }
 sn\_coap\_hdr\_s \*coap\_msg\_ptr = sn\_coap\_parser\_alloc\_message(handle);
 sn\_coap\_options\_list\_s \*options\_list\_ptr = sn\_coap\_parser\_alloc\_options(handle, coap\_msg\_ptr);
 if ((coap\_msg\_ptr == NULL) || (options\_list\_ptr == NULL)) {
 // oops, out of memory free if got already any handle->sn\_coap\_protocol\_free(coap\_msg\_ptr); handle->sn\_coap\_protocol\_free(options\_list\_ptr);
 coap\_msg\_ptr = NULL; }
 return coap\_msg\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser\_alloc\_message(struct coap\_s \*handle){ sn\_coap\_hdr\_s \*returned\_coap\_msg\_ptr;
 /\* \* \* \* Check given pointer \* \* \* \*/ if (handle == NULL) { return NULL; }
 /\* \* \* \* Allocate memory for returned CoAP message and initialize allocated memory with with default values \* \* \* \*/ returned\_coap\_msg\_ptr = handle->sn\_coap\_protocol\_malloc(sizeof(sn\_coap\_hdr\_s));
 return sn\_coap\_parser\_init\_message(returned\_coap\_msg\_ptr);}
sn\_coap\_options\_list\_s \*sn\_coap\_parser\_alloc\_options(struct coap\_s \*handle, sn\_coap\_hdr\_s \*coap\_msg\_ptr){ sn\_coap\_options\_list\_s \*options\_list\_ptr;
 /\* \* \* \* Check given pointers \* \* \* \*/ if (handle == NULL || coap\_msg\_ptr == NULL) { return NULL; }
 /\* \* \* \* If the message already has options, return them \* \* \* \*/ if (coap\_msg\_ptr->options\_list\_ptr) { return coap\_msg\_ptr->options\_list\_ptr; }
 /\* \* \* \* Allocate memory for options and initialize allocated memory with with default values \* \* \* \*/ /\* XXX not technically legal to memset pointers to 0 \*/ options\_list\_ptr = sn\_coap\_protocol\_calloc(handle, sizeof(sn\_coap\_options\_list\_s));
 if (options\_list\_ptr == NULL) { tr\_error("sn\_coap\_parser\_alloc\_options - failed to allocate options list!"); return NULL; }
 coap\_msg\_ptr->options\_list\_ptr = options\_list\_ptr;
 options\_list\_ptr->uri\_port = COAP\_OPTION\_URI\_PORT\_NONE; options\_list\_ptr->observe = COAP\_OBSERVE\_NONE; options\_list\_ptr->accept = COAP\_CT\_NONE; options\_list\_ptr->block2 = COAP\_OPTION\_BLOCK\_NONE; options\_list\_ptr->block1 = COAP\_OPTION\_BLOCK\_NONE;
 return options\_list\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser(struct coap\_s \*handle, uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_ptr, coap\_version\_e \*coap\_version\_ptr){ uint8\_t \*data\_temp\_ptr = packet\_data\_ptr; sn\_coap\_hdr\_s \*parsed\_and\_returned\_coap\_msg\_ptr = NULL;
 /\* \* \* \* Check given pointer \* \* \* \*/ if (packet\_data\_ptr == NULL || packet\_data\_len < 4 || handle == NULL) { return NULL; }
 /\* \* \* \* Allocate and initialize CoAP message \* \* \* \*/ parsed\_and\_returned\_coap\_msg\_ptr = sn\_coap\_parser\_alloc\_message(handle);
 if (parsed\_and\_returned\_coap\_msg\_ptr == NULL) { tr\_error("sn\_coap\_parser - failed to allocate message!"); return NULL; }
 /\* \* \* \* Header parsing, move pointer over the header... \* \* \* \*/ sn\_coap\_parser\_header\_parse(&data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr, coap\_version\_ptr);
 /\* \* \* \* Options parsing, move pointer over the options... \* \* \* \*/ if (sn\_coap\_parser\_options\_parse(handle, &data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr, packet\_data\_ptr, packet\_data\_len) != 0) { parsed\_and\_returned\_coap\_msg\_ptr->coap\_status = COAP\_STATUS\_PARSER\_ERROR\_IN\_HEADER; return parsed\_and\_returned\_coap\_msg\_ptr; }
 /\* \* \* \* Payload parsing \* \* \* \*/ if (sn\_coap\_parser\_payload\_parse(packet\_data\_len, packet\_data\_ptr, &data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr) == -1) { parsed\_and\_returned\_coap\_msg\_ptr->coap\_status = COAP\_STATUS\_PARSER\_ERROR\_IN\_HEADER; return parsed\_and\_returned\_coap\_msg\_ptr; }
 /\* \* \* \* Return parsed CoAP message \* \* \* \* \*/ return parsed\_and\_returned\_coap\_msg\_ptr;}
void sn\_coap\_parser\_release\_allocated\_coap\_msg\_mem(struct coap\_s \*handle, sn\_coap\_hdr\_s \*freed\_coap\_msg\_ptr){ if (handle == NULL) { return; }
 if (freed\_coap\_msg\_ptr != NULL) {
 // As there are multiple sequential calls to the protocol\_free, caching pointer to it // saves one instruction per call. void (\*local\_free)(void \*) = handle->sn\_coap\_protocol\_free;
 local\_free(freed\_coap\_msg\_ptr->uri\_path\_ptr); local\_free(freed\_coap\_msg\_ptr->token\_ptr);
 // same here, caching the struct start saves a bit. sn\_coap\_options\_list\_s \*options\_list\_ptr = freed\_coap\_msg\_ptr->options\_list\_ptr;
 if (options\_list\_ptr != NULL) {
 local\_free(options\_list\_ptr->proxy\_uri\_ptr);
 local\_free(options\_list\_ptr->etag\_ptr);
 local\_free(options\_list\_ptr->uri\_host\_ptr);
 local\_free(options\_list\_ptr->location\_path\_ptr);
 local\_free(options\_list\_ptr->location\_query\_ptr);
 local\_free(options\_list\_ptr->uri\_query\_ptr);
 local\_free(options\_list\_ptr); }
 local\_free(freed\_coap\_msg\_ptr); }}
/\*\* \* \fn static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr) \* \* \brief Parses CoAP message's Header part from given Packet data \* \* \param \*\*packet\_data\_ptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \param \*coap\_version\_ptr is destination for parsed CoAP specification version \*/static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr){ /\* Parse CoAP Version and message type\*/ \*coap\_version\_ptr = (coap\_version\_e)(\*\*packet\_data\_pptr & COAP\_HEADER\_VERSION\_MASK); dst\_coap\_msg\_ptr->msg\_type = (sn\_coap\_msg\_type\_e)(\*\*packet\_data\_pptr & COAP\_HEADER\_MSG\_TYPE\_MASK); (\*packet\_data\_pptr) += 1;
 /\* Parse Message code \*/ dst\_coap\_msg\_ptr->msg\_code = (sn\_coap\_msg\_code\_e) \*\*packet\_data\_pptr; (\*packet\_data\_pptr) += 1;
 /\* Parse Message ID \*/ dst\_coap\_msg\_ptr->msg\_id = \*(\*packet\_data\_pptr + 1); dst\_coap\_msg\_ptr->msg\_id += \*\*packet\_data\_pptr << COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT; (\*packet\_data\_pptr) += 2;
}
/\*\* \* \brief Parses a variable-length uint value from an option \* \* \param \*\*packet\_data\_pptr is source of option data to be parsed \* \param option\_len is length of option data (will be 0-4) \* \* \return Return value is value of uint \*/static uint32\_t sn\_coap\_parser\_options\_parse\_uint(uint8\_t \*\*packet\_data\_pptr, uint8\_t option\_len){ uint32\_t value = 0; while (option\_len--) { value <<= 8; value |= \*(\*packet\_data\_pptr)++; } return value;}
/\*\* \* \fn static uint8\_t sn\_coap\_parser\_options\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr) \* \* \brief Parses CoAP message's Options part from given Packet data \* \* \param \*\*packet\_data\_pptr is source of Packet data to be parsed to CoAP message \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \return Return value is 0 in ok case and -1 in failure case \*/static int8\_t sn\_coap\_parser\_options\_parse(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, uint8\_t \*packet\_data\_start\_ptr, uint16\_t packet\_len){ uint8\_t previous\_option\_number = 0; uint8\_t i = 0; int8\_t ret\_status = 0; uint16\_t message\_left = 0;
 /\* Parse token, if exists \*/ dst\_coap\_msg\_ptr->token\_len = \*packet\_data\_start\_ptr & COAP\_HEADER\_TOKEN\_LENGTH\_MASK;
 if (dst\_coap\_msg\_ptr->token\_len) { if ((dst\_coap\_msg\_ptr->token\_len > 8) || dst\_coap\_msg\_ptr->token\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - token not valid!"); return -1; }
 dst\_coap\_msg\_ptr->token\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, dst\_coap\_msg\_ptr->token\_len);
 if (dst\_coap\_msg\_ptr->token\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - failed to allocate token!"); return -1; }
 (\*packet\_data\_pptr) += dst\_coap\_msg\_ptr->token\_len; }
 message\_left = packet\_len - ((\*packet\_data\_pptr) - packet\_data\_start\_ptr);
 /\* Loop all Options \*/ while (message\_left && (\*\*packet\_data\_pptr != 0xff)) {
 /\* Get option length WITHOUT extensions \*/ uint16\_t option\_len = (\*\*packet\_data\_pptr & 0x0F);
 /\* Resolve option delta \*/ uint16\_t option\_number = (\*\*packet\_data\_pptr >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT);
 if (option\_number == 13) { option\_number = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_number == 14) { option\_number = \*(\*packet\_data\_pptr + 2); option\_number += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } /\* Option number 15 reserved for payload marker. This is handled as a error! \*/ else if (option\_number == 15) { tr\_error("sn\_coap\_parser\_options\_parse - invalid option number(15)!"); return -1; }
 /\* Add previous option to option delta and get option number \*/ option\_number += previous\_option\_number;
 /\* Add possible option length extension to resolve full length of the option \*/ if (option\_len == 13) { option\_len = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_len == 14) { option\_len = \*(\*packet\_data\_pptr + 2); option\_len += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } /\* Option number length 15 is reserved for the future use - ERROR \*/ else if (option\_len == 15) { tr\_error("sn\_coap\_parser\_options\_parse - invalid option len(15)!"); return -1; }
 message\_left = packet\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 /\* \* \* Parse option itself \* \* \*/ /\* Some options are handled independently in own functions \*/ previous\_option\_number = option\_number; /\* Allocate options\_list\_ptr if needed \*/ switch (option\_number) { case COAP\_OPTION\_MAX\_AGE: case COAP\_OPTION\_PROXY\_URI: case COAP\_OPTION\_ETAG: case COAP\_OPTION\_URI\_HOST: case COAP\_OPTION\_LOCATION\_PATH: case COAP\_OPTION\_URI\_PORT: case COAP\_OPTION\_LOCATION\_QUERY: case COAP\_OPTION\_OBSERVE: case COAP\_OPTION\_URI\_QUERY: case COAP\_OPTION\_BLOCK2: case COAP\_OPTION\_BLOCK1: case COAP\_OPTION\_ACCEPT: case COAP\_OPTION\_SIZE1: case COAP\_OPTION\_SIZE2: if (sn\_coap\_parser\_alloc\_options(handle, dst\_coap\_msg\_ptr) == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - failed to allocate options!"); return -1; } break; }
 /\* Parse option \*/ switch (option\_number) { case COAP\_OPTION\_CONTENT\_FORMAT: if ((option\_len > 2) || (dst\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE)) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_CONTENT\_FORMAT not valid!"); return -1; } (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->content\_format = (sn\_coap\_content\_format\_e) sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_MAX\_AGE: if (option\_len > 4) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_MAX\_AGE not valid!"); return -1; } (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->max\_age = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_PROXY\_URI: if ((option\_len > 1034) || (option\_len < 1) || dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_PROXY\_URI not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_len = option\_len; (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, option\_len);
 if (dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_PROXY\_URI allocation failed!"); return -1; }
 (\*packet\_data\_pptr) += option\_len;
 break;
 case COAP\_OPTION\_ETAG: /\* This is managed independently because User gives this option in one character table \*/
 ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->etag\_ptr, (uint16\_t \*)&dst\_coap\_msg\_ptr->options\_list\_ptr->etag\_len, COAP\_OPTION\_ETAG, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_ETAG not valid!"); return -1; } break;
 case COAP\_OPTION\_URI\_HOST: if ((option\_len > 255) || (option\_len < 1) || dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_HOST not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_len = option\_len; (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, option\_len);
 if (dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_HOST allocation failed!"); return -1; } (\*packet\_data\_pptr) += option\_len;
 break;
 case COAP\_OPTION\_LOCATION\_PATH: if (dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_PATH exists!"); return -1; } /\* This is managed independently because User gives this option in one character table \*/ ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_len, COAP\_OPTION\_LOCATION\_PATH, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_PATH not valid!"); return -1; }
 break;
 case COAP\_OPTION\_URI\_PORT: if ((option\_len > 2) || dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_PORT not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_port = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_LOCATION\_QUERY: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_query\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_query\_len, COAP\_OPTION\_LOCATION\_QUERY, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_QUERY not valid!"); return -1; }
 break;
 case COAP\_OPTION\_URI\_PATH: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->uri\_path\_ptr, &dst\_coap\_msg\_ptr->uri\_path\_len, COAP\_OPTION\_URI\_PATH, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_PATH not valid!"); return -1; }
 break;
 case COAP\_OPTION\_OBSERVE: if ((option\_len > 2) || dst\_coap\_msg\_ptr->options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_OBSERVE not valid!"); return -1; }
 (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->observe = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_URI\_QUERY: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_query\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_query\_len, COAP\_OPTION\_URI\_QUERY, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_QUERY not valid!"); return -1; }
 break;
 case COAP\_OPTION\_BLOCK2: if ((option\_len > 3) || dst\_coap\_msg\_ptr->options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_BLOCK2 not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->block2 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_BLOCK1: if ((option\_len > 3) || dst\_coap\_msg\_ptr->options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_BLOCK1 not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->block1 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_ACCEPT: if ((option\_len > 2) || (dst\_coap\_msg\_ptr->options\_list\_ptr->accept != COAP\_CT\_NONE)) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_ACCEPT not valid!"); return -1; }
 (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->accept = (sn\_coap\_content\_format\_e) sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_SIZE1: if ((option\_len > 4) || dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size1) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_SIZE1 not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size1 = true; (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->size1 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_SIZE2: if ((option\_len > 4) || dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_SIZE2 not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size2 = true; (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->size2 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 default: tr\_error("sn\_coap\_parser\_options\_parse - unknown option!"); return -1; }
 /\* Check for overflow \*/ if ((\*packet\_data\_pptr - packet\_data\_start\_ptr) > packet\_len) { return -1; }
 message\_left = packet\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 }
 return 0;}
/\*\* \* \fn static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(uint8\_t \*\*packet\_data\_pptr, uint8\_t options\_count\_left, uint8\_t \*previous\_option\_number\_ptr, uint8\_t \*\*dst\_pptr, \* uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len) \* \* \brief Parses CoAP message's Uri-query options \* \* \param \*\*packet\_data\_pptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \param options\_count\_left tells how many options are unhandled in Packet data \* \* \param \*previous\_option\_number\_ptr is pointer to used and returned previous Option number \* \* \return Return value is count of Uri-query optios parsed. In failure case -1 is returned.\*/static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, uint16\_t packet\_left\_len, uint8\_t \*\*dst\_pptr, uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len){ int16\_t uri\_query\_needed\_heap = sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(\*packet\_data\_pptr, packet\_left\_len, option, option\_number\_len); uint8\_t \*temp\_parsed\_uri\_query\_ptr = NULL; uint8\_t returned\_option\_counter = 0;
 if (uri\_query\_needed\_heap == -1) { return -1; }
 if (uri\_query\_needed\_heap) { \*dst\_pptr = (uint8\_t \*) handle->sn\_coap\_protocol\_malloc(uri\_query\_needed\_heap);
 if (\*dst\_pptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse\_multiple\_options - failed to allocate options!"); return -1; } }
 \*dst\_len\_ptr = uri\_query\_needed\_heap;
 temp\_parsed\_uri\_query\_ptr = \*dst\_pptr;
 /\* Loop all Uri-Query options \*/ while ((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) < uri\_query\_needed\_heap) { /\* Check if this is first Uri-Query option \*/ if (returned\_option\_counter > 0) { /\* Uri-Query is modified to following format: temp1'\0'temp2'\0'temp3 i.e. \*/ /\* Uri-Path is modified to following format: temp1\temp2\temp3 i.e. \*/ if (option == COAP\_OPTION\_URI\_QUERY || option == COAP\_OPTION\_LOCATION\_QUERY || option == COAP\_OPTION\_ETAG || option == COAP\_OPTION\_ACCEPT) { \*temp\_parsed\_uri\_query\_ptr = '&'; } else if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { \*temp\_parsed\_uri\_query\_ptr = '/'; }
 temp\_parsed\_uri\_query\_ptr++; }
 returned\_option\_counter++;
 (\*packet\_data\_pptr)++;
 if (((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) + option\_number\_len) > uri\_query\_needed\_heap) { return -1; }
 memcpy(temp\_parsed\_uri\_query\_ptr, \*packet\_data\_pptr, option\_number\_len);
 (\*packet\_data\_pptr) += option\_number\_len; temp\_parsed\_uri\_query\_ptr += option\_number\_len;
 if ((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) >= uri\_query\_needed\_heap || ((\*\*packet\_data\_pptr >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT) != 0)) { return returned\_option\_counter; }
 option\_number\_len = (\*\*packet\_data\_pptr & 0x0F); if (option\_number\_len == 13) { option\_number\_len = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_number\_len == 14) { option\_number\_len = \*(\*packet\_data\_pptr + 2); option\_number\_len += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } }
 return returned\_option\_counter;}
/\*\* \* \fn static uint16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(uint8\_t \*packet\_data\_ptr, uint8\_t options\_count\_left, uint8\_t previous\_option\_number, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len) \* \* \brief Counts needed memory for uri query option \* \* \param \*packet\_data\_ptr is start of source for Packet data to be parsed to CoAP message \* \* \param options\_count\_left tells how many options are unhandled in Packet data \* \* \param previous\_option\_number is previous Option number \* \* \param sn\_coap\_option\_numbers\_e option option number to be calculated \* \* \param uint16\_t option\_number\_len length of the first option part \*/static int16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(const uint8\_t \*packet\_data\_ptr, uint16\_t packet\_left\_len, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len){ uint16\_t ret\_value = 0; uint16\_t i = 1;
 /\* Loop all Uri-Query options \*/ while (i <= packet\_left\_len) { if (option == COAP\_OPTION\_LOCATION\_PATH && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_URI\_PATH && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_URI\_QUERY && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_LOCATION\_QUERY && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_ACCEPT && option\_number\_len > 2) { return -1; } if (option == COAP\_OPTION\_ETAG && option\_number\_len > 8) { return -1; }
 i += option\_number\_len; ret\_value += option\_number\_len + 1; /\* + 1 is for separator \*/
 if( i == packet\_left\_len ) { break; } else if( i > packet\_left\_len ) { return -1; }
 if ((\*(packet\_data\_ptr + i) >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT) != 0) { return (ret\_value - 1); /\* -1 because last Part path does not include separator \*/ }
 option\_number\_len = (\*(packet\_data\_ptr + i) & 0x0F);
 if (option\_number\_len == 13) {
 if(i + 1 >= packet\_left\_len) { return -1; }
 i++; option\_number\_len = \*(packet\_data\_ptr + i) + 13; } else if (option\_number\_len == 14) {
 if(i + 2 >= packet\_left\_len) { return -1; }
 option\_number\_len = \*(packet\_data\_ptr + i + 2); option\_number\_len += (\*(packet\_data\_ptr + i + 1) << 8) + 269; i += 2; } else if (option\_number\_len == 15) { return -1; } i++;
 }
 if (ret\_value != 0) { return (ret\_value - 1); /\* -1 because last Part path does not include separator \*/ } else { return 0; }}
/\*\* \* \fn static void sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr) \* \* \brief Parses CoAP message's Payload part from given Packet data \* \* \param packet\_data\_len is length of given Packet data to be parsed to CoAP message \* \* \param \*packet\_data\_ptr is start of source for Packet data to be parsed to CoAP message \* \* \param \*\*packet\_data\_pptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/static int8\_t sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_start\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr){ /\* If there is payload \*/ if ((\*packet\_data\_pptr - packet\_data\_start\_ptr) < packet\_data\_len) { if (\*\*packet\_data\_pptr == 0xff) { (\*packet\_data\_pptr)++; /\* Parse Payload length \*/ dst\_coap\_msg\_ptr->payload\_len = packet\_data\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 /\* The presence of a marker followed by a zero-length payload MUST be processed as a message format error \*/ if (dst\_coap\_msg\_ptr->payload\_len == 0) { return -1; }
 /\* Parse Payload by setting CoAP message's payload\_ptr to point Payload in Packet data \*/ dst\_coap\_msg\_ptr->payload\_ptr = \*packet\_data\_pptr; } /\* No payload marker.. \*/ else { tr\_error("sn\_coap\_parser\_payload\_parse - payload marker not found!"); return -1; } } return 0;}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_770207bf_20250120_231419.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fissues%2F11803)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fissues%2F11803)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fissues_fragments%2Fissue_layout&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

# memory acess out of range in MbedOS CoAP library parser part #11803

[New issue](/login?return_to=)[Jump to bottom](#comment-composer-heading)Copy link[New issue](/login?return_to=)[Jump to bottom](#comment-composer-heading)Copy linkClosedClosed[memory acess out of range in MbedOS CoAP library parser part](#top)#11803Copy linkLabels[type: bug](https://github.com/ARMmbed/mbed-os/issues?q=state%3Aopen%20label%3A%22type%3A%20bug%22)![@TheSilentDawn](https://avatars.githubusercontent.com/u/19835007?u=7ec7ec5d7622b689e1d27844ade7bf2c22329838&v=4&size=80)
## Description

![@TheSilentDawn](https://avatars.githubusercontent.com/u/19835007?u=7ec7ec5d7622b689e1d27844ade7bf2c22329838&v=4&size=48)[TheSilentDawn](https://github.com/TheSilentDawn)opened [on Nov 4, 2019](https://github.com/ARMmbed/mbed-os/issues/11803#issue-516938787)
### Description of defect

Reference: <https://github.com/ARMmbed/mbed-os/tree/master/features/frameworks/mbed-coap>

Function: sn\_coap\_parser\_options\_parse

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_parser.c](https://github.com/ARMmbed/mbed-os/blob/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c#L301)

Line 301
in
[d91ed5f](/ARMmbed/mbed-os/commit/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)

|  | while (message\_left && (\*\*packet\_data\_pptr != 0xff)) { |
| --- | --- |

Type: Buffer overflow

The CoAP parser is responsible for parsing received CoAP packets. The function sn\_coap\_parser\_options\_parse() parses CoAP input linearly using a while loop. Once an option is parsed in a loop, the current point (\*packet\_data\_pptr) is increased correspondingly. The pointer is restricted by the size of the received buffer, as well as a delimiter byte 0xFF, as shown in line 4 of the code snippet below.
```
static int8_t sn_coap_parser_options_parse(..., uint8_t **packet_data_pptr, ...)
{
...
    while (message_left && (**packet_data_pptr != 0xff)) {
       	...
       	if (option_len == 13) {
           	option_len = *(*packet_data_pptr + 1) + 13;
           	(*packet_data_pptr)++;
       	}
       	...
    }
...
}
```

Unfortunately, inside each while loop, the check of the value of *packet\_data\_pptr is not strictly enforced. More specifically, inside a loop, *packet\_data\_pptr could be increased and then dereferenced without checking. Moreover, there are many other functions in the format of sn\_coap\_parser\_**\*\*() that do not check whether the pointer is within the bound of the allocated buffer. All of these lead to heap or stack buffer overflow, depending on how the CoAP packet buffer is allocated.

In the following, we list other locations which cause out-of-bound memory accesses rooted in this vulnerability.

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_parser.c](https://github.com/ARMmbed/mbed-os/blob/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c#L660)

Line 660
in
[d91ed5f](/ARMmbed/mbed-os/commit/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)

|  | if ((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) >= uri\_query\_needed\_heap || ((\*\*packet\_data\_pptr >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT) != 0)) { |
| --- | --- |

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_parser.c](https://github.com/ARMmbed/mbed-os/blob/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c#L331)

Line 331
in
[d91ed5f](/ARMmbed/mbed-os/commit/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)

|  | option\_len = \*(\*packet\_data\_pptr + 2); |
| --- | --- |

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_parser.c](https://github.com/ARMmbed/mbed-os/blob/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c#L257)

Line 257
in
[d91ed5f](/ARMmbed/mbed-os/commit/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)

|  | value |= \*(\*packet\_data\_pptr)++; |
| --- | --- |

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_parser.c](https://github.com/ARMmbed/mbed-os/blob/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c#L310)

Line 310
in
[d91ed5f](/ARMmbed/mbed-os/commit/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)

|  | option\_number = \*(\*packet\_data\_pptr + 1) + 13; |
| --- | --- |

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_parser.c](https://github.com/ARMmbed/mbed-os/blob/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c#L313)

Line 313
in
[d91ed5f](/ARMmbed/mbed-os/commit/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)

|  | option\_number = \*(\*packet\_data\_pptr + 2); |
| --- | --- |

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_protocol.c](https://github.com/ARMmbed/mbed-os/blob/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_protocol.c#L2488)

Line 2488
in
[d0686fd](/ARMmbed/mbed-os/commit/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)

|  | memcpy(dest, source, length); |
| --- | --- |

Result: Memory corruption.

#### Target(s) affected by this defect ?

MbedOS CoAP library

#### Toolchain(s) (name and version) displaying this defect ?

N/A

#### What version of Mbed-os are you using (tag or sha) ?

MbedOS 5.13.2

#### What version(s) of tools are you using. List all that apply (E.g. mbed-cli)

mbed-cli latest version

#### How is this defect reproduced ?

Using bug\_coap\_1\_1, bug\_coap\_1\_2, bug\_coap\_1\_3, bug\_coap\_1\_4， bug\_coap\_1\_5 and bug\_coap\_1\_6 as input of demo codes below, previous crash examples in sn\_coap\_parser.c will be triggered.

```
// The code is based on the demo in the CoAP library source code of MbedOS
struct coap_s* coapHandle;
coap_version_e coapVersion = COAP_VERSION_1;
void* coap_malloc(uint16_t size){
    return malloc(size);
}
void coap_free(void* addr){
    free(addr);
}
uint8_t coap_tx_cb(uint8_t *a, uint16_t b, sn_nsdl_addr_s *c, void *d){
    debug_log("coap_tx_cb", sizeof("coap_tx_cb"));
    return 0;
}
int8_t coap_rx_cb(sn_coap_hdr_s *a, sn_nsdl_addr_s *b, void *c){
    debug_log("coap_rx_cb", sizeof("coap_rx_cb"));
    return 0;
}
void main_parser() {
    coapHandle = sn_coap_protocol_init(&coap_malloc, &coap_free, &coap_tx_cb, &coap_rx_cb);
    nsapi_size_or_error_t ret;
    uint8_t* recv_buffer = (uint8_t*)malloc(1280);
    // memset(recv_buffer, 0x0, 1280); // some inputs rely on memory without initialization which is common when the memory is reused
    // stack overflow need to change this operation
    // to allocate memory in stack, for example, uint8_t recv_buffer[1280]
    ret = read(0, recv_buffer, 1280);
    sn_coap_hdr_s* parsed = sn_coap_parser(coapHandle, ret, recv_buffer, &coapVersion);
}
```

[bug\_coap\_1\_1.log](https://github.com/ARMmbed/mbed-os/files/3802577/bug_coap_1_1.log)

[bug\_coap\_1\_2.log](https://github.com/ARMmbed/mbed-os/files/3802578/bug_coap_1_2.log)

[bug\_coap\_1\_3.log](https://github.com/ARMmbed/mbed-os/files/3802579/bug_coap_1_3.log)

[bug\_coap\_1\_4.log](https://github.com/ARMmbed/mbed-os/files/3802580/bug_coap_1_4.log)

[bug\_coap\_1\_5.log](https://github.com/ARMmbed/mbed-os/files/3802581/bug_coap_1_5.log)

[bug\_coap\_1\_6.log](https://github.com/ARMmbed/mbed-os/files/3802582/bug_coap_1_6.log)

## Metadata

### Assignees

No one assigned

### Labels

[type: bug](https://github.com/ARMmbed/mbed-os/issues?q=state%3Aopen%20label%3A%22type%3A%20bug%22)
### Type

No type
### Projects

No projects
### Milestone

No milestone

### Relationships

None yet
### Development

No branches or pull requests
## Issue actions

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_282f4836_20250120_231403.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd91ed5fa42ea0f32e4422a3c562e7b045a17da40%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_parser.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd91ed5fa42ea0f32e4422a3c562e7b045a17da40%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_parser.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

## Files

 d91ed5f
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)
2. /[features](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source)
/
# sn\_coap\_parser.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARMmbed/mbed-os/commits/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c)807 lines (655 loc) · 32.1 KB d91ed5f
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40)
2. /[features](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source)
/
# sn\_coap\_parser.c

Top
## File metadata and controls

* Code
* Blame

807 lines (655 loc) · 32.1 KB[Raw](https://github.com/ARMmbed/mbed-os/raw/d91ed5fa42ea0f32e4422a3c562e7b045a17da40/features/frameworks/mbed-coap/source/sn_coap_parser.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806/\* \* Copyright (c) 2011-2015 ARM Limited. All rights reserved. \* SPDX-License-Identifier: Apache-2.0 \* Licensed under the Apache License, Version 2.0 (the License); you may \* not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an AS IS BASIS, WITHOUT \* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
/\*\* \*\file sn\_coap\_parser.c \* \* \brief CoAP Header parser \* \* Functionality: Parses CoAP Header \* \*/
/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* INCLUDE FILES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
#include <stdio.h>#include <string.h> /\* For memset() and memcpy() \*/
#include "ns\_types.h"#include "mbed-coap/sn\_coap\_header.h"#include "mbed-coap/sn\_coap\_protocol.h"#include "sn\_coap\_header\_internal.h"#include "sn\_coap\_protocol\_internal.h"#include "mbed-trace/mbed\_trace.h"
#define TRACE\_GROUP "coap"/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* LOCAL FUNCTION PROTOTYPES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr);static int8\_t sn\_coap\_parser\_options\_parse(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, uint8\_t \*packet\_data\_start\_ptr, uint16\_t packet\_len);static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, uint16\_t packet\_left\_len, uint8\_t \*\*dst\_pptr, uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len);static int16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(const uint8\_t \*packet\_data\_ptr, uint16\_t packet\_left\_len, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len);static int8\_t sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_start\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr);
sn\_coap\_hdr\_s \*sn\_coap\_parser\_init\_message(sn\_coap\_hdr\_s \*coap\_msg\_ptr){ /\* \* \* \* Check given pointer \* \* \* \*/ if (coap\_msg\_ptr == NULL) { tr\_error("sn\_coap\_parser\_init\_message - message null!"); return NULL; }
 /\* XXX not technically legal to memset pointers to 0 \*/ memset(coap\_msg\_ptr, 0x00, sizeof(sn\_coap\_hdr\_s));
 coap\_msg\_ptr->content\_format = COAP\_CT\_NONE;
 return coap\_msg\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser\_alloc\_message\_with\_options(struct coap\_s \*handle){ // check the handle just as in any other place if (handle == NULL) { return NULL; }
 sn\_coap\_hdr\_s \*coap\_msg\_ptr = sn\_coap\_parser\_alloc\_message(handle);
 sn\_coap\_options\_list\_s \*options\_list\_ptr = sn\_coap\_parser\_alloc\_options(handle, coap\_msg\_ptr);
 if ((coap\_msg\_ptr == NULL) || (options\_list\_ptr == NULL)) {
 // oops, out of memory free if got already any handle->sn\_coap\_protocol\_free(coap\_msg\_ptr); handle->sn\_coap\_protocol\_free(options\_list\_ptr);
 coap\_msg\_ptr = NULL; }
 return coap\_msg\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser\_alloc\_message(struct coap\_s \*handle){ sn\_coap\_hdr\_s \*returned\_coap\_msg\_ptr;
 /\* \* \* \* Check given pointer \* \* \* \*/ if (handle == NULL) { return NULL; }
 /\* \* \* \* Allocate memory for returned CoAP message and initialize allocated memory with with default values \* \* \* \*/ returned\_coap\_msg\_ptr = handle->sn\_coap\_protocol\_malloc(sizeof(sn\_coap\_hdr\_s));
 return sn\_coap\_parser\_init\_message(returned\_coap\_msg\_ptr);}
sn\_coap\_options\_list\_s \*sn\_coap\_parser\_alloc\_options(struct coap\_s \*handle, sn\_coap\_hdr\_s \*coap\_msg\_ptr){ sn\_coap\_options\_list\_s \*options\_list\_ptr;
 /\* \* \* \* Check given pointers \* \* \* \*/ if (handle == NULL || coap\_msg\_ptr == NULL) { return NULL; }
 /\* \* \* \* If the message already has options, return them \* \* \* \*/ if (coap\_msg\_ptr->options\_list\_ptr) { return coap\_msg\_ptr->options\_list\_ptr; }
 /\* \* \* \* Allocate memory for options and initialize allocated memory with with default values \* \* \* \*/ /\* XXX not technically legal to memset pointers to 0 \*/ options\_list\_ptr = sn\_coap\_protocol\_calloc(handle, sizeof(sn\_coap\_options\_list\_s));
 if (options\_list\_ptr == NULL) { tr\_error("sn\_coap\_parser\_alloc\_options - failed to allocate options list!"); return NULL; }
 coap\_msg\_ptr->options\_list\_ptr = options\_list\_ptr;
 options\_list\_ptr->uri\_port = COAP\_OPTION\_URI\_PORT\_NONE; options\_list\_ptr->observe = COAP\_OBSERVE\_NONE; options\_list\_ptr->accept = COAP\_CT\_NONE; options\_list\_ptr->block2 = COAP\_OPTION\_BLOCK\_NONE; options\_list\_ptr->block1 = COAP\_OPTION\_BLOCK\_NONE;
 return options\_list\_ptr;}
sn\_coap\_hdr\_s \*sn\_coap\_parser(struct coap\_s \*handle, uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_ptr, coap\_version\_e \*coap\_version\_ptr){ uint8\_t \*data\_temp\_ptr = packet\_data\_ptr; sn\_coap\_hdr\_s \*parsed\_and\_returned\_coap\_msg\_ptr = NULL;
 /\* \* \* \* Check given pointer \* \* \* \*/ if (packet\_data\_ptr == NULL || packet\_data\_len < 4 || handle == NULL) { return NULL; }
 /\* \* \* \* Allocate and initialize CoAP message \* \* \* \*/ parsed\_and\_returned\_coap\_msg\_ptr = sn\_coap\_parser\_alloc\_message(handle);
 if (parsed\_and\_returned\_coap\_msg\_ptr == NULL) { tr\_error("sn\_coap\_parser - failed to allocate message!"); return NULL; }
 /\* \* \* \* Header parsing, move pointer over the header... \* \* \* \*/ sn\_coap\_parser\_header\_parse(&data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr, coap\_version\_ptr);
 /\* \* \* \* Options parsing, move pointer over the options... \* \* \* \*/ if (sn\_coap\_parser\_options\_parse(handle, &data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr, packet\_data\_ptr, packet\_data\_len) != 0) { parsed\_and\_returned\_coap\_msg\_ptr->coap\_status = COAP\_STATUS\_PARSER\_ERROR\_IN\_HEADER; return parsed\_and\_returned\_coap\_msg\_ptr; }
 /\* \* \* \* Payload parsing \* \* \* \*/ if (sn\_coap\_parser\_payload\_parse(packet\_data\_len, packet\_data\_ptr, &data\_temp\_ptr, parsed\_and\_returned\_coap\_msg\_ptr) == -1) { parsed\_and\_returned\_coap\_msg\_ptr->coap\_status = COAP\_STATUS\_PARSER\_ERROR\_IN\_HEADER; return parsed\_and\_returned\_coap\_msg\_ptr; }
 /\* \* \* \* Return parsed CoAP message \* \* \* \* \*/ return parsed\_and\_returned\_coap\_msg\_ptr;}
void sn\_coap\_parser\_release\_allocated\_coap\_msg\_mem(struct coap\_s \*handle, sn\_coap\_hdr\_s \*freed\_coap\_msg\_ptr){ if (handle == NULL) { return; }
 if (freed\_coap\_msg\_ptr != NULL) {
 // As there are multiple sequential calls to the protocol\_free, caching pointer to it // saves one instruction per call. void (\*local\_free)(void \*) = handle->sn\_coap\_protocol\_free;
 local\_free(freed\_coap\_msg\_ptr->uri\_path\_ptr); local\_free(freed\_coap\_msg\_ptr->token\_ptr);
 // same here, caching the struct start saves a bit. sn\_coap\_options\_list\_s \*options\_list\_ptr = freed\_coap\_msg\_ptr->options\_list\_ptr;
 if (options\_list\_ptr != NULL) {
 local\_free(options\_list\_ptr->proxy\_uri\_ptr);
 local\_free(options\_list\_ptr->etag\_ptr);
 local\_free(options\_list\_ptr->uri\_host\_ptr);
 local\_free(options\_list\_ptr->location\_path\_ptr);
 local\_free(options\_list\_ptr->location\_query\_ptr);
 local\_free(options\_list\_ptr->uri\_query\_ptr);
 local\_free(options\_list\_ptr); }
 local\_free(freed\_coap\_msg\_ptr); }}
/\*\* \* \fn static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr) \* \* \brief Parses CoAP message's Header part from given Packet data \* \* \param \*\*packet\_data\_ptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \param \*coap\_version\_ptr is destination for parsed CoAP specification version \*/static void sn\_coap\_parser\_header\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, coap\_version\_e \*coap\_version\_ptr){ /\* Parse CoAP Version and message type\*/ \*coap\_version\_ptr = (coap\_version\_e)(\*\*packet\_data\_pptr & COAP\_HEADER\_VERSION\_MASK); dst\_coap\_msg\_ptr->msg\_type = (sn\_coap\_msg\_type\_e)(\*\*packet\_data\_pptr & COAP\_HEADER\_MSG\_TYPE\_MASK); (\*packet\_data\_pptr) += 1;
 /\* Parse Message code \*/ dst\_coap\_msg\_ptr->msg\_code = (sn\_coap\_msg\_code\_e) \*\*packet\_data\_pptr; (\*packet\_data\_pptr) += 1;
 /\* Parse Message ID \*/ dst\_coap\_msg\_ptr->msg\_id = \*(\*packet\_data\_pptr + 1); dst\_coap\_msg\_ptr->msg\_id += \*\*packet\_data\_pptr << COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT; (\*packet\_data\_pptr) += 2;
}
/\*\* \* \brief Parses a variable-length uint value from an option \* \* \param \*\*packet\_data\_pptr is source of option data to be parsed \* \param option\_len is length of option data (will be 0-4) \* \* \return Return value is value of uint \*/static uint32\_t sn\_coap\_parser\_options\_parse\_uint(uint8\_t \*\*packet\_data\_pptr, uint8\_t option\_len){ uint32\_t value = 0; while (option\_len--) { value <<= 8; value |= \*(\*packet\_data\_pptr)++; } return value;}
/\*\* \* \fn static uint8\_t sn\_coap\_parser\_options\_parse(uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr) \* \* \brief Parses CoAP message's Options part from given Packet data \* \* \param \*\*packet\_data\_pptr is source of Packet data to be parsed to CoAP message \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \return Return value is 0 in ok case and -1 in failure case \*/static int8\_t sn\_coap\_parser\_options\_parse(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr, uint8\_t \*packet\_data\_start\_ptr, uint16\_t packet\_len){ uint8\_t previous\_option\_number = 0; uint8\_t i = 0; int8\_t ret\_status = 0; uint16\_t message\_left = 0;
 /\* Parse token, if exists \*/ dst\_coap\_msg\_ptr->token\_len = \*packet\_data\_start\_ptr & COAP\_HEADER\_TOKEN\_LENGTH\_MASK;
 if (dst\_coap\_msg\_ptr->token\_len) { if ((dst\_coap\_msg\_ptr->token\_len > 8) || dst\_coap\_msg\_ptr->token\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - token not valid!"); return -1; }
 dst\_coap\_msg\_ptr->token\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, dst\_coap\_msg\_ptr->token\_len);
 if (dst\_coap\_msg\_ptr->token\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - failed to allocate token!"); return -1; }
 (\*packet\_data\_pptr) += dst\_coap\_msg\_ptr->token\_len; }
 message\_left = packet\_len - ((\*packet\_data\_pptr) - packet\_data\_start\_ptr);
 /\* Loop all Options \*/ while (message\_left && (\*\*packet\_data\_pptr != 0xff)) {
 /\* Get option length WITHOUT extensions \*/ uint16\_t option\_len = (\*\*packet\_data\_pptr & 0x0F);
 /\* Resolve option delta \*/ uint16\_t option\_number = (\*\*packet\_data\_pptr >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT);
 if (option\_number == 13) { option\_number = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_number == 14) { option\_number = \*(\*packet\_data\_pptr + 2); option\_number += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } /\* Option number 15 reserved for payload marker. This is handled as a error! \*/ else if (option\_number == 15) { tr\_error("sn\_coap\_parser\_options\_parse - invalid option number(15)!"); return -1; }
 /\* Add previous option to option delta and get option number \*/ option\_number += previous\_option\_number;
 /\* Add possible option length extension to resolve full length of the option \*/ if (option\_len == 13) { option\_len = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_len == 14) { option\_len = \*(\*packet\_data\_pptr + 2); option\_len += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } /\* Option number length 15 is reserved for the future use - ERROR \*/ else if (option\_len == 15) { tr\_error("sn\_coap\_parser\_options\_parse - invalid option len(15)!"); return -1; }
 message\_left = packet\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 /\* \* \* Parse option itself \* \* \*/ /\* Some options are handled independently in own functions \*/ previous\_option\_number = option\_number; /\* Allocate options\_list\_ptr if needed \*/ switch (option\_number) { case COAP\_OPTION\_MAX\_AGE: case COAP\_OPTION\_PROXY\_URI: case COAP\_OPTION\_ETAG: case COAP\_OPTION\_URI\_HOST: case COAP\_OPTION\_LOCATION\_PATH: case COAP\_OPTION\_URI\_PORT: case COAP\_OPTION\_LOCATION\_QUERY: case COAP\_OPTION\_OBSERVE: case COAP\_OPTION\_URI\_QUERY: case COAP\_OPTION\_BLOCK2: case COAP\_OPTION\_BLOCK1: case COAP\_OPTION\_ACCEPT: case COAP\_OPTION\_SIZE1: case COAP\_OPTION\_SIZE2: if (sn\_coap\_parser\_alloc\_options(handle, dst\_coap\_msg\_ptr) == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - failed to allocate options!"); return -1; } break; }
 /\* Parse option \*/ switch (option\_number) { case COAP\_OPTION\_CONTENT\_FORMAT: if ((option\_len > 2) || (dst\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE)) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_CONTENT\_FORMAT not valid!"); return -1; } (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->content\_format = (sn\_coap\_content\_format\_e) sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_MAX\_AGE: if (option\_len > 4) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_MAX\_AGE not valid!"); return -1; } (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->max\_age = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_PROXY\_URI: if ((option\_len > 1034) || (option\_len < 1) || dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_PROXY\_URI not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_len = option\_len; (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, option\_len);
 if (dst\_coap\_msg\_ptr->options\_list\_ptr->proxy\_uri\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_PROXY\_URI allocation failed!"); return -1; }
 (\*packet\_data\_pptr) += option\_len;
 break;
 case COAP\_OPTION\_ETAG: /\* This is managed independently because User gives this option in one character table \*/
 ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->etag\_ptr, (uint16\_t \*)&dst\_coap\_msg\_ptr->options\_list\_ptr->etag\_len, COAP\_OPTION\_ETAG, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_ETAG not valid!"); return -1; } break;
 case COAP\_OPTION\_URI\_HOST: if ((option\_len > 255) || (option\_len < 1) || dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_HOST not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_len = option\_len; (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, \*packet\_data\_pptr, option\_len);
 if (dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_host\_ptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_HOST allocation failed!"); return -1; } (\*packet\_data\_pptr) += option\_len;
 break;
 case COAP\_OPTION\_LOCATION\_PATH: if (dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_ptr) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_PATH exists!"); return -1; } /\* This is managed independently because User gives this option in one character table \*/ ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_path\_len, COAP\_OPTION\_LOCATION\_PATH, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_PATH not valid!"); return -1; }
 break;
 case COAP\_OPTION\_URI\_PORT: if ((option\_len > 2) || dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_PORT not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_port = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_LOCATION\_QUERY: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_query\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->location\_query\_len, COAP\_OPTION\_LOCATION\_QUERY, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_LOCATION\_QUERY not valid!"); return -1; }
 break;
 case COAP\_OPTION\_URI\_PATH: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->uri\_path\_ptr, &dst\_coap\_msg\_ptr->uri\_path\_len, COAP\_OPTION\_URI\_PATH, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_PATH not valid!"); return -1; }
 break;
 case COAP\_OPTION\_OBSERVE: if ((option\_len > 2) || dst\_coap\_msg\_ptr->options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_OBSERVE not valid!"); return -1; }
 (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->observe = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_URI\_QUERY: ret\_status = sn\_coap\_parser\_options\_parse\_multiple\_options(handle, packet\_data\_pptr, message\_left, &dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_query\_ptr, &dst\_coap\_msg\_ptr->options\_list\_ptr->uri\_query\_len, COAP\_OPTION\_URI\_QUERY, option\_len); if (ret\_status >= 0) { i += (ret\_status - 1); /\* i += is because possible several Options are handled by sn\_coap\_parser\_options\_parse\_multiple\_options() \*/ } else { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_URI\_QUERY not valid!"); return -1; }
 break;
 case COAP\_OPTION\_BLOCK2: if ((option\_len > 3) || dst\_coap\_msg\_ptr->options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_BLOCK2 not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->block2 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_BLOCK1: if ((option\_len > 3) || dst\_coap\_msg\_ptr->options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_BLOCK1 not valid!"); return -1; } (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->block1 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len);
 break;
 case COAP\_OPTION\_ACCEPT: if ((option\_len > 2) || (dst\_coap\_msg\_ptr->options\_list\_ptr->accept != COAP\_CT\_NONE)) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_ACCEPT not valid!"); return -1; }
 (\*packet\_data\_pptr)++;
 dst\_coap\_msg\_ptr->options\_list\_ptr->accept = (sn\_coap\_content\_format\_e) sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_SIZE1: if ((option\_len > 4) || dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size1) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_SIZE1 not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size1 = true; (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->size1 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 case COAP\_OPTION\_SIZE2: if ((option\_len > 4) || dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { tr\_error("sn\_coap\_parser\_options\_parse - COAP\_OPTION\_SIZE2 not valid!"); return -1; } dst\_coap\_msg\_ptr->options\_list\_ptr->use\_size2 = true; (\*packet\_data\_pptr)++; dst\_coap\_msg\_ptr->options\_list\_ptr->size2 = sn\_coap\_parser\_options\_parse\_uint(packet\_data\_pptr, option\_len); break;
 default: tr\_error("sn\_coap\_parser\_options\_parse - unknown option!"); return -1; }
 /\* Check for overflow \*/ if ((\*packet\_data\_pptr - packet\_data\_start\_ptr) > packet\_len) { return -1; }
 message\_left = packet\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 }
 return 0;}
/\*\* \* \fn static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(uint8\_t \*\*packet\_data\_pptr, uint8\_t options\_count\_left, uint8\_t \*previous\_option\_number\_ptr, uint8\_t \*\*dst\_pptr, \* uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len) \* \* \brief Parses CoAP message's Uri-query options \* \* \param \*\*packet\_data\_pptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \* \* \param options\_count\_left tells how many options are unhandled in Packet data \* \* \param \*previous\_option\_number\_ptr is pointer to used and returned previous Option number \* \* \return Return value is count of Uri-query optios parsed. In failure case -1 is returned.\*/static int8\_t sn\_coap\_parser\_options\_parse\_multiple\_options(struct coap\_s \*handle, uint8\_t \*\*packet\_data\_pptr, uint16\_t packet\_left\_len, uint8\_t \*\*dst\_pptr, uint16\_t \*dst\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len){ int16\_t uri\_query\_needed\_heap = sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(\*packet\_data\_pptr, packet\_left\_len, option, option\_number\_len); uint8\_t \*temp\_parsed\_uri\_query\_ptr = NULL; uint8\_t returned\_option\_counter = 0;
 if (uri\_query\_needed\_heap == -1) { return -1; }
 if (uri\_query\_needed\_heap) { \*dst\_pptr = (uint8\_t \*) handle->sn\_coap\_protocol\_malloc(uri\_query\_needed\_heap);
 if (\*dst\_pptr == NULL) { tr\_error("sn\_coap\_parser\_options\_parse\_multiple\_options - failed to allocate options!"); return -1; } }
 \*dst\_len\_ptr = uri\_query\_needed\_heap;
 temp\_parsed\_uri\_query\_ptr = \*dst\_pptr;
 /\* Loop all Uri-Query options \*/ while ((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) < uri\_query\_needed\_heap) { /\* Check if this is first Uri-Query option \*/ if (returned\_option\_counter > 0) { /\* Uri-Query is modified to following format: temp1'\0'temp2'\0'temp3 i.e. \*/ /\* Uri-Path is modified to following format: temp1\temp2\temp3 i.e. \*/ if (option == COAP\_OPTION\_URI\_QUERY || option == COAP\_OPTION\_LOCATION\_QUERY || option == COAP\_OPTION\_ETAG || option == COAP\_OPTION\_ACCEPT) { \*temp\_parsed\_uri\_query\_ptr = '&'; } else if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { \*temp\_parsed\_uri\_query\_ptr = '/'; }
 temp\_parsed\_uri\_query\_ptr++; }
 returned\_option\_counter++;
 (\*packet\_data\_pptr)++;
 if (((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) + option\_number\_len) > uri\_query\_needed\_heap) { return -1; }
 memcpy(temp\_parsed\_uri\_query\_ptr, \*packet\_data\_pptr, option\_number\_len);
 (\*packet\_data\_pptr) += option\_number\_len; temp\_parsed\_uri\_query\_ptr += option\_number\_len;
 if ((temp\_parsed\_uri\_query\_ptr - \*dst\_pptr) >= uri\_query\_needed\_heap || ((\*\*packet\_data\_pptr >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT) != 0)) { return returned\_option\_counter; }
 option\_number\_len = (\*\*packet\_data\_pptr & 0x0F); if (option\_number\_len == 13) { option\_number\_len = \*(\*packet\_data\_pptr + 1) + 13; (\*packet\_data\_pptr)++; } else if (option\_number\_len == 14) { option\_number\_len = \*(\*packet\_data\_pptr + 2); option\_number\_len += (\*(\*packet\_data\_pptr + 1) << 8) + 269; (\*packet\_data\_pptr) += 2; } }
 return returned\_option\_counter;}
/\*\* \* \fn static uint16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(uint8\_t \*packet\_data\_ptr, uint8\_t options\_count\_left, uint8\_t previous\_option\_number, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len) \* \* \brief Counts needed memory for uri query option \* \* \param \*packet\_data\_ptr is start of source for Packet data to be parsed to CoAP message \* \* \param options\_count\_left tells how many options are unhandled in Packet data \* \* \param previous\_option\_number is previous Option number \* \* \param sn\_coap\_option\_numbers\_e option option number to be calculated \* \* \param uint16\_t option\_number\_len length of the first option part \*/static int16\_t sn\_coap\_parser\_options\_count\_needed\_memory\_multiple\_option(const uint8\_t \*packet\_data\_ptr, uint16\_t packet\_left\_len, sn\_coap\_option\_numbers\_e option, uint16\_t option\_number\_len){ uint16\_t ret\_value = 0; uint16\_t i = 1;
 /\* Loop all Uri-Query options \*/ while (i <= packet\_left\_len) { if (option == COAP\_OPTION\_LOCATION\_PATH && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_URI\_PATH && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_URI\_QUERY && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_LOCATION\_QUERY && option\_number\_len > 255) { return -1; } if (option == COAP\_OPTION\_ACCEPT && option\_number\_len > 2) { return -1; } if (option == COAP\_OPTION\_ETAG && option\_number\_len > 8) { return -1; }
 i += option\_number\_len; ret\_value += option\_number\_len + 1; /\* + 1 is for separator \*/
 if( i == packet\_left\_len ) { break; } else if( i > packet\_left\_len ) { return -1; }
 if ((\*(packet\_data\_ptr + i) >> COAP\_OPTIONS\_OPTION\_NUMBER\_SHIFT) != 0) { return (ret\_value - 1); /\* -1 because last Part path does not include separator \*/ }
 option\_number\_len = (\*(packet\_data\_ptr + i) & 0x0F);
 if (option\_number\_len == 13) {
 if(i + 1 >= packet\_left\_len) { return -1; }
 i++; option\_number\_len = \*(packet\_data\_ptr + i) + 13; } else if (option\_number\_len == 14) {
 if(i + 2 >= packet\_left\_len) { return -1; }
 option\_number\_len = \*(packet\_data\_ptr + i + 2); option\_number\_len += (\*(packet\_data\_ptr + i + 1) << 8) + 269; i += 2; } else if (option\_number\_len == 15) { return -1; } i++;
 }
 if (ret\_value != 0) { return (ret\_value - 1); /\* -1 because last Part path does not include separator \*/ } else { return 0; }}
/\*\* \* \fn static void sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr) \* \* \brief Parses CoAP message's Payload part from given Packet data \* \* \param packet\_data\_len is length of given Packet data to be parsed to CoAP message \* \* \param \*packet\_data\_ptr is start of source for Packet data to be parsed to CoAP message \* \* \param \*\*packet\_data\_pptr is source for Packet data to be parsed to CoAP message \* \* \param \*dst\_coap\_msg\_ptr is destination for parsed CoAP message \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*/static int8\_t sn\_coap\_parser\_payload\_parse(uint16\_t packet\_data\_len, uint8\_t \*packet\_data\_start\_ptr, uint8\_t \*\*packet\_data\_pptr, sn\_coap\_hdr\_s \*dst\_coap\_msg\_ptr){ /\* If there is payload \*/ if ((\*packet\_data\_pptr - packet\_data\_start\_ptr) < packet\_data\_len) { if (\*\*packet\_data\_pptr == 0xff) { (\*packet\_data\_pptr)++; /\* Parse Payload length \*/ dst\_coap\_msg\_ptr->payload\_len = packet\_data\_len - (\*packet\_data\_pptr - packet\_data\_start\_ptr);
 /\* The presence of a marker followed by a zero-length payload MUST be processed as a message format error \*/ if (dst\_coap\_msg\_ptr->payload\_len == 0) { return -1; }
 /\* Parse Payload by setting CoAP message's payload\_ptr to point Payload in Packet data \*/ dst\_coap\_msg\_ptr->payload\_ptr = \*packet\_data\_pptr; } /\* No payload marker.. \*/ else { tr\_error("sn\_coap\_parser\_payload\_parse - payload marker not found!"); return -1; } } return 0;}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


