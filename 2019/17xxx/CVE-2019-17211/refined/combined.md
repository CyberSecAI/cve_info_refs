=== Content from github.com_80a415f3_20250120_235004.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

## Files

 d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARMmbed/mbed-os/commits/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1099 lines (950 loc) · 45.9 KB d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Top
## File metadata and controls

* Code
* Blame

1099 lines (950 loc) · 45.9 KB[Raw](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright (c) 2011-2015 ARM Limited. All rights reserved. \* SPDX-License-Identifier: Apache-2.0 \* Licensed under the Apache License, Version 2.0 (the License); you may \* not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an AS IS BASIS, WITHOUT \* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
/\*\* \* \file sn\_coap\_builder.c \* \* \brief CoAP Message builder \* \* Functionality: Builds CoAP message \* \*/
/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* INCLUDE FILES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
#include <string.h> /\* For memset() and memcpy() \*/
#include "ns\_types.h"#include "mbed-coap/sn\_coap\_header.h"#include "sn\_coap\_header\_internal.h"#include "sn\_coap\_protocol\_internal.h"#include "mbed-trace/mbed\_trace.h"
#define TRACE\_GROUP "coap"/\* \* \* \* LOCAL FUNCTION PROTOTYPES \* \* \* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_get\_option\_part\_position(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static void sn\_coap\_builder\_payload\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);
sn\_coap\_hdr\_s \*sn\_coap\_build\_response(struct coap\_s \*handle, const sn\_coap\_hdr\_s \*coap\_packet\_ptr, uint8\_t msg\_code){ sn\_coap\_hdr\_s \*coap\_res\_ptr;
 if (!coap\_packet\_ptr || !handle) { return NULL; }
 coap\_res\_ptr = sn\_coap\_parser\_alloc\_message(handle); if (!coap\_res\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate message!"); return NULL; }
 if (msg\_code == COAP\_MSG\_CODE\_REQUEST\_GET) { // Blockwise message response is new GET coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_ACKNOWLEDGEMENT; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; coap\_res\_ptr->msg\_id = coap\_packet\_ptr->msg\_id; } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_NON\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_NON\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else { handle->sn\_coap\_protocol\_free( coap\_res\_ptr ); return NULL; }
 if (coap\_packet\_ptr->token\_ptr) { coap\_res\_ptr->token\_len = coap\_packet\_ptr->token\_len; coap\_res\_ptr->token\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, coap\_packet\_ptr->token\_ptr, coap\_res\_ptr->token\_len); if (!coap\_res\_ptr->token\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate token!"); handle->sn\_coap\_protocol\_free(coap\_res\_ptr); return NULL; } } return coap\_res\_ptr;}
int16\_t sn\_coap\_builder(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_2(dst\_packet\_data\_ptr, src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
int16\_t sn\_coap\_builder\_2(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ uint8\_t \*base\_packet\_data\_ptr;
 /\* \* \* \* Check given pointers \* \* \* \*/ if (dst\_packet\_data\_ptr == NULL || src\_coap\_msg\_ptr == NULL) { return -2; }
 /\* Initialize given Packet data memory area with zero values \*/ uint16\_t dst\_byte\_count\_to\_be\_built = sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, blockwise\_payload\_size); if (!dst\_byte\_count\_to\_be\_built) { tr\_error("sn\_coap\_builder\_2 - failed to allocate message!"); return -1; }
 // XXX: this should not be needed anymore but I have no courage to remove it yet. memset(dst\_packet\_data\_ptr, 0, dst\_byte\_count\_to\_be\_built);
 /\* \* \* \* Store base (= original) destination Packet data pointer for later usage \* \* \* \*/ base\_packet\_data\_ptr = dst\_packet\_data\_ptr;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Header part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ if (sn\_coap\_builder\_header\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr) != 0) { /\* Header building failed \*/ tr\_error("sn\_coap\_builder\_2 - header building failed!"); return -1; }
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Options part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_options\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr);
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Payload part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_payload\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr); } /\* \* \* \* Return built Packet data length \* \* \* \*/ return (dst\_packet\_data\_ptr - base\_packet\_data\_ptr);}uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ (void)blockwise\_payload\_size; uint16\_t returned\_byte\_count = 0;
 if (!src\_coap\_msg\_ptr) { return 0; } /\* \* \* \* \* HEADER \* \* \* \* \*/
 /\* Header size is fixed \*/ returned\_byte\_count = COAP\_HEADER\_LENGTH;
 /\* \* \* \* \* OPTIONS \* \* \* \* \*/
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { uint16\_t repeatable\_option\_size = 0; /\* TOKEN - Length is 1-8 bytes \*/ if (src\_coap\_msg\_ptr->token\_ptr != NULL) { if (src\_coap\_msg\_ptr->token\_len > 8 || src\_coap\_msg\_ptr->token\_len < 1) { /\* Check that option is not longer than defined \*/ tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - token too large!"); return 0; }
 returned\_byte\_count += src\_coap\_msg\_ptr->token\_len; } /\* URI PATH - Repeatable option. Length of one option is 0-255 \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_coap\_msg\_ptr->uri\_path\_len, src\_coap\_msg\_ptr->uri\_path\_ptr, COAP\_OPTION\_URI\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri path size failed!"); return 0; } }
 uint16\_t tempInt = 0; /\* CONTENT FORMAT - An integer option, up to 2 bytes \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { if ((uint32\_t) src\_coap\_msg\_ptr->content\_format > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - content format too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &tempInt); } /\* If options list pointer exists \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr != NULL) {
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* ACCEPT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->accept > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - accept too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &tempInt); } /\* MAX AGE - An integer option, omitted for default. Up to 4 bytes \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &tempInt); } /\* PROXY URI - Length of this option is 1-1034 bytes \*/ if (src\_options\_list\_ptr->proxy\_uri\_ptr != NULL) { if (src\_options\_list\_ptr->proxy\_uri\_len >= 1 && src\_options\_list\_ptr->proxy\_uri\_len <= 12) { /\* Add option header byte(s) - depending of option length \*/ returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 13 && src\_options\_list\_ptr->proxy\_uri\_len <= 269) { returned\_byte\_count += 2; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 270 && src\_options\_list\_ptr->proxy\_uri\_len <= 1034) { returned\_byte\_count += 3; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - proxy uri too large!"); return 0; }
 /\* Add needed memory for Option value \*/ returned\_byte\_count += src\_options\_list\_ptr->proxy\_uri\_len; } /\* ETAG - Repeatable option. Length of this option is 1-8 bytes\*/ if (src\_options\_list\_ptr->etag\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->etag\_len, src\_options\_list\_ptr->etag\_ptr, COAP\_OPTION\_ETAG); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - etag too large!"); return 0; } } /\* URI HOST - Length of this option is 1-255 bytes \*/ if (src\_options\_list\_ptr->uri\_host\_ptr != NULL) { if (src\_options\_list\_ptr->uri\_host\_len > 0 && src\_options\_list\_ptr->uri\_host\_len <= 12) { returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->uri\_host\_len >= 13 && src\_options\_list\_ptr->uri\_host\_len <= 255) { returned\_byte\_count += 2; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri host too large!"); return 0; }
 returned\_byte\_count += src\_options\_list\_ptr->uri\_host\_len; } /\* LOCATION PATH - Repeatable option. Length of this option is 0-255 bytes\*/ if (src\_options\_list\_ptr->location\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_path\_len, src\_options\_list\_ptr->location\_path\_ptr, COAP\_OPTION\_LOCATION\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location path too large!"); return 0; } } /\* URI PORT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->uri\_port > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri port too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &tempInt); } /\* lOCATION QUERY - Repeatable option. Length of this option is 0-255 bytes \*/ if (src\_options\_list\_ptr->location\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_query\_len, src\_options\_list\_ptr->location\_query\_ptr, COAP\_OPTION\_LOCATION\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location query too large!"); return 0; } } /\* OBSERVE - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->observe > 0xffffff) { return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &tempInt); } /\* URI QUERY - Repeatable option. Length of this option is 1-255 \*/ if (src\_options\_list\_ptr->uri\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->uri\_query\_len, src\_options\_list\_ptr->uri\_query\_ptr, COAP\_OPTION\_URI\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - observe too large!"); return 0; } }
 /\* BLOCK 1 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block1 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block1 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &tempInt); } /\* SIZE1 - Length of this option is 0-4 bytes \*/ if (src\_options\_list\_ptr->use\_size1) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &tempInt); } /\* BLOCK 2 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block2 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block2 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &tempInt); } /\* SIZE2 - Length of this option is 0-4 bytes \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &tempInt); } }#if SN\_COAP\_BLOCKWISE\_ENABLED || SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE if ((src\_coap\_msg\_ptr->payload\_len > SN\_COAP\_MAX\_NONBLOCKWISE\_PAYLOAD\_SIZE) && (src\_coap\_msg\_ptr->payload\_len > blockwise\_payload\_size) && (blockwise\_payload\_size > 0)) { returned\_byte\_count += blockwise\_payload\_size; } else { returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len; }#else returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len;#endif if (src\_coap\_msg\_ptr->payload\_len) { returned\_byte\_count ++; /\* For payload marker \*/ } returned\_byte\_count += sn\_coap\_builder\_options\_calculate\_jump\_need(src\_coap\_msg\_ptr); } return returned\_byte\_count;}/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Checks if there is need for option jump \* \* \param \*src\_coap\_msg\_ptr is source of checked CoAP message \* \* \param block option marks if block option is to be added to message later. 0 = no block option, 1 = block1 and 2 = block2 \* \* \return Returns bytes needed for jumping \*/
static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ uint8\_t previous\_option\_number = 0; uint8\_t needed\_space = 0;
 const sn\_coap\_options\_list\_s\* options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 if (options\_list\_ptr != NULL) {
 /\* If option numbers greater than 12 is not used, then jumping is not needed \*/ //TODO: Check if this is really needed! Does it enhance perf? If not -> remove if (!options\_list\_ptr->uri\_query\_ptr && options\_list\_ptr->accept == COAP\_CT\_NONE && !options\_list\_ptr->location\_query\_ptr && options\_list\_ptr->block2 == COAP\_OPTION\_BLOCK\_NONE && options\_list\_ptr->block1 == COAP\_OPTION\_BLOCK\_NONE && !options\_list\_ptr->proxy\_uri\_ptr && options\_list\_ptr->max\_age == COAP\_OPTION\_MAX\_AGE\_DEFAULT && !options\_list\_ptr->use\_size1 && !options\_list\_ptr->use\_size2) { return 0; }
 if (options\_list\_ptr->uri\_host\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_HOST); }
 if (options\_list\_ptr->etag\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_ETAG); }
 if (options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { previous\_option\_number = (COAP\_OPTION\_OBSERVE); }
 if (options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { previous\_option\_number = (COAP\_OPTION\_URI\_PORT); }
 if (options\_list\_ptr->location\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_LOCATION\_PATH); }
 if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); } if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); }
 if (options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { if ((COAP\_OPTION\_MAX\_AGE - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_MAX\_AGE); }
 if (options\_list\_ptr->uri\_query\_ptr != NULL) { if ((COAP\_OPTION\_URI\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_URI\_QUERY); } if (options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((COAP\_OPTION\_ACCEPT - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_ACCEPT); } if (options\_list\_ptr->location\_query\_ptr != NULL) { if ((COAP\_OPTION\_LOCATION\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_LOCATION\_QUERY); } if (options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK2 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK2); } if (options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK1 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK1); } if (options\_list\_ptr->use\_size2) { if ((COAP\_OPTION\_SIZE2 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE2); } if (options\_list\_ptr->proxy\_uri\_ptr != NULL) { if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 12) { needed\_space += 1; } if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 269) { //Can not happen needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_PROXY\_URI); } if (options\_list\_ptr->use\_size1) { if ((COAP\_OPTION\_SIZE1 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE1); } }
 else { if (src\_coap\_msg\_ptr->uri\_path\_ptr != 0) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); }
 if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); } } return needed\_space;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Header part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in ok case and -1 in failure case \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check validity of Header values \* \* \* \*/ if (sn\_coap\_header\_validity\_check(src\_coap\_msg\_ptr, COAP\_VERSION) != 0) { tr\_error("sn\_coap\_builder\_header\_build - header build failed!"); return -1; }
 uint8\_t\* dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Set CoAP Version, Message type and Token length \*/ dest\_packet[0] = COAP\_VERSION | src\_coap\_msg\_ptr->msg\_type | src\_coap\_msg\_ptr->token\_len;
 /\* \* \* Add Message code \* \* \*/ dest\_packet[1] = src\_coap\_msg\_ptr->msg\_code;
 /\* \* \* Add Message ID \* \* \*/ dest\_packet[2] = (uint8\_t)(src\_coap\_msg\_ptr->msg\_id >> COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT); /\* MSB part \*/ dest\_packet[3] = (uint8\_t)src\_coap\_msg\_ptr->msg\_id; /\* LSB part \*/
 \*dst\_packet\_data\_pptr = dest\_packet + 4;
 /\* Success \*/ return 0;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in every case \*/static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check if Options are used at all \* \* \* \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr == NULL && src\_coap\_msg\_ptr->token\_ptr == NULL && src\_coap\_msg\_ptr->content\_format == COAP\_CT\_NONE && src\_coap\_msg\_ptr->options\_list\_ptr == NULL) { /\* If the empty message is confirmable it is CoAP ping. \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_CONFIRMABLE) { tr\_error("sn\_coap\_builder\_options\_build - options not used!"); } return 0; }
 /\* \* \* \* First add Token option \* \* \* \*/ if (src\_coap\_msg\_ptr->token\_len && src\_coap\_msg\_ptr->token\_ptr) { memcpy(\*dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->token\_ptr, src\_coap\_msg\_ptr->token\_len); } (\*dst\_packet\_data\_pptr) += src\_coap\_msg\_ptr->token\_len;
 /\* Then build rest of the options \*/
 /\* \* \* \* Initialize previous Option number for new built message \* \* \* \*/ uint16\_t previous\_option\_number = 0;
 //missing: COAP\_OPTION\_IF\_MATCH, COAP\_OPTION\_IF\_NONE\_MATCH, COAP\_OPTION\_SIZE
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* Check if less used options are used at all \*/ if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Uri-Host option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_host\_len, src\_options\_list\_ptr->uri\_host\_ptr, COAP\_OPTION\_URI\_HOST, &previous\_option\_number);
 /\* \* \* \* Build ETag option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->etag\_ptr, src\_options\_list\_ptr->etag\_len, COAP\_OPTION\_ETAG, &previous\_option\_number);
 /\* \* \* \* Build Observe option \* \* \* \* \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Port option \* \* \* \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_path\_ptr, src\_options\_list\_ptr->location\_path\_len, COAP\_OPTION\_LOCATION\_PATH, &previous\_option\_number); } /\* \* \* \* Build Uri-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->uri\_path\_ptr, src\_coap\_msg\_ptr->uri\_path\_len, COAP\_OPTION\_URI\_PATH, &previous\_option\_number);
 /\* \* \* \* Build Content-Type option \* \* \* \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &previous\_option\_number); }
 if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Max-Age option \* \* \* \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Query option \* \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_query\_ptr, src\_options\_list\_ptr->uri\_query\_len, COAP\_OPTION\_URI\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Accept option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->accept != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Query option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_query\_ptr, src\_options\_list\_ptr->location\_query\_len, COAP\_OPTION\_LOCATION\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Block2 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &previous\_option\_number); }
 /\* \* \* \* Build Block1 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &previous\_option\_number); }
 /\* \* \* \* Build Size2 option \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &previous\_option\_number); }
 /\* \* \* \* Build Proxy-Uri option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->proxy\_uri\_len, src\_options\_list\_ptr->proxy\_uri\_ptr, COAP\_OPTION\_PROXY\_URI, &previous\_option\_number);
 /\* \* \* \* Build Size1 option \* \* \* \*/ if (src\_options\_list\_ptr->use\_size1) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &previous\_option\_number); } }
 /\* Success \*/ return 0;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_value\_len, uint8\_t \*option\_value\_ptr, sn\_coap\_option\_numbers\_e option\_number) \* \* \brief Adds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param option\_value\_len is Option value length to be added \* \* \param \*option\_value\_ptr is pointer to Option value data to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is 0 if option was not added, 1 if added \*/static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (option\_ptr != NULL) { uint16\_t option\_delta;
 option\_delta = (option\_number - \*previous\_option\_number);
 /\* \* \* Build option header \* \* \*/
 uint8\_t first\_byte;
 /\* First option length without extended part \*/ if (option\_len <= 12) { first\_byte = option\_len; }
 else if (option\_len > 12 && option\_len < 269) { first\_byte = 0x0D; }
 else /\*if (option\_len >= 269)\*/ { first\_byte = 0x0E; }
 uint8\_t \*dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Then option delta with extensions, and move pointer \*/ if (option\_delta <= 12) { dest\_packet[0] = first\_byte + (option\_delta << 4); dest\_packet += 1; }
 else if (option\_delta > 12 && option\_delta < 269) { dest\_packet[0] = first\_byte + 0xD0; option\_delta -= 13;
 dest\_packet[1] = (uint8\_t)option\_delta; dest\_packet += 2; } //This is currently dead code (but possibly needed in future) else /\*if (option\_delta >= 269)\*/ { dest\_packet[0] = first\_byte + 0xE0; option\_delta -= 269;
 dest\_packet[1] = (option\_delta >> 8); dest\_packet[2] = (uint8\_t)option\_delta; dest\_packet += 3; }
 /\* Now option length extensions, if needed \*/ if (option\_len > 12 && option\_len < 269) { dest\_packet[0] = (uint8\_t)(option\_len - 13); dest\_packet += 1; }
 else if (option\_len >= 269) { dest\_packet[0] = ((option\_len - 269) >> 8); dest\_packet[1] = (uint8\_t)(option\_len - 269); dest\_packet += 2; }
 \*previous\_option\_number = option\_number;
 /\* Write Option value \*/ memcpy(dest\_packet, option\_ptr, option\_len);
 /\* Increase destination Packet data pointer \*/ dest\_packet += option\_len;
 \*dst\_packet\_data\_pptr = dest\_packet;
 return 1; }
 /\* Success \*/ return 0;}
/\*\* \* \brief Constructs a uint Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data; NULL \* to compute size only. \* \* \param option\_value is Option value to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is total option size, or -1 in write failure case \*/static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t option\_value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ uint8\_t payload[4]; uint8\_t len = 0; /\* Construct the variable-length payload representing the value \*/ for (uint8\_t i = 0; i < 4; i++) { if (len > 0 || (option\_value & 0xff000000)) { payload[len++] = option\_value >> 24; } option\_value <<= 8; }
 /\* If output pointer isn't NULL, write it out \*/ if (dst\_packet\_data\_pptr) { // No need to check & handle return value, as the function returns failure only if the option pointer is zero // and it is pointing to a local variable here. sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, len, payload, option\_number, previous\_option\_number); }
 /\* Return the total option size \*/ return 1 + len;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint8\_t \*\*src\_pptr, uint16\_t \*src\_len\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Builds Option Uri-Query from given CoAP Header structure to Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param uint8\_t \*\*src\_ptr \* \* \param uint16\_t src\_len \* \* \paramsn\_coap\_option\_numbers\_e option option to be added \* \* \return Return value is 0 always \*/static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (src\_pptr != NULL) { const uint8\_t \*query\_ptr = src\_pptr; uint8\_t query\_part\_count = 0; uint16\_t query\_len = src\_len; uint8\_t i = 0; uint16\_t query\_part\_offset = 0;
 /\* Get query part count \*/ query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option);
 /\* \* \* \* Options by adding all parts to option \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* Get length of query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Get position of query part \*/ query\_part\_offset = sn\_coap\_builder\_options\_get\_option\_part\_position(query\_len, query\_ptr, i, option);
 /\* Add Uri-query's one part to Options \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, one\_query\_part\_len, src\_pptr + query\_part\_offset, option, previous\_option\_number); } } /\* Success \*/}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Calculates needed Packet data memory size for option \* \* \param path\_len is length of calculated strting(s) \* \* \param \*path\_ptr is pointer to calculated options \* \* \return Return value is count of needed memory as bytes for Uri-query option \*/static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option); uint8\_t i = 0; uint16\_t ret\_value = 0;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Calculate Uri-query options length \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* \* \* Length of Option number and Option value length \* \* \*/
 /\* Get length of Query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Check option length \*/ switch (option) { case (COAP\_OPTION\_ETAG): /\* Length 1-8 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 8) { return 0; } break; case (COAP\_OPTION\_LOCATION\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_URI\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_LOCATION\_QUERY): /\* Length 0-255 \*/ if (one\_query\_part\_len > 255) { return 0; } break; case (COAP\_OPTION\_URI\_QUERY): /\* Length 1-255 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 255) { return 0; } break;// case (COAP\_OPTION\_ACCEPT): /\* Length 0-2 \*/// if (one\_query\_part\_len > 2) {// return 0;// }// break; default: break; //impossible scenario currently }
 /\* Check if 4 bits are enough for writing Option value length \*/ if (one\_query\_part\_len <= 12) { /\* 4 bits are enough for Option value length \*/ ret\_value++; } else if (one\_query\_part\_len >= 13 && one\_query\_part\_len < 269) { /\* Extra byte for Option value length is needed \*/ ret\_value += 2; } //This can only happen if we are in default case above, currently is not happening else if (one\_query\_part\_len >= 270 && one\_query\_part\_len < 1034) { /\* Extra bytes for Option value length is needed \*/ ret\_value += 3; }
 /\* \* \* Length of Option value \* \* \*/
 /\* Increase options length \*/ ret\_value += one\_query\_part\_len; }
 /\* Success \*/ return ret\_value;}
/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets query part count from whole option string \* \* \param query\_len is length of whole Path \* \* \param \*query\_ptr is pointer to the start of whole Path \* \* \return Return value is count of query parts \*/static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t returned\_query\_count = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters (not first and last char) \*/ for (query\_len\_index = 1; query\_len\_index < query\_len - 1; query\_len\_index++) { /\* If new query part starts \*/ if (\*(query\_ptr + query\_len\_index) == char\_to\_search) { /\* If match \*/ returned\_query\_count++; } }
 returned\_query\_count++;
 return returned\_query\_count;}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets one's query part length from whole query string \* \* \param query\_len is length of whole string \* \* \param \*query\_ptr is pointer to the start of whole string \* \* \param query\_index is query part index to be found \* \* \param sn\_coap\_option\_numbers\_e option is option number of the option \* \* \return Return value is length of query part \*/static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option){ uint16\_t returned\_query\_part\_len = 0; uint8\_t temp\_query\_index = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters \*/ for (query\_len\_index = 0; query\_len\_index < query\_len; query\_len\_index++) { /\* Store character to temp\_char for helping debugging \*/ uint8\_t temp\_char = \*query\_ptr;
 /\* If new query part starts \*/ if (temp\_char == char\_to\_search && returned\_query\_part\_len > 0) { /\* returned\_query\_part\_len > 0 is for querys which start with "\0" \*/ /\* If query part index is wanted \*/ if (temp\_query\_index == query\_index) { /\* Return length of query part \*/ return returned\_query\_part\_len; } else { /\* Reset length of query part because wanted query part finding continues\*/ returned\_query\_part\_len = 0; }
 /\* Next query part is looped \*/ temp\_query\_index++;[View remainder of file in raw view](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_a5f4322a_20250120_235014.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

## Files

 d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARMmbed/mbed-os/commits/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1099 lines (950 loc) · 45.9 KB d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Top
## File metadata and controls

* Code
* Blame

1099 lines (950 loc) · 45.9 KB[Raw](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright (c) 2011-2015 ARM Limited. All rights reserved. \* SPDX-License-Identifier: Apache-2.0 \* Licensed under the Apache License, Version 2.0 (the License); you may \* not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an AS IS BASIS, WITHOUT \* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
/\*\* \* \file sn\_coap\_builder.c \* \* \brief CoAP Message builder \* \* Functionality: Builds CoAP message \* \*/
/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* INCLUDE FILES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
#include <string.h> /\* For memset() and memcpy() \*/
#include "ns\_types.h"#include "mbed-coap/sn\_coap\_header.h"#include "sn\_coap\_header\_internal.h"#include "sn\_coap\_protocol\_internal.h"#include "mbed-trace/mbed\_trace.h"
#define TRACE\_GROUP "coap"/\* \* \* \* LOCAL FUNCTION PROTOTYPES \* \* \* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_get\_option\_part\_position(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static void sn\_coap\_builder\_payload\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);
sn\_coap\_hdr\_s \*sn\_coap\_build\_response(struct coap\_s \*handle, const sn\_coap\_hdr\_s \*coap\_packet\_ptr, uint8\_t msg\_code){ sn\_coap\_hdr\_s \*coap\_res\_ptr;
 if (!coap\_packet\_ptr || !handle) { return NULL; }
 coap\_res\_ptr = sn\_coap\_parser\_alloc\_message(handle); if (!coap\_res\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate message!"); return NULL; }
 if (msg\_code == COAP\_MSG\_CODE\_REQUEST\_GET) { // Blockwise message response is new GET coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_ACKNOWLEDGEMENT; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; coap\_res\_ptr->msg\_id = coap\_packet\_ptr->msg\_id; } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_NON\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_NON\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else { handle->sn\_coap\_protocol\_free( coap\_res\_ptr ); return NULL; }
 if (coap\_packet\_ptr->token\_ptr) { coap\_res\_ptr->token\_len = coap\_packet\_ptr->token\_len; coap\_res\_ptr->token\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, coap\_packet\_ptr->token\_ptr, coap\_res\_ptr->token\_len); if (!coap\_res\_ptr->token\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate token!"); handle->sn\_coap\_protocol\_free(coap\_res\_ptr); return NULL; } } return coap\_res\_ptr;}
int16\_t sn\_coap\_builder(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_2(dst\_packet\_data\_ptr, src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
int16\_t sn\_coap\_builder\_2(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ uint8\_t \*base\_packet\_data\_ptr;
 /\* \* \* \* Check given pointers \* \* \* \*/ if (dst\_packet\_data\_ptr == NULL || src\_coap\_msg\_ptr == NULL) { return -2; }
 /\* Initialize given Packet data memory area with zero values \*/ uint16\_t dst\_byte\_count\_to\_be\_built = sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, blockwise\_payload\_size); if (!dst\_byte\_count\_to\_be\_built) { tr\_error("sn\_coap\_builder\_2 - failed to allocate message!"); return -1; }
 // XXX: this should not be needed anymore but I have no courage to remove it yet. memset(dst\_packet\_data\_ptr, 0, dst\_byte\_count\_to\_be\_built);
 /\* \* \* \* Store base (= original) destination Packet data pointer for later usage \* \* \* \*/ base\_packet\_data\_ptr = dst\_packet\_data\_ptr;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Header part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ if (sn\_coap\_builder\_header\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr) != 0) { /\* Header building failed \*/ tr\_error("sn\_coap\_builder\_2 - header building failed!"); return -1; }
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Options part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_options\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr);
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Payload part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_payload\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr); } /\* \* \* \* Return built Packet data length \* \* \* \*/ return (dst\_packet\_data\_ptr - base\_packet\_data\_ptr);}uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ (void)blockwise\_payload\_size; uint16\_t returned\_byte\_count = 0;
 if (!src\_coap\_msg\_ptr) { return 0; } /\* \* \* \* \* HEADER \* \* \* \* \*/
 /\* Header size is fixed \*/ returned\_byte\_count = COAP\_HEADER\_LENGTH;
 /\* \* \* \* \* OPTIONS \* \* \* \* \*/
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { uint16\_t repeatable\_option\_size = 0; /\* TOKEN - Length is 1-8 bytes \*/ if (src\_coap\_msg\_ptr->token\_ptr != NULL) { if (src\_coap\_msg\_ptr->token\_len > 8 || src\_coap\_msg\_ptr->token\_len < 1) { /\* Check that option is not longer than defined \*/ tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - token too large!"); return 0; }
 returned\_byte\_count += src\_coap\_msg\_ptr->token\_len; } /\* URI PATH - Repeatable option. Length of one option is 0-255 \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_coap\_msg\_ptr->uri\_path\_len, src\_coap\_msg\_ptr->uri\_path\_ptr, COAP\_OPTION\_URI\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri path size failed!"); return 0; } }
 uint16\_t tempInt = 0; /\* CONTENT FORMAT - An integer option, up to 2 bytes \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { if ((uint32\_t) src\_coap\_msg\_ptr->content\_format > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - content format too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &tempInt); } /\* If options list pointer exists \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr != NULL) {
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* ACCEPT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->accept > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - accept too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &tempInt); } /\* MAX AGE - An integer option, omitted for default. Up to 4 bytes \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &tempInt); } /\* PROXY URI - Length of this option is 1-1034 bytes \*/ if (src\_options\_list\_ptr->proxy\_uri\_ptr != NULL) { if (src\_options\_list\_ptr->proxy\_uri\_len >= 1 && src\_options\_list\_ptr->proxy\_uri\_len <= 12) { /\* Add option header byte(s) - depending of option length \*/ returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 13 && src\_options\_list\_ptr->proxy\_uri\_len <= 269) { returned\_byte\_count += 2; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 270 && src\_options\_list\_ptr->proxy\_uri\_len <= 1034) { returned\_byte\_count += 3; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - proxy uri too large!"); return 0; }
 /\* Add needed memory for Option value \*/ returned\_byte\_count += src\_options\_list\_ptr->proxy\_uri\_len; } /\* ETAG - Repeatable option. Length of this option is 1-8 bytes\*/ if (src\_options\_list\_ptr->etag\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->etag\_len, src\_options\_list\_ptr->etag\_ptr, COAP\_OPTION\_ETAG); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - etag too large!"); return 0; } } /\* URI HOST - Length of this option is 1-255 bytes \*/ if (src\_options\_list\_ptr->uri\_host\_ptr != NULL) { if (src\_options\_list\_ptr->uri\_host\_len > 0 && src\_options\_list\_ptr->uri\_host\_len <= 12) { returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->uri\_host\_len >= 13 && src\_options\_list\_ptr->uri\_host\_len <= 255) { returned\_byte\_count += 2; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri host too large!"); return 0; }
 returned\_byte\_count += src\_options\_list\_ptr->uri\_host\_len; } /\* LOCATION PATH - Repeatable option. Length of this option is 0-255 bytes\*/ if (src\_options\_list\_ptr->location\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_path\_len, src\_options\_list\_ptr->location\_path\_ptr, COAP\_OPTION\_LOCATION\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location path too large!"); return 0; } } /\* URI PORT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->uri\_port > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri port too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &tempInt); } /\* lOCATION QUERY - Repeatable option. Length of this option is 0-255 bytes \*/ if (src\_options\_list\_ptr->location\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_query\_len, src\_options\_list\_ptr->location\_query\_ptr, COAP\_OPTION\_LOCATION\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location query too large!"); return 0; } } /\* OBSERVE - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->observe > 0xffffff) { return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &tempInt); } /\* URI QUERY - Repeatable option. Length of this option is 1-255 \*/ if (src\_options\_list\_ptr->uri\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->uri\_query\_len, src\_options\_list\_ptr->uri\_query\_ptr, COAP\_OPTION\_URI\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - observe too large!"); return 0; } }
 /\* BLOCK 1 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block1 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block1 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &tempInt); } /\* SIZE1 - Length of this option is 0-4 bytes \*/ if (src\_options\_list\_ptr->use\_size1) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &tempInt); } /\* BLOCK 2 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block2 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block2 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &tempInt); } /\* SIZE2 - Length of this option is 0-4 bytes \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &tempInt); } }#if SN\_COAP\_BLOCKWISE\_ENABLED || SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE if ((src\_coap\_msg\_ptr->payload\_len > SN\_COAP\_MAX\_NONBLOCKWISE\_PAYLOAD\_SIZE) && (src\_coap\_msg\_ptr->payload\_len > blockwise\_payload\_size) && (blockwise\_payload\_size > 0)) { returned\_byte\_count += blockwise\_payload\_size; } else { returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len; }#else returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len;#endif if (src\_coap\_msg\_ptr->payload\_len) { returned\_byte\_count ++; /\* For payload marker \*/ } returned\_byte\_count += sn\_coap\_builder\_options\_calculate\_jump\_need(src\_coap\_msg\_ptr); } return returned\_byte\_count;}/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Checks if there is need for option jump \* \* \param \*src\_coap\_msg\_ptr is source of checked CoAP message \* \* \param block option marks if block option is to be added to message later. 0 = no block option, 1 = block1 and 2 = block2 \* \* \return Returns bytes needed for jumping \*/
static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ uint8\_t previous\_option\_number = 0; uint8\_t needed\_space = 0;
 const sn\_coap\_options\_list\_s\* options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 if (options\_list\_ptr != NULL) {
 /\* If option numbers greater than 12 is not used, then jumping is not needed \*/ //TODO: Check if this is really needed! Does it enhance perf? If not -> remove if (!options\_list\_ptr->uri\_query\_ptr && options\_list\_ptr->accept == COAP\_CT\_NONE && !options\_list\_ptr->location\_query\_ptr && options\_list\_ptr->block2 == COAP\_OPTION\_BLOCK\_NONE && options\_list\_ptr->block1 == COAP\_OPTION\_BLOCK\_NONE && !options\_list\_ptr->proxy\_uri\_ptr && options\_list\_ptr->max\_age == COAP\_OPTION\_MAX\_AGE\_DEFAULT && !options\_list\_ptr->use\_size1 && !options\_list\_ptr->use\_size2) { return 0; }
 if (options\_list\_ptr->uri\_host\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_HOST); }
 if (options\_list\_ptr->etag\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_ETAG); }
 if (options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { previous\_option\_number = (COAP\_OPTION\_OBSERVE); }
 if (options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { previous\_option\_number = (COAP\_OPTION\_URI\_PORT); }
 if (options\_list\_ptr->location\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_LOCATION\_PATH); }
 if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); } if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); }
 if (options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { if ((COAP\_OPTION\_MAX\_AGE - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_MAX\_AGE); }
 if (options\_list\_ptr->uri\_query\_ptr != NULL) { if ((COAP\_OPTION\_URI\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_URI\_QUERY); } if (options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((COAP\_OPTION\_ACCEPT - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_ACCEPT); } if (options\_list\_ptr->location\_query\_ptr != NULL) { if ((COAP\_OPTION\_LOCATION\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_LOCATION\_QUERY); } if (options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK2 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK2); } if (options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK1 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK1); } if (options\_list\_ptr->use\_size2) { if ((COAP\_OPTION\_SIZE2 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE2); } if (options\_list\_ptr->proxy\_uri\_ptr != NULL) { if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 12) { needed\_space += 1; } if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 269) { //Can not happen needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_PROXY\_URI); } if (options\_list\_ptr->use\_size1) { if ((COAP\_OPTION\_SIZE1 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE1); } }
 else { if (src\_coap\_msg\_ptr->uri\_path\_ptr != 0) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); }
 if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); } } return needed\_space;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Header part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in ok case and -1 in failure case \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check validity of Header values \* \* \* \*/ if (sn\_coap\_header\_validity\_check(src\_coap\_msg\_ptr, COAP\_VERSION) != 0) { tr\_error("sn\_coap\_builder\_header\_build - header build failed!"); return -1; }
 uint8\_t\* dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Set CoAP Version, Message type and Token length \*/ dest\_packet[0] = COAP\_VERSION | src\_coap\_msg\_ptr->msg\_type | src\_coap\_msg\_ptr->token\_len;
 /\* \* \* Add Message code \* \* \*/ dest\_packet[1] = src\_coap\_msg\_ptr->msg\_code;
 /\* \* \* Add Message ID \* \* \*/ dest\_packet[2] = (uint8\_t)(src\_coap\_msg\_ptr->msg\_id >> COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT); /\* MSB part \*/ dest\_packet[3] = (uint8\_t)src\_coap\_msg\_ptr->msg\_id; /\* LSB part \*/
 \*dst\_packet\_data\_pptr = dest\_packet + 4;
 /\* Success \*/ return 0;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in every case \*/static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check if Options are used at all \* \* \* \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr == NULL && src\_coap\_msg\_ptr->token\_ptr == NULL && src\_coap\_msg\_ptr->content\_format == COAP\_CT\_NONE && src\_coap\_msg\_ptr->options\_list\_ptr == NULL) { /\* If the empty message is confirmable it is CoAP ping. \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_CONFIRMABLE) { tr\_error("sn\_coap\_builder\_options\_build - options not used!"); } return 0; }
 /\* \* \* \* First add Token option \* \* \* \*/ if (src\_coap\_msg\_ptr->token\_len && src\_coap\_msg\_ptr->token\_ptr) { memcpy(\*dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->token\_ptr, src\_coap\_msg\_ptr->token\_len); } (\*dst\_packet\_data\_pptr) += src\_coap\_msg\_ptr->token\_len;
 /\* Then build rest of the options \*/
 /\* \* \* \* Initialize previous Option number for new built message \* \* \* \*/ uint16\_t previous\_option\_number = 0;
 //missing: COAP\_OPTION\_IF\_MATCH, COAP\_OPTION\_IF\_NONE\_MATCH, COAP\_OPTION\_SIZE
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* Check if less used options are used at all \*/ if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Uri-Host option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_host\_len, src\_options\_list\_ptr->uri\_host\_ptr, COAP\_OPTION\_URI\_HOST, &previous\_option\_number);
 /\* \* \* \* Build ETag option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->etag\_ptr, src\_options\_list\_ptr->etag\_len, COAP\_OPTION\_ETAG, &previous\_option\_number);
 /\* \* \* \* Build Observe option \* \* \* \* \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Port option \* \* \* \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_path\_ptr, src\_options\_list\_ptr->location\_path\_len, COAP\_OPTION\_LOCATION\_PATH, &previous\_option\_number); } /\* \* \* \* Build Uri-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->uri\_path\_ptr, src\_coap\_msg\_ptr->uri\_path\_len, COAP\_OPTION\_URI\_PATH, &previous\_option\_number);
 /\* \* \* \* Build Content-Type option \* \* \* \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &previous\_option\_number); }
 if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Max-Age option \* \* \* \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Query option \* \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_query\_ptr, src\_options\_list\_ptr->uri\_query\_len, COAP\_OPTION\_URI\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Accept option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->accept != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Query option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_query\_ptr, src\_options\_list\_ptr->location\_query\_len, COAP\_OPTION\_LOCATION\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Block2 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &previous\_option\_number); }
 /\* \* \* \* Build Block1 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &previous\_option\_number); }
 /\* \* \* \* Build Size2 option \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &previous\_option\_number); }
 /\* \* \* \* Build Proxy-Uri option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->proxy\_uri\_len, src\_options\_list\_ptr->proxy\_uri\_ptr, COAP\_OPTION\_PROXY\_URI, &previous\_option\_number);
 /\* \* \* \* Build Size1 option \* \* \* \*/ if (src\_options\_list\_ptr->use\_size1) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &previous\_option\_number); } }
 /\* Success \*/ return 0;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_value\_len, uint8\_t \*option\_value\_ptr, sn\_coap\_option\_numbers\_e option\_number) \* \* \brief Adds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param option\_value\_len is Option value length to be added \* \* \param \*option\_value\_ptr is pointer to Option value data to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is 0 if option was not added, 1 if added \*/static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (option\_ptr != NULL) { uint16\_t option\_delta;
 option\_delta = (option\_number - \*previous\_option\_number);
 /\* \* \* Build option header \* \* \*/
 uint8\_t first\_byte;
 /\* First option length without extended part \*/ if (option\_len <= 12) { first\_byte = option\_len; }
 else if (option\_len > 12 && option\_len < 269) { first\_byte = 0x0D; }
 else /\*if (option\_len >= 269)\*/ { first\_byte = 0x0E; }
 uint8\_t \*dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Then option delta with extensions, and move pointer \*/ if (option\_delta <= 12) { dest\_packet[0] = first\_byte + (option\_delta << 4); dest\_packet += 1; }
 else if (option\_delta > 12 && option\_delta < 269) { dest\_packet[0] = first\_byte + 0xD0; option\_delta -= 13;
 dest\_packet[1] = (uint8\_t)option\_delta; dest\_packet += 2; } //This is currently dead code (but possibly needed in future) else /\*if (option\_delta >= 269)\*/ { dest\_packet[0] = first\_byte + 0xE0; option\_delta -= 269;
 dest\_packet[1] = (option\_delta >> 8); dest\_packet[2] = (uint8\_t)option\_delta; dest\_packet += 3; }
 /\* Now option length extensions, if needed \*/ if (option\_len > 12 && option\_len < 269) { dest\_packet[0] = (uint8\_t)(option\_len - 13); dest\_packet += 1; }
 else if (option\_len >= 269) { dest\_packet[0] = ((option\_len - 269) >> 8); dest\_packet[1] = (uint8\_t)(option\_len - 269); dest\_packet += 2; }
 \*previous\_option\_number = option\_number;
 /\* Write Option value \*/ memcpy(dest\_packet, option\_ptr, option\_len);
 /\* Increase destination Packet data pointer \*/ dest\_packet += option\_len;
 \*dst\_packet\_data\_pptr = dest\_packet;
 return 1; }
 /\* Success \*/ return 0;}
/\*\* \* \brief Constructs a uint Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data; NULL \* to compute size only. \* \* \param option\_value is Option value to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is total option size, or -1 in write failure case \*/static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t option\_value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ uint8\_t payload[4]; uint8\_t len = 0; /\* Construct the variable-length payload representing the value \*/ for (uint8\_t i = 0; i < 4; i++) { if (len > 0 || (option\_value & 0xff000000)) { payload[len++] = option\_value >> 24; } option\_value <<= 8; }
 /\* If output pointer isn't NULL, write it out \*/ if (dst\_packet\_data\_pptr) { // No need to check & handle return value, as the function returns failure only if the option pointer is zero // and it is pointing to a local variable here. sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, len, payload, option\_number, previous\_option\_number); }
 /\* Return the total option size \*/ return 1 + len;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint8\_t \*\*src\_pptr, uint16\_t \*src\_len\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Builds Option Uri-Query from given CoAP Header structure to Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param uint8\_t \*\*src\_ptr \* \* \param uint16\_t src\_len \* \* \paramsn\_coap\_option\_numbers\_e option option to be added \* \* \return Return value is 0 always \*/static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (src\_pptr != NULL) { const uint8\_t \*query\_ptr = src\_pptr; uint8\_t query\_part\_count = 0; uint16\_t query\_len = src\_len; uint8\_t i = 0; uint16\_t query\_part\_offset = 0;
 /\* Get query part count \*/ query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option);
 /\* \* \* \* Options by adding all parts to option \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* Get length of query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Get position of query part \*/ query\_part\_offset = sn\_coap\_builder\_options\_get\_option\_part\_position(query\_len, query\_ptr, i, option);
 /\* Add Uri-query's one part to Options \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, one\_query\_part\_len, src\_pptr + query\_part\_offset, option, previous\_option\_number); } } /\* Success \*/}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Calculates needed Packet data memory size for option \* \* \param path\_len is length of calculated strting(s) \* \* \param \*path\_ptr is pointer to calculated options \* \* \return Return value is count of needed memory as bytes for Uri-query option \*/static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option); uint8\_t i = 0; uint16\_t ret\_value = 0;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Calculate Uri-query options length \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* \* \* Length of Option number and Option value length \* \* \*/
 /\* Get length of Query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Check option length \*/ switch (option) { case (COAP\_OPTION\_ETAG): /\* Length 1-8 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 8) { return 0; } break; case (COAP\_OPTION\_LOCATION\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_URI\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_LOCATION\_QUERY): /\* Length 0-255 \*/ if (one\_query\_part\_len > 255) { return 0; } break; case (COAP\_OPTION\_URI\_QUERY): /\* Length 1-255 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 255) { return 0; } break;// case (COAP\_OPTION\_ACCEPT): /\* Length 0-2 \*/// if (one\_query\_part\_len > 2) {// return 0;// }// break; default: break; //impossible scenario currently }
 /\* Check if 4 bits are enough for writing Option value length \*/ if (one\_query\_part\_len <= 12) { /\* 4 bits are enough for Option value length \*/ ret\_value++; } else if (one\_query\_part\_len >= 13 && one\_query\_part\_len < 269) { /\* Extra byte for Option value length is needed \*/ ret\_value += 2; } //This can only happen if we are in default case above, currently is not happening else if (one\_query\_part\_len >= 270 && one\_query\_part\_len < 1034) { /\* Extra bytes for Option value length is needed \*/ ret\_value += 3; }
 /\* \* \* Length of Option value \* \* \*/
 /\* Increase options length \*/ ret\_value += one\_query\_part\_len; }
 /\* Success \*/ return ret\_value;}
/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets query part count from whole option string \* \* \param query\_len is length of whole Path \* \* \param \*query\_ptr is pointer to the start of whole Path \* \* \return Return value is count of query parts \*/static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t returned\_query\_count = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters (not first and last char) \*/ for (query\_len\_index = 1; query\_len\_index < query\_len - 1; query\_len\_index++) { /\* If new query part starts \*/ if (\*(query\_ptr + query\_len\_index) == char\_to\_search) { /\* If match \*/ returned\_query\_count++; } }
 returned\_query\_count++;
 return returned\_query\_count;}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets one's query part length from whole query string \* \* \param query\_len is length of whole string \* \* \param \*query\_ptr is pointer to the start of whole string \* \* \param query\_index is query part index to be found \* \* \param sn\_coap\_option\_numbers\_e option is option number of the option \* \* \return Return value is length of query part \*/static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option){ uint16\_t returned\_query\_part\_len = 0; uint8\_t temp\_query\_index = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters \*/ for (query\_len\_index = 0; query\_len\_index < query\_len; query\_len\_index++) { /\* Store character to temp\_char for helping debugging \*/ uint8\_t temp\_char = \*query\_ptr;
 /\* If new query part starts \*/ if (temp\_char == char\_to\_search && returned\_query\_part\_len > 0) { /\* returned\_query\_part\_len > 0 is for querys which start with "\0" \*/ /\* If query part index is wanted \*/ if (temp\_query\_index == query\_index) { /\* Return length of query part \*/ return returned\_query\_part\_len; } else { /\* Reset length of query part because wanted query part finding continues\*/ returned\_query\_part\_len = 0; }
 /\* Next query part is looped \*/ temp\_query\_index++;[View remainder of file in raw view](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_56e2d73a_20250120_235009.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

## Files

 d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARMmbed/mbed-os/commits/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1099 lines (950 loc) · 45.9 KB d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Top
## File metadata and controls

* Code
* Blame

1099 lines (950 loc) · 45.9 KB[Raw](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright (c) 2011-2015 ARM Limited. All rights reserved. \* SPDX-License-Identifier: Apache-2.0 \* Licensed under the Apache License, Version 2.0 (the License); you may \* not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an AS IS BASIS, WITHOUT \* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
/\*\* \* \file sn\_coap\_builder.c \* \* \brief CoAP Message builder \* \* Functionality: Builds CoAP message \* \*/
/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* INCLUDE FILES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
#include <string.h> /\* For memset() and memcpy() \*/
#include "ns\_types.h"#include "mbed-coap/sn\_coap\_header.h"#include "sn\_coap\_header\_internal.h"#include "sn\_coap\_protocol\_internal.h"#include "mbed-trace/mbed\_trace.h"
#define TRACE\_GROUP "coap"/\* \* \* \* LOCAL FUNCTION PROTOTYPES \* \* \* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_get\_option\_part\_position(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static void sn\_coap\_builder\_payload\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);
sn\_coap\_hdr\_s \*sn\_coap\_build\_response(struct coap\_s \*handle, const sn\_coap\_hdr\_s \*coap\_packet\_ptr, uint8\_t msg\_code){ sn\_coap\_hdr\_s \*coap\_res\_ptr;
 if (!coap\_packet\_ptr || !handle) { return NULL; }
 coap\_res\_ptr = sn\_coap\_parser\_alloc\_message(handle); if (!coap\_res\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate message!"); return NULL; }
 if (msg\_code == COAP\_MSG\_CODE\_REQUEST\_GET) { // Blockwise message response is new GET coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_ACKNOWLEDGEMENT; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; coap\_res\_ptr->msg\_id = coap\_packet\_ptr->msg\_id; } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_NON\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_NON\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else { handle->sn\_coap\_protocol\_free( coap\_res\_ptr ); return NULL; }
 if (coap\_packet\_ptr->token\_ptr) { coap\_res\_ptr->token\_len = coap\_packet\_ptr->token\_len; coap\_res\_ptr->token\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, coap\_packet\_ptr->token\_ptr, coap\_res\_ptr->token\_len); if (!coap\_res\_ptr->token\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate token!"); handle->sn\_coap\_protocol\_free(coap\_res\_ptr); return NULL; } } return coap\_res\_ptr;}
int16\_t sn\_coap\_builder(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_2(dst\_packet\_data\_ptr, src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
int16\_t sn\_coap\_builder\_2(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ uint8\_t \*base\_packet\_data\_ptr;
 /\* \* \* \* Check given pointers \* \* \* \*/ if (dst\_packet\_data\_ptr == NULL || src\_coap\_msg\_ptr == NULL) { return -2; }
 /\* Initialize given Packet data memory area with zero values \*/ uint16\_t dst\_byte\_count\_to\_be\_built = sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, blockwise\_payload\_size); if (!dst\_byte\_count\_to\_be\_built) { tr\_error("sn\_coap\_builder\_2 - failed to allocate message!"); return -1; }
 // XXX: this should not be needed anymore but I have no courage to remove it yet. memset(dst\_packet\_data\_ptr, 0, dst\_byte\_count\_to\_be\_built);
 /\* \* \* \* Store base (= original) destination Packet data pointer for later usage \* \* \* \*/ base\_packet\_data\_ptr = dst\_packet\_data\_ptr;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Header part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ if (sn\_coap\_builder\_header\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr) != 0) { /\* Header building failed \*/ tr\_error("sn\_coap\_builder\_2 - header building failed!"); return -1; }
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Options part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_options\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr);
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Payload part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_payload\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr); } /\* \* \* \* Return built Packet data length \* \* \* \*/ return (dst\_packet\_data\_ptr - base\_packet\_data\_ptr);}uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ (void)blockwise\_payload\_size; uint16\_t returned\_byte\_count = 0;
 if (!src\_coap\_msg\_ptr) { return 0; } /\* \* \* \* \* HEADER \* \* \* \* \*/
 /\* Header size is fixed \*/ returned\_byte\_count = COAP\_HEADER\_LENGTH;
 /\* \* \* \* \* OPTIONS \* \* \* \* \*/
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { uint16\_t repeatable\_option\_size = 0; /\* TOKEN - Length is 1-8 bytes \*/ if (src\_coap\_msg\_ptr->token\_ptr != NULL) { if (src\_coap\_msg\_ptr->token\_len > 8 || src\_coap\_msg\_ptr->token\_len < 1) { /\* Check that option is not longer than defined \*/ tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - token too large!"); return 0; }
 returned\_byte\_count += src\_coap\_msg\_ptr->token\_len; } /\* URI PATH - Repeatable option. Length of one option is 0-255 \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_coap\_msg\_ptr->uri\_path\_len, src\_coap\_msg\_ptr->uri\_path\_ptr, COAP\_OPTION\_URI\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri path size failed!"); return 0; } }
 uint16\_t tempInt = 0; /\* CONTENT FORMAT - An integer option, up to 2 bytes \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { if ((uint32\_t) src\_coap\_msg\_ptr->content\_format > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - content format too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &tempInt); } /\* If options list pointer exists \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr != NULL) {
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* ACCEPT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->accept > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - accept too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &tempInt); } /\* MAX AGE - An integer option, omitted for default. Up to 4 bytes \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &tempInt); } /\* PROXY URI - Length of this option is 1-1034 bytes \*/ if (src\_options\_list\_ptr->proxy\_uri\_ptr != NULL) { if (src\_options\_list\_ptr->proxy\_uri\_len >= 1 && src\_options\_list\_ptr->proxy\_uri\_len <= 12) { /\* Add option header byte(s) - depending of option length \*/ returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 13 && src\_options\_list\_ptr->proxy\_uri\_len <= 269) { returned\_byte\_count += 2; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 270 && src\_options\_list\_ptr->proxy\_uri\_len <= 1034) { returned\_byte\_count += 3; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - proxy uri too large!"); return 0; }
 /\* Add needed memory for Option value \*/ returned\_byte\_count += src\_options\_list\_ptr->proxy\_uri\_len; } /\* ETAG - Repeatable option. Length of this option is 1-8 bytes\*/ if (src\_options\_list\_ptr->etag\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->etag\_len, src\_options\_list\_ptr->etag\_ptr, COAP\_OPTION\_ETAG); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - etag too large!"); return 0; } } /\* URI HOST - Length of this option is 1-255 bytes \*/ if (src\_options\_list\_ptr->uri\_host\_ptr != NULL) { if (src\_options\_list\_ptr->uri\_host\_len > 0 && src\_options\_list\_ptr->uri\_host\_len <= 12) { returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->uri\_host\_len >= 13 && src\_options\_list\_ptr->uri\_host\_len <= 255) { returned\_byte\_count += 2; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri host too large!"); return 0; }
 returned\_byte\_count += src\_options\_list\_ptr->uri\_host\_len; } /\* LOCATION PATH - Repeatable option. Length of this option is 0-255 bytes\*/ if (src\_options\_list\_ptr->location\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_path\_len, src\_options\_list\_ptr->location\_path\_ptr, COAP\_OPTION\_LOCATION\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location path too large!"); return 0; } } /\* URI PORT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->uri\_port > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri port too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &tempInt); } /\* lOCATION QUERY - Repeatable option. Length of this option is 0-255 bytes \*/ if (src\_options\_list\_ptr->location\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_query\_len, src\_options\_list\_ptr->location\_query\_ptr, COAP\_OPTION\_LOCATION\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location query too large!"); return 0; } } /\* OBSERVE - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->observe > 0xffffff) { return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &tempInt); } /\* URI QUERY - Repeatable option. Length of this option is 1-255 \*/ if (src\_options\_list\_ptr->uri\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->uri\_query\_len, src\_options\_list\_ptr->uri\_query\_ptr, COAP\_OPTION\_URI\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - observe too large!"); return 0; } }
 /\* BLOCK 1 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block1 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block1 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &tempInt); } /\* SIZE1 - Length of this option is 0-4 bytes \*/ if (src\_options\_list\_ptr->use\_size1) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &tempInt); } /\* BLOCK 2 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block2 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block2 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &tempInt); } /\* SIZE2 - Length of this option is 0-4 bytes \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &tempInt); } }#if SN\_COAP\_BLOCKWISE\_ENABLED || SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE if ((src\_coap\_msg\_ptr->payload\_len > SN\_COAP\_MAX\_NONBLOCKWISE\_PAYLOAD\_SIZE) && (src\_coap\_msg\_ptr->payload\_len > blockwise\_payload\_size) && (blockwise\_payload\_size > 0)) { returned\_byte\_count += blockwise\_payload\_size; } else { returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len; }#else returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len;#endif if (src\_coap\_msg\_ptr->payload\_len) { returned\_byte\_count ++; /\* For payload marker \*/ } returned\_byte\_count += sn\_coap\_builder\_options\_calculate\_jump\_need(src\_coap\_msg\_ptr); } return returned\_byte\_count;}/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Checks if there is need for option jump \* \* \param \*src\_coap\_msg\_ptr is source of checked CoAP message \* \* \param block option marks if block option is to be added to message later. 0 = no block option, 1 = block1 and 2 = block2 \* \* \return Returns bytes needed for jumping \*/
static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ uint8\_t previous\_option\_number = 0; uint8\_t needed\_space = 0;
 const sn\_coap\_options\_list\_s\* options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 if (options\_list\_ptr != NULL) {
 /\* If option numbers greater than 12 is not used, then jumping is not needed \*/ //TODO: Check if this is really needed! Does it enhance perf? If not -> remove if (!options\_list\_ptr->uri\_query\_ptr && options\_list\_ptr->accept == COAP\_CT\_NONE && !options\_list\_ptr->location\_query\_ptr && options\_list\_ptr->block2 == COAP\_OPTION\_BLOCK\_NONE && options\_list\_ptr->block1 == COAP\_OPTION\_BLOCK\_NONE && !options\_list\_ptr->proxy\_uri\_ptr && options\_list\_ptr->max\_age == COAP\_OPTION\_MAX\_AGE\_DEFAULT && !options\_list\_ptr->use\_size1 && !options\_list\_ptr->use\_size2) { return 0; }
 if (options\_list\_ptr->uri\_host\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_HOST); }
 if (options\_list\_ptr->etag\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_ETAG); }
 if (options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { previous\_option\_number = (COAP\_OPTION\_OBSERVE); }
 if (options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { previous\_option\_number = (COAP\_OPTION\_URI\_PORT); }
 if (options\_list\_ptr->location\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_LOCATION\_PATH); }
 if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); } if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); }
 if (options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { if ((COAP\_OPTION\_MAX\_AGE - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_MAX\_AGE); }
 if (options\_list\_ptr->uri\_query\_ptr != NULL) { if ((COAP\_OPTION\_URI\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_URI\_QUERY); } if (options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((COAP\_OPTION\_ACCEPT - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_ACCEPT); } if (options\_list\_ptr->location\_query\_ptr != NULL) { if ((COAP\_OPTION\_LOCATION\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_LOCATION\_QUERY); } if (options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK2 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK2); } if (options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK1 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK1); } if (options\_list\_ptr->use\_size2) { if ((COAP\_OPTION\_SIZE2 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE2); } if (options\_list\_ptr->proxy\_uri\_ptr != NULL) { if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 12) { needed\_space += 1; } if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 269) { //Can not happen needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_PROXY\_URI); } if (options\_list\_ptr->use\_size1) { if ((COAP\_OPTION\_SIZE1 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE1); } }
 else { if (src\_coap\_msg\_ptr->uri\_path\_ptr != 0) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); }
 if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); } } return needed\_space;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Header part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in ok case and -1 in failure case \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check validity of Header values \* \* \* \*/ if (sn\_coap\_header\_validity\_check(src\_coap\_msg\_ptr, COAP\_VERSION) != 0) { tr\_error("sn\_coap\_builder\_header\_build - header build failed!"); return -1; }
 uint8\_t\* dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Set CoAP Version, Message type and Token length \*/ dest\_packet[0] = COAP\_VERSION | src\_coap\_msg\_ptr->msg\_type | src\_coap\_msg\_ptr->token\_len;
 /\* \* \* Add Message code \* \* \*/ dest\_packet[1] = src\_coap\_msg\_ptr->msg\_code;
 /\* \* \* Add Message ID \* \* \*/ dest\_packet[2] = (uint8\_t)(src\_coap\_msg\_ptr->msg\_id >> COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT); /\* MSB part \*/ dest\_packet[3] = (uint8\_t)src\_coap\_msg\_ptr->msg\_id; /\* LSB part \*/
 \*dst\_packet\_data\_pptr = dest\_packet + 4;
 /\* Success \*/ return 0;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in every case \*/static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check if Options are used at all \* \* \* \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr == NULL && src\_coap\_msg\_ptr->token\_ptr == NULL && src\_coap\_msg\_ptr->content\_format == COAP\_CT\_NONE && src\_coap\_msg\_ptr->options\_list\_ptr == NULL) { /\* If the empty message is confirmable it is CoAP ping. \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_CONFIRMABLE) { tr\_error("sn\_coap\_builder\_options\_build - options not used!"); } return 0; }
 /\* \* \* \* First add Token option \* \* \* \*/ if (src\_coap\_msg\_ptr->token\_len && src\_coap\_msg\_ptr->token\_ptr) { memcpy(\*dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->token\_ptr, src\_coap\_msg\_ptr->token\_len); } (\*dst\_packet\_data\_pptr) += src\_coap\_msg\_ptr->token\_len;
 /\* Then build rest of the options \*/
 /\* \* \* \* Initialize previous Option number for new built message \* \* \* \*/ uint16\_t previous\_option\_number = 0;
 //missing: COAP\_OPTION\_IF\_MATCH, COAP\_OPTION\_IF\_NONE\_MATCH, COAP\_OPTION\_SIZE
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* Check if less used options are used at all \*/ if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Uri-Host option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_host\_len, src\_options\_list\_ptr->uri\_host\_ptr, COAP\_OPTION\_URI\_HOST, &previous\_option\_number);
 /\* \* \* \* Build ETag option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->etag\_ptr, src\_options\_list\_ptr->etag\_len, COAP\_OPTION\_ETAG, &previous\_option\_number);
 /\* \* \* \* Build Observe option \* \* \* \* \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Port option \* \* \* \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_path\_ptr, src\_options\_list\_ptr->location\_path\_len, COAP\_OPTION\_LOCATION\_PATH, &previous\_option\_number); } /\* \* \* \* Build Uri-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->uri\_path\_ptr, src\_coap\_msg\_ptr->uri\_path\_len, COAP\_OPTION\_URI\_PATH, &previous\_option\_number);
 /\* \* \* \* Build Content-Type option \* \* \* \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &previous\_option\_number); }
 if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Max-Age option \* \* \* \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Query option \* \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_query\_ptr, src\_options\_list\_ptr->uri\_query\_len, COAP\_OPTION\_URI\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Accept option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->accept != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Query option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_query\_ptr, src\_options\_list\_ptr->location\_query\_len, COAP\_OPTION\_LOCATION\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Block2 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &previous\_option\_number); }
 /\* \* \* \* Build Block1 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &previous\_option\_number); }
 /\* \* \* \* Build Size2 option \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &previous\_option\_number); }
 /\* \* \* \* Build Proxy-Uri option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->proxy\_uri\_len, src\_options\_list\_ptr->proxy\_uri\_ptr, COAP\_OPTION\_PROXY\_URI, &previous\_option\_number);
 /\* \* \* \* Build Size1 option \* \* \* \*/ if (src\_options\_list\_ptr->use\_size1) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &previous\_option\_number); } }
 /\* Success \*/ return 0;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_value\_len, uint8\_t \*option\_value\_ptr, sn\_coap\_option\_numbers\_e option\_number) \* \* \brief Adds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param option\_value\_len is Option value length to be added \* \* \param \*option\_value\_ptr is pointer to Option value data to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is 0 if option was not added, 1 if added \*/static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (option\_ptr != NULL) { uint16\_t option\_delta;
 option\_delta = (option\_number - \*previous\_option\_number);
 /\* \* \* Build option header \* \* \*/
 uint8\_t first\_byte;
 /\* First option length without extended part \*/ if (option\_len <= 12) { first\_byte = option\_len; }
 else if (option\_len > 12 && option\_len < 269) { first\_byte = 0x0D; }
 else /\*if (option\_len >= 269)\*/ { first\_byte = 0x0E; }
 uint8\_t \*dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Then option delta with extensions, and move pointer \*/ if (option\_delta <= 12) { dest\_packet[0] = first\_byte + (option\_delta << 4); dest\_packet += 1; }
 else if (option\_delta > 12 && option\_delta < 269) { dest\_packet[0] = first\_byte + 0xD0; option\_delta -= 13;
 dest\_packet[1] = (uint8\_t)option\_delta; dest\_packet += 2; } //This is currently dead code (but possibly needed in future) else /\*if (option\_delta >= 269)\*/ { dest\_packet[0] = first\_byte + 0xE0; option\_delta -= 269;
 dest\_packet[1] = (option\_delta >> 8); dest\_packet[2] = (uint8\_t)option\_delta; dest\_packet += 3; }
 /\* Now option length extensions, if needed \*/ if (option\_len > 12 && option\_len < 269) { dest\_packet[0] = (uint8\_t)(option\_len - 13); dest\_packet += 1; }
 else if (option\_len >= 269) { dest\_packet[0] = ((option\_len - 269) >> 8); dest\_packet[1] = (uint8\_t)(option\_len - 269); dest\_packet += 2; }
 \*previous\_option\_number = option\_number;
 /\* Write Option value \*/ memcpy(dest\_packet, option\_ptr, option\_len);
 /\* Increase destination Packet data pointer \*/ dest\_packet += option\_len;
 \*dst\_packet\_data\_pptr = dest\_packet;
 return 1; }
 /\* Success \*/ return 0;}
/\*\* \* \brief Constructs a uint Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data; NULL \* to compute size only. \* \* \param option\_value is Option value to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is total option size, or -1 in write failure case \*/static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t option\_value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ uint8\_t payload[4]; uint8\_t len = 0; /\* Construct the variable-length payload representing the value \*/ for (uint8\_t i = 0; i < 4; i++) { if (len > 0 || (option\_value & 0xff000000)) { payload[len++] = option\_value >> 24; } option\_value <<= 8; }
 /\* If output pointer isn't NULL, write it out \*/ if (dst\_packet\_data\_pptr) { // No need to check & handle return value, as the function returns failure only if the option pointer is zero // and it is pointing to a local variable here. sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, len, payload, option\_number, previous\_option\_number); }
 /\* Return the total option size \*/ return 1 + len;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint8\_t \*\*src\_pptr, uint16\_t \*src\_len\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Builds Option Uri-Query from given CoAP Header structure to Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param uint8\_t \*\*src\_ptr \* \* \param uint16\_t src\_len \* \* \paramsn\_coap\_option\_numbers\_e option option to be added \* \* \return Return value is 0 always \*/static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (src\_pptr != NULL) { const uint8\_t \*query\_ptr = src\_pptr; uint8\_t query\_part\_count = 0; uint16\_t query\_len = src\_len; uint8\_t i = 0; uint16\_t query\_part\_offset = 0;
 /\* Get query part count \*/ query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option);
 /\* \* \* \* Options by adding all parts to option \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* Get length of query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Get position of query part \*/ query\_part\_offset = sn\_coap\_builder\_options\_get\_option\_part\_position(query\_len, query\_ptr, i, option);
 /\* Add Uri-query's one part to Options \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, one\_query\_part\_len, src\_pptr + query\_part\_offset, option, previous\_option\_number); } } /\* Success \*/}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Calculates needed Packet data memory size for option \* \* \param path\_len is length of calculated strting(s) \* \* \param \*path\_ptr is pointer to calculated options \* \* \return Return value is count of needed memory as bytes for Uri-query option \*/static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option); uint8\_t i = 0; uint16\_t ret\_value = 0;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Calculate Uri-query options length \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* \* \* Length of Option number and Option value length \* \* \*/
 /\* Get length of Query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Check option length \*/ switch (option) { case (COAP\_OPTION\_ETAG): /\* Length 1-8 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 8) { return 0; } break; case (COAP\_OPTION\_LOCATION\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_URI\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_LOCATION\_QUERY): /\* Length 0-255 \*/ if (one\_query\_part\_len > 255) { return 0; } break; case (COAP\_OPTION\_URI\_QUERY): /\* Length 1-255 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 255) { return 0; } break;// case (COAP\_OPTION\_ACCEPT): /\* Length 0-2 \*/// if (one\_query\_part\_len > 2) {// return 0;// }// break; default: break; //impossible scenario currently }
 /\* Check if 4 bits are enough for writing Option value length \*/ if (one\_query\_part\_len <= 12) { /\* 4 bits are enough for Option value length \*/ ret\_value++; } else if (one\_query\_part\_len >= 13 && one\_query\_part\_len < 269) { /\* Extra byte for Option value length is needed \*/ ret\_value += 2; } //This can only happen if we are in default case above, currently is not happening else if (one\_query\_part\_len >= 270 && one\_query\_part\_len < 1034) { /\* Extra bytes for Option value length is needed \*/ ret\_value += 3; }
 /\* \* \* Length of Option value \* \* \*/
 /\* Increase options length \*/ ret\_value += one\_query\_part\_len; }
 /\* Success \*/ return ret\_value;}
/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets query part count from whole option string \* \* \param query\_len is length of whole Path \* \* \param \*query\_ptr is pointer to the start of whole Path \* \* \return Return value is count of query parts \*/static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t returned\_query\_count = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters (not first and last char) \*/ for (query\_len\_index = 1; query\_len\_index < query\_len - 1; query\_len\_index++) { /\* If new query part starts \*/ if (\*(query\_ptr + query\_len\_index) == char\_to\_search) { /\* If match \*/ returned\_query\_count++; } }
 returned\_query\_count++;
 return returned\_query\_count;}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets one's query part length from whole query string \* \* \param query\_len is length of whole string \* \* \param \*query\_ptr is pointer to the start of whole string \* \* \param query\_index is query part index to be found \* \* \param sn\_coap\_option\_numbers\_e option is option number of the option \* \* \return Return value is length of query part \*/static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option){ uint16\_t returned\_query\_part\_len = 0; uint8\_t temp\_query\_index = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters \*/ for (query\_len\_index = 0; query\_len\_index < query\_len; query\_len\_index++) { /\* Store character to temp\_char for helping debugging \*/ uint8\_t temp\_char = \*query\_ptr;
 /\* If new query part starts \*/ if (temp\_char == char\_to\_search && returned\_query\_part\_len > 0) { /\* returned\_query\_part\_len > 0 is for querys which start with "\0" \*/ /\* If query part index is wanted \*/ if (temp\_query\_index == query\_index) { /\* Return length of query part \*/ return returned\_query\_part\_len; } else { /\* Reset length of query part because wanted query part finding continues\*/ returned\_query\_part\_len = 0; }
 /\* Next query part is looped \*/ temp\_query\_index++;[View remainder of file in raw view](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_84f16e90_20250120_235019.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

## Files

 d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARMmbed/mbed-os/commits/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1099 lines (950 loc) · 45.9 KB d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Top
## File metadata and controls

* Code
* Blame

1099 lines (950 loc) · 45.9 KB[Raw](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright (c) 2011-2015 ARM Limited. All rights reserved. \* SPDX-License-Identifier: Apache-2.0 \* Licensed under the Apache License, Version 2.0 (the License); you may \* not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an AS IS BASIS, WITHOUT \* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
/\*\* \* \file sn\_coap\_builder.c \* \* \brief CoAP Message builder \* \* Functionality: Builds CoAP message \* \*/
/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* INCLUDE FILES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
#include <string.h> /\* For memset() and memcpy() \*/
#include "ns\_types.h"#include "mbed-coap/sn\_coap\_header.h"#include "sn\_coap\_header\_internal.h"#include "sn\_coap\_protocol\_internal.h"#include "mbed-trace/mbed\_trace.h"
#define TRACE\_GROUP "coap"/\* \* \* \* LOCAL FUNCTION PROTOTYPES \* \* \* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_get\_option\_part\_position(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static void sn\_coap\_builder\_payload\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);
sn\_coap\_hdr\_s \*sn\_coap\_build\_response(struct coap\_s \*handle, const sn\_coap\_hdr\_s \*coap\_packet\_ptr, uint8\_t msg\_code){ sn\_coap\_hdr\_s \*coap\_res\_ptr;
 if (!coap\_packet\_ptr || !handle) { return NULL; }
 coap\_res\_ptr = sn\_coap\_parser\_alloc\_message(handle); if (!coap\_res\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate message!"); return NULL; }
 if (msg\_code == COAP\_MSG\_CODE\_REQUEST\_GET) { // Blockwise message response is new GET coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_ACKNOWLEDGEMENT; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; coap\_res\_ptr->msg\_id = coap\_packet\_ptr->msg\_id; } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_NON\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_NON\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else { handle->sn\_coap\_protocol\_free( coap\_res\_ptr ); return NULL; }
 if (coap\_packet\_ptr->token\_ptr) { coap\_res\_ptr->token\_len = coap\_packet\_ptr->token\_len; coap\_res\_ptr->token\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, coap\_packet\_ptr->token\_ptr, coap\_res\_ptr->token\_len); if (!coap\_res\_ptr->token\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate token!"); handle->sn\_coap\_protocol\_free(coap\_res\_ptr); return NULL; } } return coap\_res\_ptr;}
int16\_t sn\_coap\_builder(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_2(dst\_packet\_data\_ptr, src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
int16\_t sn\_coap\_builder\_2(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ uint8\_t \*base\_packet\_data\_ptr;
 /\* \* \* \* Check given pointers \* \* \* \*/ if (dst\_packet\_data\_ptr == NULL || src\_coap\_msg\_ptr == NULL) { return -2; }
 /\* Initialize given Packet data memory area with zero values \*/ uint16\_t dst\_byte\_count\_to\_be\_built = sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, blockwise\_payload\_size); if (!dst\_byte\_count\_to\_be\_built) { tr\_error("sn\_coap\_builder\_2 - failed to allocate message!"); return -1; }
 // XXX: this should not be needed anymore but I have no courage to remove it yet. memset(dst\_packet\_data\_ptr, 0, dst\_byte\_count\_to\_be\_built);
 /\* \* \* \* Store base (= original) destination Packet data pointer for later usage \* \* \* \*/ base\_packet\_data\_ptr = dst\_packet\_data\_ptr;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Header part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ if (sn\_coap\_builder\_header\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr) != 0) { /\* Header building failed \*/ tr\_error("sn\_coap\_builder\_2 - header building failed!"); return -1; }
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Options part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_options\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr);
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Payload part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_payload\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr); } /\* \* \* \* Return built Packet data length \* \* \* \*/ return (dst\_packet\_data\_ptr - base\_packet\_data\_ptr);}uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ (void)blockwise\_payload\_size; uint16\_t returned\_byte\_count = 0;
 if (!src\_coap\_msg\_ptr) { return 0; } /\* \* \* \* \* HEADER \* \* \* \* \*/
 /\* Header size is fixed \*/ returned\_byte\_count = COAP\_HEADER\_LENGTH;
 /\* \* \* \* \* OPTIONS \* \* \* \* \*/
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { uint16\_t repeatable\_option\_size = 0; /\* TOKEN - Length is 1-8 bytes \*/ if (src\_coap\_msg\_ptr->token\_ptr != NULL) { if (src\_coap\_msg\_ptr->token\_len > 8 || src\_coap\_msg\_ptr->token\_len < 1) { /\* Check that option is not longer than defined \*/ tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - token too large!"); return 0; }
 returned\_byte\_count += src\_coap\_msg\_ptr->token\_len; } /\* URI PATH - Repeatable option. Length of one option is 0-255 \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_coap\_msg\_ptr->uri\_path\_len, src\_coap\_msg\_ptr->uri\_path\_ptr, COAP\_OPTION\_URI\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri path size failed!"); return 0; } }
 uint16\_t tempInt = 0; /\* CONTENT FORMAT - An integer option, up to 2 bytes \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { if ((uint32\_t) src\_coap\_msg\_ptr->content\_format > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - content format too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &tempInt); } /\* If options list pointer exists \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr != NULL) {
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* ACCEPT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->accept > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - accept too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &tempInt); } /\* MAX AGE - An integer option, omitted for default. Up to 4 bytes \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &tempInt); } /\* PROXY URI - Length of this option is 1-1034 bytes \*/ if (src\_options\_list\_ptr->proxy\_uri\_ptr != NULL) { if (src\_options\_list\_ptr->proxy\_uri\_len >= 1 && src\_options\_list\_ptr->proxy\_uri\_len <= 12) { /\* Add option header byte(s) - depending of option length \*/ returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 13 && src\_options\_list\_ptr->proxy\_uri\_len <= 269) { returned\_byte\_count += 2; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 270 && src\_options\_list\_ptr->proxy\_uri\_len <= 1034) { returned\_byte\_count += 3; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - proxy uri too large!"); return 0; }
 /\* Add needed memory for Option value \*/ returned\_byte\_count += src\_options\_list\_ptr->proxy\_uri\_len; } /\* ETAG - Repeatable option. Length of this option is 1-8 bytes\*/ if (src\_options\_list\_ptr->etag\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->etag\_len, src\_options\_list\_ptr->etag\_ptr, COAP\_OPTION\_ETAG); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - etag too large!"); return 0; } } /\* URI HOST - Length of this option is 1-255 bytes \*/ if (src\_options\_list\_ptr->uri\_host\_ptr != NULL) { if (src\_options\_list\_ptr->uri\_host\_len > 0 && src\_options\_list\_ptr->uri\_host\_len <= 12) { returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->uri\_host\_len >= 13 && src\_options\_list\_ptr->uri\_host\_len <= 255) { returned\_byte\_count += 2; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri host too large!"); return 0; }
 returned\_byte\_count += src\_options\_list\_ptr->uri\_host\_len; } /\* LOCATION PATH - Repeatable option. Length of this option is 0-255 bytes\*/ if (src\_options\_list\_ptr->location\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_path\_len, src\_options\_list\_ptr->location\_path\_ptr, COAP\_OPTION\_LOCATION\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location path too large!"); return 0; } } /\* URI PORT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->uri\_port > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri port too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &tempInt); } /\* lOCATION QUERY - Repeatable option. Length of this option is 0-255 bytes \*/ if (src\_options\_list\_ptr->location\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_query\_len, src\_options\_list\_ptr->location\_query\_ptr, COAP\_OPTION\_LOCATION\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location query too large!"); return 0; } } /\* OBSERVE - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->observe > 0xffffff) { return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &tempInt); } /\* URI QUERY - Repeatable option. Length of this option is 1-255 \*/ if (src\_options\_list\_ptr->uri\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->uri\_query\_len, src\_options\_list\_ptr->uri\_query\_ptr, COAP\_OPTION\_URI\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - observe too large!"); return 0; } }
 /\* BLOCK 1 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block1 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block1 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &tempInt); } /\* SIZE1 - Length of this option is 0-4 bytes \*/ if (src\_options\_list\_ptr->use\_size1) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &tempInt); } /\* BLOCK 2 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block2 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block2 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &tempInt); } /\* SIZE2 - Length of this option is 0-4 bytes \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &tempInt); } }#if SN\_COAP\_BLOCKWISE\_ENABLED || SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE if ((src\_coap\_msg\_ptr->payload\_len > SN\_COAP\_MAX\_NONBLOCKWISE\_PAYLOAD\_SIZE) && (src\_coap\_msg\_ptr->payload\_len > blockwise\_payload\_size) && (blockwise\_payload\_size > 0)) { returned\_byte\_count += blockwise\_payload\_size; } else { returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len; }#else returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len;#endif if (src\_coap\_msg\_ptr->payload\_len) { returned\_byte\_count ++; /\* For payload marker \*/ } returned\_byte\_count += sn\_coap\_builder\_options\_calculate\_jump\_need(src\_coap\_msg\_ptr); } return returned\_byte\_count;}/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Checks if there is need for option jump \* \* \param \*src\_coap\_msg\_ptr is source of checked CoAP message \* \* \param block option marks if block option is to be added to message later. 0 = no block option, 1 = block1 and 2 = block2 \* \* \return Returns bytes needed for jumping \*/
static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ uint8\_t previous\_option\_number = 0; uint8\_t needed\_space = 0;
 const sn\_coap\_options\_list\_s\* options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 if (options\_list\_ptr != NULL) {
 /\* If option numbers greater than 12 is not used, then jumping is not needed \*/ //TODO: Check if this is really needed! Does it enhance perf? If not -> remove if (!options\_list\_ptr->uri\_query\_ptr && options\_list\_ptr->accept == COAP\_CT\_NONE && !options\_list\_ptr->location\_query\_ptr && options\_list\_ptr->block2 == COAP\_OPTION\_BLOCK\_NONE && options\_list\_ptr->block1 == COAP\_OPTION\_BLOCK\_NONE && !options\_list\_ptr->proxy\_uri\_ptr && options\_list\_ptr->max\_age == COAP\_OPTION\_MAX\_AGE\_DEFAULT && !options\_list\_ptr->use\_size1 && !options\_list\_ptr->use\_size2) { return 0; }
 if (options\_list\_ptr->uri\_host\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_HOST); }
 if (options\_list\_ptr->etag\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_ETAG); }
 if (options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { previous\_option\_number = (COAP\_OPTION\_OBSERVE); }
 if (options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { previous\_option\_number = (COAP\_OPTION\_URI\_PORT); }
 if (options\_list\_ptr->location\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_LOCATION\_PATH); }
 if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); } if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); }
 if (options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { if ((COAP\_OPTION\_MAX\_AGE - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_MAX\_AGE); }
 if (options\_list\_ptr->uri\_query\_ptr != NULL) { if ((COAP\_OPTION\_URI\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_URI\_QUERY); } if (options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((COAP\_OPTION\_ACCEPT - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_ACCEPT); } if (options\_list\_ptr->location\_query\_ptr != NULL) { if ((COAP\_OPTION\_LOCATION\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_LOCATION\_QUERY); } if (options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK2 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK2); } if (options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK1 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK1); } if (options\_list\_ptr->use\_size2) { if ((COAP\_OPTION\_SIZE2 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE2); } if (options\_list\_ptr->proxy\_uri\_ptr != NULL) { if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 12) { needed\_space += 1; } if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 269) { //Can not happen needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_PROXY\_URI); } if (options\_list\_ptr->use\_size1) { if ((COAP\_OPTION\_SIZE1 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE1); } }
 else { if (src\_coap\_msg\_ptr->uri\_path\_ptr != 0) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); }
 if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); } } return needed\_space;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Header part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in ok case and -1 in failure case \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check validity of Header values \* \* \* \*/ if (sn\_coap\_header\_validity\_check(src\_coap\_msg\_ptr, COAP\_VERSION) != 0) { tr\_error("sn\_coap\_builder\_header\_build - header build failed!"); return -1; }
 uint8\_t\* dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Set CoAP Version, Message type and Token length \*/ dest\_packet[0] = COAP\_VERSION | src\_coap\_msg\_ptr->msg\_type | src\_coap\_msg\_ptr->token\_len;
 /\* \* \* Add Message code \* \* \*/ dest\_packet[1] = src\_coap\_msg\_ptr->msg\_code;
 /\* \* \* Add Message ID \* \* \*/ dest\_packet[2] = (uint8\_t)(src\_coap\_msg\_ptr->msg\_id >> COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT); /\* MSB part \*/ dest\_packet[3] = (uint8\_t)src\_coap\_msg\_ptr->msg\_id; /\* LSB part \*/
 \*dst\_packet\_data\_pptr = dest\_packet + 4;
 /\* Success \*/ return 0;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in every case \*/static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check if Options are used at all \* \* \* \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr == NULL && src\_coap\_msg\_ptr->token\_ptr == NULL && src\_coap\_msg\_ptr->content\_format == COAP\_CT\_NONE && src\_coap\_msg\_ptr->options\_list\_ptr == NULL) { /\* If the empty message is confirmable it is CoAP ping. \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_CONFIRMABLE) { tr\_error("sn\_coap\_builder\_options\_build - options not used!"); } return 0; }
 /\* \* \* \* First add Token option \* \* \* \*/ if (src\_coap\_msg\_ptr->token\_len && src\_coap\_msg\_ptr->token\_ptr) { memcpy(\*dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->token\_ptr, src\_coap\_msg\_ptr->token\_len); } (\*dst\_packet\_data\_pptr) += src\_coap\_msg\_ptr->token\_len;
 /\* Then build rest of the options \*/
 /\* \* \* \* Initialize previous Option number for new built message \* \* \* \*/ uint16\_t previous\_option\_number = 0;
 //missing: COAP\_OPTION\_IF\_MATCH, COAP\_OPTION\_IF\_NONE\_MATCH, COAP\_OPTION\_SIZE
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* Check if less used options are used at all \*/ if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Uri-Host option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_host\_len, src\_options\_list\_ptr->uri\_host\_ptr, COAP\_OPTION\_URI\_HOST, &previous\_option\_number);
 /\* \* \* \* Build ETag option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->etag\_ptr, src\_options\_list\_ptr->etag\_len, COAP\_OPTION\_ETAG, &previous\_option\_number);
 /\* \* \* \* Build Observe option \* \* \* \* \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Port option \* \* \* \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_path\_ptr, src\_options\_list\_ptr->location\_path\_len, COAP\_OPTION\_LOCATION\_PATH, &previous\_option\_number); } /\* \* \* \* Build Uri-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->uri\_path\_ptr, src\_coap\_msg\_ptr->uri\_path\_len, COAP\_OPTION\_URI\_PATH, &previous\_option\_number);
 /\* \* \* \* Build Content-Type option \* \* \* \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &previous\_option\_number); }
 if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Max-Age option \* \* \* \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Query option \* \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_query\_ptr, src\_options\_list\_ptr->uri\_query\_len, COAP\_OPTION\_URI\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Accept option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->accept != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Query option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_query\_ptr, src\_options\_list\_ptr->location\_query\_len, COAP\_OPTION\_LOCATION\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Block2 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &previous\_option\_number); }
 /\* \* \* \* Build Block1 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &previous\_option\_number); }
 /\* \* \* \* Build Size2 option \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &previous\_option\_number); }
 /\* \* \* \* Build Proxy-Uri option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->proxy\_uri\_len, src\_options\_list\_ptr->proxy\_uri\_ptr, COAP\_OPTION\_PROXY\_URI, &previous\_option\_number);
 /\* \* \* \* Build Size1 option \* \* \* \*/ if (src\_options\_list\_ptr->use\_size1) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &previous\_option\_number); } }
 /\* Success \*/ return 0;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_value\_len, uint8\_t \*option\_value\_ptr, sn\_coap\_option\_numbers\_e option\_number) \* \* \brief Adds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param option\_value\_len is Option value length to be added \* \* \param \*option\_value\_ptr is pointer to Option value data to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is 0 if option was not added, 1 if added \*/static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (option\_ptr != NULL) { uint16\_t option\_delta;
 option\_delta = (option\_number - \*previous\_option\_number);
 /\* \* \* Build option header \* \* \*/
 uint8\_t first\_byte;
 /\* First option length without extended part \*/ if (option\_len <= 12) { first\_byte = option\_len; }
 else if (option\_len > 12 && option\_len < 269) { first\_byte = 0x0D; }
 else /\*if (option\_len >= 269)\*/ { first\_byte = 0x0E; }
 uint8\_t \*dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Then option delta with extensions, and move pointer \*/ if (option\_delta <= 12) { dest\_packet[0] = first\_byte + (option\_delta << 4); dest\_packet += 1; }
 else if (option\_delta > 12 && option\_delta < 269) { dest\_packet[0] = first\_byte + 0xD0; option\_delta -= 13;
 dest\_packet[1] = (uint8\_t)option\_delta; dest\_packet += 2; } //This is currently dead code (but possibly needed in future) else /\*if (option\_delta >= 269)\*/ { dest\_packet[0] = first\_byte + 0xE0; option\_delta -= 269;
 dest\_packet[1] = (option\_delta >> 8); dest\_packet[2] = (uint8\_t)option\_delta; dest\_packet += 3; }
 /\* Now option length extensions, if needed \*/ if (option\_len > 12 && option\_len < 269) { dest\_packet[0] = (uint8\_t)(option\_len - 13); dest\_packet += 1; }
 else if (option\_len >= 269) { dest\_packet[0] = ((option\_len - 269) >> 8); dest\_packet[1] = (uint8\_t)(option\_len - 269); dest\_packet += 2; }
 \*previous\_option\_number = option\_number;
 /\* Write Option value \*/ memcpy(dest\_packet, option\_ptr, option\_len);
 /\* Increase destination Packet data pointer \*/ dest\_packet += option\_len;
 \*dst\_packet\_data\_pptr = dest\_packet;
 return 1; }
 /\* Success \*/ return 0;}
/\*\* \* \brief Constructs a uint Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data; NULL \* to compute size only. \* \* \param option\_value is Option value to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is total option size, or -1 in write failure case \*/static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t option\_value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ uint8\_t payload[4]; uint8\_t len = 0; /\* Construct the variable-length payload representing the value \*/ for (uint8\_t i = 0; i < 4; i++) { if (len > 0 || (option\_value & 0xff000000)) { payload[len++] = option\_value >> 24; } option\_value <<= 8; }
 /\* If output pointer isn't NULL, write it out \*/ if (dst\_packet\_data\_pptr) { // No need to check & handle return value, as the function returns failure only if the option pointer is zero // and it is pointing to a local variable here. sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, len, payload, option\_number, previous\_option\_number); }
 /\* Return the total option size \*/ return 1 + len;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint8\_t \*\*src\_pptr, uint16\_t \*src\_len\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Builds Option Uri-Query from given CoAP Header structure to Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param uint8\_t \*\*src\_ptr \* \* \param uint16\_t src\_len \* \* \paramsn\_coap\_option\_numbers\_e option option to be added \* \* \return Return value is 0 always \*/static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (src\_pptr != NULL) { const uint8\_t \*query\_ptr = src\_pptr; uint8\_t query\_part\_count = 0; uint16\_t query\_len = src\_len; uint8\_t i = 0; uint16\_t query\_part\_offset = 0;
 /\* Get query part count \*/ query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option);
 /\* \* \* \* Options by adding all parts to option \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* Get length of query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Get position of query part \*/ query\_part\_offset = sn\_coap\_builder\_options\_get\_option\_part\_position(query\_len, query\_ptr, i, option);
 /\* Add Uri-query's one part to Options \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, one\_query\_part\_len, src\_pptr + query\_part\_offset, option, previous\_option\_number); } } /\* Success \*/}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Calculates needed Packet data memory size for option \* \* \param path\_len is length of calculated strting(s) \* \* \param \*path\_ptr is pointer to calculated options \* \* \return Return value is count of needed memory as bytes for Uri-query option \*/static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option); uint8\_t i = 0; uint16\_t ret\_value = 0;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Calculate Uri-query options length \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* \* \* Length of Option number and Option value length \* \* \*/
 /\* Get length of Query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Check option length \*/ switch (option) { case (COAP\_OPTION\_ETAG): /\* Length 1-8 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 8) { return 0; } break; case (COAP\_OPTION\_LOCATION\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_URI\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_LOCATION\_QUERY): /\* Length 0-255 \*/ if (one\_query\_part\_len > 255) { return 0; } break; case (COAP\_OPTION\_URI\_QUERY): /\* Length 1-255 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 255) { return 0; } break;// case (COAP\_OPTION\_ACCEPT): /\* Length 0-2 \*/// if (one\_query\_part\_len > 2) {// return 0;// }// break; default: break; //impossible scenario currently }
 /\* Check if 4 bits are enough for writing Option value length \*/ if (one\_query\_part\_len <= 12) { /\* 4 bits are enough for Option value length \*/ ret\_value++; } else if (one\_query\_part\_len >= 13 && one\_query\_part\_len < 269) { /\* Extra byte for Option value length is needed \*/ ret\_value += 2; } //This can only happen if we are in default case above, currently is not happening else if (one\_query\_part\_len >= 270 && one\_query\_part\_len < 1034) { /\* Extra bytes for Option value length is needed \*/ ret\_value += 3; }
 /\* \* \* Length of Option value \* \* \*/
 /\* Increase options length \*/ ret\_value += one\_query\_part\_len; }
 /\* Success \*/ return ret\_value;}
/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets query part count from whole option string \* \* \param query\_len is length of whole Path \* \* \param \*query\_ptr is pointer to the start of whole Path \* \* \return Return value is count of query parts \*/static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t returned\_query\_count = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters (not first and last char) \*/ for (query\_len\_index = 1; query\_len\_index < query\_len - 1; query\_len\_index++) { /\* If new query part starts \*/ if (\*(query\_ptr + query\_len\_index) == char\_to\_search) { /\* If match \*/ returned\_query\_count++; } }
 returned\_query\_count++;
 return returned\_query\_count;}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets one's query part length from whole query string \* \* \param query\_len is length of whole string \* \* \param \*query\_ptr is pointer to the start of whole string \* \* \param query\_index is query part index to be found \* \* \param sn\_coap\_option\_numbers\_e option is option number of the option \* \* \return Return value is length of query part \*/static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option){ uint16\_t returned\_query\_part\_len = 0; uint8\_t temp\_query\_index = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters \*/ for (query\_len\_index = 0; query\_len\_index < query\_len; query\_len\_index++) { /\* Store character to temp\_char for helping debugging \*/ uint8\_t temp\_char = \*query\_ptr;
 /\* If new query part starts \*/ if (temp\_char == char\_to\_search && returned\_query\_part\_len > 0) { /\* returned\_query\_part\_len > 0 is for querys which start with "\0" \*/ /\* If query part index is wanted \*/ if (temp\_query\_index == query\_index) { /\* Return length of query part \*/ return returned\_query\_part\_len; } else { /\* Reset length of query part because wanted query part finding continues\*/ returned\_query\_part\_len = 0; }
 /\* Next query part is looped \*/ temp\_query\_index++;[View remainder of file in raw view](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_fdc09c85_20250120_235022.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fissues%2F11804)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fissues%2F11804)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fissues_fragments%2Fissue_layout&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

# memory access out of range in MbedOS CoAP library builder part #11804

[New issue](/login?return_to=)[Jump to bottom](#comment-composer-heading)Copy link[New issue](/login?return_to=)[Jump to bottom](#comment-composer-heading)Copy linkClosedClosed[memory access out of range in MbedOS CoAP library builder part](#top)#11804Copy linkLabels[type: bug](https://github.com/ARMmbed/mbed-os/issues?q=state%3Aopen%20label%3A%22type%3A%20bug%22)![@TheSilentDawn](https://avatars.githubusercontent.com/u/19835007?u=7ec7ec5d7622b689e1d27844ade7bf2c22329838&v=4&size=80)
## Description

![@TheSilentDawn](https://avatars.githubusercontent.com/u/19835007?u=7ec7ec5d7622b689e1d27844ade7bf2c22329838&v=4&size=48)[TheSilentDawn](https://github.com/TheSilentDawn)opened [on Nov 4, 2019](https://github.com/ARMmbed/mbed-os/issues/11804#issue-516940400)
### Description of defect

Reference: <https://github.com/ARMmbed/mbed-os/tree/master/features/frameworks/mbed-coap>

Function: sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_builder.c](https://github.com/ARMmbed/mbed-os/blob/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c#L355)

Line 355
in
[d0686fd](/ARMmbed/mbed-os/commit/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)

|  | returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len; |
| --- | --- |

Type: Integer overflow

The CoAP builder is responsible for crafting outgoing CoAP messages. The function sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2() is used to calculate the needed memory for the CoAP message from the sn\_coap\_hdr\_s data structure. Both returned\_byte\_count and src\_coap\_msg\_ptr->payload\_len are of type uint16\_t. When added together, the result returned\_byte\_count will wrap around the maximum as shown in line 4. As a result, insufficient buffer is allocated for the corresponding CoAP message.
```
uint16_t sn_coap_builder_calc_needed_packet_data_size_2(const sn_coap_hdr_s *src_coap_msg_ptr, ...)
{
...
       returned_byte_count += src_coap_msg_ptr->payload_len;
...
}
When the data in the sn_coap_hdr_s is copied into the allocated buffer, out-of-bound memory access will happen (line 4).
```c
static int16_t sn_coap_builder_options_build_add_one_option(..., uint16_t option_len, const uint8_t *option_ptr, ...)
{
...
    	memcpy(dest_packet, option_ptr, option_len);
...
}
```

In the following, we list other locations which will cause out-of-bound memory accesses rooted in this vulnerability.

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_builder.c](https://github.com/ARMmbed/mbed-os/blob/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c#L1090)

Line 1090
in
[d0686fd](/ARMmbed/mbed-os/commit/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)

|  | \*\*dst\_packet\_data\_pptr = 0xff; |
| --- | --- |

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_builder.c](https://github.com/ARMmbed/mbed-os/blob/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c#L710)

Line 710
in
[d0686fd](/ARMmbed/mbed-os/commit/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)

|  | dest\_packet[0] = first\_byte + (option\_delta << 4); |
| --- | --- |

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_builder.c](https://github.com/ARMmbed/mbed-os/blob/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c#L524)

Line 524
in
[d0686fd](/ARMmbed/mbed-os/commit/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)

|  | dest\_packet[1] = src\_coap\_msg\_ptr->msg\_code; |
| --- | --- |

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_builder.c](https://github.com/ARMmbed/mbed-os/blob/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c#L527)

Line 527
in
[d0686fd](/ARMmbed/mbed-os/commit/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)

|  | dest\_packet[2] = (uint8\_t)(src\_coap\_msg\_ptr->msg\_id >> COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT); /\* MSB part \*/ |
| --- | --- |

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_builder.c](https://github.com/ARMmbed/mbed-os/blob/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c#L528)

Line 528
in
[d0686fd](/ARMmbed/mbed-os/commit/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)

|  | dest\_packet[3] = (uint8\_t)src\_coap\_msg\_ptr->msg\_id; /\* LSB part \*/ |
| --- | --- |

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_builder.c](https://github.com/ARMmbed/mbed-os/blob/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c#L718)

Line 718
in
[d0686fd](/ARMmbed/mbed-os/commit/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)

|  | dest\_packet[1] = (uint8\_t)option\_delta; |
| --- | --- |

[mbed-os/features/frameworks/mbed-coap/source/sn\_coap\_builder.c](https://github.com/ARMmbed/mbed-os/blob/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c#L746)

Line 746
in
[d0686fd](/ARMmbed/mbed-os/commit/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)

|  | memcpy(dest\_packet, option\_ptr, option\_len); |
| --- | --- |

Result: Memory corruption.

#### Target(s) affected by this defect ?

MbedOS CoAP library

#### Toolchain(s) (name and version) displaying this defect ?

N/A

#### What version of Mbed-os are you using (tag or sha) ?

MbedOS 5.13.2

#### What version(s) of tools are you using. List all that apply (E.g. mbed-cli)

mbed-cli latest version

#### How is this defect reproduced ?

N/A

## Metadata

### Assignees

No one assigned

### Labels

[type: bug](https://github.com/ARMmbed/mbed-os/issues?q=state%3Aopen%20label%3A%22type%3A%20bug%22)
### Type

No type
### Projects

No projects
### Milestone

No milestone

### Relationships

None yet
### Development

No branches or pull requests
## Issue actions

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_d3013348_20250120_234958.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

## Files

 d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARMmbed/mbed-os/commits/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1099 lines (950 loc) · 45.9 KB d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Top
## File metadata and controls

* Code
* Blame

1099 lines (950 loc) · 45.9 KB[Raw](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright (c) 2011-2015 ARM Limited. All rights reserved. \* SPDX-License-Identifier: Apache-2.0 \* Licensed under the Apache License, Version 2.0 (the License); you may \* not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an AS IS BASIS, WITHOUT \* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
/\*\* \* \file sn\_coap\_builder.c \* \* \brief CoAP Message builder \* \* Functionality: Builds CoAP message \* \*/
/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* INCLUDE FILES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
#include <string.h> /\* For memset() and memcpy() \*/
#include "ns\_types.h"#include "mbed-coap/sn\_coap\_header.h"#include "sn\_coap\_header\_internal.h"#include "sn\_coap\_protocol\_internal.h"#include "mbed-trace/mbed\_trace.h"
#define TRACE\_GROUP "coap"/\* \* \* \* LOCAL FUNCTION PROTOTYPES \* \* \* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_get\_option\_part\_position(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static void sn\_coap\_builder\_payload\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);
sn\_coap\_hdr\_s \*sn\_coap\_build\_response(struct coap\_s \*handle, const sn\_coap\_hdr\_s \*coap\_packet\_ptr, uint8\_t msg\_code){ sn\_coap\_hdr\_s \*coap\_res\_ptr;
 if (!coap\_packet\_ptr || !handle) { return NULL; }
 coap\_res\_ptr = sn\_coap\_parser\_alloc\_message(handle); if (!coap\_res\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate message!"); return NULL; }
 if (msg\_code == COAP\_MSG\_CODE\_REQUEST\_GET) { // Blockwise message response is new GET coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_ACKNOWLEDGEMENT; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; coap\_res\_ptr->msg\_id = coap\_packet\_ptr->msg\_id; } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_NON\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_NON\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else { handle->sn\_coap\_protocol\_free( coap\_res\_ptr ); return NULL; }
 if (coap\_packet\_ptr->token\_ptr) { coap\_res\_ptr->token\_len = coap\_packet\_ptr->token\_len; coap\_res\_ptr->token\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, coap\_packet\_ptr->token\_ptr, coap\_res\_ptr->token\_len); if (!coap\_res\_ptr->token\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate token!"); handle->sn\_coap\_protocol\_free(coap\_res\_ptr); return NULL; } } return coap\_res\_ptr;}
int16\_t sn\_coap\_builder(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_2(dst\_packet\_data\_ptr, src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
int16\_t sn\_coap\_builder\_2(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ uint8\_t \*base\_packet\_data\_ptr;
 /\* \* \* \* Check given pointers \* \* \* \*/ if (dst\_packet\_data\_ptr == NULL || src\_coap\_msg\_ptr == NULL) { return -2; }
 /\* Initialize given Packet data memory area with zero values \*/ uint16\_t dst\_byte\_count\_to\_be\_built = sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, blockwise\_payload\_size); if (!dst\_byte\_count\_to\_be\_built) { tr\_error("sn\_coap\_builder\_2 - failed to allocate message!"); return -1; }
 // XXX: this should not be needed anymore but I have no courage to remove it yet. memset(dst\_packet\_data\_ptr, 0, dst\_byte\_count\_to\_be\_built);
 /\* \* \* \* Store base (= original) destination Packet data pointer for later usage \* \* \* \*/ base\_packet\_data\_ptr = dst\_packet\_data\_ptr;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Header part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ if (sn\_coap\_builder\_header\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr) != 0) { /\* Header building failed \*/ tr\_error("sn\_coap\_builder\_2 - header building failed!"); return -1; }
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Options part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_options\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr);
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Payload part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_payload\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr); } /\* \* \* \* Return built Packet data length \* \* \* \*/ return (dst\_packet\_data\_ptr - base\_packet\_data\_ptr);}uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ (void)blockwise\_payload\_size; uint16\_t returned\_byte\_count = 0;
 if (!src\_coap\_msg\_ptr) { return 0; } /\* \* \* \* \* HEADER \* \* \* \* \*/
 /\* Header size is fixed \*/ returned\_byte\_count = COAP\_HEADER\_LENGTH;
 /\* \* \* \* \* OPTIONS \* \* \* \* \*/
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { uint16\_t repeatable\_option\_size = 0; /\* TOKEN - Length is 1-8 bytes \*/ if (src\_coap\_msg\_ptr->token\_ptr != NULL) { if (src\_coap\_msg\_ptr->token\_len > 8 || src\_coap\_msg\_ptr->token\_len < 1) { /\* Check that option is not longer than defined \*/ tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - token too large!"); return 0; }
 returned\_byte\_count += src\_coap\_msg\_ptr->token\_len; } /\* URI PATH - Repeatable option. Length of one option is 0-255 \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_coap\_msg\_ptr->uri\_path\_len, src\_coap\_msg\_ptr->uri\_path\_ptr, COAP\_OPTION\_URI\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri path size failed!"); return 0; } }
 uint16\_t tempInt = 0; /\* CONTENT FORMAT - An integer option, up to 2 bytes \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { if ((uint32\_t) src\_coap\_msg\_ptr->content\_format > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - content format too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &tempInt); } /\* If options list pointer exists \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr != NULL) {
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* ACCEPT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->accept > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - accept too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &tempInt); } /\* MAX AGE - An integer option, omitted for default. Up to 4 bytes \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &tempInt); } /\* PROXY URI - Length of this option is 1-1034 bytes \*/ if (src\_options\_list\_ptr->proxy\_uri\_ptr != NULL) { if (src\_options\_list\_ptr->proxy\_uri\_len >= 1 && src\_options\_list\_ptr->proxy\_uri\_len <= 12) { /\* Add option header byte(s) - depending of option length \*/ returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 13 && src\_options\_list\_ptr->proxy\_uri\_len <= 269) { returned\_byte\_count += 2; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 270 && src\_options\_list\_ptr->proxy\_uri\_len <= 1034) { returned\_byte\_count += 3; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - proxy uri too large!"); return 0; }
 /\* Add needed memory for Option value \*/ returned\_byte\_count += src\_options\_list\_ptr->proxy\_uri\_len; } /\* ETAG - Repeatable option. Length of this option is 1-8 bytes\*/ if (src\_options\_list\_ptr->etag\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->etag\_len, src\_options\_list\_ptr->etag\_ptr, COAP\_OPTION\_ETAG); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - etag too large!"); return 0; } } /\* URI HOST - Length of this option is 1-255 bytes \*/ if (src\_options\_list\_ptr->uri\_host\_ptr != NULL) { if (src\_options\_list\_ptr->uri\_host\_len > 0 && src\_options\_list\_ptr->uri\_host\_len <= 12) { returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->uri\_host\_len >= 13 && src\_options\_list\_ptr->uri\_host\_len <= 255) { returned\_byte\_count += 2; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri host too large!"); return 0; }
 returned\_byte\_count += src\_options\_list\_ptr->uri\_host\_len; } /\* LOCATION PATH - Repeatable option. Length of this option is 0-255 bytes\*/ if (src\_options\_list\_ptr->location\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_path\_len, src\_options\_list\_ptr->location\_path\_ptr, COAP\_OPTION\_LOCATION\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location path too large!"); return 0; } } /\* URI PORT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->uri\_port > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri port too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &tempInt); } /\* lOCATION QUERY - Repeatable option. Length of this option is 0-255 bytes \*/ if (src\_options\_list\_ptr->location\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_query\_len, src\_options\_list\_ptr->location\_query\_ptr, COAP\_OPTION\_LOCATION\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location query too large!"); return 0; } } /\* OBSERVE - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->observe > 0xffffff) { return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &tempInt); } /\* URI QUERY - Repeatable option. Length of this option is 1-255 \*/ if (src\_options\_list\_ptr->uri\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->uri\_query\_len, src\_options\_list\_ptr->uri\_query\_ptr, COAP\_OPTION\_URI\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - observe too large!"); return 0; } }
 /\* BLOCK 1 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block1 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block1 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &tempInt); } /\* SIZE1 - Length of this option is 0-4 bytes \*/ if (src\_options\_list\_ptr->use\_size1) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &tempInt); } /\* BLOCK 2 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block2 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block2 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &tempInt); } /\* SIZE2 - Length of this option is 0-4 bytes \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &tempInt); } }#if SN\_COAP\_BLOCKWISE\_ENABLED || SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE if ((src\_coap\_msg\_ptr->payload\_len > SN\_COAP\_MAX\_NONBLOCKWISE\_PAYLOAD\_SIZE) && (src\_coap\_msg\_ptr->payload\_len > blockwise\_payload\_size) && (blockwise\_payload\_size > 0)) { returned\_byte\_count += blockwise\_payload\_size; } else { returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len; }#else returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len;#endif if (src\_coap\_msg\_ptr->payload\_len) { returned\_byte\_count ++; /\* For payload marker \*/ } returned\_byte\_count += sn\_coap\_builder\_options\_calculate\_jump\_need(src\_coap\_msg\_ptr); } return returned\_byte\_count;}/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Checks if there is need for option jump \* \* \param \*src\_coap\_msg\_ptr is source of checked CoAP message \* \* \param block option marks if block option is to be added to message later. 0 = no block option, 1 = block1 and 2 = block2 \* \* \return Returns bytes needed for jumping \*/
static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ uint8\_t previous\_option\_number = 0; uint8\_t needed\_space = 0;
 const sn\_coap\_options\_list\_s\* options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 if (options\_list\_ptr != NULL) {
 /\* If option numbers greater than 12 is not used, then jumping is not needed \*/ //TODO: Check if this is really needed! Does it enhance perf? If not -> remove if (!options\_list\_ptr->uri\_query\_ptr && options\_list\_ptr->accept == COAP\_CT\_NONE && !options\_list\_ptr->location\_query\_ptr && options\_list\_ptr->block2 == COAP\_OPTION\_BLOCK\_NONE && options\_list\_ptr->block1 == COAP\_OPTION\_BLOCK\_NONE && !options\_list\_ptr->proxy\_uri\_ptr && options\_list\_ptr->max\_age == COAP\_OPTION\_MAX\_AGE\_DEFAULT && !options\_list\_ptr->use\_size1 && !options\_list\_ptr->use\_size2) { return 0; }
 if (options\_list\_ptr->uri\_host\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_HOST); }
 if (options\_list\_ptr->etag\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_ETAG); }
 if (options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { previous\_option\_number = (COAP\_OPTION\_OBSERVE); }
 if (options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { previous\_option\_number = (COAP\_OPTION\_URI\_PORT); }
 if (options\_list\_ptr->location\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_LOCATION\_PATH); }
 if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); } if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); }
 if (options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { if ((COAP\_OPTION\_MAX\_AGE - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_MAX\_AGE); }
 if (options\_list\_ptr->uri\_query\_ptr != NULL) { if ((COAP\_OPTION\_URI\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_URI\_QUERY); } if (options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((COAP\_OPTION\_ACCEPT - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_ACCEPT); } if (options\_list\_ptr->location\_query\_ptr != NULL) { if ((COAP\_OPTION\_LOCATION\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_LOCATION\_QUERY); } if (options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK2 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK2); } if (options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK1 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK1); } if (options\_list\_ptr->use\_size2) { if ((COAP\_OPTION\_SIZE2 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE2); } if (options\_list\_ptr->proxy\_uri\_ptr != NULL) { if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 12) { needed\_space += 1; } if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 269) { //Can not happen needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_PROXY\_URI); } if (options\_list\_ptr->use\_size1) { if ((COAP\_OPTION\_SIZE1 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE1); } }
 else { if (src\_coap\_msg\_ptr->uri\_path\_ptr != 0) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); }
 if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); } } return needed\_space;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Header part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in ok case and -1 in failure case \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check validity of Header values \* \* \* \*/ if (sn\_coap\_header\_validity\_check(src\_coap\_msg\_ptr, COAP\_VERSION) != 0) { tr\_error("sn\_coap\_builder\_header\_build - header build failed!"); return -1; }
 uint8\_t\* dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Set CoAP Version, Message type and Token length \*/ dest\_packet[0] = COAP\_VERSION | src\_coap\_msg\_ptr->msg\_type | src\_coap\_msg\_ptr->token\_len;
 /\* \* \* Add Message code \* \* \*/ dest\_packet[1] = src\_coap\_msg\_ptr->msg\_code;
 /\* \* \* Add Message ID \* \* \*/ dest\_packet[2] = (uint8\_t)(src\_coap\_msg\_ptr->msg\_id >> COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT); /\* MSB part \*/ dest\_packet[3] = (uint8\_t)src\_coap\_msg\_ptr->msg\_id; /\* LSB part \*/
 \*dst\_packet\_data\_pptr = dest\_packet + 4;
 /\* Success \*/ return 0;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in every case \*/static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check if Options are used at all \* \* \* \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr == NULL && src\_coap\_msg\_ptr->token\_ptr == NULL && src\_coap\_msg\_ptr->content\_format == COAP\_CT\_NONE && src\_coap\_msg\_ptr->options\_list\_ptr == NULL) { /\* If the empty message is confirmable it is CoAP ping. \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_CONFIRMABLE) { tr\_error("sn\_coap\_builder\_options\_build - options not used!"); } return 0; }
 /\* \* \* \* First add Token option \* \* \* \*/ if (src\_coap\_msg\_ptr->token\_len && src\_coap\_msg\_ptr->token\_ptr) { memcpy(\*dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->token\_ptr, src\_coap\_msg\_ptr->token\_len); } (\*dst\_packet\_data\_pptr) += src\_coap\_msg\_ptr->token\_len;
 /\* Then build rest of the options \*/
 /\* \* \* \* Initialize previous Option number for new built message \* \* \* \*/ uint16\_t previous\_option\_number = 0;
 //missing: COAP\_OPTION\_IF\_MATCH, COAP\_OPTION\_IF\_NONE\_MATCH, COAP\_OPTION\_SIZE
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* Check if less used options are used at all \*/ if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Uri-Host option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_host\_len, src\_options\_list\_ptr->uri\_host\_ptr, COAP\_OPTION\_URI\_HOST, &previous\_option\_number);
 /\* \* \* \* Build ETag option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->etag\_ptr, src\_options\_list\_ptr->etag\_len, COAP\_OPTION\_ETAG, &previous\_option\_number);
 /\* \* \* \* Build Observe option \* \* \* \* \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Port option \* \* \* \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_path\_ptr, src\_options\_list\_ptr->location\_path\_len, COAP\_OPTION\_LOCATION\_PATH, &previous\_option\_number); } /\* \* \* \* Build Uri-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->uri\_path\_ptr, src\_coap\_msg\_ptr->uri\_path\_len, COAP\_OPTION\_URI\_PATH, &previous\_option\_number);
 /\* \* \* \* Build Content-Type option \* \* \* \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &previous\_option\_number); }
 if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Max-Age option \* \* \* \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Query option \* \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_query\_ptr, src\_options\_list\_ptr->uri\_query\_len, COAP\_OPTION\_URI\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Accept option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->accept != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Query option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_query\_ptr, src\_options\_list\_ptr->location\_query\_len, COAP\_OPTION\_LOCATION\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Block2 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &previous\_option\_number); }
 /\* \* \* \* Build Block1 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &previous\_option\_number); }
 /\* \* \* \* Build Size2 option \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &previous\_option\_number); }
 /\* \* \* \* Build Proxy-Uri option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->proxy\_uri\_len, src\_options\_list\_ptr->proxy\_uri\_ptr, COAP\_OPTION\_PROXY\_URI, &previous\_option\_number);
 /\* \* \* \* Build Size1 option \* \* \* \*/ if (src\_options\_list\_ptr->use\_size1) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &previous\_option\_number); } }
 /\* Success \*/ return 0;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_value\_len, uint8\_t \*option\_value\_ptr, sn\_coap\_option\_numbers\_e option\_number) \* \* \brief Adds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param option\_value\_len is Option value length to be added \* \* \param \*option\_value\_ptr is pointer to Option value data to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is 0 if option was not added, 1 if added \*/static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (option\_ptr != NULL) { uint16\_t option\_delta;
 option\_delta = (option\_number - \*previous\_option\_number);
 /\* \* \* Build option header \* \* \*/
 uint8\_t first\_byte;
 /\* First option length without extended part \*/ if (option\_len <= 12) { first\_byte = option\_len; }
 else if (option\_len > 12 && option\_len < 269) { first\_byte = 0x0D; }
 else /\*if (option\_len >= 269)\*/ { first\_byte = 0x0E; }
 uint8\_t \*dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Then option delta with extensions, and move pointer \*/ if (option\_delta <= 12) { dest\_packet[0] = first\_byte + (option\_delta << 4); dest\_packet += 1; }
 else if (option\_delta > 12 && option\_delta < 269) { dest\_packet[0] = first\_byte + 0xD0; option\_delta -= 13;
 dest\_packet[1] = (uint8\_t)option\_delta; dest\_packet += 2; } //This is currently dead code (but possibly needed in future) else /\*if (option\_delta >= 269)\*/ { dest\_packet[0] = first\_byte + 0xE0; option\_delta -= 269;
 dest\_packet[1] = (option\_delta >> 8); dest\_packet[2] = (uint8\_t)option\_delta; dest\_packet += 3; }
 /\* Now option length extensions, if needed \*/ if (option\_len > 12 && option\_len < 269) { dest\_packet[0] = (uint8\_t)(option\_len - 13); dest\_packet += 1; }
 else if (option\_len >= 269) { dest\_packet[0] = ((option\_len - 269) >> 8); dest\_packet[1] = (uint8\_t)(option\_len - 269); dest\_packet += 2; }
 \*previous\_option\_number = option\_number;
 /\* Write Option value \*/ memcpy(dest\_packet, option\_ptr, option\_len);
 /\* Increase destination Packet data pointer \*/ dest\_packet += option\_len;
 \*dst\_packet\_data\_pptr = dest\_packet;
 return 1; }
 /\* Success \*/ return 0;}
/\*\* \* \brief Constructs a uint Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data; NULL \* to compute size only. \* \* \param option\_value is Option value to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is total option size, or -1 in write failure case \*/static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t option\_value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ uint8\_t payload[4]; uint8\_t len = 0; /\* Construct the variable-length payload representing the value \*/ for (uint8\_t i = 0; i < 4; i++) { if (len > 0 || (option\_value & 0xff000000)) { payload[len++] = option\_value >> 24; } option\_value <<= 8; }
 /\* If output pointer isn't NULL, write it out \*/ if (dst\_packet\_data\_pptr) { // No need to check & handle return value, as the function returns failure only if the option pointer is zero // and it is pointing to a local variable here. sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, len, payload, option\_number, previous\_option\_number); }
 /\* Return the total option size \*/ return 1 + len;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint8\_t \*\*src\_pptr, uint16\_t \*src\_len\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Builds Option Uri-Query from given CoAP Header structure to Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param uint8\_t \*\*src\_ptr \* \* \param uint16\_t src\_len \* \* \paramsn\_coap\_option\_numbers\_e option option to be added \* \* \return Return value is 0 always \*/static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (src\_pptr != NULL) { const uint8\_t \*query\_ptr = src\_pptr; uint8\_t query\_part\_count = 0; uint16\_t query\_len = src\_len; uint8\_t i = 0; uint16\_t query\_part\_offset = 0;
 /\* Get query part count \*/ query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option);
 /\* \* \* \* Options by adding all parts to option \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* Get length of query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Get position of query part \*/ query\_part\_offset = sn\_coap\_builder\_options\_get\_option\_part\_position(query\_len, query\_ptr, i, option);
 /\* Add Uri-query's one part to Options \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, one\_query\_part\_len, src\_pptr + query\_part\_offset, option, previous\_option\_number); } } /\* Success \*/}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Calculates needed Packet data memory size for option \* \* \param path\_len is length of calculated strting(s) \* \* \param \*path\_ptr is pointer to calculated options \* \* \return Return value is count of needed memory as bytes for Uri-query option \*/static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option); uint8\_t i = 0; uint16\_t ret\_value = 0;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Calculate Uri-query options length \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* \* \* Length of Option number and Option value length \* \* \*/
 /\* Get length of Query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Check option length \*/ switch (option) { case (COAP\_OPTION\_ETAG): /\* Length 1-8 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 8) { return 0; } break; case (COAP\_OPTION\_LOCATION\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_URI\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_LOCATION\_QUERY): /\* Length 0-255 \*/ if (one\_query\_part\_len > 255) { return 0; } break; case (COAP\_OPTION\_URI\_QUERY): /\* Length 1-255 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 255) { return 0; } break;// case (COAP\_OPTION\_ACCEPT): /\* Length 0-2 \*/// if (one\_query\_part\_len > 2) {// return 0;// }// break; default: break; //impossible scenario currently }
 /\* Check if 4 bits are enough for writing Option value length \*/ if (one\_query\_part\_len <= 12) { /\* 4 bits are enough for Option value length \*/ ret\_value++; } else if (one\_query\_part\_len >= 13 && one\_query\_part\_len < 269) { /\* Extra byte for Option value length is needed \*/ ret\_value += 2; } //This can only happen if we are in default case above, currently is not happening else if (one\_query\_part\_len >= 270 && one\_query\_part\_len < 1034) { /\* Extra bytes for Option value length is needed \*/ ret\_value += 3; }
 /\* \* \* Length of Option value \* \* \*/
 /\* Increase options length \*/ ret\_value += one\_query\_part\_len; }
 /\* Success \*/ return ret\_value;}
/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets query part count from whole option string \* \* \param query\_len is length of whole Path \* \* \param \*query\_ptr is pointer to the start of whole Path \* \* \return Return value is count of query parts \*/static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t returned\_query\_count = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters (not first and last char) \*/ for (query\_len\_index = 1; query\_len\_index < query\_len - 1; query\_len\_index++) { /\* If new query part starts \*/ if (\*(query\_ptr + query\_len\_index) == char\_to\_search) { /\* If match \*/ returned\_query\_count++; } }
 returned\_query\_count++;
 return returned\_query\_count;}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets one's query part length from whole query string \* \* \param query\_len is length of whole string \* \* \param \*query\_ptr is pointer to the start of whole string \* \* \param query\_index is query part index to be found \* \* \param sn\_coap\_option\_numbers\_e option is option number of the option \* \* \return Return value is length of query part \*/static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option){ uint16\_t returned\_query\_part\_len = 0; uint8\_t temp\_query\_index = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters \*/ for (query\_len\_index = 0; query\_len\_index < query\_len; query\_len\_index++) { /\* Store character to temp\_char for helping debugging \*/ uint8\_t temp\_char = \*query\_ptr;
 /\* If new query part starts \*/ if (temp\_char == char\_to\_search && returned\_query\_part\_len > 0) { /\* returned\_query\_part\_len > 0 is for querys which start with "\0" \*/ /\* If query part index is wanted \*/ if (temp\_query\_index == query\_index) { /\* Return length of query part \*/ return returned\_query\_part\_len; } else { /\* Reset length of query part because wanted query part finding continues\*/ returned\_query\_part\_len = 0; }
 /\* Next query part is looped \*/ temp\_query\_index++;[View remainder of file in raw view](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_96f107c9_20250120_234954.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

## Files

 d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARMmbed/mbed-os/commits/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1099 lines (950 loc) · 45.9 KB d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Top
## File metadata and controls

* Code
* Blame

1099 lines (950 loc) · 45.9 KB[Raw](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright (c) 2011-2015 ARM Limited. All rights reserved. \* SPDX-License-Identifier: Apache-2.0 \* Licensed under the Apache License, Version 2.0 (the License); you may \* not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an AS IS BASIS, WITHOUT \* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
/\*\* \* \file sn\_coap\_builder.c \* \* \brief CoAP Message builder \* \* Functionality: Builds CoAP message \* \*/
/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* INCLUDE FILES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
#include <string.h> /\* For memset() and memcpy() \*/
#include "ns\_types.h"#include "mbed-coap/sn\_coap\_header.h"#include "sn\_coap\_header\_internal.h"#include "sn\_coap\_protocol\_internal.h"#include "mbed-trace/mbed\_trace.h"
#define TRACE\_GROUP "coap"/\* \* \* \* LOCAL FUNCTION PROTOTYPES \* \* \* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_get\_option\_part\_position(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static void sn\_coap\_builder\_payload\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);
sn\_coap\_hdr\_s \*sn\_coap\_build\_response(struct coap\_s \*handle, const sn\_coap\_hdr\_s \*coap\_packet\_ptr, uint8\_t msg\_code){ sn\_coap\_hdr\_s \*coap\_res\_ptr;
 if (!coap\_packet\_ptr || !handle) { return NULL; }
 coap\_res\_ptr = sn\_coap\_parser\_alloc\_message(handle); if (!coap\_res\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate message!"); return NULL; }
 if (msg\_code == COAP\_MSG\_CODE\_REQUEST\_GET) { // Blockwise message response is new GET coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_ACKNOWLEDGEMENT; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; coap\_res\_ptr->msg\_id = coap\_packet\_ptr->msg\_id; } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_NON\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_NON\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else { handle->sn\_coap\_protocol\_free( coap\_res\_ptr ); return NULL; }
 if (coap\_packet\_ptr->token\_ptr) { coap\_res\_ptr->token\_len = coap\_packet\_ptr->token\_len; coap\_res\_ptr->token\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, coap\_packet\_ptr->token\_ptr, coap\_res\_ptr->token\_len); if (!coap\_res\_ptr->token\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate token!"); handle->sn\_coap\_protocol\_free(coap\_res\_ptr); return NULL; } } return coap\_res\_ptr;}
int16\_t sn\_coap\_builder(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_2(dst\_packet\_data\_ptr, src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
int16\_t sn\_coap\_builder\_2(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ uint8\_t \*base\_packet\_data\_ptr;
 /\* \* \* \* Check given pointers \* \* \* \*/ if (dst\_packet\_data\_ptr == NULL || src\_coap\_msg\_ptr == NULL) { return -2; }
 /\* Initialize given Packet data memory area with zero values \*/ uint16\_t dst\_byte\_count\_to\_be\_built = sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, blockwise\_payload\_size); if (!dst\_byte\_count\_to\_be\_built) { tr\_error("sn\_coap\_builder\_2 - failed to allocate message!"); return -1; }
 // XXX: this should not be needed anymore but I have no courage to remove it yet. memset(dst\_packet\_data\_ptr, 0, dst\_byte\_count\_to\_be\_built);
 /\* \* \* \* Store base (= original) destination Packet data pointer for later usage \* \* \* \*/ base\_packet\_data\_ptr = dst\_packet\_data\_ptr;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Header part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ if (sn\_coap\_builder\_header\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr) != 0) { /\* Header building failed \*/ tr\_error("sn\_coap\_builder\_2 - header building failed!"); return -1; }
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Options part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_options\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr);
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Payload part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_payload\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr); } /\* \* \* \* Return built Packet data length \* \* \* \*/ return (dst\_packet\_data\_ptr - base\_packet\_data\_ptr);}uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ (void)blockwise\_payload\_size; uint16\_t returned\_byte\_count = 0;
 if (!src\_coap\_msg\_ptr) { return 0; } /\* \* \* \* \* HEADER \* \* \* \* \*/
 /\* Header size is fixed \*/ returned\_byte\_count = COAP\_HEADER\_LENGTH;
 /\* \* \* \* \* OPTIONS \* \* \* \* \*/
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { uint16\_t repeatable\_option\_size = 0; /\* TOKEN - Length is 1-8 bytes \*/ if (src\_coap\_msg\_ptr->token\_ptr != NULL) { if (src\_coap\_msg\_ptr->token\_len > 8 || src\_coap\_msg\_ptr->token\_len < 1) { /\* Check that option is not longer than defined \*/ tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - token too large!"); return 0; }
 returned\_byte\_count += src\_coap\_msg\_ptr->token\_len; } /\* URI PATH - Repeatable option. Length of one option is 0-255 \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_coap\_msg\_ptr->uri\_path\_len, src\_coap\_msg\_ptr->uri\_path\_ptr, COAP\_OPTION\_URI\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri path size failed!"); return 0; } }
 uint16\_t tempInt = 0; /\* CONTENT FORMAT - An integer option, up to 2 bytes \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { if ((uint32\_t) src\_coap\_msg\_ptr->content\_format > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - content format too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &tempInt); } /\* If options list pointer exists \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr != NULL) {
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* ACCEPT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->accept > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - accept too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &tempInt); } /\* MAX AGE - An integer option, omitted for default. Up to 4 bytes \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &tempInt); } /\* PROXY URI - Length of this option is 1-1034 bytes \*/ if (src\_options\_list\_ptr->proxy\_uri\_ptr != NULL) { if (src\_options\_list\_ptr->proxy\_uri\_len >= 1 && src\_options\_list\_ptr->proxy\_uri\_len <= 12) { /\* Add option header byte(s) - depending of option length \*/ returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 13 && src\_options\_list\_ptr->proxy\_uri\_len <= 269) { returned\_byte\_count += 2; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 270 && src\_options\_list\_ptr->proxy\_uri\_len <= 1034) { returned\_byte\_count += 3; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - proxy uri too large!"); return 0; }
 /\* Add needed memory for Option value \*/ returned\_byte\_count += src\_options\_list\_ptr->proxy\_uri\_len; } /\* ETAG - Repeatable option. Length of this option is 1-8 bytes\*/ if (src\_options\_list\_ptr->etag\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->etag\_len, src\_options\_list\_ptr->etag\_ptr, COAP\_OPTION\_ETAG); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - etag too large!"); return 0; } } /\* URI HOST - Length of this option is 1-255 bytes \*/ if (src\_options\_list\_ptr->uri\_host\_ptr != NULL) { if (src\_options\_list\_ptr->uri\_host\_len > 0 && src\_options\_list\_ptr->uri\_host\_len <= 12) { returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->uri\_host\_len >= 13 && src\_options\_list\_ptr->uri\_host\_len <= 255) { returned\_byte\_count += 2; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri host too large!"); return 0; }
 returned\_byte\_count += src\_options\_list\_ptr->uri\_host\_len; } /\* LOCATION PATH - Repeatable option. Length of this option is 0-255 bytes\*/ if (src\_options\_list\_ptr->location\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_path\_len, src\_options\_list\_ptr->location\_path\_ptr, COAP\_OPTION\_LOCATION\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location path too large!"); return 0; } } /\* URI PORT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->uri\_port > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri port too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &tempInt); } /\* lOCATION QUERY - Repeatable option. Length of this option is 0-255 bytes \*/ if (src\_options\_list\_ptr->location\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_query\_len, src\_options\_list\_ptr->location\_query\_ptr, COAP\_OPTION\_LOCATION\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location query too large!"); return 0; } } /\* OBSERVE - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->observe > 0xffffff) { return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &tempInt); } /\* URI QUERY - Repeatable option. Length of this option is 1-255 \*/ if (src\_options\_list\_ptr->uri\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->uri\_query\_len, src\_options\_list\_ptr->uri\_query\_ptr, COAP\_OPTION\_URI\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - observe too large!"); return 0; } }
 /\* BLOCK 1 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block1 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block1 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &tempInt); } /\* SIZE1 - Length of this option is 0-4 bytes \*/ if (src\_options\_list\_ptr->use\_size1) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &tempInt); } /\* BLOCK 2 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block2 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block2 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &tempInt); } /\* SIZE2 - Length of this option is 0-4 bytes \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &tempInt); } }#if SN\_COAP\_BLOCKWISE\_ENABLED || SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE if ((src\_coap\_msg\_ptr->payload\_len > SN\_COAP\_MAX\_NONBLOCKWISE\_PAYLOAD\_SIZE) && (src\_coap\_msg\_ptr->payload\_len > blockwise\_payload\_size) && (blockwise\_payload\_size > 0)) { returned\_byte\_count += blockwise\_payload\_size; } else { returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len; }#else returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len;#endif if (src\_coap\_msg\_ptr->payload\_len) { returned\_byte\_count ++; /\* For payload marker \*/ } returned\_byte\_count += sn\_coap\_builder\_options\_calculate\_jump\_need(src\_coap\_msg\_ptr); } return returned\_byte\_count;}/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Checks if there is need for option jump \* \* \param \*src\_coap\_msg\_ptr is source of checked CoAP message \* \* \param block option marks if block option is to be added to message later. 0 = no block option, 1 = block1 and 2 = block2 \* \* \return Returns bytes needed for jumping \*/
static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ uint8\_t previous\_option\_number = 0; uint8\_t needed\_space = 0;
 const sn\_coap\_options\_list\_s\* options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 if (options\_list\_ptr != NULL) {
 /\* If option numbers greater than 12 is not used, then jumping is not needed \*/ //TODO: Check if this is really needed! Does it enhance perf? If not -> remove if (!options\_list\_ptr->uri\_query\_ptr && options\_list\_ptr->accept == COAP\_CT\_NONE && !options\_list\_ptr->location\_query\_ptr && options\_list\_ptr->block2 == COAP\_OPTION\_BLOCK\_NONE && options\_list\_ptr->block1 == COAP\_OPTION\_BLOCK\_NONE && !options\_list\_ptr->proxy\_uri\_ptr && options\_list\_ptr->max\_age == COAP\_OPTION\_MAX\_AGE\_DEFAULT && !options\_list\_ptr->use\_size1 && !options\_list\_ptr->use\_size2) { return 0; }
 if (options\_list\_ptr->uri\_host\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_HOST); }
 if (options\_list\_ptr->etag\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_ETAG); }
 if (options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { previous\_option\_number = (COAP\_OPTION\_OBSERVE); }
 if (options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { previous\_option\_number = (COAP\_OPTION\_URI\_PORT); }
 if (options\_list\_ptr->location\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_LOCATION\_PATH); }
 if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); } if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); }
 if (options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { if ((COAP\_OPTION\_MAX\_AGE - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_MAX\_AGE); }
 if (options\_list\_ptr->uri\_query\_ptr != NULL) { if ((COAP\_OPTION\_URI\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_URI\_QUERY); } if (options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((COAP\_OPTION\_ACCEPT - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_ACCEPT); } if (options\_list\_ptr->location\_query\_ptr != NULL) { if ((COAP\_OPTION\_LOCATION\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_LOCATION\_QUERY); } if (options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK2 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK2); } if (options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK1 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK1); } if (options\_list\_ptr->use\_size2) { if ((COAP\_OPTION\_SIZE2 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE2); } if (options\_list\_ptr->proxy\_uri\_ptr != NULL) { if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 12) { needed\_space += 1; } if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 269) { //Can not happen needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_PROXY\_URI); } if (options\_list\_ptr->use\_size1) { if ((COAP\_OPTION\_SIZE1 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE1); } }
 else { if (src\_coap\_msg\_ptr->uri\_path\_ptr != 0) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); }
 if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); } } return needed\_space;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Header part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in ok case and -1 in failure case \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check validity of Header values \* \* \* \*/ if (sn\_coap\_header\_validity\_check(src\_coap\_msg\_ptr, COAP\_VERSION) != 0) { tr\_error("sn\_coap\_builder\_header\_build - header build failed!"); return -1; }
 uint8\_t\* dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Set CoAP Version, Message type and Token length \*/ dest\_packet[0] = COAP\_VERSION | src\_coap\_msg\_ptr->msg\_type | src\_coap\_msg\_ptr->token\_len;
 /\* \* \* Add Message code \* \* \*/ dest\_packet[1] = src\_coap\_msg\_ptr->msg\_code;
 /\* \* \* Add Message ID \* \* \*/ dest\_packet[2] = (uint8\_t)(src\_coap\_msg\_ptr->msg\_id >> COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT); /\* MSB part \*/ dest\_packet[3] = (uint8\_t)src\_coap\_msg\_ptr->msg\_id; /\* LSB part \*/
 \*dst\_packet\_data\_pptr = dest\_packet + 4;
 /\* Success \*/ return 0;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in every case \*/static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check if Options are used at all \* \* \* \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr == NULL && src\_coap\_msg\_ptr->token\_ptr == NULL && src\_coap\_msg\_ptr->content\_format == COAP\_CT\_NONE && src\_coap\_msg\_ptr->options\_list\_ptr == NULL) { /\* If the empty message is confirmable it is CoAP ping. \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_CONFIRMABLE) { tr\_error("sn\_coap\_builder\_options\_build - options not used!"); } return 0; }
 /\* \* \* \* First add Token option \* \* \* \*/ if (src\_coap\_msg\_ptr->token\_len && src\_coap\_msg\_ptr->token\_ptr) { memcpy(\*dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->token\_ptr, src\_coap\_msg\_ptr->token\_len); } (\*dst\_packet\_data\_pptr) += src\_coap\_msg\_ptr->token\_len;
 /\* Then build rest of the options \*/
 /\* \* \* \* Initialize previous Option number for new built message \* \* \* \*/ uint16\_t previous\_option\_number = 0;
 //missing: COAP\_OPTION\_IF\_MATCH, COAP\_OPTION\_IF\_NONE\_MATCH, COAP\_OPTION\_SIZE
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* Check if less used options are used at all \*/ if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Uri-Host option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_host\_len, src\_options\_list\_ptr->uri\_host\_ptr, COAP\_OPTION\_URI\_HOST, &previous\_option\_number);
 /\* \* \* \* Build ETag option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->etag\_ptr, src\_options\_list\_ptr->etag\_len, COAP\_OPTION\_ETAG, &previous\_option\_number);
 /\* \* \* \* Build Observe option \* \* \* \* \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Port option \* \* \* \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_path\_ptr, src\_options\_list\_ptr->location\_path\_len, COAP\_OPTION\_LOCATION\_PATH, &previous\_option\_number); } /\* \* \* \* Build Uri-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->uri\_path\_ptr, src\_coap\_msg\_ptr->uri\_path\_len, COAP\_OPTION\_URI\_PATH, &previous\_option\_number);
 /\* \* \* \* Build Content-Type option \* \* \* \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &previous\_option\_number); }
 if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Max-Age option \* \* \* \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Query option \* \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_query\_ptr, src\_options\_list\_ptr->uri\_query\_len, COAP\_OPTION\_URI\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Accept option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->accept != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Query option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_query\_ptr, src\_options\_list\_ptr->location\_query\_len, COAP\_OPTION\_LOCATION\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Block2 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &previous\_option\_number); }
 /\* \* \* \* Build Block1 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &previous\_option\_number); }
 /\* \* \* \* Build Size2 option \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &previous\_option\_number); }
 /\* \* \* \* Build Proxy-Uri option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->proxy\_uri\_len, src\_options\_list\_ptr->proxy\_uri\_ptr, COAP\_OPTION\_PROXY\_URI, &previous\_option\_number);
 /\* \* \* \* Build Size1 option \* \* \* \*/ if (src\_options\_list\_ptr->use\_size1) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &previous\_option\_number); } }
 /\* Success \*/ return 0;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_value\_len, uint8\_t \*option\_value\_ptr, sn\_coap\_option\_numbers\_e option\_number) \* \* \brief Adds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param option\_value\_len is Option value length to be added \* \* \param \*option\_value\_ptr is pointer to Option value data to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is 0 if option was not added, 1 if added \*/static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (option\_ptr != NULL) { uint16\_t option\_delta;
 option\_delta = (option\_number - \*previous\_option\_number);
 /\* \* \* Build option header \* \* \*/
 uint8\_t first\_byte;
 /\* First option length without extended part \*/ if (option\_len <= 12) { first\_byte = option\_len; }
 else if (option\_len > 12 && option\_len < 269) { first\_byte = 0x0D; }
 else /\*if (option\_len >= 269)\*/ { first\_byte = 0x0E; }
 uint8\_t \*dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Then option delta with extensions, and move pointer \*/ if (option\_delta <= 12) { dest\_packet[0] = first\_byte + (option\_delta << 4); dest\_packet += 1; }
 else if (option\_delta > 12 && option\_delta < 269) { dest\_packet[0] = first\_byte + 0xD0; option\_delta -= 13;
 dest\_packet[1] = (uint8\_t)option\_delta; dest\_packet += 2; } //This is currently dead code (but possibly needed in future) else /\*if (option\_delta >= 269)\*/ { dest\_packet[0] = first\_byte + 0xE0; option\_delta -= 269;
 dest\_packet[1] = (option\_delta >> 8); dest\_packet[2] = (uint8\_t)option\_delta; dest\_packet += 3; }
 /\* Now option length extensions, if needed \*/ if (option\_len > 12 && option\_len < 269) { dest\_packet[0] = (uint8\_t)(option\_len - 13); dest\_packet += 1; }
 else if (option\_len >= 269) { dest\_packet[0] = ((option\_len - 269) >> 8); dest\_packet[1] = (uint8\_t)(option\_len - 269); dest\_packet += 2; }
 \*previous\_option\_number = option\_number;
 /\* Write Option value \*/ memcpy(dest\_packet, option\_ptr, option\_len);
 /\* Increase destination Packet data pointer \*/ dest\_packet += option\_len;
 \*dst\_packet\_data\_pptr = dest\_packet;
 return 1; }
 /\* Success \*/ return 0;}
/\*\* \* \brief Constructs a uint Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data; NULL \* to compute size only. \* \* \param option\_value is Option value to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is total option size, or -1 in write failure case \*/static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t option\_value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ uint8\_t payload[4]; uint8\_t len = 0; /\* Construct the variable-length payload representing the value \*/ for (uint8\_t i = 0; i < 4; i++) { if (len > 0 || (option\_value & 0xff000000)) { payload[len++] = option\_value >> 24; } option\_value <<= 8; }
 /\* If output pointer isn't NULL, write it out \*/ if (dst\_packet\_data\_pptr) { // No need to check & handle return value, as the function returns failure only if the option pointer is zero // and it is pointing to a local variable here. sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, len, payload, option\_number, previous\_option\_number); }
 /\* Return the total option size \*/ return 1 + len;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint8\_t \*\*src\_pptr, uint16\_t \*src\_len\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Builds Option Uri-Query from given CoAP Header structure to Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param uint8\_t \*\*src\_ptr \* \* \param uint16\_t src\_len \* \* \paramsn\_coap\_option\_numbers\_e option option to be added \* \* \return Return value is 0 always \*/static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (src\_pptr != NULL) { const uint8\_t \*query\_ptr = src\_pptr; uint8\_t query\_part\_count = 0; uint16\_t query\_len = src\_len; uint8\_t i = 0; uint16\_t query\_part\_offset = 0;
 /\* Get query part count \*/ query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option);
 /\* \* \* \* Options by adding all parts to option \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* Get length of query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Get position of query part \*/ query\_part\_offset = sn\_coap\_builder\_options\_get\_option\_part\_position(query\_len, query\_ptr, i, option);
 /\* Add Uri-query's one part to Options \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, one\_query\_part\_len, src\_pptr + query\_part\_offset, option, previous\_option\_number); } } /\* Success \*/}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Calculates needed Packet data memory size for option \* \* \param path\_len is length of calculated strting(s) \* \* \param \*path\_ptr is pointer to calculated options \* \* \return Return value is count of needed memory as bytes for Uri-query option \*/static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option); uint8\_t i = 0; uint16\_t ret\_value = 0;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Calculate Uri-query options length \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* \* \* Length of Option number and Option value length \* \* \*/
 /\* Get length of Query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Check option length \*/ switch (option) { case (COAP\_OPTION\_ETAG): /\* Length 1-8 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 8) { return 0; } break; case (COAP\_OPTION\_LOCATION\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_URI\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_LOCATION\_QUERY): /\* Length 0-255 \*/ if (one\_query\_part\_len > 255) { return 0; } break; case (COAP\_OPTION\_URI\_QUERY): /\* Length 1-255 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 255) { return 0; } break;// case (COAP\_OPTION\_ACCEPT): /\* Length 0-2 \*/// if (one\_query\_part\_len > 2) {// return 0;// }// break; default: break; //impossible scenario currently }
 /\* Check if 4 bits are enough for writing Option value length \*/ if (one\_query\_part\_len <= 12) { /\* 4 bits are enough for Option value length \*/ ret\_value++; } else if (one\_query\_part\_len >= 13 && one\_query\_part\_len < 269) { /\* Extra byte for Option value length is needed \*/ ret\_value += 2; } //This can only happen if we are in default case above, currently is not happening else if (one\_query\_part\_len >= 270 && one\_query\_part\_len < 1034) { /\* Extra bytes for Option value length is needed \*/ ret\_value += 3; }
 /\* \* \* Length of Option value \* \* \*/
 /\* Increase options length \*/ ret\_value += one\_query\_part\_len; }
 /\* Success \*/ return ret\_value;}
/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets query part count from whole option string \* \* \param query\_len is length of whole Path \* \* \param \*query\_ptr is pointer to the start of whole Path \* \* \return Return value is count of query parts \*/static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t returned\_query\_count = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters (not first and last char) \*/ for (query\_len\_index = 1; query\_len\_index < query\_len - 1; query\_len\_index++) { /\* If new query part starts \*/ if (\*(query\_ptr + query\_len\_index) == char\_to\_search) { /\* If match \*/ returned\_query\_count++; } }
 returned\_query\_count++;
 return returned\_query\_count;}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets one's query part length from whole query string \* \* \param query\_len is length of whole string \* \* \param \*query\_ptr is pointer to the start of whole string \* \* \param query\_index is query part index to be found \* \* \param sn\_coap\_option\_numbers\_e option is option number of the option \* \* \return Return value is length of query part \*/static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option){ uint16\_t returned\_query\_part\_len = 0; uint8\_t temp\_query\_index = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters \*/ for (query\_len\_index = 0; query\_len\_index < query\_len; query\_len\_index++) { /\* Store character to temp\_char for helping debugging \*/ uint8\_t temp\_char = \*query\_ptr;
 /\* If new query part starts \*/ if (temp\_char == char\_to\_search && returned\_query\_part\_len > 0) { /\* returned\_query\_part\_len > 0 is for querys which start with "\0" \*/ /\* If query part index is wanted \*/ if (temp\_query\_index == query\_index) { /\* Return length of query part \*/ return returned\_query\_part\_len; } else { /\* Reset length of query part because wanted query part finding continues\*/ returned\_query\_part\_len = 0; }
 /\* Next query part is looped \*/ temp\_query\_index++;[View remainder of file in raw view](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from github.com_dc4c7592_20250120_234948.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FARMmbed%2Fmbed-os%2Fblob%2Fd0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6%2Ffeatures%2Fframeworks%2Fmbed-coap%2Fsource%2Fsn_coap_builder.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=ARMmbed%2Fmbed-os)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[ARMmbed](/ARMmbed)
/
**[mbed-os](/ARMmbed/mbed-os)**
Public

* [Notifications](/login?return_to=%2FARMmbed%2Fmbed-os) You must be signed in to change notification settings
* [Fork
  3k](/login?return_to=%2FARMmbed%2Fmbed-os)
* [Star
   4.7k](/login?return_to=%2FARMmbed%2Fmbed-os)

* [Code](/ARMmbed/mbed-os)
* [Issues
  195](/ARMmbed/mbed-os/issues)
* [Pull requests
  11](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects
  0](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

Additional navigation options

* [Code](/ARMmbed/mbed-os)
* [Issues](/ARMmbed/mbed-os/issues)
* [Pull requests](/ARMmbed/mbed-os/pulls)
* [Actions](/ARMmbed/mbed-os/actions)
* [Projects](/ARMmbed/mbed-os/projects)
* [Security](/ARMmbed/mbed-os/security)
* [Insights](/ARMmbed/mbed-os/pulse)

## Files

 d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Copy path Blame  Blame
## Latest commit

## History

[History](/ARMmbed/mbed-os/commits/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1099 lines (950 loc) · 45.9 KB d0686fd
## Breadcrumbs

1. [mbed-os](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6)
2. /[features](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features)
3. /[frameworks](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks)
4. /[mbed-coap](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap)
5. /[source](/ARMmbed/mbed-os/tree/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source)
/
# sn\_coap\_builder.c

Top
## File metadata and controls

* Code
* Blame

1099 lines (950 loc) · 45.9 KB[Raw](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000/\* \* Copyright (c) 2011-2015 ARM Limited. All rights reserved. \* SPDX-License-Identifier: Apache-2.0 \* Licensed under the Apache License, Version 2.0 (the License); you may \* not use this file except in compliance with the License. \* You may obtain a copy of the License at \* \* http://www.apache.org/licenses/LICENSE-2.0 \* \* Unless required by applicable law or agreed to in writing, software \* distributed under the License is distributed on an AS IS BASIS, WITHOUT \* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \* See the License for the specific language governing permissions and \* limitations under the License. \*/
/\*\* \* \file sn\_coap\_builder.c \* \* \brief CoAP Message builder \* \* Functionality: Builds CoAP message \* \*/
/\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*//\* \* \* \* INCLUDE FILES \* \* \* \*//\* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/
#include <string.h> /\* For memset() and memcpy() \*/
#include "ns\_types.h"#include "mbed-coap/sn\_coap\_header.h"#include "sn\_coap\_header\_internal.h"#include "sn\_coap\_protocol\_internal.h"#include "mbed-trace/mbed\_trace.h"
#define TRACE\_GROUP "coap"/\* \* \* \* LOCAL FUNCTION PROTOTYPES \* \* \* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len\_ptr, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number);static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option);static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static int16\_t sn\_coap\_builder\_options\_get\_option\_part\_position(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option);static void sn\_coap\_builder\_payload\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr);
sn\_coap\_hdr\_s \*sn\_coap\_build\_response(struct coap\_s \*handle, const sn\_coap\_hdr\_s \*coap\_packet\_ptr, uint8\_t msg\_code){ sn\_coap\_hdr\_s \*coap\_res\_ptr;
 if (!coap\_packet\_ptr || !handle) { return NULL; }
 coap\_res\_ptr = sn\_coap\_parser\_alloc\_message(handle); if (!coap\_res\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate message!"); return NULL; }
 if (msg\_code == COAP\_MSG\_CODE\_REQUEST\_GET) { // Blockwise message response is new GET coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_ACKNOWLEDGEMENT; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; coap\_res\_ptr->msg\_id = coap\_packet\_ptr->msg\_id; } else if (coap\_packet\_ptr->msg\_type == COAP\_MSG\_TYPE\_NON\_CONFIRMABLE) { coap\_res\_ptr->msg\_type = COAP\_MSG\_TYPE\_NON\_CONFIRMABLE; coap\_res\_ptr->msg\_code = (sn\_coap\_msg\_code\_e)msg\_code; /\* msg\_id needs to be set by the caller in this case \*/ } else { handle->sn\_coap\_protocol\_free( coap\_res\_ptr ); return NULL; }
 if (coap\_packet\_ptr->token\_ptr) { coap\_res\_ptr->token\_len = coap\_packet\_ptr->token\_len; coap\_res\_ptr->token\_ptr = sn\_coap\_protocol\_malloc\_copy(handle, coap\_packet\_ptr->token\_ptr, coap\_res\_ptr->token\_len); if (!coap\_res\_ptr->token\_ptr) { tr\_error("sn\_coap\_build\_response - failed to allocate token!"); handle->sn\_coap\_protocol\_free(coap\_res\_ptr); return NULL; } } return coap\_res\_ptr;}
int16\_t sn\_coap\_builder(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_2(dst\_packet\_data\_ptr, src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
int16\_t sn\_coap\_builder\_2(uint8\_t \*dst\_packet\_data\_ptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ uint8\_t \*base\_packet\_data\_ptr;
 /\* \* \* \* Check given pointers \* \* \* \*/ if (dst\_packet\_data\_ptr == NULL || src\_coap\_msg\_ptr == NULL) { return -2; }
 /\* Initialize given Packet data memory area with zero values \*/ uint16\_t dst\_byte\_count\_to\_be\_built = sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, blockwise\_payload\_size); if (!dst\_byte\_count\_to\_be\_built) { tr\_error("sn\_coap\_builder\_2 - failed to allocate message!"); return -1; }
 // XXX: this should not be needed anymore but I have no courage to remove it yet. memset(dst\_packet\_data\_ptr, 0, dst\_byte\_count\_to\_be\_built);
 /\* \* \* \* Store base (= original) destination Packet data pointer for later usage \* \* \* \*/ base\_packet\_data\_ptr = dst\_packet\_data\_ptr;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Header part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ if (sn\_coap\_builder\_header\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr) != 0) { /\* Header building failed \*/ tr\_error("sn\_coap\_builder\_2 - header building failed!"); return -1; }
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Options part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_options\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr);
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Payload part building \* \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ sn\_coap\_builder\_payload\_build(&dst\_packet\_data\_ptr, src\_coap\_msg\_ptr); } /\* \* \* \* Return built Packet data length \* \* \* \*/ return (dst\_packet\_data\_ptr - base\_packet\_data\_ptr);}uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ return sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(src\_coap\_msg\_ptr, SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE);}
uint16\_t sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr, uint16\_t blockwise\_payload\_size){ (void)blockwise\_payload\_size; uint16\_t returned\_byte\_count = 0;
 if (!src\_coap\_msg\_ptr) { return 0; } /\* \* \* \* \* HEADER \* \* \* \* \*/
 /\* Header size is fixed \*/ returned\_byte\_count = COAP\_HEADER\_LENGTH;
 /\* \* \* \* \* OPTIONS \* \* \* \* \*/
 /\* If else than Reset message because Reset message must be empty \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_RESET) { uint16\_t repeatable\_option\_size = 0; /\* TOKEN - Length is 1-8 bytes \*/ if (src\_coap\_msg\_ptr->token\_ptr != NULL) { if (src\_coap\_msg\_ptr->token\_len > 8 || src\_coap\_msg\_ptr->token\_len < 1) { /\* Check that option is not longer than defined \*/ tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - token too large!"); return 0; }
 returned\_byte\_count += src\_coap\_msg\_ptr->token\_len; } /\* URI PATH - Repeatable option. Length of one option is 0-255 \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_coap\_msg\_ptr->uri\_path\_len, src\_coap\_msg\_ptr->uri\_path\_ptr, COAP\_OPTION\_URI\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri path size failed!"); return 0; } }
 uint16\_t tempInt = 0; /\* CONTENT FORMAT - An integer option, up to 2 bytes \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { if ((uint32\_t) src\_coap\_msg\_ptr->content\_format > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - content format too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &tempInt); } /\* If options list pointer exists \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr != NULL) {
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* ACCEPT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->accept > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - accept too large!"); return 0; }
 returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &tempInt); } /\* MAX AGE - An integer option, omitted for default. Up to 4 bytes \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &tempInt); } /\* PROXY URI - Length of this option is 1-1034 bytes \*/ if (src\_options\_list\_ptr->proxy\_uri\_ptr != NULL) { if (src\_options\_list\_ptr->proxy\_uri\_len >= 1 && src\_options\_list\_ptr->proxy\_uri\_len <= 12) { /\* Add option header byte(s) - depending of option length \*/ returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 13 && src\_options\_list\_ptr->proxy\_uri\_len <= 269) { returned\_byte\_count += 2; }
 else if (src\_options\_list\_ptr->proxy\_uri\_len >= 270 && src\_options\_list\_ptr->proxy\_uri\_len <= 1034) { returned\_byte\_count += 3; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - proxy uri too large!"); return 0; }
 /\* Add needed memory for Option value \*/ returned\_byte\_count += src\_options\_list\_ptr->proxy\_uri\_len; } /\* ETAG - Repeatable option. Length of this option is 1-8 bytes\*/ if (src\_options\_list\_ptr->etag\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->etag\_len, src\_options\_list\_ptr->etag\_ptr, COAP\_OPTION\_ETAG); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - etag too large!"); return 0; } } /\* URI HOST - Length of this option is 1-255 bytes \*/ if (src\_options\_list\_ptr->uri\_host\_ptr != NULL) { if (src\_options\_list\_ptr->uri\_host\_len > 0 && src\_options\_list\_ptr->uri\_host\_len <= 12) { returned\_byte\_count++; }
 else if (src\_options\_list\_ptr->uri\_host\_len >= 13 && src\_options\_list\_ptr->uri\_host\_len <= 255) { returned\_byte\_count += 2; }
 else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri host too large!"); return 0; }
 returned\_byte\_count += src\_options\_list\_ptr->uri\_host\_len; } /\* LOCATION PATH - Repeatable option. Length of this option is 0-255 bytes\*/ if (src\_options\_list\_ptr->location\_path\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_path\_len, src\_options\_list\_ptr->location\_path\_ptr, COAP\_OPTION\_LOCATION\_PATH); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location path too large!"); return 0; } } /\* URI PORT - An integer option, up to 2 bytes \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->uri\_port > 0xffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - uri port too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &tempInt); } /\* lOCATION QUERY - Repeatable option. Length of this option is 0-255 bytes \*/ if (src\_options\_list\_ptr->location\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->location\_query\_len, src\_options\_list\_ptr->location\_query\_ptr, COAP\_OPTION\_LOCATION\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - location query too large!"); return 0; } } /\* OBSERVE - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->observe > 0xffffff) { return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &tempInt); } /\* URI QUERY - Repeatable option. Length of this option is 1-255 \*/ if (src\_options\_list\_ptr->uri\_query\_ptr != NULL) { repeatable\_option\_size = sn\_coap\_builder\_options\_calc\_option\_size(src\_options\_list\_ptr->uri\_query\_len, src\_options\_list\_ptr->uri\_query\_ptr, COAP\_OPTION\_URI\_QUERY); if (repeatable\_option\_size) { returned\_byte\_count += repeatable\_option\_size; } else { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - observe too large!"); return 0; } }
 /\* BLOCK 1 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block1 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block1 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &tempInt); } /\* SIZE1 - Length of this option is 0-4 bytes \*/ if (src\_options\_list\_ptr->use\_size1) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &tempInt); } /\* BLOCK 2 - An integer option, up to 3 bytes \*/ if (src\_options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((uint32\_t) src\_options\_list\_ptr->block2 > 0xffffff) { tr\_error("sn\_coap\_builder\_calc\_needed\_packet\_data\_size\_2 - block2 too large!"); return 0; } returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &tempInt); } /\* SIZE2 - Length of this option is 0-4 bytes \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { returned\_byte\_count += sn\_coap\_builder\_options\_build\_add\_uint\_option(NULL, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &tempInt); } }#if SN\_COAP\_BLOCKWISE\_ENABLED || SN\_COAP\_MAX\_BLOCKWISE\_PAYLOAD\_SIZE if ((src\_coap\_msg\_ptr->payload\_len > SN\_COAP\_MAX\_NONBLOCKWISE\_PAYLOAD\_SIZE) && (src\_coap\_msg\_ptr->payload\_len > blockwise\_payload\_size) && (blockwise\_payload\_size > 0)) { returned\_byte\_count += blockwise\_payload\_size; } else { returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len; }#else returned\_byte\_count += src\_coap\_msg\_ptr->payload\_len;#endif if (src\_coap\_msg\_ptr->payload\_len) { returned\_byte\_count ++; /\* For payload marker \*/ } returned\_byte\_count += sn\_coap\_builder\_options\_calculate\_jump\_need(src\_coap\_msg\_ptr); } return returned\_byte\_count;}/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Checks if there is need for option jump \* \* \param \*src\_coap\_msg\_ptr is source of checked CoAP message \* \* \param block option marks if block option is to be added to message later. 0 = no block option, 1 = block1 and 2 = block2 \* \* \return Returns bytes needed for jumping \*/
static uint8\_t sn\_coap\_builder\_options\_calculate\_jump\_need(const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ uint8\_t previous\_option\_number = 0; uint8\_t needed\_space = 0;
 const sn\_coap\_options\_list\_s\* options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 if (options\_list\_ptr != NULL) {
 /\* If option numbers greater than 12 is not used, then jumping is not needed \*/ //TODO: Check if this is really needed! Does it enhance perf? If not -> remove if (!options\_list\_ptr->uri\_query\_ptr && options\_list\_ptr->accept == COAP\_CT\_NONE && !options\_list\_ptr->location\_query\_ptr && options\_list\_ptr->block2 == COAP\_OPTION\_BLOCK\_NONE && options\_list\_ptr->block1 == COAP\_OPTION\_BLOCK\_NONE && !options\_list\_ptr->proxy\_uri\_ptr && options\_list\_ptr->max\_age == COAP\_OPTION\_MAX\_AGE\_DEFAULT && !options\_list\_ptr->use\_size1 && !options\_list\_ptr->use\_size2) { return 0; }
 if (options\_list\_ptr->uri\_host\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_HOST); }
 if (options\_list\_ptr->etag\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_ETAG); }
 if (options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { previous\_option\_number = (COAP\_OPTION\_OBSERVE); }
 if (options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { previous\_option\_number = (COAP\_OPTION\_URI\_PORT); }
 if (options\_list\_ptr->location\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_LOCATION\_PATH); }
 if (src\_coap\_msg\_ptr->uri\_path\_ptr != NULL) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); } if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); }
 if (options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { if ((COAP\_OPTION\_MAX\_AGE - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_MAX\_AGE); }
 if (options\_list\_ptr->uri\_query\_ptr != NULL) { if ((COAP\_OPTION\_URI\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_URI\_QUERY); } if (options\_list\_ptr->accept != COAP\_CT\_NONE) { if ((COAP\_OPTION\_ACCEPT - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_ACCEPT); } if (options\_list\_ptr->location\_query\_ptr != NULL) { if ((COAP\_OPTION\_LOCATION\_QUERY - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_LOCATION\_QUERY); } if (options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK2 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK2); } if (options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { if ((COAP\_OPTION\_BLOCK1 - previous\_option\_number) > 12 ){ needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_BLOCK1); } if (options\_list\_ptr->use\_size2) { if ((COAP\_OPTION\_SIZE2 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE2); } if (options\_list\_ptr->proxy\_uri\_ptr != NULL) { if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 12) { needed\_space += 1; } if ((COAP\_OPTION\_PROXY\_URI - previous\_option\_number) > 269) { //Can not happen needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_PROXY\_URI); } if (options\_list\_ptr->use\_size1) { if ((COAP\_OPTION\_SIZE1 - previous\_option\_number) > 12) { needed\_space += 1; } previous\_option\_number = (COAP\_OPTION\_SIZE1); } }
 else { if (src\_coap\_msg\_ptr->uri\_path\_ptr != 0) { previous\_option\_number = (COAP\_OPTION\_URI\_PATH); }
 if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { previous\_option\_number = (COAP\_OPTION\_CONTENT\_FORMAT); } } return needed\_space;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Header part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in ok case and -1 in failure case \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* \*/static int8\_t sn\_coap\_builder\_header\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check validity of Header values \* \* \* \*/ if (sn\_coap\_header\_validity\_check(src\_coap\_msg\_ptr, COAP\_VERSION) != 0) { tr\_error("sn\_coap\_builder\_header\_build - header build failed!"); return -1; }
 uint8\_t\* dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Set CoAP Version, Message type and Token length \*/ dest\_packet[0] = COAP\_VERSION | src\_coap\_msg\_ptr->msg\_type | src\_coap\_msg\_ptr->token\_len;
 /\* \* \* Add Message code \* \* \*/ dest\_packet[1] = src\_coap\_msg\_ptr->msg\_code;
 /\* \* \* Add Message ID \* \* \*/ dest\_packet[2] = (uint8\_t)(src\_coap\_msg\_ptr->msg\_id >> COAP\_HEADER\_MSG\_ID\_MSB\_SHIFT); /\* MSB part \*/ dest\_packet[3] = (uint8\_t)src\_coap\_msg\_ptr->msg\_id; /\* LSB part \*/
 \*dst\_packet\_data\_pptr = dest\_packet + 4;
 /\* Success \*/ return 0;}
/\*\* \* \fn static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr) \* \* \brief Builds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param \*src\_coap\_msg\_ptr is source for building Packet data \* \* \return Return value is 0 in every case \*/static int8\_t sn\_coap\_builder\_options\_build(uint8\_t \*\*dst\_packet\_data\_pptr, const sn\_coap\_hdr\_s \*src\_coap\_msg\_ptr){ /\* \* \* \* Check if Options are used at all \* \* \* \*/ if (src\_coap\_msg\_ptr->uri\_path\_ptr == NULL && src\_coap\_msg\_ptr->token\_ptr == NULL && src\_coap\_msg\_ptr->content\_format == COAP\_CT\_NONE && src\_coap\_msg\_ptr->options\_list\_ptr == NULL) { /\* If the empty message is confirmable it is CoAP ping. \*/ if (src\_coap\_msg\_ptr->msg\_type != COAP\_MSG\_TYPE\_CONFIRMABLE) { tr\_error("sn\_coap\_builder\_options\_build - options not used!"); } return 0; }
 /\* \* \* \* First add Token option \* \* \* \*/ if (src\_coap\_msg\_ptr->token\_len && src\_coap\_msg\_ptr->token\_ptr) { memcpy(\*dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->token\_ptr, src\_coap\_msg\_ptr->token\_len); } (\*dst\_packet\_data\_pptr) += src\_coap\_msg\_ptr->token\_len;
 /\* Then build rest of the options \*/
 /\* \* \* \* Initialize previous Option number for new built message \* \* \* \*/ uint16\_t previous\_option\_number = 0;
 //missing: COAP\_OPTION\_IF\_MATCH, COAP\_OPTION\_IF\_NONE\_MATCH, COAP\_OPTION\_SIZE
 const sn\_coap\_options\_list\_s \*src\_options\_list\_ptr = src\_coap\_msg\_ptr->options\_list\_ptr;
 /\* Check if less used options are used at all \*/ if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Uri-Host option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_host\_len, src\_options\_list\_ptr->uri\_host\_ptr, COAP\_OPTION\_URI\_HOST, &previous\_option\_number);
 /\* \* \* \* Build ETag option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->etag\_ptr, src\_options\_list\_ptr->etag\_len, COAP\_OPTION\_ETAG, &previous\_option\_number);
 /\* \* \* \* Build Observe option \* \* \* \* \*/ if (src\_options\_list\_ptr->observe != COAP\_OBSERVE\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->observe, COAP\_OPTION\_OBSERVE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Port option \* \* \* \*/ if (src\_options\_list\_ptr->uri\_port != COAP\_OPTION\_URI\_PORT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_port, COAP\_OPTION\_URI\_PORT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_path\_ptr, src\_options\_list\_ptr->location\_path\_len, COAP\_OPTION\_LOCATION\_PATH, &previous\_option\_number); } /\* \* \* \* Build Uri-Path option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->uri\_path\_ptr, src\_coap\_msg\_ptr->uri\_path\_len, COAP\_OPTION\_URI\_PATH, &previous\_option\_number);
 /\* \* \* \* Build Content-Type option \* \* \* \*/ if (src\_coap\_msg\_ptr->content\_format != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_coap\_msg\_ptr->content\_format, COAP\_OPTION\_CONTENT\_FORMAT, &previous\_option\_number); }
 if (src\_options\_list\_ptr != NULL) { /\* \* \* \* Build Max-Age option \* \* \* \*/ if (src\_options\_list\_ptr->max\_age != COAP\_OPTION\_MAX\_AGE\_DEFAULT) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->max\_age, COAP\_OPTION\_MAX\_AGE, &previous\_option\_number); }
 /\* \* \* \* Build Uri-Query option \* \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->uri\_query\_ptr, src\_options\_list\_ptr->uri\_query\_len, COAP\_OPTION\_URI\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Accept option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->accept != COAP\_CT\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->accept, COAP\_OPTION\_ACCEPT, &previous\_option\_number); }
 /\* \* \* \* Build Location-Query option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_multiple\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->location\_query\_ptr, src\_options\_list\_ptr->location\_query\_len, COAP\_OPTION\_LOCATION\_QUERY, &previous\_option\_number);
 /\* \* \* \* Build Block2 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block2 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block2, COAP\_OPTION\_BLOCK2, &previous\_option\_number); }
 /\* \* \* \* Build Block1 option \* \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->block1 != COAP\_OPTION\_BLOCK\_NONE) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->block1, COAP\_OPTION\_BLOCK1, &previous\_option\_number); }
 /\* \* \* \* Build Size2 option \* \* \* \*/ if (src\_coap\_msg\_ptr->options\_list\_ptr->use\_size2) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size2, COAP\_OPTION\_SIZE2, &previous\_option\_number); }
 /\* \* \* \* Build Proxy-Uri option \* \* \* \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->proxy\_uri\_len, src\_options\_list\_ptr->proxy\_uri\_ptr, COAP\_OPTION\_PROXY\_URI, &previous\_option\_number);
 /\* \* \* \* Build Size1 option \* \* \* \*/ if (src\_options\_list\_ptr->use\_size1) { sn\_coap\_builder\_options\_build\_add\_uint\_option(dst\_packet\_data\_pptr, src\_options\_list\_ptr->size1, COAP\_OPTION\_SIZE1, &previous\_option\_number); } }
 /\* Success \*/ return 0;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_value\_len, uint8\_t \*option\_value\_ptr, sn\_coap\_option\_numbers\_e option\_number) \* \* \brief Adds Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param option\_value\_len is Option value length to be added \* \* \param \*option\_value\_ptr is pointer to Option value data to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is 0 if option was not added, 1 if added \*/static int16\_t sn\_coap\_builder\_options\_build\_add\_one\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint16\_t option\_len, const uint8\_t \*option\_ptr, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (option\_ptr != NULL) { uint16\_t option\_delta;
 option\_delta = (option\_number - \*previous\_option\_number);
 /\* \* \* Build option header \* \* \*/
 uint8\_t first\_byte;
 /\* First option length without extended part \*/ if (option\_len <= 12) { first\_byte = option\_len; }
 else if (option\_len > 12 && option\_len < 269) { first\_byte = 0x0D; }
 else /\*if (option\_len >= 269)\*/ { first\_byte = 0x0E; }
 uint8\_t \*dest\_packet = \*dst\_packet\_data\_pptr;
 /\* Then option delta with extensions, and move pointer \*/ if (option\_delta <= 12) { dest\_packet[0] = first\_byte + (option\_delta << 4); dest\_packet += 1; }
 else if (option\_delta > 12 && option\_delta < 269) { dest\_packet[0] = first\_byte + 0xD0; option\_delta -= 13;
 dest\_packet[1] = (uint8\_t)option\_delta; dest\_packet += 2; } //This is currently dead code (but possibly needed in future) else /\*if (option\_delta >= 269)\*/ { dest\_packet[0] = first\_byte + 0xE0; option\_delta -= 269;
 dest\_packet[1] = (option\_delta >> 8); dest\_packet[2] = (uint8\_t)option\_delta; dest\_packet += 3; }
 /\* Now option length extensions, if needed \*/ if (option\_len > 12 && option\_len < 269) { dest\_packet[0] = (uint8\_t)(option\_len - 13); dest\_packet += 1; }
 else if (option\_len >= 269) { dest\_packet[0] = ((option\_len - 269) >> 8); dest\_packet[1] = (uint8\_t)(option\_len - 269); dest\_packet += 2; }
 \*previous\_option\_number = option\_number;
 /\* Write Option value \*/ memcpy(dest\_packet, option\_ptr, option\_len);
 /\* Increase destination Packet data pointer \*/ dest\_packet += option\_len;
 \*dst\_packet\_data\_pptr = dest\_packet;
 return 1; }
 /\* Success \*/ return 0;}
/\*\* \* \brief Constructs a uint Options part of Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data; NULL \* to compute size only. \* \* \param option\_value is Option value to be added \* \* \param option\_number is Option number to be added \* \* \return Return value is total option size, or -1 in write failure case \*/static uint8\_t sn\_coap\_builder\_options\_build\_add\_uint\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint32\_t option\_value, sn\_coap\_option\_numbers\_e option\_number, uint16\_t \*previous\_option\_number){ uint8\_t payload[4]; uint8\_t len = 0; /\* Construct the variable-length payload representing the value \*/ for (uint8\_t i = 0; i < 4; i++) { if (len > 0 || (option\_value & 0xff000000)) { payload[len++] = option\_value >> 24; } option\_value <<= 8; }
 /\* If output pointer isn't NULL, write it out \*/ if (dst\_packet\_data\_pptr) { // No need to check & handle return value, as the function returns failure only if the option pointer is zero // and it is pointing to a local variable here. sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, len, payload, option\_number, previous\_option\_number); }
 /\* Return the total option size \*/ return 1 + len;}
/\*\* \* \fn static int16\_t sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, uint8\_t \*\*src\_pptr, uint16\_t \*src\_len\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Builds Option Uri-Query from given CoAP Header structure to Packet data \* \* \param \*\*dst\_packet\_data\_pptr is destination for built Packet data \* \* \param uint8\_t \*\*src\_ptr \* \* \param uint16\_t src\_len \* \* \paramsn\_coap\_option\_numbers\_e option option to be added \* \* \return Return value is 0 always \*/static void sn\_coap\_builder\_options\_build\_add\_multiple\_option(uint8\_t \*\*dst\_packet\_data\_pptr, const uint8\_t \*src\_pptr, uint16\_t src\_len, sn\_coap\_option\_numbers\_e option, uint16\_t \*previous\_option\_number){ /\* Check if there is option at all \*/ if (src\_pptr != NULL) { const uint8\_t \*query\_ptr = src\_pptr; uint8\_t query\_part\_count = 0; uint16\_t query\_len = src\_len; uint8\_t i = 0; uint16\_t query\_part\_offset = 0;
 /\* Get query part count \*/ query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option);
 /\* \* \* \* Options by adding all parts to option \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* Get length of query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Get position of query part \*/ query\_part\_offset = sn\_coap\_builder\_options\_get\_option\_part\_position(query\_len, query\_ptr, i, option);
 /\* Add Uri-query's one part to Options \*/ sn\_coap\_builder\_options\_build\_add\_one\_option(dst\_packet\_data\_pptr, one\_query\_part\_len, src\_pptr + query\_part\_offset, option, previous\_option\_number); } } /\* Success \*/}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Calculates needed Packet data memory size for option \* \* \param path\_len is length of calculated strting(s) \* \* \param \*path\_ptr is pointer to calculated options \* \* \return Return value is count of needed memory as bytes for Uri-query option \*/static uint16\_t sn\_coap\_builder\_options\_calc\_option\_size(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t query\_part\_count = sn\_coap\_builder\_options\_get\_option\_part\_count(query\_len, query\_ptr, option); uint8\_t i = 0; uint16\_t ret\_value = 0;
 /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ /\* \* \* \* Calculate Uri-query options length \* \* \*/ /\* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \* \*/ for (i = 0; i < query\_part\_count; i++) { /\* \* \* Length of Option number and Option value length \* \* \*/
 /\* Get length of Query part \*/ uint16\_t one\_query\_part\_len = sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(query\_len, query\_ptr, i, option);
 /\* Check option length \*/ switch (option) { case (COAP\_OPTION\_ETAG): /\* Length 1-8 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 8) { return 0; } break; case (COAP\_OPTION\_LOCATION\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_URI\_PATH): /\* Length 0-255 \*/ case (COAP\_OPTION\_LOCATION\_QUERY): /\* Length 0-255 \*/ if (one\_query\_part\_len > 255) { return 0; } break; case (COAP\_OPTION\_URI\_QUERY): /\* Length 1-255 \*/ if (one\_query\_part\_len < 1 || one\_query\_part\_len > 255) { return 0; } break;// case (COAP\_OPTION\_ACCEPT): /\* Length 0-2 \*/// if (one\_query\_part\_len > 2) {// return 0;// }// break; default: break; //impossible scenario currently }
 /\* Check if 4 bits are enough for writing Option value length \*/ if (one\_query\_part\_len <= 12) { /\* 4 bits are enough for Option value length \*/ ret\_value++; } else if (one\_query\_part\_len >= 13 && one\_query\_part\_len < 269) { /\* Extra byte for Option value length is needed \*/ ret\_value += 2; } //This can only happen if we are in default case above, currently is not happening else if (one\_query\_part\_len >= 270 && one\_query\_part\_len < 1034) { /\* Extra bytes for Option value length is needed \*/ ret\_value += 3; }
 /\* \* \* Length of Option value \* \* \*/
 /\* Increase options length \*/ ret\_value += one\_query\_part\_len; }
 /\* Success \*/ return ret\_value;}
/\*\* \* \fn static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets query part count from whole option string \* \* \param query\_len is length of whole Path \* \* \param \*query\_ptr is pointer to the start of whole Path \* \* \return Return value is count of query parts \*/static uint8\_t sn\_coap\_builder\_options\_get\_option\_part\_count(uint16\_t query\_len, const uint8\_t \*query\_ptr, sn\_coap\_option\_numbers\_e option){ uint8\_t returned\_query\_count = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters (not first and last char) \*/ for (query\_len\_index = 1; query\_len\_index < query\_len - 1; query\_len\_index++) { /\* If new query part starts \*/ if (\*(query\_ptr + query\_len\_index) == char\_to\_search) { /\* If match \*/ returned\_query\_count++; } }
 returned\_query\_count++;
 return returned\_query\_count;}
/\*\* \* \fn static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option) \* \* \brief Gets one's query part length from whole query string \* \* \param query\_len is length of whole string \* \* \param \*query\_ptr is pointer to the start of whole string \* \* \param query\_index is query part index to be found \* \* \param sn\_coap\_option\_numbers\_e option is option number of the option \* \* \return Return value is length of query part \*/static uint16\_t sn\_coap\_builder\_options\_get\_option\_part\_length\_from\_whole\_option\_string(uint16\_t query\_len, const uint8\_t \*query\_ptr, uint8\_t query\_index, sn\_coap\_option\_numbers\_e option){ uint16\_t returned\_query\_part\_len = 0; uint8\_t temp\_query\_index = 0; uint16\_t query\_len\_index = 0; uint8\_t char\_to\_search = '&';
 if (option == COAP\_OPTION\_URI\_PATH || option == COAP\_OPTION\_LOCATION\_PATH) { char\_to\_search = '/'; }
 /\* Loop whole query and search '\0' characters \*/ for (query\_len\_index = 0; query\_len\_index < query\_len; query\_len\_index++) { /\* Store character to temp\_char for helping debugging \*/ uint8\_t temp\_char = \*query\_ptr;
 /\* If new query part starts \*/ if (temp\_char == char\_to\_search && returned\_query\_part\_len > 0) { /\* returned\_query\_part\_len > 0 is for querys which start with "\0" \*/ /\* If query part index is wanted \*/ if (temp\_query\_index == query\_index) { /\* Return length of query part \*/ return returned\_query\_part\_len; } else { /\* Reset length of query part because wanted query part finding continues\*/ returned\_query\_part\_len = 0; }
 /\* Next query part is looped \*/ temp\_query\_index++;[View remainder of file in raw view](https://github.com/ARMmbed/mbed-os/raw/d0686fd30b4d3d02efdc7e4d0fbf0dfe173543b6/features/frameworks/mbed-coap/source/sn_coap_builder.c)

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


