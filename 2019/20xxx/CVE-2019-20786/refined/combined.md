=== Content from www.usenix.org_e79ffd8c_20250121_003931.html ===
Analysis of DTLS Implementations
Using Protocol State Fuzzing

Paul Fiter˘au-Bro¸stean
Uppsala University

Bengt Jonsson
Uppsala University

Robert Merget
Ruhr University Bochum

Joeri de Ruiter
SIDN Labs

Konstantinos Sagonas
Uppsala University

Juraj Somorovsky
Paderborn University

Abstract

Recent years have witnessed an increasing number of proto-
cols relying on UDP. Compared to TCP, UDP offers perfor-
mance advantages such as simplicity and lower latency. This
has motivated its adoption in Voice over IP, tunneling techno-
logies, IoT, and novel Web protocols. To protect sensitive data
exchange in these scenarios, the DTLS protocol has been de-
veloped as a cryptographic variation of TLS. DTLS’s main
challenge is to support the stateless and unreliable transport of
UDP. This has forced protocol designers to make choices that
affect the complexity of DTLS, and to incorporate features
that need not be addressed in the numerous TLS analyses.

We present the ﬁrst comprehensive analysis of DTLS im-
plementations using protocol state fuzzing. To that end, we ex-
tend TLS-Attacker, an open source framework for analyzing
TLS implementations, with support for DTLS tailored to the
stateless and unreliable nature of the underlying UDP layer.
We build a framework for applying protocol state fuzzing on
DTLS servers, and use it to learn state machine models for
thirteen DTLS implementations. Analysis of the learned state
models reveals four serious security vulnerabilities, including
a full client authentication bypass in the latest JSSE version,
as well as several functional bugs and non-conformance is-
sues. It also uncovers considerable differences between the
models, conﬁrming the complexity of DTLS state machines.

1 Introduction

UDP is widely used as an unreliable transfer protocol for
Voice over IP, tunneling technologies, and new Web protocols,
and is one of the commonly used protocols in the Internet
of Things (IoT). As UDP does not offer any security by it-
self, Datagram Transport Layer Security (DTLS) [29, 36] was
introduced. DTLS is a variation on TLS, a widely used secu-
rity protocol responsible for securing communication over a
reliable data transfer protocol.

reach 11.6 billion by 2021 [26]. This will constitute half of all
devices connected to the Internet, with the percentage set to
grow in subsequent years. Such trends also increase the need
to ensure that software designed for these devices is properly
scrutinized, particularly with regards to its security.

DTLS is also used as one of the two security protocols in
WebRTC, a framework enabling real-time communication.
WebRTC can be used, for example, to implement video con-
ferencing in browsers without the need for a plugin. It is
supported by all major browsers, including Mozilla Firefox,
Google Chrome, Microsoft Edge, and Apple’s Safari.

Whereas signiﬁcant effort has been invested into ensuring
security of TLS implementations, those based on DTLS have
so far received considerably less scrutiny. Our work ﬁlls this
gap by providing an extensible platform for testing and analy-
zing systems based on DTLS. We describe this framework,
and use it to analyze a number of existing DTLS implementa-
tions, including the most commonly used ones. Our speciﬁc
focus is on ﬁnding logical ﬂaws, which can be exposed by
non-standard or unexpected sequences of messages, using a
technique known as protocol state fuzzing (or simply state fuz-
zing).

As in TLS, each DTLS client and server effectively imple-
ments a state machine which keeps track of how far protocol
operation has progressed: which types of messages have been
exchanged, whether the cryptographic materials have been
agreed upon and/or computed, etc. Each DTLS implementa-
tion must correctly manage such a state machine for a number
of conﬁgurations and key exchange mechanisms. Correspon-
ding implementation ﬂaws, so-called state machine bugs, may
be exploitable, e.g., to bypass authentication steps or establish
insecure connections [5]. To ﬁnd such ﬂaws, state fuzzing
has proven particularly effective not only for TLS [13], but
also for SSH [19], TCP [18], MQTT [40], OpenVPN [12],
QUIC [33], and the 802.11 4-Way Handshake [28], leading
to the discovery of several security vulnerabilities and non-
conformance issues in their implementations.

DTLS is one of the primary protocols for securing IoT
applications [38]. The number of IoT devices is projected to

State fuzzing automatically infers state machine descripti-
ons of protocol implementations using model learning [32,41].

This is an automated black-box technique which sends se-
lected sequences of messages to the implementation, observes
the corresponding outputs, and produces a Mealy machine
that abstractly describes how the implementation responds to
message ﬂows. The Mealy machine can then be analyzed to
spot ﬂaws in the implementation’s control logic or check com-
pliance with its speciﬁcation. State fuzzing works without any
a priori knowledge of the protocol state machine, but relies
on a manually constructed protocol-speciﬁc test harness, a.k.a.
a MAPPER, which translates symbols in the Mealy machine
to protocol packets exchanged with the implementation.

Challenges resulting from the DTLS design. DTLS is
more complex than other security protocols that have so far
been subject to state fuzzing. Most of these [12, 18, 19] run
over TCP, relying on its support for reliable connections. In
contrast, DTLS runs over UDP, which is connectionless. This
implies that DTLS has to implement its own retransmission
mechanism and provide support for message loss, reordering,
and fragmentation. Moreover, an ongoing DTLS interaction
cannot be terminated by simply closing the connection, as is
the case with TLS. As a result, most DTLS implementations
allow interaction to continue even after reception of unex-
pected messages —after all, these messages might have just
arrived out of order— and may subsequently allow a hands-
hake to “restart in the middle” and ﬁnish successfully. Finally,
compared to TLS, DTLS includes an additional message ex-
change used to prevent Denial-of-Service attacks. All this
added complexity makes protocol state fuzzing more difﬁcult
to apply for DTLS than for TLS.

Supporting mapper construction. DTLS’ support for
message loss, reordering, and fragmentation requires additio-
nal packet parameters compared to TLS, such as message se-
quence numbers. DTLS parameters have to be correctly mana-
ged by the MAPPER. This requires special care when deviating
from an expected handshake sequence (a.k.a. a happy ﬂow),
since each particular parameter management strategy may
allow or prohibit a “restarting” handshake to be eventually
completed. In order to facilitate MAPPER construction and
parameter management, we have developed a test framework
for DTLS, which allows easy deﬁnitions of arbitrary protocol
packets and efﬁcient experimentation with parameter manage-
ment strategies. This test framework is realized by extending
TLS-Attacker [39], an existing open source framework for
testing TLS implementations, with support for DTLS. The
framework forms the basis for our MAPPER used for DTLS
state fuzzing. The test framework can also be used in its own
right to support other fuzzing techniques.

Handling the complexity of DTLS state machines. The
above properties of DTLS imply that state machine models
of DTLS implementations are signiﬁcantly more complex
than corresponding state machines for TLS and other proto-
cols. Their complexity is further increased when analyzing
the four main key exchange mechanisms together rather than

separately, and when exploring settings involving client certi-
ﬁcate authentication. Such complexity in the models creates
problems both for the model learning algorithm and for the
interpretation of resulting models. We ameliorate and avoid
some of the complexity in two ways: 1) Our test harness does
not employ reordering and fragmentation, and hence this is
not part of our learned models. 2) We adapt the MAPPER so
as to enable handshakes to “restart”, which has the additional
side-effect of decreasing the size of the learned models, since
successful restarts typically show up as back-transitions to
regular handshake states.
Obtaining models for a wide range of implementations
and conﬁgurations. We have applied our platform to thirteen
implementations of ten distinct vendors (Section 6). Besides
covering a wide spectrum of DTLS implementations, ranging
from mature, general-purpose libraries to implementations
designed for IoT or WebRTC, we mention that some of them
are DTLS libraries without a TLS component, on which state
fuzzing has never been applied before.

For each implementation we examine many, often all, com-
binations of supported key exchange and client certiﬁcate
authentication conﬁgurations. This ensures that state fuzzing
does not miss bugs that are only present in certain conﬁgurati-
ons. In fact, this proved important: several of the Java Secure
Socket Extension (JSSE) bugs reported in Section 7.4 could
only have been discovered with a conﬁguration requiring
client certiﬁcate authentication.
From models to bugs. Once models are obtained we proceed
to analyze them, looking for unexpected or superﬂuous states
and transitions. Some of the main ﬁndings of our analysis are:
(i) A complete client authentication bypass in JSSE, which is
the default TLS/DTLS library of the Java Standard Edition
Platform. The bug allows attackers to authenticate themselves
to a JSSE server by sending special out-of-order DTLS mes-
sages without ever proving to the server that they know the
private key for the certiﬁcate they transmit. The bug is especi-
ally devastating, since it also affects JSSE’s TLS library. This
greatly increases its impact, as JSSE’s TLS library is often
used to authenticate users with smart cards at web sites or
web services. (ii) A state machine bug in the Scandium frame-
work allowed us to ﬁnish a DTLS handshake without sending
a ChangeCipherSpec message. This resulted in the server
accepting plaintext messages even if indicated otherwise by
the negotiated cryptographic mechanisms. Note that this bug
is similar to the EarlyFinished bug found in the TLS JSSE
implementation [13]. (iii) A similar bug was also present in
PionDTLS, a Go implementation for WebRTC. Investigation
of this bug led to discovery of a graver issue whereby the
PionDTLS server freely processes unencrypted application
data once a handshake has been completed. (iv) Finally, three
conﬁrmed functional bugs in TinyDTLS, a lightweight DTLS
implementation for IoT devices.
Contributions. In summary, this work:

• Extends TLS-Attacker with DTLS functionality and

uses it to implement a protocol state fuzzing platform
for DTLS servers.

• Provides Mealy machine models for thirteen DTLS ser-
ver implementations, including the most commonly used
ones, with models exploring most key exchange algo-
rithms and client certiﬁcate authentication settings.

• Analyzes the learned models and reports several non-
conformance bugs and a number of security vulnerabili-
ties in DTLS implementations. Some of these vulnerabi-
lities affect also the TLS part of these libraries.

Responsible disclosure. We have reported all issues to the
respective projects complying with their security procedures.
The reported security issues were all conﬁrmed by the respon-
sible developers, who implemented proper countermeasures.
We provide more details in Section 7.
Outline. We start by brieﬂy reviewing DTLS, model learning,
and the TLS-Attacker framework in Sections 2 to 4. Subse-
quently, we present the learning setup we employ (Section 5),
the DTLS server implementations we tested and the effort
spent on learning state machines for them (Section 6), follo-
wed by a detailed analysis of the issues that were found in the
various DTLS implementations (Section 7). Therein, we pre-
sent state machines for three of these implementations, whilst
making the rest available online. Section 8 reviews related
work, and Section 9 ends this paper with some conclusions
and directions for further work.

2 Datagram Transport Layer Security

DTLS is an adaptation of TLS [15] for datagram transport
layer protocols. It is currently available in two versions:
DTLS 1.0 [35], based on TLS 1.1 [14], and DTLS 1.2, based
on TLS 1.2 [15]. Version 1.3 is currently under development.
This work focuses on TLS/DTLS version 1.2.

At a high level, both TLS and DTLS consist of two major
building blocks: (1) The Handshake is responsible for nego-
tiating session keys and cryptographic algorithms, and key
agreement is either based on public key cryptography (the
standard case), or on pre-shared keys. The set of algorithms
to be used is speciﬁed in a cipher suite. (2) The Record Layer
splits the received cleartext data stream into DTLS Records.
Handshake messages are also sent as records (typically unen-
crypted), and after the ChangeCipherSpec message is sent
in the handshake, the content of all subsequent records is en-
crypted using the negotiated session keys—where different
keys are used for the two communication directions.

The stateless and inherently unreliable datagram transport
layer has prompted the designers of DTLS to introduce several
changes to the original TLS protocol. Below, we describe
the handshake protocol and Record Layer, and discuss the
changes introduced which are relevant to our paper. However,
we remark that more differences exist [29, 36].

Figure 1: DTLS handshake. Encrypted messages are inside
braces. Optional messages are inside square brackets. Messa-
ges speciﬁc to DTLS are in blue.

Handshake protocol. Figure 1 illustrates the DTLS hands-
hake. The client initiates communication by sending Client-
Hello, which includes the highest supported DTLS version
number, a random nonce, the cipher suites supported by the
client, and optional extensions. In DTLS, the server responds
with a HelloVerifyRequest message, which contains a stateless
cookie. This message prompts the client to resend the Client-
Hello message, which then includes the stateless cookie, and
attempts to prevent Denial-of-Service attacks [36].

The server responds with the following messages: Server-
Hello contains the server’s DTLS version, the cipher suite
chosen by the server, a second random nonce, and optional
extensions. Certiﬁcate carries the server’s certiﬁcate, which
contains the server’s public key. In ServerKeyExchange the
server sends an ephemeral public key which is signed with
the private key for the server’s certiﬁcate. This signature also
covers both nonces. CertiﬁcateRequest asks the client to au-
thenticate to the server. This message is optional, and only
used when the server is conﬁgured to authenticate clients via
certiﬁcates. ServerHelloDone marks that no other messages
are forthcoming.

The client responds with a list of messages: Certiﬁ-
cate, ClientKeyExchange, CertiﬁcateVerify, ChangeCipher-
Spec, and Finished. The Certiﬁcate and CertiﬁcateVerify mes-
sages are optional and only transmitted when the server reque-
sts client authentication. They contain, respectively, a client
certiﬁcate and a signature computed over all previous messa-
ges with the client’s long term private key. The client sends its
public key share in the ClientKeyExchange message. Both par-
ties then use the exchanged information to derive symmetric

ClientServerflight1ClientHelloflight2HelloVerifyRequestflight3ClientHelloflight4ServerHello[Certificate][ServerKeyExchange][CertificateRequest]ServerHelloDoneflight5[Certificate]ClientKeyExchange[CertificateVerify]ChangeCipherSpec{Finished}flight6ChangeCipherSpec{Finished}flight7{Application}keys that are used in the rest of the protocol. The client sends
ChangeCipherSpec to indicate that it will use the negotiated
keys from now in the Record Layer. Finally, it sends Finished
encrypted with the new keys, which contains an HMAC over
the previous handshake messages. The server responds with
its own ChangeCipherSpec and Finished messages. There-
after, both client and server can exchange authenticated and
encrypted application data.

Several DTLS handshakes can be performed within one
DTLS connection. Performing a subsequent handshake allows
the client and server to renew the cryptographic key material.
This process is also called renegotiation.

UDP datagrams are often limited to 1500 bytes [36]. Since
handshake messages can become longer than the datagram
size, a fragmentation concept has been introduced in DTLS.
This allows the implementation to split a handshake message
into several fragments and send it over the wire in distinct
records so that every record respects the maximum datagram
size. To support this, new ﬁelds have been introduced in the
handshake messages: message sequence, fragment offset, and
fragment length. Message sequence indicates the position
of the message within the handshake and is also used in a
retransmission mechanism.

Record Layer. All messages in DTLS are wrapped in so-
called records. During the ﬁrst DTLS handshake, the Record
Layer operates in epoch 0. This epoch number is included in
the header of the DTLS record. If cryptographic keys have
been negotiated and activated by sending a ChangeCipher-
Spec, the Record Layer increases the epoch number to 1 which
indicates that the contents of the actual record are encrypted.
Since the handshake may be repeated several times (renegoti-
ation), the epoch number may also be increased further.

While TLS has implicit sequence numbers, DTLS has expli-
cit sequence numbers. This is required since the protocol does
not guarantee message arrival and therefore cannot guarantee
that the implicit counters are synchronized. At the start of
each epoch, sequence numbers are reset to 0, and for each new
record the sequence number is increased. Note that re-sending
a record due to the loss of a UDP packet still increases the
sequence number.

3 Background on Model Learning

Our state fuzzing framework infers a model of a protocol
implementation in the form of a Mealy machine, which des-
cribes how the implementation responds to sequences of
well-formed messages. Mealy machines are ﬁnite state auto-
mata with ﬁnite alphabets of input and output symbols. They
are widely used to model the behavior of protocol entities
(e.g., [10, 25]). Starting from an initial state, they process
one input symbol at a time. Each input symbol triggers the
generation of an output symbol and brings the machine to a
new state.

To infer a Mealy machine model of an implementation,
we use model learning. An analyzed implementation is re-
ferred to as the system under test (SUT). Model learning is
an automated black-box technique which a priori needs to
know only the input and output alphabets of the SUT. The
most well-known model learning algorithm is Angluin’s L∗
algorithm [3], which has been reﬁned into more efﬁcient ver-
sions, such as the TTT algorithm [22] which is the one we use.
These algorithms assume that the SUT exhibits deterministic
behavior, and produce a deterministic Mealy machine.

Model learning algorithms operate in two alternating pha-
ses: hypothesis construction and hypothesis validation. Du-
ring hypothesis construction, selected sequences of input sym-
bols are sent to the SUT, observing which sequences of output
symbols are generated in response. The selection of input
sequences depends on the observed responses to previous
sequences. When certain convergence criteria are satisﬁed,
the learning algorithm constructs a hypothesis, which is a
minimal deterministic Mealy machine that is consistent with
the observations recorded so far. This means that for input
sequences that have been sent to the SUT, the hypothesis pro-
duces the same output as the one observed from the SUT. For
other input sequences, the hypothesis predicts an output by
extrapolating from the recorded observations. To validate that
these predictions agree with the behavior of the SUT, lear-
ning then moves to the validation phase, in which the SUT is
subject to a conformance testing algorithm which aims to va-
lidate that the behavior of the SUT agrees with the hypothesis.
If conformance testing ﬁnds a counterexample, i.e., an input
sequence on which the SUT and the hypothesis disagree, the
hypothesis construction phase is reentered in order to build
a more reﬁned hypothesis which also takes the discovered
counterexample into account. If no counterexample is found,
learning terminates and returns the current hypothesis. This
is not an absolute guarantee that the SUT conforms to the
hypothesis, although many conformance testing algorithms
provide such guarantees under some technical assumptions. If
the cycle of hypothesis construction and validation does not
terminate, this indicates that the behavior of the SUT cannot
be captured by a ﬁnite Mealy machine whose size and com-
plexity is within reach of the employed learning algorithm.

Model learning algorithms work in practice with ﬁnite input
alphabets of modest sizes. In order to learn realistic SUTs, the
learning setup is extended with a so-called MAPPER, which
acts as a test harness that transforms input symbols from
the ﬁnite alphabet known to the learning algorithm to actual
protocol messages sent to the SUT, as illustrated in Fig. 2.
Typically, the input alphabet consists of different types of mes-
sages, often reﬁned to represent interesting variations, e.g.,
concerning the key exchange algorithm. The MAPPER trans-
forms each such message to an SUT message by supplying
message parameters, performing cryptographic operations,
etc. Conversely, the MAPPER translates output from the SUT
into the alphabet of output symbols known to the learning

algorithm. The MAPPER also maintains state that is hidden
from the learning algorithm but needed for supplying mes-
sage parameters; this can include sequence numbers, agreed
encryption keys, etc. The choice of input alphabet and the de-
sign of the MAPPER require domain speciﬁc knowledge about
the tested protocol. Once the mapper has been implemented,
model learning proceeds fully automatically.

4 DTLS Framework Implementation

The Transport Layer Security (TLS) protocol is one of the
most important cryptographic protocols used on the Internet.
Due to its importance and widespread deployment, TLS and
its various attacks [2,4,5,7,13,30,43] have been under scrutiny
by security researchers. As a result, by now, there exist several
frameworks [6, 24, 31, 39] for the evaluation of TLS libraries.
In contrast, DTLS has been largely overlooked in these fra-
meworks or considered out of scope. Instead of starting from
scratch, we have decided to create a framework for testing
DTLS based on the newest version of TLS-Attacker [39].

4.1 TLS-Attacker

TLS-Attacker is an open-source, ﬂexible Java-based TLS ana-
lysis framework that allows its users to create and modify
TLS protocol ﬂows as well as the structure of the included
TLS messages. The user is then able to test and analyze the
behavior of an implementation, and create attacks and tools
with the custom TLS stack of TLS-Attacker as a software
library. TLS-Attacker has been integrated in the build process
of several TLS libraries [8, 27] to increase their test coverage.
TLS-Attacker employs solely the low-level cryptography
provided by Java, and implements the TLS protocol itself. Its
main functionality relies on the concept of workﬂow traces
which allow to deﬁne arbitrary protocol ﬂows. Every TLS
protocol ﬂow can be represented by a sequence of Send and
Receive actions. The developer can construct a workﬂow trace
in Java or in XML. Once TLS-Attacker receives a workﬂow
trace, it attempts to execute the predeﬁned TLS messages, and
records the behavior of the tested TLS peer. A Java example
with an ECDHE-RSA key exchange is shown below:

WorkflowTrace flow = new WorkflowTrace();
trace.addTlsActions(new TlsAction[]{

new SendAction(conn, new ClientHelloMessage()),
new ReceiveAction(conn, new ServerHelloMessage()),
new ReceiveAction(conn, new CertificateMessage()),
new ReceiveAction(conn, new ECDHEServerKeyExchangeMessage()),
new ReceiveAction(conn, new ServerHelloDoneMessage()),
new SendAction(conn, new ECDHClientKeyExchangeMessage()),
new SendAction(conn, new ChangeCipherSpecMessage()),
new SendAction(conn, new Finished()),
new ReceiveAction(conn, new ChangeCipherSpecMessage()),
new ReceiveAction(conn, new Finished())

});

Notice how messages in the above ﬂow are described at a high
level. To execute ﬂows, TLS-Attacker generates valid packets
for messages, and parses messages from packet responses. It

ClientHello

Record(..ClientHello(..))

LEARNER

MAPPER
[TLS-Attacker]

SUT

ServerHello

Record(..ServerHello(..))

Figure 2: DTLS Learning Setup.

does this by maintaining a context, which it updates as new
messages are sent and received. The context encompasses
stateful information relevant to a TLS connection such as
stored random nonces, agreed upon algorithms, and suppor-
ted cipher suites. Using this information, TLS-Attacker can
generate valid or semi-valid messages, encrypt them using
the negotiated cipher suite, and send them to a peer.

All the above properties make TLS-Attacker ideal for gene-
rating valid packets from message names, which in our case
are the symbols of the input alphabet.

4.2 Our DTLS Testing Framework

Our DTLS testing framework extends TLS-Attacker with sup-
port for DTLS 1.0 and DTLS 1.2. This extension allows TLS-
Attacker to generate, send and receive DTLS packets and,
more broadly, to execute valid and invalid DTLS ﬂows. Our
implementation involved several changes, among which we
mention: i) added support for DTLS handshake message frag-
mentation; ii) a new ﬁeld to the ClientHello message for
storing a server cookie; iii) new ﬁelds to the TLS context, one
for storing the cookie received, others for keeping track of
the record epoch and message sequence number (how these
ﬁelds are updated is explained in Section 5.2); and iv) new
options for retransmission and fragmentation handling.

5 Learning Setup

The learning setup1 comprises three components:
the
LEARNER, the MAPPER and the SUT; cf. Fig. 2. The SUT is a
DTLS server implementation, though our setup can be easily
adapted to support clients. The LEARNER generates inputs
from a ﬁnite alphabet of input symbols. The MAPPER trans-
forms these inputs into full DTLS records and sends them over
a datagram connection to the SUT. The MAPPER then captu-
res the SUT’s reply, translates it to symbols in the alphabet
of output symbols, and delivers them back to the LEARNER.
The LEARNER ﬁnally uses the information obtained from the
exchanged sequences of input and output symbols to generate
a Mealy machine, as described in Section 3.

5.1 Learner

The LEARNER is implemented using LearnLib [23], a Java
library implementing algorithms for learning automata and
Mealy machines. The library also provides state-of-the art

1Available at https://github.com/assist-project/dtls-fuzzer/

Table 1: Symbols used in learning and their shorthands. We
list only the output symbols which are mentioned in the paper.

Symbol

Shorthand

ClientHello(T)

CH(T)
T ∈ {DH, ECDH, RSA, PSK}

CertiﬁcateRequest
ClientKeyExchange(T)

CertReq
CKE(T)

t
e
b
a
h
p
l
a

t
u
p
n
i

t
e
b
a
h
p
l
a

t
u
p
t
u
o

T ∈ {RSA, ECDSA}

CertiﬁcateVerify
EmptyCertiﬁcate
Certiﬁcate(T)

T ∈ {DH, ECDH, RSA, PSK}
CertVer
Cert(empty)
Cert(t)
t ∈ {RSA, EC}
CCS
ChangeCipherSpec
App
Application
Alert(CloseNotify)
A(CN)
Alert(UnexpectedMessage) A(UM)
A(BC)
Alert(BadCertiﬁcate)
A(DE)
Alert(DecodeError)
A(DYE)
Alert(DecryptError)
A(IE)
Alert(InternalError)
HVR
HelloVerifyRequest
SH
ServerHello
SHD
ServerHelloDone
SKE(T)
ServerKeyExchange(T)

T ∈ {DH, ECDH, PSK}

Finished
NoResp
Disabled
Unknown Message

F
-
Disabled
UM

conformance testing algorithms, which are used by the lear-
ning algorithm for hypothesis validation. The learning algo-
rithm chosen is TTT [22], a state-of-the-art algorithm that
requires fewer test inputs compared to other algorithms [21].
For conformance testing, we use Wp [11] and a variation of
it, Wp-Random [20].

Table 1 displays the alphabets of input and output symbols,
as well as the shorthands that we use to make their represen-
tation more compact. The input alphabet includes in abstract
form all client messages introduced in Section 2. Additionally,
it includes Application for sending a simple application mes-
sage, and two common alert messages, Alert(CloseNotify) and
Alert(UnexpectedMessage). (Interpretations for the alerts can
be found in the TLS 1.2 speciﬁcation [15, p. 31].) Finally, Cer-
tiﬁcate, EmptyCertiﬁcate, and CertiﬁcateVerify are included
for sending certiﬁcate-related messages. Certiﬁcate contains
a single valid certiﬁcate, and is parameterized by the public
key signing algorithm. EmptyCertiﬁcate denotes sending a
certiﬁcate message with an empty list of certiﬁcates.

The output alphabet includes abstractions for each diffe-
rent message the SUT responds with, similarly to the input
alphabet. It also includes three special outputs: NoResp, when
the SUT does not respond; Disabled, when the SUT process
is no longer running; and Unknown, when the SUT responds

with a message which cannot be decrypted by the MAPPER.
This happens, for example, if the MAPPER has replaced the
keys necessary to decrypt the output by a new set of keys.

5.2 Mapper

The MAPPER uses our DTLS testing framework to translate
between LEARNER inputs/outputs and actual DTLS messages.
Behaviorally, the MAPPER operates like a DTLS client, with
control ﬂow deferred to the LEARNER. In order to reduce the
learning effort, we do not subject the SUT to message reor-
dering or fragmentation. Hence, the MAPPER is conﬁgured to
send each handshake message in one single DTLS fragment.
To correctly supply and check DTLS-speciﬁc ﬁelds in mes-
sages, the MAPPER maintains the state of the interaction in
a context, which it uses to generate and parse messages. Our
DTLS testing framework already maintains such a context for
executing protocol ﬂows. Hence, we let our MAPPER use this
context, with a few adaptations to support efﬁcient learning.
Key components of this context are cookie, cipherState and
digest, as well as nextSendMsgSeq and nextRecvMsgSeq, for
the next message sequence number to be sent and received,
respectively. Each message sent is equipped with the value of
nextMsgSeqSent, which is then incremented. nextRecvMsgSeq
is assigned the sequence number of each message received,
provided it is the next expected one. The MAPPER also main-
tains analogous state variables for record sequence numbers,
as well as numbers of epochs that are incremented whenever
a ChangeCipherSpec is sent. These variables are also used
to assemble fragments into messages and detect retransmissi-
ons. Retransmissions here refer to messages whose message
sequence number or epoch are smaller than those expected.

The variable cookie, initially set to empty, retains the va-
lue of the cookie ﬁeld in the most recent HelloVerifyRequest
message received from the server, and is used when sending
subsequent ClientHello messages. The variable cipherState
stores the next symmetric keys to be used for decrypting/en-
crypting messages. To be put in use, a cipherState ﬁrst has
to be deployed. The cipherState deployed initially is set to
null (no encryption/decryption). On each ClientKeyExchange
sent, cipherState is updated using information from an ear-
lier ClientHello-ServerHello exchange. On each ChangeCip-
herSpec sent, cipherState is deployed. This implies that the
MAPPER will only start encrypting/decrypting once Client-
Hello and ServerHello are exchanged, and a ClientKeyEx-
change and a ChangeCipherSpec have been issued. Prior to
these actions, messages are sent in plaintext.

The variable digest stores a buffer of all handshake messa-
ges sent so far, i.e., each handshake message that is sent or
received is also appended to digest. A hash over this variable
is included in every Finished message sent, to be veriﬁed by
the server. The variable digest is cleared after each Finished,
and also before sending ClientHello. This strategy for reset-
ting digest enables handshakes to “restart in the middle”, by

ensuring that hashes are computed over exactly the messages
in the most recent current handshake. After experimenting
with different strategies for resetting digest, we found that
this strategy allows handshakes that restart to complete, whe-
reas other strategies do not. It also produces smaller learned
models, since successful restarts typically show up as back-
transitions to regular handshake states. As an example, for
TinyDTLS using a PSK conﬁguration, the number of states
in the learned model was reduced from 36 if digest was not
reset, to 22 if it was.

5.3 Making the SUT Behavior Deterministic

As mentioned in Section 3, the learning algorithm employed
works under the assumption that the SUT exhibits determinis-
tic behavior, i.e., the output generated depends uniquely on the
supplied input sequence. During learning experiments, howe-
ver, timing effects occasionally manifest as non-determinism
to the time-agnostic LEARNER. Below, we describe our stra-
tegies to remedy this problem.

One cause for timing-induced non-determinism is the
LEARNER sending the ﬁrst input too early, before the SUT has
fully started, or the MAPPER determining prematurely that the
SUT does not respond. We address this by tailoring, for each
SUT, the start and response timeouts. These are, respectively,
the delay before the ﬁrst input is sent (allowing the SUT to
initialize), and the time the MAPPER waits for each response
before concluding a timeout. In order to reduce learning time,
we adjust the response timeout for certain messages, parti-
cularly ClientHello and Finished, to which the SUT could
take longer to respond. Finally, in order to optimize the start
timeout for the slower JSSE and Scandium implementations,
we wrap around the SUT a program which preloads key ma-
terial, among other things. This key material is then reused
rather than reloaded for each new sequence of inputs. Once
the server is ready to receive packets, the wrapper program no-
tiﬁes the LEARNER of the port number at which the server is
listening. The LEARNER can then immediately start sending
inputs, rather than having to wait for a predeﬁned period.

Another cause for non-determinism is timeout-triggered
retransmissions by the SUT. To address this, we set the re-
transmission timeout of the SUT to a high value. For some
SUTs, this is a conﬁgurable parameter; for others we had to
alter the source code. Corresponding patches are provided on
the learning setup’s website for reproducibility.

Even with the above strategies, an SUT would sometimes
produce alternative outputs due to spurious timing effects.
In order to detect such cases, we store SUT’s responses to
queries in a cache during the hypothesis construction phase,
and conﬁrm each counterexample produced by hypothesis va-
lidation before delivering it to the LEARNER. When detecting
a case of differing responses to the same input, we rerun the
sequence until at least 80% of the responses are the same; this
always happened within a small number of retrials.

6 Experimental Setup and Experiments

An experiment conﬁguration comprises the implementation,
the key exchange algorithms and client authentication setting
based on which we form the input alphabet, and whether
messages with retransmissions were discarded.

6.1

Implementations Tested and Analyzed

In total, we analyzed thirteen different implementations. This
includes well-known TLS implementations like OpenSSL,
GnuTLS, MbedTLS, JSSE, WolfSSL, and NSS, which also
support DTLS. For JSSE we analyzed the Sun JSSE provi-
der of Java 9 and 12. Furthermore, we analyzed PionDTLS,
a Go implementation of DTLS 1.2 for WebRTC. The re-
maining implementations are IoT-speciﬁc and support only
DTLS. Scandium is the DTLS implementation which is part
of Eclipse’s Java CoAP implementation. The two TinyDTLS
variants are lightweight implementations speciﬁcally desig-
ned for IoT devices. TinyDTLS for Contiki-NG branched
out from that in Eclipse’s IoT suite, and has been develo-
ped independently ever since. We refer to Eclipse’s variant
as TinyDTLSE , and to Contiki-NG’s as TinyDTLSC. When
referring to both, we simply use TinyDTLS. For GnuTLS
and Scandium, we analyzed two versions; the later version
contains bug ﬁxes uncovered in the earlier one. As with
TinyDTLS, we omit versions when referring to both.

To avoid having to write our own DTLS servers, we use uti-
lities to conﬁgure and launch DTLS servers that are provided
by the developers where possible. For example, for OpenSSL,
we use the openssl s_server utility, for GnuTLS we use
gnutls-serv, etc. There are three exceptions (PionDTLS,
Scandium, and JSSE) for which we wrote our own DTLS ap-
plications2 as either there were no standard utilities available
or the available ones did not provide the desired functiona-
lity. For every implementation, Table 2 displays the name,
version, utility, supported key exchange algorithms and client
certiﬁcate authentication conﬁgurations, and a URL. We use
commit identiﬁers as versions for both TinyDTLS variants,
PionDTLS, and Scandium. The two commits for Scandium
belong to the development version 2.0.0 and shall, more sug-
gestively be referred to as Scandiumold and Scandiumnew.
Note that client certiﬁcate authentication is relevant for DH,
ECDH and RSA, but not for PSK whose handshake does not
incorporate certiﬁcate messages [17, p. 4].

The input alphabet, described in Table 1, includes inputs
necessary to perform handshakes using every key exchange
algorithm supported, two alerts, and one application message.
Whenever certiﬁcates can be part of the key exchange algo-
rithm, they are also included in the alphabet. The SUT is
conﬁgured to use client certiﬁcates whenever these are sup-
ported. Therein we explore three conﬁgurations: (i) required:

2These implementations are accessible via the learning setup’s website.

Table 2: DTLS implementations tested. ”-” means a custom program was provided. Client certiﬁcate authentication can be
disabled (NONE), required (REQ) and optional (OPT). Grayed out or slanted are conﬁgurations supported by the library but
not made available by the utility. For slanted conﬁgurations this support was added, which enabled testing them. Braces gather
conﬁgurations explored via single learning experiments.

Name

Version Utility

Algorithms

Client Cert Auth URL

GnuTLS

JSSE

MbedTLS
NSS
OpenSSL
PionDTLS
Scandiumold
Scandiumnew
TinyDTLSC
TinyDTLSE
WolfSSL

3.5.19
3.6.7
9.0.4
12.0.2
2.16.1
3.46
1.1.1b
e4481fc
c7895c6
6979a09
53a0d97
8414f8a
4.0.0

gnutls-serv

-

ssl-server2

tstclnt
openssl s_server
-

-

dtls-server

dtls-server

server

(cid:124)

(cid:123)(cid:122)

,ECDH
(cid:124) (cid:123)(cid:122) (cid:125)

DH,ECDH,RSA,PSK
(cid:125)
DH,ECDH,RSA,PSK
(cid:124)
(cid:125)
(cid:123)(cid:122)
DH,ECDH,RSA
(cid:124)(cid:123)(cid:122)(cid:125)
,RSA
(cid:124)(cid:123)(cid:122)(cid:125)

DH
(cid:124)(cid:123)(cid:122)(cid:125)
DH,ECDH,RSA,PSK
(cid:124)
(cid:125)
(cid:123)(cid:122)
DH,ECDH,RSA
(cid:124)
(cid:125)
(cid:123)(cid:122)
DH,ECDH,RSA,PSK
(cid:123)(cid:122)
(cid:124)
(cid:125)
,PSK
ECDH
(cid:124)(cid:123)(cid:122)(cid:125)
(cid:124) (cid:123)(cid:122) (cid:125)
,PSK
ECDH
(cid:124)(cid:123)(cid:122)(cid:125)
(cid:124) (cid:123)(cid:122) (cid:125)
,PSK
ECDH
(cid:124)(cid:123)(cid:122)(cid:125)
(cid:124) (cid:123)(cid:122) (cid:125)
,PSK
ECDH
(cid:124)(cid:123)(cid:122)(cid:125)
(cid:124) (cid:123)(cid:122) (cid:125)
,PSK
ECDH
(cid:124) (cid:123)(cid:122) (cid:125)
(cid:124)(cid:123)(cid:122)(cid:125)
,PSK
DH,ECDH,RSA
(cid:124)(cid:123)(cid:122)(cid:125)
(cid:125)
(cid:123)(cid:122)
(cid:124)

NONE,REQ,OPT
(cid:124)(cid:123)(cid:122)(cid:125)
,OPT
(cid:124)(cid:123)(cid:122)(cid:125)
,OPT

,REQ
NONE
(cid:124) (cid:123)(cid:122) (cid:125)
(cid:124) (cid:123)(cid:122) (cid:125)
NONE,REQ
(cid:124) (cid:123)(cid:122) (cid:125)
,OPT
,REQ
(cid:124)(cid:123)(cid:122)(cid:125)
(cid:124) (cid:123)(cid:122) (cid:125)
,OPT
,REQ
(cid:124)(cid:123)(cid:122)(cid:125)
(cid:124) (cid:123)(cid:122) (cid:125)
,REQ,OPT

NONE
(cid:124) (cid:123)(cid:122) (cid:125)
NONE
(cid:124) (cid:123)(cid:122) (cid:125)
NONE
(cid:124) (cid:123)(cid:122) (cid:125)
NONE
(cid:124) (cid:123)(cid:122) (cid:125)
NONE
(cid:124) (cid:123)(cid:122) (cid:125)
NONE
(cid:124) (cid:123)(cid:122) (cid:125)
NONE
(cid:124) (cid:123)(cid:122) (cid:125)
NONE
(cid:124) (cid:123)(cid:122) (cid:125)
NONE
(cid:124) (cid:123)(cid:122) (cid:125)
NONE
(cid:124) (cid:123)(cid:122) (cid:125)

,OPT
(cid:124)(cid:123)(cid:122)(cid:125)
,OPT
(cid:124)(cid:123)(cid:122)(cid:125)
,OPT
(cid:124)(cid:123)(cid:122)(cid:125)
,OPT
(cid:124)(cid:123)(cid:122)(cid:125)

,OPT

,REQ
(cid:124) (cid:123)(cid:122) (cid:125)
,REQ
(cid:124) (cid:123)(cid:122) (cid:125)
,REQ
(cid:124) (cid:123)(cid:122) (cid:125)
,REQ
(cid:124) (cid:123)(cid:122) (cid:125)
,REQ
(cid:124) (cid:123)(cid:122) (cid:125)
,REQ
(cid:124) (cid:123)(cid:122) (cid:125)
,REQ
(cid:124) (cid:123)(cid:122) (cid:125)

https://www.gnutls.org

https://www.oracle.com/java/

https://tls.mbed.org

https://nss-crypto.org

https://www.openssl.org

https://github.com/pion/dtls

https://www.eclipse.org/californium/

https://github.com/contiki-ng/tinydtls

https://github.com/eclipse/tinydtls

https://www.wolfssl.com

a valid certiﬁcate is requested (via CertiﬁcateRequest mes-
sage) and required to complete a handshake; (ii) optional:
a valid certiﬁcate is requested but not required; and (iii) di-
sabled: a valid certiﬁcate is neither requested nor required.
These conﬁgurations are further detailed in Section 7.1.

In some experiments, we had to remove inputs from the
input alphabet and/or limit the set of explored conﬁgurations.
For PionDTLS, NSS and WolfSSL, the reason was that the
server program or library does not support certain combinati-
ons of key exchange algorithms and certiﬁcate conﬁgurations.
Similarly, PionDTLS’s library does not allow PSK and ECDH
cipher suites to be used together, NSS’s utility does not sup-
port certiﬁcate authentication, whilst WolfSSL’s utility could
not be conﬁgured to simultaneously support all key exchange
algorithms. In cases where learned models were large (for
TinyDTLS, Scandium, and JSSE) or when response time was
slow (for Scandium and JSSE), we generated models sepa-
rately for each key exchange algorithm, in order to keep the
learning time reasonable.

6.2 Learning Effort

In our experiments, model learning converged on all analy-
zed implementations, except for JSSE (all conﬁgurations),
WolfSSL with disabled client authentication, and Scandium
using ECDH alphabets. For these conﬁgurations, the last
hypothesis models produced by learning are not complete,
but still very informative as bases for analysis.

Statistics from the learning experiments for which model
learning converged are shown in Table 3. These include the
number of states, number of tests, and learning time. Our
analysis focuses on these three quantities.
Number of states. First, note that the number of states in all

models is a two-digit number. This means that the models
we learn for these DTLS implementations are non-trivial. In
particular, we remark that the number of states is considerably
larger than those reported for TLS implementations, with our
DTLS models averaging 25 states while the TLS models are
averaging 9 states [13]. This conﬁrms our expectations about
the increased complexity of DTLS, and the complexity that
learning with several cipher suites adds to most models.

Second, the number of states is, unsurprisingly, affected by
the alphabet conﬁguration. PSK conﬁgurations generally lead
to smaller models than ECDH ones. (This is expected, since
the handshake sequence is longer unless client certiﬁcate au-
thentication is disabled.) However, combining multiple cipher
suites in one alphabet does not necessarily result in much
larger models. For example, OpenSSL or MbedTLS generate
relatively small models (19 and 17 states respectively, when
authentication is required) even with four cipher suites. This
can be explained by the fact that in mature implementations
handshakes for different key exchange algorithms/authenti-
cation conﬁgurations tend to share states. (For example, in
Fig. 3 note how all handshakes ﬁnish in states 5 and 6.)

Third, as we will soon see, there appears to be a strong cor-
relation between the number of states and bugs. The most con-
sequential bugs were found in implementations generating the
largest models (JSSE, PionDTLS, Scandiumold, TinyDTLS).
Hence, reducing state machine size is a viable strategy for
improving software correctness.
Number of tests. The number of tests was between 21 000
and 50 000 for most implementations, with only PionDTLS
and GnuTLS 3.6.7 requiring considerably more. Implemen-
tations which resulted in the largest models also required
the most tests. PionDTLS leads in terms of model size (66
states) and number of tests (113 508). The one exception to

Table 3: Results of learning experiments. The “Timeout“ column refers to the response timeout, to which ∗ is appended in case
the timeout was adjusted based on the input. The “Alphabet Used” column describes the type of cipher suites used, if certiﬁcate
inputs were included (CERT), if authentication was disabled (NONE), optional (OPT) or required (REQ), and if retransmissions
were discarded (DISC).

Alphabet Used

States of
Final Model

Hypotheses

Tests

Tests to last
Hypothesis

Time
(mins)

Implementation
and Version

Timeout
(msecs)

GnuTLS 3.5.19

GnuTLS 3.6.7

200

50∗

MbedTLS 2.16.1

50

PSK+RSA_CERT_OPT

DH+ECDH+PSK+RSA_CERT_NONE

DH+ECDH+PSK+RSA_CERT_OPT

DH+ECDH+PSK+RSA_CERT_REQ

DH+ECDH+PSK+RSA_CERT_NONE

DH+ECDH+PSK+RSA_CERT_OPT

DH+ECDH+PSK+RSA_CERT_REQ

NSS 3.46

100

DH+ECDH+RSA_DISC

OpenSSL 1.1.1b

10

DH+ECDH+PSK+RSA_CERT_NONE

DH+ECDH+PSK+RSA_CERT_OPT

DH+ECDH+PSK+RSA_CERT_REQ

PionDTLS

100

Scandiumold

100∗

Scandiumnew

100∗

TinyDTLSC

TinyDTLSE

WolfSSL 4.0.0

100

100

80∗

ECDH_CERT_NONE

ECDH_CERT_OPT

ECDH_CERT_REQ

PSK

ECDH_CERT_NONE_DISC

ECDH_CERT_OPT_DISC

ECDH_CERT_REQ_DISC

PSK

ECDH_CERT_NONE

ECDH_CERT_OPT

ECDH_CERT_REQ

PSK

ECDH_CERT_NONE

ECDH_CERT_REQ

PSK

ECDH_CERT_NONE

ECDH_CERT_REQ

PSK

DH+ECDH+RSA_CERT_REQ

PSK

29

11
19
16

12
20
17

10

14
22
19

66
66
66
14

30
45
31
16

13
17
15
13

25
30
25

22
27
22

24
10

18

6
14
11

2
6
5

5

7
14
10

37
37
33
7

13
21
13
9

7
11
8
7

13
23
15

12
14
11

16
5

46276

36279
84896
87809

27811
34236
32389

21040

36258
49467
41638

70886
113508
94384
21303

36927
45087
35404
22646

25548
27352
27233
22983

30696
35747
27148

56697
29897
24403

45402
21611

5921

2423
39513
43435

531
3108
2755

465

4119
9003
4359

25920
68792
50767
1859

7144
7006
3519
883

2394
2033
2804
1352

2292
5111
2713

3209
1746
2728

8392
584

3577

1141
2873
2722

545
677
658

445

303
404
338

1842
3067
2523
503

2518
2833
2243
1656

1607
1693
1718
1621

1162
1367
1065

1872
981
707

1851
656

the rule is GnuTLS 3.6.7, which competes with PionDTLS
for the highest number of tests, yet has relatively few states.
We found that conformance testing using Wp-based methods
generally struggled with this implementation. A central acti-
vity of Wp-based methods is to ﬁnd sequences of inputs that
uniquely identify the different states in the Mealy machine.
GnuTLS is designed to provide minimally informative output
to inputs that deviate from the happy ﬂow: in most cases, the
implementation simply discards such inputs and stays silent
(this can be seen in e.g., Fig. 3). As a consequence, the input
sequence which uniquely identiﬁes a state can be very hard

to ﬁnd, and can even be too long to be discovered during
learning or conformance testing.

Learning time. Model learning experiments completed
within one day on average, except for four implementations.
Among these, PionDTLS and Scandium take considerably lon-
ger due to large models (66 states for PionDTLS). Scandium
and GnuTLS take longer due to high response timeout values,
motivated by very long processing times for messages such as
ClientHello (400 and 200 msecs respectively). This highlights
the importance of message-speciﬁc timeouts, as suggested in
Section 5.3.

Figure 3: Model of a GnuTLS 3.6.7 server with client certiﬁcate authentication optional. Blue edges capture the ﬂows of regular
handshakes: dashed and dashed-dotted edges indicate the handshake expected when client certiﬁcate authentication is required,
respectively when it is disabled. A dotted brown edge indicates a transition leading to a handshake restart.

7 Analysis of the Resulting State Machines

This section provides an analysis of the models against the
speciﬁcation. We ﬁrst give an overview of a DTLS state ma-
chine, using the model learned for GnuTLS as an example.
We explain the strategies employed to identify non-compliant
behaviors using the learned models. We then outline the non-
compliant behaviors observed in the tested libraries. Finally,
we present library-speciﬁc ﬁndings and vulnerabilities, inclu-
ding the client authentication bypass in JSSE.

7.1 Description of a GnuTLS State Machine

Displaying models is challenging due to the large number of
inputs and states. We therefore prune the models via the fol-
lowing strategies. We ﬁrst use the Other input as replacement
for inputs not captured in a visible transition which lead to the
same state and output. Inputs and outputs are then replaced by
their corresponding shorthands shown in Table 1. Finally, we
place transitions connecting the same states on single edges.
Due to page limitations, this section only includes models for

GnuTLS 3.6.7, JSSE 12.0.2 and PionDTLS. All other models
can be accessed via the learning setup’s website.

Figure 3 shows a model generated for the GnuTLS 3.6.7 li-
brary and can be interpreted as follows. The server starts from
the initial state, which is always state 0 on the state machine.
On receiving ClientHello(PSK) it generates HelloVerify-
Request and transitions to state 2. In response to a second
ClientHello(PSK), it generates the messages ServerHello and
ServerHelloDone and transitions to state 3. Continuing the
PSK handshake ﬂow, on receiving ClientKeyExchange(PSK),
ChangeCipherSpec and Finished, the server generates No-
Resp (i.e., nothing) for the ﬁrst two messages, and Change-
CipherSpec and Finished for the third. In this interaction, the
server traverses the states 4 and 5, ending in 6.

The GnuTLS server was conﬁgured to use PSK- and RSA-
based cipher suites. This is reﬂected in the model’s input
alphabet, which includes ClientHello and ClientKeyExchange
for both PSK and RSA. Client certiﬁcate authentication was
set to optional. In this situation, the server makes a client cer-
tiﬁcate request, as indicated by the CertReq label on the edge
from state 2 to state 7 in Fig. 3. The server does not require

client certiﬁcates, hence handshakes can be completed even
if the client chooses to send an EmptyCertiﬁcate by following
states 0, 2, 7, 11, 4, 5 and 6; or no certiﬁcate at all by following
states 0, 2, 7, 4, 5 and 6. Finally, if the client authenticates
with a Certiﬁcate message, the handshake traverses states 0, 2,
7, 9, 10, 4, 5 and 6. Note that client certiﬁcate authentication
is implicitly disabled for cipher suites which do not support
it, such as PSK-based ones.

Besides states traversed by handshake ﬂows, the model
contains three other states: states 1, 8 and 12. State 1 is a
sink state, which is a state the model cannot transition out of.
States 8 and 12 are superﬂuous states, since they are not ne-
cessary for implementation correctness. They are a byproduct
of the implementation allowing handshake restarts, which are
possible from these states by transitions to state 2.

7.2

Identifying Irregular Behaviors

To identify potentially vulnerable behaviors using learned
models, we employ the following strategies.

First, we inspect models for irregular handshake ﬂows (ir-
regular handshakes for short). These are ﬂows that lead to
handshake completion, indicated by a successfully transmit-
ted Finished from the server, but may omit, repeat or change
the order of handshake messages, relative to regular ﬂows
permitted by the speciﬁcation. To aid analysis of larger mo-
dels (such as those of JSSE or PionDTLS) we developed a
script to automatically remove states from which a hands-
hake cannot be completed (i.e., it is no longer possible to
receive a Finished from the server). On the reduced models,
handshake-completing ﬂows can be identiﬁed much more ea-
sily; this is showcased by Figs. 4 and 5. Using this approach,
we uncovered bugs like early Finished, wherein a handshake
is completed by omitting the ChangeCipherSpec message.
We refer to Sections 7.4 to 7.6 for descriptions of such bugs
for JSSE, Scandium and PionDTLS. Note that the script used
to reduce models comes packaged with our learning setup.

Second, we look for outputs from the server which do not
conform to the speciﬁcation. Of particular interest are irre-
gular ServerHello responses, which are not part of irregular
handshakes (otherwise the ﬂows would have been detected
and analyzed by our ﬁrst strategy). We investigate whether
a handshake may be completed using these responses. To
that end, we probe the SUT’s reaction after such responses
to manually-crafted messages (typically ClientKeyExchange,
ChangeCipherSpec and Finished), whose message sequen-
ce/epoch numbers differ from what our MAPPER generates.
Doing so, we were able to complete handshakes in TinyDTLS
using invalid epoch numbers; see Section 7.8. Also of interest
are Alert outputs, as they shed light on how the system pro-
cesses unexpected inputs. For example, Alert(DecryptError)
suggests the SUT is not able to decrypt a message. Hence,
Alert(DecryptError) is only expected as a response to an en-
crypted message, and not to an unencrypted message, as was

Table 4: Summary of irregular behaviors detected in the tested
libraries. The message_seq column summarizes the correct
usage of these numbers. (cid:55) indicates that the implementation
ﬁnished the handshake with an invalid message_seq. The
third column summarizes the cookie computation correctness.
The last column depicts whether implementations correctly
validate the handshake message sequence.

Library

GnuTLS
JSSE 9.0.4
JSSE 12.0.2
MbedTLS
NSS
OpenSSL
PionDTLS
Scandiumold
Scandiumnew
TinyDTLS
WolfSSL

Validation of Cookie Message
message_seq
numbers

order
veriﬁcation

comp.

(cid:55)
(cid:51)
(cid:51)
(cid:55)
(cid:51)
(cid:51)
(cid:51)
(cid:55)
(cid:55)
(cid:55)
(cid:55)

(cid:55)
(cid:51)
(cid:51)
(cid:55)
(cid:55)
(cid:55)
(cid:51)
(cid:51)
(cid:51)
(cid:51)
(cid:51)

(cid:51)
(cid:51)
(cid:55)
(cid:51)
(cid:51)
(cid:51)
(cid:55)
(cid:55)
(cid:51)
(cid:51)
(cid:51)

the case for TinyDTLS; see Section 7.8.

Finally, we inspect the code exercised by irregular beha-
viors identiﬁed by the ﬁrst two strategies in order to assess
whether they can result in further ﬂaws. Such ﬂaws can be
more severe than the initial irregularity suggests. As an exam-
ple, the non-conforming Alert(DecryptError) in TinyDTLS
led us to discover loss of reliability in the face of reorde-
ring. Investigation can also reveal bugs not directly related
to the behavior inspected, which, however, exercise roughly
the same portion of code. Such was the case for PionDTLS,
where investigating an early Finished bug led to the discovery
of premature processing of application data; see Section 7.6.

7.3 General Behavior Patterns

Several conforming and non-conforming behavior patterns
emerged while analyzing the learned models. Table 4 summa-
rizes the irregular behaviors and the affected implementations.
Handshake with invalid message_seq numbers. Many
DTLS server implementations allow for creating new associa-
tions even when having an already established connection [36,
Section 4.2.8]. This process involves performing a new Client-
Hello–ServerHello exchange in the middle of an already star-
ted or ﬁnished handshake, and results in agreeing on a new
cipher suite and key material. The motivation behind this be-
havior is to support clients that want to re-establish a new
connection after loosing one (e.g., after a reboot). According
to the DTLS speciﬁcation [36, Section 4.2.2], every Client-
Hello starting a new handshake must have message_seq =
0. Every following handshake message has to increase the

Figure 4: Model of a JSSE 12.0.2 server with client certiﬁcate authentication required. Blue edges capture the happy ﬂow,
dotted red a handshake with an unauthenticated ClientKeyExchange message, dashed-dotted red a handshake without certiﬁcate
messages, dashed red a handshake without CertiﬁcateVerify.

message_seq number by one.3

In ﬁve of the tested implementations, it was possible to
start a DTLS handshake with a higher message_seq number.
It was also possible to identify these implementations from the
learned models. For example, in the GnuTLS model (Fig. 3),
we were able to detect such an invalid behavior by following
the transitions looping back to state 2.
Non-conforming cookie computation. Upon receiving a
ClientHello message, the server computes a stateless cookie
and sends it via HelloVerifyRequest. The server expects the
cookie to be replayed in the subsequent ClientHello message.
According to the speciﬁcation, the replayed ClientHello mes-
sage must contain the same parameters as the ﬁrst one (e.g.,
supported cipher suites) [36, Section 4.2.1]. For this purpose,
the server should use the initial ClientHello parameters to
compute the cookie value.

In our evaluation, we could observe four implementations
incorrectly computing the cookie value, resulting in incorrect
validation of replayed ClientHello messages. Such a hands-
hake is also captured in Fig. 3, where an RSA handshake can
be completed even if the ﬁrst message was ClientHello(PSK).
An exceptional case is NSS, which omits the cookie exchange
step altogether, in discord with the speciﬁcation’s recommen-
dation.
Handshake with invalid order of messages. The most con-

3As mentioned in Section 2, DTLS also deﬁnes explicit sequence numbers
in DTLS records. In contrast to message_seq numbers located in handshake
messages, an implementation can accept a DTLS record with a sequence
number that was increased by more than one. This allows for accepting DTLS
records after losing previous UDP packets.

sequential divergent behaviors are handshakes where invalid
message sequences lead to handshake completion. These be-
haviors may have severe security implications. We found that
JSSE, PionDTLS, and Scandiumold do not correctly verify
the DTLS handshake message sequence in their internal state
machines. Below we discuss these bugs and their implicati-
ons.

7.4 Bypassing Client Authentication in JSSE

Figure 4 depicts the hypothesis model generated for JSSE
12.0.2 using one RSA-based cipher suite after two days of
learning. The model was obtained by erasing all states from
which a handshake could no longer be completed. The JSSE
server was conﬁgured to require client authentication.

The model depicts a correctly completed handshake, which
is marked with blue edges and follows states 0, 2, 4, 11, 12,
3, 9, and 10. This ﬂow includes Certiﬁcate and Certiﬁcate-
Verify messages correctly sent by the client to authenticate to
the server. However, even though the server required client
authentication, we were able to complete DTLS handshakes
without sending Certiﬁcate or CertiﬁcateVerify messages. The
invalid handshakes are captured in red and allow a client
to bypass client authentication. Our analysis revealed that
versions 11, 12 and 13 of Oracle and OpenJDK Java are
affected for all key exchange algorithms. Previous versions
are not affected by this issue.
Unauthenticated ClientKeyExchange. We start the descrip-
tion of JSSE vulnerabilities with a slightly modiﬁed happy
ﬂow, which follows states 0, 2, 4, 11, 5, 3, 9 and 10, and traver-

ses dotted red edges on the model. In this ﬂow, the client sends
a CertiﬁcateVerify message before the ClientKeyExchange.
This implies that the ClientKeyExchange message is not au-
thenticated with the client certiﬁcate.

Being able to ﬁnalize such a DTLS handshake does not
directly result in a critical vulnerability. If the client behaves
correctly and sends messages in the correct order, an attacker
cannot modify the ClientKeyExchange message or the mes-
sage order because all the handshake messages are protected
by the Finished message. Still, this bug shows a ﬁrst invalid
behavior, and scratches on the surface of other invalid ones.
Certiﬁcate-less client authentication. The second vulnera-
bility is marked with dashed-dotted red edges in Fig. 4. The
DTLS handshake starts with four ordinary ﬂights of messages.
In the fourth ﬂight, the server requests client authentication
by sending a CertiﬁcateRequest message. However, the client
ignores this message and continues the handshake with Client-
KeyExchange, ChangeCipherSpec, and Finished messages,
without sending Certiﬁcate and CertiﬁcateVerify. The server
responds to the last message with ChangeCipherSpec and
Finished, thus completing handshake. This allows the client
to completely bypass client authentication and proceed with
sending application data.

Note that the handshake process remains completely trans-
parent to the server, as long as the server does not try to
manually inspect the certiﬁcate of the peer after completing
the handshake. Since the client does not send any certiﬁcate,
the certiﬁcate in the internal JSSE context is null. If the ser-
ver attempts to evaluate the certiﬁcate data (e.g., to access
the subject name or certiﬁcate issuer ﬁelds), this will result
in an SSLPeerUnverifiedException and most likely interrupt
the authentication process. The next ﬁnding bypasses this
constraint as well.
CertiﬁcateVerify-less client authentications. The third vul-
nerability follows red dashed edges in Fig. 4 and partially
relies on the behavior described above. It allows an attacker
to authenticate as an arbitrary user without the possession of
the private key. The only prerequisite is that the attacker is
in possession of a valid client certiﬁcate. This requirement is
in most cases trivially achieved as certiﬁcates are usually not
considered private and can be found in public repositories or
provided in frameworks like Certiﬁcate Transparency.

As already visualized on the model, after receiving the
second server message ﬂight, the attacker can send a Client-
KeyExchange message, thus transitioning from 4 to 7. Instead
of directly sending a ChangeCipherSpec message, we con-
tinue with an out-of-order Certiﬁcate message. Finally, we
send ChangeCipherSpec and Finished. The server then re-
sponds with ChangeCipherSpec and Finished, after which it
can accept an Application message encrypted under the esta-
blished keys. Thus, the attacker is able to ﬁnalize the DTLS
handshake without CertiﬁcateVerify, and thus without being
in possession of the certiﬁcate’s private key. The crucial diffe-
rence in comparison to the previous vulnerability is that the

server accepts the certiﬁcate, and is able to correctly process
its contents. Therefore, no SSLPeerUnverifiedException is
thrown, and the application has no possibility to detect the
invalid client behavior.
Attack rationale and state machine analysis. To under-
stand the above described behaviors, we analyzed the JSSE
state machine implementation. The reason behind the vulne-
rabilities is not intuitive. In general, it can be summarized in
the following processing properties. First, the server does not
validate a proper message order. From the ﬁrst bug, we can
conclude that speciﬁc handshake messages can be sent in a dif-
ferent order (e.g., ClientKeyExchange and CertiﬁcateVerify).
Second, the server only partially validates the correctness
of received messages. For example, it validates whether the
handshake contains a ClientKeyExchange message, or it does
not accept further ClientHello messages after a ServerHello-
Done message has been sent. Third, and most importantly,
the server does not verify the presence of critical messages
after the handshake has been ﬁnalized. In particular, it does
not check whether Certiﬁcate and CertiﬁcateVerify messages
were received after a CertiﬁcateRequest has been sent.

Our code analysis revealed that the JSSE implementa-
tion always waits for at least ClientKeyExchange, Change-
CipherSpec, and Finished messages. Messages arriving out-
of-order can be cached. This explains why we could observe
so many different paths leading to handshake completion in
the learned model.

Interestingly, the bugs affect the TLS implementation in a
similar way as well. Omitting the Certiﬁcate and Certiﬁcate-
Verify messages also authenticates the client. Additionally,
just removing the CertiﬁcateVerify message (while leaving
the Certiﬁcate message) also authenticates the client. We
were able to reproduce the issues with Apache Tomcat 9.0.22,
which was conﬁgured with JSSE and required client authenti-
cation.4 We reported the vulnerabilities to the Oracle security
team. They were assigned CVE-2020-2655 and patched with
the Oracle critical patch update in January 2020.

7.5 State Machine Bugs in Scandium

Scandiumold produced some of the largest models. This is
reﬂective of the fact that the implementation did not use an
internal state machine to validate the sequence of handshake
messages. Consequently, its model captures handshakes with
invalid sequences of messages. Reporting our ﬁndings promp-
ted Scandium developers to update the implementation with
state machine validation (Scandiumnew). This update ﬁxed all
the Scandium bugs reported in this paper. The update not only
helped to simplify the learned model (for a PSK conﬁguration
reducing the size from 16 to 13), but also enabled convergence
for ECDH conﬁgurations resulting in similarly small models.

4It is also possible to conﬁgure Apache Tomcat with an OpenSSL engine

(https://tomcat.apache.org/tomcat-9.0-doc/ssl-howto.html).
This version was not affected.

Figure 5: Model of a PionDTLS server with client certiﬁcate authentication required. The model was reduced from 66 states to
11 by retaining only states from which a handshake can be ﬁnalized. Dotted red indicates an early Finished handshake, dashed
red a handshake with a delayed CertiﬁcateVerify message.

Models for the original and updated versions are available
online. Below, we present ﬁndings for the original version.
Early Finished. Scandium allows a handshake to be comple-
ted without the client sending a ChangeCipherSpec message.
The server then interprets all the upcoming messages as sent
in plaintext. It still expects a valid Finished message with
correct verify_data from the client to complete the handshake.
Therefore, a man-in-the-middle attacker is not able to simply
drop ChangeCipherSpec and use a fabricated Finished mes-
sage to decrypt the trafﬁc. A valid verify_data would still be
required to complete the handshake. This is not possible to
compute without possessing the master secret or exploiting
further bugs. However, this behavior shows fragility of the
Scandium state machine.

The early Finished message bug is remarkably similar to
the bug reported for JSSE 1.8.0_25 [13], and is related to
the attack described by Wagner and Schneier [44]. An attac-
ker could exploit this behavior by injecting a backdoor into
a library which would force a DTLS client to skip Change-
CipherSpec messages. The attacker could then observe plain-
text connections established with any Scandium server.
Multiple ChangeCipherSpec in a handshake. Scandium
can complete handshakes wherein ChangeCipherSpec is fol-
lowed by one or more ChangeCipherSpec messages and then
Finished. On each ChangeCipherSpec sent, the MAPPER in-
crements the epoch used in follow-up messages. Thus, the
sent Finished carries an epoch number for which a cipher has
not been negotiated. The fact that Scandium completes hands-
hakes in such a situation further showcases the looseness of
its implementation.
Measurable improvements. After we reported the vulnera-
bilities to the Scandium developers, they were able to simplify
Scandium’s state machine signiﬁcantly. Scandiumnew gene-

rates at most 17 states, whereas Scandiumold generates up to
45 in a more restricted setting.

7.6 Severe Bugs in PionDTLS

Early Finished revisited. PionDTLS exhibits an early Fi-
nished message bug which is similar to the one found in
Scandium. Obtained for a server requiring certiﬁcate authenti-
cation, PionDTLS’s model (Fig. 5) captures three handshakes
instead of the one expected. The two additional handsha-
kes are an early Finished handshake and a handshake with
a ChangeCipherSpec message preceding CertiﬁcateVerify
(where the CertiﬁcateVerify is sent encrypted). This latter bug
clearly shows that PionDTLS does not correctly validate the
ordering of messages.
Processing of unencrypted application data. During the
analysis of the previous bug, we noticed that PionDTLS
freely processed unencrypted application data delivered with
epoch 0. This bug has severe consequences by allowing an
attacker to inject arbitrary application data at any point once a
handshake has been completed. The bug was promptly ﬁxed
once we reported our ﬁndings to the developers.
HelloVerifyRequest retransmissions. PionDTLS occasio-
nally responds to the ﬁrst ClientHello message with multiple
HelloVerifyRequest messages. This response is marked with
HVR+ in Fig. 5. When investigating this behavior we found
that PionDTLS will retransmit HelloVerifyRequest messa-
ges until a timeout elapses or it receives the second Client-
Hello. RFC 6347 advises against retransmitting HelloVerify-
Request [36, p. 6], as doing so requires the server to keep
state, making it susceptible to Denial-of-Service attacks. The
retransmission also enables ampliﬁcation attacks, wherein an
attacker sends ClientHello messages to the server with the

IP address of a victim as the source address. As a result, the
server will then send its replies to the spoofed source address,
thus ﬂooding the victim with HelloVerifyRequest messages.

7.7

Invalid Handshake Start in GnuTLS

In GnuTLS 3.5.19, we detected a bug in the initial state;
the implementation treated most messages as if they were
ClientHello. In doing so, the server responded to them with
HelloVerifyRequest and it transitioned to the next handshake
state. We reported the bug to the GnuTLS developers who
were able to reproduce and ﬁx the issue.

7.8 Security Violations & Bugs in TinyDTLS

Insecure renegotiation. After performing a DTLS hands-
hake with a TinyDTLS server, we were able to use the esta-
blished encrypted connection to perform the next handshake.
This process is also called renegotiation and allows the client
to establish new keys for the given connection. However, it
can only be safely used if the ClientHello message contains a
renegotiation indication extension and the server can process
it [34]. Otherwise, the server may be vulnerable to an insecure
renegotiation attack [34]; see also CVE-2009-3555.

The ClientHello messages we used did not contain any
renegotiation indication extension. Therefore, every renego-
tiation attempt should have been rejected by the processing
server. However, this was not the case. TinyDTLS violated
RFC 5746 [34, Sect. 3.2] and was vulnerable to the insecure
renegotiation attack. The real exploitability of this behavior
depends on the application using the TinyDTLS library.
Crashes on ChangeCipherSpec. In addition, we found that
in certain states TinyDTLSE crashes on receiving Change-
CipherSpec. For example, it crashed on receiving this mes-
sage in the initial state. The crashing behavior resulted in a
reduction of states compared to TinyDTLSC since crashing
inputs predictably lead to a single sink state. The crash was
a result of a segmentation fault resulting from a null address
read. This bug is a rediscovery of CVE-2017-7243, which is
still unﬁxed in the master branch of the TinyDTLSE .
From inconsistent alert to unreliable handshake protocol.
By analyzing the learned model, we could observe frequent
usage of Alert(DecryptError) messages. This alert is sent by
TinyDTLS whenever it tries to decrypt a record (whether it is
actually encrypted or not), and fails to ﬁnd key material for
the epoch in its internal state. This behavior is in itself rat-
her unproblematic, but TinyDTLS also invalidates the whole
connection in such a case. This can result in connections brea-
king unnecessarily when the ChangeCipherSpec and Finished
messages are received out of order in a regular handshake.
Handshake with invalid epoch numbers. The model for
TinyDTLSC revealed that the server can perform the ﬁrst two
steps of a handshake using ClientHello messages with epoch 1
when no cipher for epoch 0 has yet been negotiated. Upon

further investigation, we were able to complete the hands-
hake by sending ClientKeyExchange, ChangeCipherSpec and
Finished having the same epochs as in a normal handshake
(which are 0, 0 and 1, respectively). The handshake is clearly
invalid and should not have been possible to complete.

7.9 Bugs in OpenSSL

Finished treated as retransmission. After a successful
handshake completion, the OpenSSL server treats retrans-
mitted Finished messages incorrectly. OpenSSL responds to
a newly computed and transmitted Finished message by re-
sending the last ﬂight (ChangeCipherSpec, Finished). The
Finished message received from the server has a different mes-
sage sequence number and verify_data content. An adequate
response would have been either to discard this message, or
to send an alert and possibly terminate the connection.
InternalError alerts.
is sent by
OpenSSL in response to unexpected Finished messages. In-
ternally, OpenSSL is processing the message and trying to
compute the verify_data for the Finished message. However,
due to defensive programming, missing parameters in the ses-
sion context are discovered, the processing of the message is
stopped, and an Alert(InternalError) is returned. An appropri-
ate response should have been an alert indicating the receipt
of an out-of-order message. Alert(UnexpectedMessage) has
been designed for such purposes.

Alert(InternalError)

7.10 Observed Code Patterns

We can conclude that in our analysis we observed several
repeating code patterns, which led to the bugs and vulnerabili-
ties. Most importantly, most of the analyzed implementations
do not use proper state machines. While they attempt to verify
the handshake protocol ﬂow with simple checks in switch sta-
tements, a complete message ﬂow validation is missing. This
was, for example, observed by the analysis of the Scandium
implementation, which was too liberal when it comes to the
message sequence veriﬁcation; only other additional checks
in the code prevented further security vulnerabilities. One
reason for missing state machines could be the fact the DTLS
speciﬁcation [36] does not give a design for one. We believe
that protocol standards should contain such designs and de-
mand that implementations use them.

In the libraries implementing TLS and DTLS, we could
observe that the code is re-used in both protocols. This means
that similar vulnerabilities in one protocol implementation can
inﬂuence the other. For example, we found the authentication
bypass in JSSE by analyzing the DTLS server implementation.
However, our subsequent analysis revealed that the bug is also
applicable to TLS. We expect that similar behaviors will be
found in the future.

Interestingly, both Scandium and PionDTLS include the
same early Finished message bug that was found in JSSE TLS

in 2015 [13]. While this again may be attributed to missing
state machine implementation, we believe that this bug is
closely related to an ambiguity, which is mentioned in [36].

the system, though this time it was not introduced by the me-
dium but by the system itself. In their work, a simple majority
voting system was sufﬁcient to address these issues.

As with TLS, the ChangeCipherSpec message is
not technically a handshake message [...]. This cre-
ates a potential ambiguity because the order of the
ChangeCipherSpec cannot be established unambi-
guously with respect to the handshake messages in
case of message loss.

In DTLS up to version 1.2, this ambiguity has to be resolved
by hard-coding the expected ChangeCipherSpec message.
In the recent DTLS 1.3 drafts [16], the problem has been
resolved by removing ChangeCipherSpec messages entirely.

8 Related Work

In this section, we give a brief summary of previous work on
analyses of DTLS and on state fuzzing of security protocols.
Due to the similarity with TLS, most of the attacks appli-
cable to TLS are potentially applicable to DTLS protocol
implementations as well. This includes attacks like Heart-
bleed [37], Bleichenbacher’s attack [7], or CBC padding ora-
cle attacks [43]. One exception is the attack presented by
AlFardan and Paterson in 2012, who adapted padding oracle
attacks to DTLS by using novel DTLS side channels [1]. The
adaptation exploits subtle timing differences between pro-
cessing packets with valid and invalid padding, ampliﬁed by
the processing of subsequent Heartbeat messages. The attack
was applicable to OpenSSL and GnuTLS. In 2013, the same
authors extended their work to a powerful attack breaking
both TLS and DTLS – Lucky13 [2].

Van Drueten obtained some preliminary results on ana-
lyzing DTLS implementations using protocol state fuzzing,
from which this work branched off. His thesis [42] analy-
zed OpenSSL and mbedTLS with a limited input alphabet
and did not reveal any security vulnerabilities. De Ruiter and
Poll [13] used protocol state fuzzing to analyze TLS imple-
mentations and found several security bugs. In comparison,
the models we learn are signiﬁcantly larger, due to complexity
in DTLS introduced by UDP, and our inclusion of several key
exchange algorithms and certiﬁcate settings. Also, as stated
before, some of the bugs we found are only possible under
particular conﬁgurations or are speciﬁc to DTLS.

McMahon Stone et al. [28] extend state learning such that
it also captures time behavior and can operate also over an un-
reliable communication medium. They then use the extension
to analyze implementations of the 802.11 4-Way Handshake
in seven Wi-Fi routers. In dealing with non-determinism, our
work employs some of the same strategies, such as checking
counterexamples against a cache, or using majority voting.
However, it can use a more efﬁcient learning setup, as it does
not have to deal with a lossy medium and resulting timeouts.
Chalupar et al. [9] also had to address non-determinism of

9 Conclusions and Future Work

We have presented the ﬁrst protocol state fuzzing framework
for DTLS. As a basis, in particular for constructing a MAPPER,
we have developed a test framework for DTLS, based on
TLS-Attacker. The MAPPER and test framework implement
DTLS speciﬁcs including explicit sequence number, support
for cookie management, and epoch numbers. In this paper,
we focused on discovering state machine bugs, triggered by
sequences of valid handshake messages. We did not exer-
cise reordering and fragmentation. Nevertheless, we used our
platform to generate models of thirteen widely used DTLS
server implementations, and were able to ﬁnd critical security
vulnerabilities and implementation ﬂaws in them.

There are several directions for future work: (i) The analy-
sis can also explore Record Layer functionality such as frag-
mentation and reordering, by adding a strategy for sending
reordered and fragmented records. Since these functionali-
ties should be handled transparently by the Record Layer, we
can directly use our already learned models as speciﬁcations.
(ii) Our learned models can be used to support systematic tes-
ting with invalid input messages, as is done in protocol fuzzers.
(iii) Our analysis of learned models was performed manually;
automation using model checking techniques should be inves-
tigated, for example, by following the methodology presented
in work for TCP [18] or SSH [19].

Acknowledgements

We would like to thank Jörg Schwenk, our shepherd Kenneth
Paterson, and the anonymous reviewers for many insightful
comments. We also thank Niels van Drueten for his contribu-
tion to an initial version of the test framework.

The research was established at the Lorentz Center works-
hop on Systematic Analysis of Security Protocol Implementa-
tions. It was partially funded by the Swedish Foundation for
Strategic Research (SSF) through the aSSIsT project, the Swe-
dish Research Council, and the Deutsche Forschungsgemein-
schaft (DFG, German Research Foundation) under Germany’s
Excellence Strategy - EXC 2092 CASA - 390781972.

References

[1] Nadhem AlFardan and Kenneth G. Paterson. Plaintext-
recovery attacks against Datagram TLS. In Network and
Distributed System Security Symposium, NDSS 2012,
2012.

[2] Nadhem J. AlFardan and Kenneth G. Paterson. Lucky
thirteen: Breaking the TLS and DTLS record protocols.

In 2013 IEEE Symposium on Security and Privacy, pa-
ges 526–540. IEEE, 2013.

[3] Dana Angluin. Learning regular sets from queries
and counterexamples. Information and Computation,
75(2):87–106, 1987.

[4] Nimrod Aviram, Sebastian Schinzel, Juraj Somorovsky,
Nadia Heninger, Maik Dankel, Jens Steube, Luke Va-
lenta, David Adrian, J. Alex Halderman, Viktor Dukho-
vni, Emilia Käsper, Shaanan Cohney, Susanne Engels,
Christof Paar, and Yuval Shavitt. DROWN: Breaking
TLS using SSLv2. In 25th USENIX Security Symposium,
USENIX Security 16, pages 689–706, August 2016.

[5] Benjamin Beurdouche, Karthikeyan Bhargavan, Antoine
Delignat-Lavaud, Cédric Fournet, Markulf Kohlweiss,
Alfredo Pironti, Pierre-Yves Strub, and Jean Karim Zin-
zindohoue. A messy state of the union: Taming the
composite state machines of TLS. Commun. ACM,
60(2):99–107, February 2017.

[6] Benjamin Beurdouche, Antoine Delignat-Lavaud, Na-
dim Kobeissi, Alfredo Pironti, and Karthikeyan Bharga-
van. FlexTLS: A tool for testing TLS implementations.
In 9th USENIX Workshop on Offensive Technologies,
WOOT 15. USENIX Association, August 2015.

[7] Daniel Bleichenbacher. Chosen ciphertext attacks
against protocols based on the RSA encryption stan-
dard PKCS #1. In Advances in Cryptology - CRYPTO
’98, volume 1462 of LNCS. Springer, Berlin / Heidelberg,
1998.

[8] Botan: Crypto and TLS for C++11, 2019.

[9] Georg Chalupar, Stefan Peherstorfer, Erik Poll, and Joeri
de Ruiter. Automated reverse engineering using Lego R(cid:13).
In 8th USENIX Workshop on Offensive Technologies,
WOOT 14. USENIX Association, August 2014.

[10] Chia Yuan Cho, Domagoj Babic, Eui Chul Richard Shin,
and Dawn Song. Inference and analysis of formal mo-
dels of botnet command and control protocols. In Pro-
ceedings of the 17th ACM Conference on Computer and
Communications Security, CCS 2010, pages 426–439.
ACM, October 2010.

[11] Tsun S. Chow. Testing software design modeled by
ﬁnite-state machines. IEEE Trans. Soft. Eng., 4(3):178–
187, May 1978. Special collection based on COMPSAC.

[12] Lesly-Ann Daniel, Erik Poll, and Joeri de Ruiter. In-
ferring OpenVPN state machines using protocol state
In IEEE European Symposium on Security
fuzzing.
and Privacy (EuroS&P) Workshops, pages 11–19. IEEE,
April 2018.

[13] Joeri de Ruiter and Erik Poll. Protocol state fuzzing of
TLS implementations. In 24th USENIX Security Sym-
posium, pages 193–206. USENIX Association, August
2015.

[14] T. Dierks and Eric Rescorla. The transport layer security
(TLS) protocol version 1.1. RFC 4346, April 2006.

[15] T. Dierks and Eric Rescorla. The transport layer security
TLS protocol version 1.2. RFC 5246, August 2008.

[16] N. Modadugu E. Rescorla, H. Tschofenig. The datagram
transport layer security (DTLS) protocol version 1.3 -
draft-34, July 2018.

[17] P. Eronen and H. Tschofenig. Pre-shared key ciphers-
uites for transport layer security (TLS). RFC 4279,
December 2005.

[18] Paul Fiter˘au-Bro¸stean, Ramon Janssen, and Frits W.
Vaandrager. Combining model learning and model
checking to analyze TCP implementations. In Compu-
ter Aided Veriﬁcation - 28th International Conference,
CAV 2016, Proceedings, Part II, volume 9780 of LNCS,
pages 454–471. Springer, 2016.

[19] Paul Fiter˘au-Bro¸stean, Toon Lenaerts, Joeri de Ruiter,
Erik Poll, Frits W. Vaandrager, and Patrick Verleg. Mo-
del learning and model checking of SSH implementati-
ons. In Proceedings of the 24th ACM SIGSOFT Interna-
tional SPIN Symposium on Model Checking of Software,
SPIN 2017, pages 142–151. ACM, 2017.

[20] Susumu Fujiwara, Gregor von Bochmann, Ferhat Khen-
dek, Mokhtar Amalou, and Abderrazak Ghedamsi. Test
selection based on ﬁnite state models. IEEE Trans. Soft.
Eng., 17(6):591–603, June 1991.

[21] Malte Isberner. Foundations of Active Automata Lear-
ning: An Algorithmic Perspective. PhD thesis, Technical
University Dortmund, Germany, 2015.

[22] Malte Isberner, Falk Howar, and Bernhard Steffen. The
TTT algorithm: A redundancy-free approach to active
automata learning. In Runtime Veriﬁcation: 5th Interna-
tional Conference, RV 2014, Proceedings, volume 8734
of LNCS, pages 307–322. Springer, September 2014.

[23] Malte Isberner, Falk Howar, and Bernhard Steffen. The
open-source LearnLib - A framework for active auto-
mata learning. In Computer Aided Veriﬁcation - 27th
International Conference, CAV, volume 9206 of LNCS,
pages 487–495. Springer, 2015.

[24] Hubert Kario. tlsfuzzer, 2018.

[25] David Lee and Mihalis Yannakakis. Principles and met-
hods of testing ﬁnite state machines—a survey. Procee-
dings of the IEEE, 84(8):1090–1123, 1996.

[26] Knud Lasse Lueth. State of the IoT 2018: Number of
IoT devices now at 7B — market accelerating, August
2018.

[27] matrixSSL. Compact Embedded SSL/TLS stack, 2019.

[28] Chris McMahon Stone, Tom Chothia, and Joeri de Rui-
ter. Extending automated protocol state learning for the
802.11 4-way handshake. In Computer Security, volume
11098 of LNCS, pages 325–345, Cham, August 2018.
Springer International Publishing.

[29] Nagendra Modadugu and Eric Rescorla. The design and
implementation of Datagram TLS. In Proceedings of the
Network and Distributed System Security Symposium,
NDSS 2004, 2004.

[30] Bodo Möller, Thai Duong, and Krzysztof Kotowicz.
This POODLE bites: exploiting the SSL 3.0 fallback,
2014.

[31] Thomas Pornin. BoarSSL, 2017.

[32] Harald Raffelt, Maik Merten, Bernhard Steffen, and Ti-
ziana Margaria. Dynamic testing via automata learning.
STTT, 11(4):307–324, 2009.

[33] Abdullah Rasool, Greg Alpár, and Joeri de Ruiter.
arXiv preprint

State machine inference of QUIC.
arXiv:1903.04384, 2019.

[34] E. Rescorla, M. Ray, S. Dispensa, and N. Oskov. Trans-
port layer security (TLS) renegotiation indication exten-
sion. RFC 5746, February 2010.

[35] Eric Rescorla and Nagendra Modadugu. Datagram trans-

port layer security. RFC 4347, April 2006.

[36] Eric Rescorla and Nagendra Modadugu. Datagram trans-
port layer security version 1.2. RFC 6347, January 2012.

[37] Riku, Antti, Matti, and Neel Mehta. Heartbleed, CVE-

2014-0160, 2015.

[38] Zach Shelby, Klaus Hartke, and Carsten Bormann. The
constrained application protocol (CoAP). RFC 7252,
June 2014.

[39] Juraj Somorovsky. Systematic fuzzing and testing of
TLS libraries. In Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security,
CCS ’16, pages 1492–1504, New York, NY, USA, 2016.
ACM.

[40] Martin Tappler, Bernhard K. Aichernig, and Roderick
Bloem. Model-based testing IoT communication via
active automata learning. In Software Testing, Veriﬁ-
cation and Validation, (ICST) 2017 IEEE International
Conference on, pages 276–287. IEEE Computer Society,
March 2017.

[41] Frits W. Vaandrager. Model learning. Commun. ACM,

60(2):86–95, 2017.

[42] Niels van Drueten. Security analysis of DTLS 1.2 im-
plementations. Bachelor thesis, Radboud University,
Nijmegen, The Netherlands, 2019.

[43] Serge Vaudenay. Security ﬂaws induced by CBC pad-
ding - applications to SSL, IPSEC, WTLS ... In Advan-
ces in Cryptology - EUROCRYPT 2002, volume 2332
of LNCS. Springer, Berlin / Heidelberg, April 2002.

[44] David Wagner and Bruce Schneier. Analysis of the SSL
3.0 protocol. In Proceedings of the 2nd USENIX Works-
hop on Electronic Commerce, pages 29–40, Berkeley,
CA, USA, 1996. USENIX Association.



=== Content from github.com_6a5298cf_20250121_003927.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpion%2Fdtls%2Fcompare%2Fv1.5.1...v1.5.2)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpion%2Fdtls%2Fcompare%2Fv1.5.1...v1.5.2)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fcompare%2Fshow&source=header-repo&source_repo=pion%2Fdtls)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[pion](/pion)
/
**[dtls](/pion/dtls)**
Public

* [Notifications](/login?return_to=%2Fpion%2Fdtls) You must be signed in to change notification settings
* [Fork
  161](/login?return_to=%2Fpion%2Fdtls)
* [Star
   614](/login?return_to=%2Fpion%2Fdtls)

* [Code](/pion/dtls)
* [Issues
  8](/pion/dtls/issues)
* [Pull requests
  2](/pion/dtls/pulls)
* [Actions](/pion/dtls/actions)
* [Security](/pion/dtls/security)
* [Insights](/pion/dtls/pulse)

Additional navigation options

* [Code](/pion/dtls)
* [Issues](/pion/dtls/issues)
* [Pull requests](/pion/dtls/pulls)
* [Actions](/pion/dtls/actions)
* [Security](/pion/dtls/security)
* [Insights](/pion/dtls/pulse)

[Permalink](https://github.com/pion/dtls/compare/pion%3A91d652d...pion%3Afd73a5d)
# Comparing changes

 Choose two branches to see what’s changed or to start a new pull request.
If you need to, you can also  compare across forks
 or
[learn more about diff comparisons](https://docs.github.com/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-comparing-branches-in-pull-requests#three-dot-and-two-dot-git-diff-comparisons).

# Open a pull request

 Create a new pull request by comparing changes across two branches. If you need to, you can also  compare across forks
.
[Learn more about diff comparisons here](https://docs.github.com/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-comparing-branches-in-pull-requests#three-dot-and-two-dot-git-diff-comparisons).

*base repository:*
pion/dtls

Failed to load repositories. Confirm that selected base ref is valid, then try again.

 Loading

*base:*
v1.5.1

Choose a base ref

Branches
Tags

Could not load branches

Nothing to show

 Loading

[{{ refName }}
default](/pion/dtls/compare/%7B%7B%20urlEncodedRefName%20%7D%7D...v1.5.2)

Could not load tags

Nothing to show

[{{ refName }}
default](/pion/dtls/compare/%7B%7B%20urlEncodedRefName%20%7D%7D...v1.5.2)

 Loading

...

*head repository:*
pion/dtls

Failed to load repositories. Confirm that selected head ref is valid, then try again.

 Loading

*compare:*
v1.5.2

Choose a head ref

Branches
Tags

Could not load branches

Nothing to show

 Loading

[{{ refName }}
default](/pion/dtls/compare/v1.5.1...%7B%7B%20urlEncodedRefName%20%7D%7D)

Could not load tags

Nothing to show

[{{ refName }}
default](/pion/dtls/compare/v1.5.1...%7B%7B%20urlEncodedRefName%20%7D%7D)

 Loading

6
contributors

[Commits
33](#commits_bucket)
[Files changed
43](#files_bucket)

 Loading

 Loading

### This comparison is taking too long to generate.

Unfortunately it looks like we can’t render this comparison for you right now. It might be too big, or there might be something weird with your repository.

You can try running this command locally to see the comparison on your machine:

`git diff v1.5.1...v1.5.2`

  Retry

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from www.usenix.org_2bf73fd1_20250121_003928.html ===


 [usenix\_logo\_notag\_white](/)

* [Sign In](/user?destination=conference/usenixsecurity20/presentation/fiterau-brostean)
* [Conferences](/conferences)

 [![](https://www.usenix.org/sites/default/files/styles/neat_conference_menu_logo/public/sec20_wordmark_stacked_white.png?itok=mZLIWrxD)](/conference/usenixsecurity20)

* [Attend](/conference/usenixsecurity20#registration)
  + [Registration Information](/conference/usenixsecurity20/registration-information)
  + [Student Grant Application](/conference/usenixsecurity20/student-grant-application)
  + [Diversity Grant Application](/conference/usenixsecurity20/diversity-grants-application)
  + [Grants for Black Computer Science Students Application](/conference/usenixsecurity20/grant-application-black-students)
* [Program](/conference/usenixsecurity20/technical-sessions)
  + [Technical Sessions](/conference/usenixsecurity20/technical-sessions)
  + [Spring Quarter Accepted Papers](/conference/usenixsecurity20/spring-accepted-papers)
  + [Summer Quarter Accepted Papers](/conference/usenixsecurity20/summer-accepted-papers)
  + [Fall Quarter Accepted Papers](/conference/usenixsecurity20/fall-accepted-papers)
* [Participate](/conference/usenixsecurity20/call-for-papers)
  + [Call for Papers](/conference/usenixsecurity20/call-for-papers)
  + [Submission Policies and Instructions](/conference/usenixsecurity20/submission-policies-and-instructions)

  + [Call for Artifacts](/conference/usenixsecurity20/call-for-artifacts)
  + [Artifact Evaluation Information](/conference/usenixsecurity20/artifact-evaluation-information)

  + [Instructions for Presenters](/conference/usenixsecurity20/instructions-presenters)
  + [Hack@Sec](https://hackat.events/sec20/)
* [Sponsors](/conference/usenixsecurity20#sponsorship)
* [About](/conference/usenixsecurity20#marquee)
  + [Symposium Organizers](/conference/usenixsecurity20#organizers)
  + [Past Symposia](/conferences/byname/108)
  + [Code of Conduct](/conferences/coc)
  + [Questions](/conference/usenixsecurity20#questions)

# Analysis of DTLS Implementations Using Protocol State Fuzzing

Authors:

Paul Fiterau-Brostean and Bengt Jonsson, *Uppsala University;* Robert Merget, *Ruhr-University Bochum;* Joeri de Ruiter, *SIDN Labs;* Konstantinos Sagonas, *Uppsala University;* Juraj Somorovsky, *Paderborn University*

Abstract:

Recent years have witnessed an increasing number of protocols relying on UDP. Compared to TCP, UDP offers performance advantages such as simplicity and lower latency. This has motivated its adoption in Voice over IP, tunneling technologies, IoT, and novel Web protocols. To protect sensitive data exchange in these scenarios, the DTLS protocol has been developed as a cryptographic variation of TLS. DTLS’s main challenge is to support the stateless and unreliable transport of UDP. This has forced protocol designers to make choices that affect the complexity of DTLS, and to incorporate features that need not be addressed in the numerous TLS analyses.

We present the first comprehensive analysis of DTLS implementations using protocol state fuzzing. To that end, we extend TLS-Attacker, an open source framework for analyzing TLS implementations, with support for DTLS tailored to the stateless and unreliable nature of the underlying UDP layer. We build a framework for applying protocol state fuzzing on DTLS servers, and use it to learn state machine models for thirteen DTLS implementations. Analysis of the learned state models reveals four serious security vulnerabilities, including a full client authentication bypass in the latest JSSE version, as well as several functional bugs and non-conformance issues. It also uncovers considerable differences between the models, confirming the complexity of DTLS state machines.

## [Paul Fiterau-Brostean, Uppsala University](/conference/usenixsecurity20/speaker-or-organizer/paul-fiterau-brostean-uppsala-university)

## [Bengt Jonsson, Uppsala University](/conference/usenixsecurity20/speaker-or-organizer/bengt-jonsson-uppsala-university)

## [Robert Merget, Ruhr-University Bochum](/conference/usenixsecurity20/speaker-or-organizer/robert-merget-ruhr-university-bochum)

## [Joeri de Ruiter, SIDN Labs](/conference/usenixsecurity20/speaker-or-organizer/joeri-de-ruiter-sidn-labs)

## [Konstantinos Sagonas, Uppsala University](/conference/usenixsecurity20/speaker-or-organizer/konstantinos-sagonas-uppsala-university)

## [Juraj Somorovsky, Paderborn University](/conference/usenixsecurity20/speaker-or-organizer/juraj-somorovsky-paderborn-university)

## Open Access Media

USENIX is committed to Open Access to the research presented at our events. Papers and proceedings are freely available to everyone once the event begins. Any video, audio, and/or slides that are posted after the event are also free and open to everyone. [Support USENIX](/annual-fund) and our commitment to Open Access.

BibTeX@inproceedings {251568,

author = {Paul Fiterau-Brostean and Bengt Jonsson and Robert Merget and Joeri de Ruiter and Konstantinos Sagonas and Juraj Somorovsky},

title = {Analysis of {DTLS} Implementations Using Protocol State Fuzzing},

booktitle = {29th USENIX Security Symposium (USENIX Security 20)},

year = {2020},

isbn = {978-1-939133-17-5},

pages = {2523--2540},

url = {https://www.usenix.org/conference/usenixsecurity20/presentation/fiterau-brostean},

publisher = {USENIX Association},

month = aug

}

[Download](/biblio/export/bibtex/251568)![PDF icon](/modules/file/icons/application-pdf.png "application/pdf") [Fiterau-Brostean PDF](https://www.usenix.org/system/files/sec20-fiterau-brostean.pdf "sec20-fiterau-brostean.pdf")![PDF icon](/modules/file/icons/application-pdf.png "application/pdf") [Fiterau-Brostean Paper (Prepublication) PDF](https://www.usenix.org/system/files/sec20fall_fiterau-brostean_prepub.pdf "sec20fall_fiterau-brostean_prepub.pdf")![](https://www.usenix.org/sites/all/modules/usenix/usenix_files/images/usenix-unlocked.png)[View the slides](https://www.usenix.org/system/files/sec20_slides_fiterau-brostean.pdf)![](https://www.usenix.org/sites/default/files/usenix_artifact_evaluation_passed_125.png)
## Presentation Video

* [Attend](/conference/usenixsecurity20#registration)
  + [Registration Information](/conference/usenixsecurity20/registration-information)
  + [Student Grant Application](/conference/usenixsecurity20/student-grant-application)
  + [Diversity Grant Application](/conference/usenixsecurity20/diversity-grants-application)
  + [Grants for Black Computer Science Students Application](/conference/usenixsecurity20/grant-application-black-students)
* [Program](/conference/usenixsecurity20/technical-sessions)
  + [Technical Sessions](/conference/usenixsecurity20/technical-sessions)
  + [Spring Quarter Accepted Papers](/conference/usenixsecurity20/spring-accepted-papers)
  + [Summer Quarter Accepted Papers](/conference/usenixsecurity20/summer-accepted-papers)
  + [Fall Quarter Accepted Papers](/conference/usenixsecurity20/fall-accepted-papers)
* [Participate](/conference/usenixsecurity20/call-for-papers)
  + [Call for Papers](/conference/usenixsecurity20/call-for-papers)
  + [Submission Policies and Instructions](/conference/usenixsecurity20/submission-policies-and-instructions)
  + [Call for Artifacts](/conference/usenixsecurity20/call-for-artifacts)
  + [Artifact Evaluation Information](/conference/usenixsecurity20/artifact-evaluation-information)
  + [Instructions for Presenters](/conference/usenixsecurity20/instructions-presenters)
  + [Hack@Sec](https://hackat.events/sec20/)
* [Sponsors](/conference/usenixsecurity20#sponsorship)
* [About](/conference/usenixsecurity20#marquee)
  + [Symposium Organizers](/conference/usenixsecurity20#organizers)
  + [Past Symposia](/conferences/byname/108)
  + [Code of Conduct](/conferences/coc)
  + [Questions](/conference/usenixsecurity20#questions)

[Twitter](http://twitter.com/usenixsecurity)[Facebook](https://www.facebook.com/USENIX-Security-Symposium-13544602263)[Youtube](http://www.youtube.com/user/USENIXAssociation)

* [Privacy Policy](/privacy-policy)
* [Contact Us](/contact)

© USENIX



=== Content from github.com_855aee51_20250121_003926.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpion%2Fdtls%2Fcommit%2Ffd73a5df2ff0e1fb6ae6a51e2777d7a16cc4f4e0)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpion%2Fdtls%2Fcommit%2Ffd73a5df2ff0e1fb6ae6a51e2777d7a16cc4f4e0)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fvoltron%2Fcommit_fragments%2Frepo_layout&source=header-repo&source_repo=pion%2Fdtls)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[pion](/pion)
/
**[dtls](/pion/dtls)**
Public

* [Notifications](/login?return_to=%2Fpion%2Fdtls) You must be signed in to change notification settings
* [Fork
  161](/login?return_to=%2Fpion%2Fdtls)
* [Star
   614](/login?return_to=%2Fpion%2Fdtls)

* [Code](/pion/dtls)
* [Issues
  8](/pion/dtls/issues)
* [Pull requests
  2](/pion/dtls/pulls)
* [Actions](/pion/dtls/actions)
* [Security](/pion/dtls/security)
* [Insights](/pion/dtls/pulse)

Additional navigation options

* [Code](/pion/dtls)
* [Issues](/pion/dtls/issues)
* [Pull requests](/pion/dtls/pulls)
* [Actions](/pion/dtls/actions)
* [Security](/pion/dtls/security)
* [Insights](/pion/dtls/pulse)

## Commit

[Permalink](/pion/dtls/commit/fd73a5df2ff0e1fb6ae6a51e2777d7a16cc4f4e0)

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

Assert that ApplicationData has epoch != 0

[Browse files](/pion/dtls/tree/fd73a5df2ff0e1fb6ae6a51e2777d7a16cc4f4e0)
Browse the repository at this point in the history

```
Otherwise we may accept unencrypted/unauthenticated ApplicationData
from a remote
```

* Loading branch information

[![@Sean-Der](https://avatars.githubusercontent.com/u/1302304?s=40&v=4)](/Sean-Der)

[Sean-Der](/pion/dtls/commits?author=Sean-Der "View all commits by Sean-Der")
committed
Oct 11, 2019

1 parent
[8294885](/pion/dtls/commit/82948855ecb86a9e0b86c8dd43d010cbc545dc94)

commit fd73a5d

Showing
**1 changed file**
with
**4 additions**
and
**0 deletions**.

* Whitespace
* Ignore whitespace

* Split
* Unified

## There are no files selected for viewing

4 changes: 4 additions & 0 deletions

4
[conn.go](#diff-4f427d2b022907c552328e63f137561f6de92396d7a6e8f6c2ea1bcf0db52654 "conn.go")

Show comments

[View file](/pion/dtls/blob/fd73a5df2ff0e1fb6ae6a51e2777d7a16cc4f4e0/conn.go)
Edit file

Delete file

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

  [Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D)

| Original file line number | Diff line number | Diff line change |
| --- | --- | --- |
| Expand Up | | @@ -559,6 +559,10 @@ func (c \*Conn) handleIncomingPacket(buf []byte) (\*alert, error) { |
|  |  | c.log.Trace("<- ChangeCipherSpec") |
|  |  | c.setRemoteEpoch(c.getRemoteEpoch() + 1) |
|  |  | case \*applicationData: |
|  |  | if h.epoch == 0 { |
|  |  | return &alert{alertLevelFatal, alertUnexpectedMessage}, fmt.Errorf("ApplicationData with epoch of 0") |
|  |  | } |
|  |  |  |
|  |  | c.decrypted <- content.data |
|  |  | default: |
|  |  | return &alert{alertLevelFatal, alertUnexpectedMessage}, fmt.Errorf("unhandled contentType %d", content.contentType()) |
| Expand Down | |  |

Toggle all file notes
Toggle all file annotations

### 0 comments on commit `fd73a5d`

Please
[sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fpion%2Fdtls%2Fcommit%2Ffd73a5df2ff0e1fb6ae6a51e2777d7a16cc4f4e0) to comment.

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.


