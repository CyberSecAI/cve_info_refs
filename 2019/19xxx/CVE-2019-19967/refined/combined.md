=== Content from tools.ietf.org_f380b44c_20250121_031613.html ===


* Light
* Dark
* Auto

[RFC 28

Unknown](/doc/rfc28/)

|  | Title |  | Time Standards |
| --- | --- | --- | --- |
| Document | Document type |  | RFC - Unknown  January 1970  [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") This RFC was published on the Legacy stream. This RFC is **not endorsed by the IETF** and has **no formal standing** in the [IETF standards process](/doc/rfc2026/). |
| --- | --- | --- | --- |
|  | Select version |  | * [RFC 28](/doc/html/rfc28) |
|  | Authors |  | Email authors |
|  | RFC stream |  | Legacy |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc28.txt) [html](https://www.rfc-editor.org/rfc/rfc28.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc28.txt.pdf) [bibtex](/doc/rfc28/bibtex/) |
|  |  |  | [Report a bug](https://github.com/ietf-tools/datatracker/issues/new/choose) |

```
Network Working Group                                   Bill English
[RFC-28](/doc/html/rfc28)                                                  SRI
                                                        13 January 1970

                          TIME STANDARDS

We are about to install a relatively accurate real-time clock on our
system.  I would like any comments relative to Network time standards
for such things as delay measurement so we can decide how good our clock
should be.

DISTRIBUTION:

[A](#appendix-A). Bhushan, MIT
[S](#appendix-S). Carr, Utah
[G](#appendix-G). Cole, SDS
[S](#appendix-S). Crocker, UCLA
[K](#appendix-K). Fry, MITRE
[J](#appendix-J). Heafner, RAND
[B](#appendix-B). Kahn, BB&N
[T](#appendix-T). O'Sullivan, Raytheon
[L](#appendix-L). Roberts, ARPA
[P](#appendix-P). Rovner, LL
[R](#appendix-R). Stoughton, UCSB
```

[Datatracker](/doc/rfc28/)

RFC 28

RFC
- Unknown

* Info
* Contents
* Prefs

| Document | Document type |  | RFC - Unknown  January 1970  [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") This RFC was published on the Legacy stream. This RFC is **not endorsed by the IETF** and has **no formal standing** in the [IETF standards process](/doc/rfc2026/). |
| --- | --- | --- | --- |
|  | Select version |  | * [RFC 28](/doc/html/rfc28) |
|  | Authors |  | Email authors |
|  | RFC stream |  | Legacy |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc28.txt) [html](https://www.rfc-editor.org/rfc/rfc28.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc28.txt.pdf) [bibtex](/doc/rfc28/bibtex/) |

[Report a datatracker bug](https://github.com/ietf-tools/datatracker/issues/new/choose)

Show sidebar by default

Yes

No

Tab to show by default

Info

Contents

HTMLization configuration

HTMLize the plaintext

Plaintextify the HTML

Maximum font size

Page dependencies

Inline

Reference

Citation links

 Go to reference section

Go to linked document

![](//analytics.ietf.org/piwik.php?idsite=7)



=== Content from github.com_a43a08f5_20250121_031614.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ffilipi86%2FConnectBoxDOCSIS-3.0)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Ffilipi86%2FConnectBoxDOCSIS-3.0)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=filipi86%2FConnectBoxDOCSIS-3.0)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[filipi86](/filipi86)
/
**[ConnectBoxDOCSIS-3.0](/filipi86/ConnectBoxDOCSIS-3.0)**
Public

* [Notifications](/login?return_to=%2Ffilipi86%2FConnectBoxDOCSIS-3.0) You must be signed in to change notification settings
* [Fork
  1](/login?return_to=%2Ffilipi86%2FConnectBoxDOCSIS-3.0)
* [Star
   9](/login?return_to=%2Ffilipi86%2FConnectBoxDOCSIS-3.0)

The Connect Box is the worldwide most compact EuroDOCSIS 3.0 Voice Gateway which provides the ideal all-in-one wired and wireless solution, designed for your home, home office, or small business/enterprise. It can be used in households with one or more computers capable of wireless connectivity for remote access to the wireless gateway.

[9
stars](/filipi86/ConnectBoxDOCSIS-3.0/stargazers) [1
fork](/filipi86/ConnectBoxDOCSIS-3.0/forks) [Branches](/filipi86/ConnectBoxDOCSIS-3.0/branches) [Tags](/filipi86/ConnectBoxDOCSIS-3.0/tags) [Activity](/filipi86/ConnectBoxDOCSIS-3.0/activity)
 [Star](/login?return_to=%2Ffilipi86%2FConnectBoxDOCSIS-3.0)

 [Notifications](/login?return_to=%2Ffilipi86%2FConnectBoxDOCSIS-3.0) You must be signed in to change notification settings

* [Code](/filipi86/ConnectBoxDOCSIS-3.0)
* [Issues
  0](/filipi86/ConnectBoxDOCSIS-3.0/issues)
* [Pull requests
  0](/filipi86/ConnectBoxDOCSIS-3.0/pulls)
* [Actions](/filipi86/ConnectBoxDOCSIS-3.0/actions)
* [Projects
  0](/filipi86/ConnectBoxDOCSIS-3.0/projects)
* [Security](/filipi86/ConnectBoxDOCSIS-3.0/security)
* [Insights](/filipi86/ConnectBoxDOCSIS-3.0/pulse)

Additional navigation options

* [Code](/filipi86/ConnectBoxDOCSIS-3.0)
* [Issues](/filipi86/ConnectBoxDOCSIS-3.0/issues)
* [Pull requests](/filipi86/ConnectBoxDOCSIS-3.0/pulls)
* [Actions](/filipi86/ConnectBoxDOCSIS-3.0/actions)
* [Projects](/filipi86/ConnectBoxDOCSIS-3.0/projects)
* [Security](/filipi86/ConnectBoxDOCSIS-3.0/security)
* [Insights](/filipi86/ConnectBoxDOCSIS-3.0/pulse)

# filipi86/ConnectBoxDOCSIS-3.0

    master[Branches](/filipi86/ConnectBoxDOCSIS-3.0/branches)[Tags](/filipi86/ConnectBoxDOCSIS-3.0/tags)Go to fileCode
## Folders and files

| Name | | Name | Last commit message | Last commit date |
| --- | --- | --- | --- | --- |
| Latest commit History[38 Commits](/filipi86/ConnectBoxDOCSIS-3.0/commits/master/) | | |
| [README.md](/filipi86/ConnectBoxDOCSIS-3.0/blob/master/README.md "README.md") | | [README.md](/filipi86/ConnectBoxDOCSIS-3.0/blob/master/README.md "README.md") |  |  |
| View all files | | |

## Repository files navigation

* README
# ConnectBoxDOCSIS-3.0

**Exploiting Connect Box EuroDOCSIS 3.0 Voice Gateway CH7465LG-NCIP-6.12.18.25-2p6-NOSH**

**CVE-2019-19967** - <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19967>

**National Vulnerability Database - NVD** - <https://nvd.nist.gov/vuln/detail/CVE-2019-19967>

**Description**

The Administration page on Connect Box EuroDOCSIS 3.0 Voice Gateway CH7465LG-NCIP-6.12.18.25-2p6-NOSH devices accepts a cleartext password in a POST request on port 80, as demonstrated by the Password field to the xml/setter.xml URI.

============================================================================

# ConnectBoxDOCSIS-3.0

[![connect_box_1_modem](https://user-images.githubusercontent.com/31785433/71375371-48959d00-25be-11ea-99fc-6b23375f89c6.png)](https://user-images.githubusercontent.com/31785433/71375371-48959d00-25be-11ea-99fc-6b23375f89c6.png)

The Connect Box is the worldwide most compact EuroDOCSIS 3.0 Voice Gateway which provides the ideal all-in-one wired and wireless solution, designed for your home, home office, or small business/enterprise.

It can be used in households with one or more computers capable of wireless connectivity for remote access to the wireless gateway.

============================================================================

The purpose of this exploration is to validate the security applied to the standard implementation of the router, as well as to guarantee the application of the main security models, whether in a home user or in a corporate environment.
We performed this proof of concept to get obtain the administrator credentials of the Connect Box DOCSIS 3.0 Voice Gateway router, it was possible to successfully perform, when sniffing the HTTP traffic packets, within the same tested network, when we perform some tests we discover a vulnerability in this router in the Authentication process known as Cleartext Transmission of Sensitive Information.
After discovering this flaw, we communicated the manufacturer about it, which put us in contact with the development team to assist in the improvement process, we also registered this failure through CVE - CVE-2019-19967
Using Wireshark for packet capture and a Firefox browser to access the router management panel, it was possible to realize that admin credentials were passed in clear text, and not applied nothing of security, we could said the simple Basic Authentication (ie.Base64-encoded), as shown in the images below:

**Victim 1**

[![Victim1](https://user-images.githubusercontent.com/31785433/71374644-bf7d6680-25bb-11ea-853f-44db27933398.png)](https://user-images.githubusercontent.com/31785433/71374644-bf7d6680-25bb-11ea-853f-44db27933398.png)

**Victim 2**

[![Victim2](https://user-images.githubusercontent.com/31785433/71374789-534f3280-25bc-11ea-86a0-b6b16735e8c9.png)](https://user-images.githubusercontent.com/31785433/71374789-534f3280-25bc-11ea-86a0-b6b16735e8c9.png)

**Attacker**

[![Attacker](https://user-images.githubusercontent.com/31785433/71374788-534f3280-25bc-11ea-9b46-623b28997933.png)](https://user-images.githubusercontent.com/31785433/71374788-534f3280-25bc-11ea-9b46-623b28997933.png)

**PoC in Video**

Here we can see three different Virtual Machines connecting in the same networking

**Access in the environment**

In this video below, We can see the all Attacker Machine using **Wireshark** to sniff the network, we realize two attempts to login in Administration page.

[![Access](https://camo.githubusercontent.com/0f3a9bcfede1ad704e587ccbc2e0c52c4b00fd74114813501a4f99cd9d4c55c6/68747470733a2f2f692e76696d656f63646e2e636f6d2f66696c7465722f6f7665726c61793f737263303d6874747073253341253246253246692e76696d656f63646e2e636f6d253246766964656f2532463834313835383331345f31323830783732302e6a706726737263313d6874747073253341253246253246662e76696d656f63646e2e636f6d253246696d616765735f76362532467368617265253246706c61795f69636f6e5f6f7665726c61792e706e67)](https://vimeo.com/381213952)

**WireShark**

Here, as we can see, we try acess with the password "admin", however we receive the "login incorrect", but when tha victim machine try to connect with the correct login, the wireshark receive the passaword in **clear text** as we can see.

[![Wiresharl](https://camo.githubusercontent.com/fc16f61aad41fc6c91c1f5e4dcc8d73b57f58bea3c1dd6139c9a4a4a8061e9b3/68747470733a2f2f692e76696d656f63646e2e636f6d2f66696c7465722f6f7665726c61793f737263303d6874747073253341253246253246692e76696d656f63646e2e636f6d253246766964656f2532463834313835383334375f31323830783732302e6a706726737263313d6874747073253341253246253246662e76696d656f63646e2e636f6d253246696d616765735f76362532467368617265253246706c61795f69636f6e5f6f7665726c61792e706e67)](https://vimeo.com/381213996)

**Pcap Analysis**

Here, we can see, a pcap file receive in kali linux machine, when we can open in the wireshark and we analyse this file, we can see the same behavior in about Authentication without simple protection.

[![Access](https://camo.githubusercontent.com/7652fcf6a20112f711baa192fc9c654e78c787e70f352f28095a052dc1bb83b4/68747470733a2f2f692e76696d656f63646e2e636f6d2f66696c7465722f6f7665726c61793f737263303d6874747073253341253246253246692e76696d656f63646e2e636f6d253246766964656f2532463834313835383333375f31323830783732302e6a706726737263313d6874747073253341253246253246662e76696d656f63646e2e636f6d253246696d616765735f76362532467368617265253246706c61795f69636f6e5f6f7665726c61792e706e67)](https://vimeo.com/381213980)

**Manufacturer**

After discovering this flaw, we communicated(31/12/2020) the manufacturer about it, which put us in contact with the development team to assist in the improvement process (27/01/2020)
LASTUPDATE - 24/02/2020 by Manufacture
"What I can tell you is that this issue was discovered previously...but is hard to say when this will be fixed as the real vulnerability of this risk is very low"

**Publications**

<https://pentestmag.com/product/pentest-build-your-own-pentest-lab-in-2020/>

[https://www.linkedin.com/feed/update/urn:li:activity:6633366352042307585/](https://www.linkedin.com/feed/update/urn%3Ali%3Aactivity%3A6633366352042307585/)

[https://medium.com/@filipi86/router-exploiting-6ddd0aed2ddf](https://medium.com/%40filipi86/router-exploiting-6ddd0aed2ddf)

**References**

<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19967>

<https://nvd.nist.gov/vuln/detail/CVE-2019-19967>

<https://github.com/filipi86/ConnectBoxDOCSIS-3.0>

RFC 2660 - <https://tools.ietf.org/html/rfc2660>

RFC 7231 - <https://tools.ietf.org/html/rfc7231>

RFC 2818 - <https://tools.ietf.org/html/rfc2818>

RFC 2612 - <https://tools.ietf.org/html/rfc2616>

<http://cwe.mitre.org/data/definitions/319.html>

Official Document form UPC - <https://www.upc.ch/pdf/support/manuals/en/internet/ConnectBox/connect-box-manual.pdf>

## About

The Connect Box is the worldwide most compact EuroDOCSIS 3.0 Voice Gateway which provides the ideal all-in-one wired and wireless solution, designed for your home, home office, or small business/enterprise. It can be used in households with one or more computers capable of wireless connectivity for remote access to the wireless gateway.

### Resources

[Readme](#readme-ov-file)

[Activity](/filipi86/ConnectBoxDOCSIS-3.0/activity)
### Stars

[**9**
stars](/filipi86/ConnectBoxDOCSIS-3.0/stargazers)
### Watchers

[**2**
watching](/filipi86/ConnectBoxDOCSIS-3.0/watchers)
### Forks

[**1**
fork](/filipi86/ConnectBoxDOCSIS-3.0/forks)
[Report repository](/contact/report-content?content_url=https%3A%2F%2Fgithub.com%2Ffilipi86%2FConnectBoxDOCSIS-3.0&report=filipi86+%28user%29)

## [Releases](/filipi86/ConnectBoxDOCSIS-3.0/releases)

No releases published

## [Packages 0](/users/filipi86/packages?repo_name=ConnectBoxDOCSIS-3.0)

No packages published

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from medium.com_c9310a40_20250121_031615.html ===
[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F6ddd0aed2ddf&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---top_nav_layout_nav----------------------------------)

Sign up

[Sign in](/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2Fcoreshield%2Frouter-exploiting-6ddd0aed2ddf&source=post_page---top_nav_layout_nav-----------------------global_nav-----------)

[Write](/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---top_nav_layout_nav-----------------------new_post_topnav-----------)

Sign up

[Sign in](/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2Fcoreshield%2Frouter-exploiting-6ddd0aed2ddf&source=post_page---top_nav_layout_nav-----------------------global_nav-----------)

![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)
# Router Exploiting

[![Filipi Pires](https://miro.medium.com/v2/resize:fill:88:88/1*f988jsRYWvTYjvLPkpj0Bw.png)](/%40filipi86?source=post_page---byline--6ddd0aed2ddf--------------------------------)[![CoreShield](https://miro.medium.com/v2/resize:fill:48:48/1*RUGYLK6N1LTlJr7WIQvFow.png)](https://medium.com/coreshield?source=post_page---byline--6ddd0aed2ddf--------------------------------)

[Filipi Pires](/%40filipi86?source=post_page---byline--6ddd0aed2ddf--------------------------------)

·

[Follow](/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F7c5ea898d3fc&operation=register&redirect=https%3A%2F%2Fmedium.com%2Fcoreshield%2Frouter-exploiting-6ddd0aed2ddf&user=Filipi+Pires&userId=7c5ea898d3fc&source=post_page-7c5ea898d3fc--byline--6ddd0aed2ddf---------------------post_header-----------)

Published in[CoreShield](https://medium.com/coreshield?source=post_page---byline--6ddd0aed2ddf--------------------------------)·6 min read·Apr 4, 2020

--

Listen

Share

# Exploiting **Connect Box EuroDOCSIS 3.0**

# **Abstract**

*Nowadays, routers are an integral part of today’s home and small office networks. Usually, these kind of devices are implemented in many places with default configuration and are, typically, managed by people who do not have any special technical knowledge. Often poorly configured and vulnerable, such devices are an easy target for network-based attacks, allowing cyber-criminals to quickly and easily gain control over a network. I bet you heard the latest news about the “Infected 500,000 Devices That Could Cut Users Off From The Internet”. Over Half a Million Routers Infected by Destructive VPNFilter Malware. In this article we explain how to get admin credentials the in Connect Box DOCSIS 3.0 Voice Gateway router it was possible sniffing the HTTP traffic packets, within the same tested network, and perform some tests it is possible discover a vulnerability in the authentication process known as Cleartext Transmission of Sensitive Information. This router that has been tested is in Poland by the internet service provider UPC. This company provides services in many EU countries. This flaw it is register in through CVE — CVE-2019–19967 (https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19967) and according* ***National Vulnerability Database-NVD*** *this vulnerability has been signed by basescore : 7.5 high (https://nvd.nist.gov/vuln/detail/CVE-2019-19967).*

*Keywords: Router Exploitation, Security, CyberSecurity.*

# Connect Box — UPC Router

The Connect Box is the worldwide most compact EuroDOCSIS 3.0 Voice Gateway which provides the ideal all-in-one wired and wireless solution, designed for your home, home office, or small business/enterprise. It can be used in households with one or more computers capable of wireless connectivity for remote access to the wireless gateway.

![]()

Source: google images

The purpose of this exploration is to validate the security applied to the standard implementation of the router, as well as to guarantee the application of the main security models, whether in a home user or in a corporate environment.

We performed this proof of concept to get obtain the administrator credentials of the Connect Box DOCSIS 3.0 Voice Gateway router, it was possible to successfully perform, when sniffing the HTTP traffic packets, within the same tested network, when we perform some tests we discover a vulnerability in this router in the Authentication process known as **Cleartext Transmission of Sensitive Information.**

After discovering this flaw, we communicated the manufacturer about it, which put us in contact with the development team to assist in the improvement process, we also registered this failure through CVE — CVE-2019–19967 (https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19967)

This router that has been tested is in Poland by the internet service provider UPC. This company provides services in many EU countries.

# Understanding Authentication Process

The first step in this kind of exploration is to understand how the application handles with the authentication process, as well as, the responses that are “*printed*” on the authentication page.

![]()

Figure 1: created by owner (2020)

When put this information in the application (tried “*admin*” access), we received the error return, as you can see in figure 1, but the text in the box, doesn’t in password for, after that, as you can see in the in figure 2, about the input form it is with *type* as “text”.

![]()

Figure 2: created by owner (2020)

In this case, a recommendation it is use in the input form to this authentication input **type=password**, as you can see in the figure 3. However, this would be just a visual protection, we still can’t know how the password treatment is done, when and how authentication is performed, for that we need to use some network sniffer to check how this request and return authentication works in the network communication.

![]()

Figure 3: created by owner (2020)

# **Looking Network Communication**

I have been used the attacker machine with the **IP Address: 192.168.0.45** to run the **Wireshark** and received all traffic the network, after that I’ve used victim machine — **Victim 1–192.168.0.80**

![]()

Figure 5: **Victim Machine**
 created by owner (2020)

![]()

Figure 5: **Attacker Machine**
 created by owner (2020)

# **Wireshark Analysis.**

We tried to access with the password “*admin*”, however we receive the “login incorrect” information printed in the web page, so we went to see how Wireshark received this Authentication, my intention here, it was to discovery, what kind of encryption for authentication the application have used, but for my surprise, as you can see in the figure 6, the authentication not use none encrypt process the password is pass in the network in clear text, in this case we can to think about vulnerability known by MITRE as **Cleartext Transmission of Sensitive Information** ([http://cwe.mitre.org/data/definitions/319.html)](http://cwe.mitre.org/data/definitions/319.html%29.)

![]()

Figure 6: created by owner (2020)

So now, we just need to receive a valid authentication, when you try to connect with your correct password, just be happy, because the Admin Authentication, it will be in ClearText, for anyone that is receiving network traffic in the same network.

![]()

Figure 7: created by owner (2020)

Another important poins is, If an attacker has access on this pcap file in other machine, as you can see in windows machine below (figure 8), when this attacker opens in the Wireshark and he starts to analyze this file, we can see the same behavior in authentication process in clear text without simple protection.

![]()

Figure 8: created by owner (2020)

# **Conclusion**

As we can see in this article, a simple cryptographic flaw in the process of web page authentication, can greatly compromise the security of a home user when a company that use this router, this vulnerability it is known as the software transmits sensitive or security-critical data in cleartext in a communication channel that can be sniffed by unauthorized actor and it was signed as CVE-2019–19967 (https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19967)

You can configure a web application with some type of hidden, encoded, protection, or then some authentication with encryption, or based on some token, so there are many ways to increase the security level of your router.

So, I recommend reading some RFC — HTTP Hypertext Transfer Protocol, to understand the operation, as well as ways of protection.

# Publications

[## PenTest: Build Your Own Pentest Lab in 2020

### Dear PenTest Readers, We are extremely happy to present you the first 2020 edition of PenTest Mag! The main focus of…

pentestmag.com](https://pentestmag.com/product/pentest-build-your-own-pentest-lab-in-2020/?source=post_page-----6ddd0aed2ddf--------------------------------)[## The Cyber Security Hub™ posted on LinkedIn

### Research paper: Exploiting Connect Box - via Filipi Pires...

www.linkedin.com](https://www.linkedin.com/feed/update/urn%3Ali%3Aactivity%3A6633366352042307585/?source=post_page-----6ddd0aed2ddf--------------------------------)[## filipi86/ConnectBoxDOCSIS-3.0

### The Connect Box is the worldwide most compact EuroDOCSIS 3.0 Voice Gateway which provides the ideal all-in-one wired…

github.com](https://github.com/filipi86/ConnectBoxDOCSIS-3.0?source=post_page-----6ddd0aed2ddf--------------------------------)
# **References**

<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19967> — Access at 16/01/2020
<https://nvd.nist.gov/vuln/detail/CVE-2019-19967> — Access at 27/08/2020
<https://github.com/filipi86/ConnectBoxDOCSIS-3.0> — Access at 16/01/2020
RFC 2660 — <https://tools.ietf.org/html/rfc2660> — Access at 16/01/2020
RFC 7231 — <https://tools.ietf.org/html/rfc7231> — Access at 16/01/2020
RFC 2818 — <https://tools.ietf.org/html/rfc2818> — Access at 16/01/2020
RFC 2612 — <https://tools.ietf.org/html/rfc2616> — Access at 16/01/2020
<http://cwe.mitre.org/data/definitions/319.html> — Acess at 27/01/2020
Official Document form UPC — <https://www.upc.ch/pdf/support/manuals/en/internet/ConnectBox/connect-box-manual.pdf> — Access at 16/01/2020

[Router Exploitation](/tag/router-exploitation?source=post_page-----6ddd0aed2ddf--------------------------------)[Security](/tag/security?source=post_page-----6ddd0aed2ddf--------------------------------)[Cybersecurity](/tag/cybersecurity?source=post_page-----6ddd0aed2ddf--------------------------------)[Hacking](/tag/hacking?source=post_page-----6ddd0aed2ddf--------------------------------)[Vulnerability](/tag/vulnerability?source=post_page-----6ddd0aed2ddf--------------------------------)

--

--

[![CoreShield](https://miro.medium.com/v2/resize:fill:96:96/1*RUGYLK6N1LTlJr7WIQvFow.png)](https://medium.com/coreshield?source=post_page---post_publication_info--6ddd0aed2ddf--------------------------------)[![CoreShield](https://miro.medium.com/v2/resize:fill:128:128/1*RUGYLK6N1LTlJr7WIQvFow.png)](https://medium.com/coreshield?source=post_page---post_publication_info--6ddd0aed2ddf--------------------------------)[## Published in CoreShield](https://medium.com/coreshield?source=post_page---post_publication_info--6ddd0aed2ddf--------------------------------)[40 Followers](/coreshield/followers?source=post_page---post_publication_info--6ddd0aed2ddf--------------------------------)·[Last published Dec 10, 2020](/coreshield/fireeye-hacked-b710f716b5ec?source=post_page---post_publication_info--6ddd0aed2ddf--------------------------------)

We work at ZUP IT and research new technologies and new ways to make Information Security an Cool Experience

[![Filipi Pires](https://miro.medium.com/v2/resize:fill:96:96/1*f988jsRYWvTYjvLPkpj0Bw.png)](/%40filipi86?source=post_page---post_author_info--6ddd0aed2ddf--------------------------------)[![Filipi Pires](https://miro.medium.com/v2/resize:fill:128:128/1*f988jsRYWvTYjvLPkpj0Bw.png)](/%40filipi86?source=post_page---post_author_info--6ddd0aed2ddf--------------------------------)Follow[## Written by Filipi Pires](/%40filipi86?source=post_page---post_author_info--6ddd0aed2ddf--------------------------------)[40 Followers](/%40filipi86/followers?source=post_page---post_author_info--6ddd0aed2ddf--------------------------------)·[19 Following](/%40filipi86/following?source=post_page---post_author_info--6ddd0aed2ddf--------------------------------)

Global Threat Researcher and CyberSecurity Advocate, Speaker at events in many countries such as US, Canada, France, Spain, Germany, Poland, and others

Follow
## No responses yet

[Help](https://help.medium.com/hc/en-us?source=post_page-----6ddd0aed2ddf--------------------------------)[Status](https://medium.statuspage.io/?source=post_page-----6ddd0aed2ddf--------------------------------)[About](/about?autoplay=1&source=post_page-----6ddd0aed2ddf--------------------------------)[Careers](/jobs-at-medium/work-at-medium-959d1a85284e?source=post_page-----6ddd0aed2ddf--------------------------------)[Press](pressinquiries%40medium.com?source=post_page-----6ddd0aed2ddf--------------------------------)[Blog](https://blog.medium.com/?source=post_page-----6ddd0aed2ddf--------------------------------)[Privacy](https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----6ddd0aed2ddf--------------------------------)[Terms](https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----6ddd0aed2ddf--------------------------------)[Text to speech](https://speechify.com/medium?source=post_page-----6ddd0aed2ddf--------------------------------)[Teams](/business?source=post_page-----6ddd0aed2ddf--------------------------------)



=== Content from tools.ietf.org_1280ac87_20250121_031613.html ===


* Light
* Dark
* Auto

[RFC 2660

Historic](/doc/rfc2660/)

|  | Title |  | The Secure HyperText Transfer Protocol |
| --- | --- | --- | --- |
| Document | Document type |  | RFC - Historic  August 1999  [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") Status changed by [status-change-http-experiments-to-historic](/doc/status-change-http-experiments-to-historic/ "Status change of HTTP experiments to Historic") Was [draft-ietf-wts-shttp](/doc/draft-ietf-wts-shttp/06/) ([wts WG](/wg/wts/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [06](/doc/html/draft-ietf-wts-shttp-06) * [RFC 2660](/doc/html/rfc2660) |
|  | Compare versions |  | RFC 2660  draft-ietf-wts-shttp-06  draft-ietf-wts-shttp-05  draft-ietf-wts-shttp-04  draft-ietf-wts-shttp-03  draft-ietf-wts-shttp-02  draft-ietf-wts-shttp-01   RFC 2660  draft-ietf-wts-shttp-06  draft-ietf-wts-shttp-05  draft-ietf-wts-shttp-04  draft-ietf-wts-shttp-03  draft-ietf-wts-shttp-02  draft-ietf-wts-shttp-01   Side-by-side  Inline |
|  | Authors |  | [Eric Rescorla](/person/ekr%40rtfm.com "Datatracker profile of Eric Rescorla") , [Allan M. Schiffman](/person/ams%40terisa.com "Datatracker profile of Allan M. Schiffman")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc2660.txt) [html](https://www.rfc-editor.org/rfc/rfc2660.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc2660.txt.pdf) [bibtex](/doc/rfc2660/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](http://www-ns.rutgers.edu/www-security) |
|  |  |  | [Report a bug](https://github.com/ietf-tools/datatracker/issues/new/choose) |

```
Network Working Group                                       E. Rescorla
Request for Comments: 2660                                   RTFM, Inc.
Category: Experimental                                     A. Schiffman
                                                   Terisa Systems, Inc.
                                                            August 1999

                 The Secure HyperText Transfer Protocol

Status of this Memo

   This memo defines an Experimental Protocol for the Internet
   community.  It does not specify an Internet standard of any kind.
   Discussion and suggestions for improvement are requested.
   Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

Abstract

   This memo describes a syntax for securing messages sent using the
   Hypertext Transfer Protocol (HTTP), which forms the basis for the
   World Wide Web. Secure HTTP (S-HTTP) provides independently
   applicable security services for transaction confidentiality,
   authenticity/integrity and non-repudiability of origin.

   The protocol emphasizes maximum flexibility in choice of key
   management mechanisms, security policies and cryptographic algorithms
   by supporting option negotiation between parties for each
   transaction.

Table of Contents

   [1](#section-1). Introduction .................................................. [3](#page-3)
   [1.1](#section-1.1). Summary of Features ......................................... [3](#page-3)
   [1.2](#section-1.2). Changes ..................................................... [4](#page-4)
   [1.3](#section-1.3). Processing Model ............................................ [5](#page-5)
   [1.4](#section-1.4). Modes of Operation .......................................... [6](#page-6)
   [1.5](#section-1.5). Implementation Options ...................................... [7](#page-7)
   [2](#section-2). Message Format ................................................ [7](#page-7)
   [2.1](#section-2.1). Notational Conventions ...................................... [8](#page-8)
   [2.2](#section-2.2). The Request Line ............................................ [8](#page-8)
   [2.3](#section-2.3). The Status Line ............................................. [8](#page-8)
   [2.4](#section-2.4). Secure HTTP Header Lines .................................... [8](#page-8)
   [2.5](#section-2.5). Content .....................................................[12](#page-12)
   [2.6](#section-2.6). Encapsulation Format Options ................................[13](#page-13)

Rescorla & Schiffman          Experimental                      [Page 1]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   [2.6.1](#section-2.6.1). Content-Privacy-Domain: CMS ...............................[13](#page-13)
   [2.6.2](#section-2.6.2). Content-Privacy-Domain: MOSS ..............................[14](#page-14)
   [2.6.3](#section-2.6.3). Permitted HTTP headers ....................................[14](#page-14)
   [2.6.3.2](#section-2.6.3.2). Host ....................................................[15](#page-15)
   [2.6.3.3](#section-2.6.3.3). Connection ..............................................[15](#page-15)
   [3](#section-3). Cryptographic Parameters ......................................[15](#page-15)
   [3.1](#section-3.1). Options Headers .............................................[15](#page-15)
   [3.2](#section-3.2). Negotiation Options .........................................[16](#page-16)
   [3.2.1](#section-3.2.1). Negotiation Overview ......................................[16](#page-16)
   [3.2.2](#section-3.2.2). Negotiation Option Format .................................[16](#page-16)
   [3.2.3](#section-3.2.3). Parametrization for Variable-length Key Ciphers ...........[18](#page-18)
   [3.2.4](#section-3.2.4). Negotiation Syntax ........................................[18](#page-18)
   [3.3](#section-3.3). Non-Negotiation Headers .....................................[23](#page-23)
   [3.3.1](#section-3.3.1). Encryption-Identity .......................................[23](#page-23)
   [3.3.2](#section-3.3.2). Certificate-Info ..........................................[23](#page-23)
   [3.3.3](#section-3.3.3). Key-Assign ................................................[24](#page-24)
   [3.3.4](#section-3.3.4). Nonces ....................................................[25](#page-25)
   [3.4](#section-3.4). Grouping Headers With SHTTP-Cryptopts .......................[26](#page-26)
   [3.4.1](#section-3.4.1). SHTTP-Cryptopts ...........................................[26](#page-26)
   [4](#section-4). New Header Lines for HTTP .....................................[26](#page-26)
   [4.1](#section-4.1). Security-Scheme .............................................[26](#page-26)
   [5](#section-5). (Retriable) Server Status Error Reports .......................[27](#page-27)
   [5.1](#section-5.1). Retry for Option (Re)Negotiation ............................[27](#page-27)
   [5.2](#section-5.2). Specific Retry Behavior .....................................[28](#page-28)
   [5.3](#section-5.3). Limitations On Automatic Retries ............................[29](#page-29)
   [6](#section-6). Other Issues ..................................................[30](#page-30)
   [6.1](#section-6.1). Compatibility of Servers with Old Clients ...................[30](#page-30)
   [6.2](#section-6.2). URL Protocol Type ...........................................[30](#page-30)
   [6.3](#section-6.3). Browser Presentation ........................................[31](#page-31)
   [7](#section-7). Implementation Notes ..........................................[32](#page-32)
   [7.1](#section-7.1). Preenhanced Data ............................................[32](#page-32)
   [7.2](#section-7.2). Note:Proxy Interaction ......................................[34](#page-34)
   [7.2.1](#section-7.2.1). Client-Proxy Authentication ...............................[34](#page-34)
   [8](#section-8). Implementation Recommendations and Requirements ...............[34](#page-34)
   [9](#section-9). Protocol Syntax Summary .......................................[35](#page-35)
   [10](#section-10). An Extended Example ..........................................[36](#page-36)
   Appendix: A Review of CMS ........................................[40](#page-40)
   Bibliography and References ......................................[41](#page-41)
   Security Considerations ..........................................[43](#page-43)
   Authors' Addresses ...............................................[44](#page-44)
   Full Copyright Statement..........................................[45](#page-45)

Rescorla & Schiffman          Experimental                      [Page 2]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[1](#section-1).  Introduction

   The World Wide Web (WWW) is a distributed hypermedia system which has
   gained widespread acceptance among Internet users.  Although WWW
   browsers support other, preexisting Internet application protocols,
   the native and primary protocol used between WWW clients and servers
   is the HyperText Transfer Protocol (HTTP) [[RFC-2616](/doc/html/rfc2616)].  The ease of
   use of the Web has prompted its widespread employment as a
   client/server architecture for many applications.  Many such
   applications require the client and server to be able to authenticate
   each other and exchange sensitive information confidentially. The
   original HTTP specification had only modest support for the
   cryptographic mechanisms appropriate for such transactions.

   Secure HTTP (S-HTTP) provides secure communication mechanisms between
   an HTTP client-server pair in order to enable spontaneous commercial
   transactions for a wide range of applications.  Our design intent is
   to provide a flexible protocol that supports multiple orthogonal
   operation modes, key management mechanisms, trust models,
   cryptographic algorithms and encapsulation formats through option
   negotiation between parties for each transaction.

[1.1](#section-1.1).  Summary of Features

   Secure HTTP is a secure message-oriented communications protocol
   designed for use in conjunction with HTTP. It is designed to coexist
   with HTTP's messaging model and to be easily integrated with HTTP
   applications.

   Secure HTTP provides a variety of security mechanisms to HTTP clients
   and servers, providing the security service options appropriate to
   the wide range of potential end uses possible for the World-Wide Web.
   The protocol provides symmetric capabilities to both client and
   server (in that equal treatment is given to both requests and
   replies, as well as for the preferences of both parties) while
   preserving the transaction model and implementation characteristics
   of HTTP.

   Several cryptographic message format standards may be incorporated
   into S-HTTP clients and servers, particularly, but in principle not
   limited to, [[CMS](#ref-CMS)] and [MOSS]. S-HTTP supports interoperation among a
   variety of implementations, and is compatible with HTTP.  S-HTTP
   aware clients can communicate with S-HTTP oblivious servers and
   vice-versa, although such transactions obviously would not use S-HTTP
   security features.

   S-HTTP does not require client-side public key certificates (or
   public keys), as it supports symmetric key-only operation modes.

Rescorla & Schiffman          Experimental                      [Page 3]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   This is significant because it means that spontaneous private
   transactions can occur without requiring individual users to have
   an established public key.  While S-HTTP is able to take advantage
   of ubiquitous certification infrastructures, its deployment does
   not require it.

   S-HTTP supports end-to-end secure transactions, in contrast with the
   original HTTP authorization mechanisms which require the client to
   attempt access and be denied before the security mechanism is
   employed.  Clients may be "primed" to initiate a secure transaction
   (typically using information supplied in message headers); this may
   be used to support encryption of fill-out forms, for example. With
   S-HTTP, no sensitive data need ever be sent over the network in the
   clear.

   S-HTTP provides full flexibility of cryptographic algorithms, modes
   and parameters. Option negotiation is used to allow clients and
   servers to agree on transaction modes (e.g., should the request be
   signed or encrypted or both -- similarly for the reply?);
   cryptographic algorithms (RSA vs. DSA for signing, DES vs.
   RC2 for encrypting, etc.); and certificate selection
   (please sign with your "Block-buster Video certificate").

   S-HTTP attempts to avoid presuming a particular trust model, although
   its designers admit to a conscious effort to facilitate
   multiply-rooted hierarchical trust, and anticipate that principals may
   have many public key certificates.

   S-HTTP differs from Digest-Authentication, described in [[RFC-2617](/doc/html/rfc2617)] in
   that it provides support for public key cryptography and consequently
   digital signature capability, as well as providing confidentiality.

[1.2](#section-1.2).  Changes

   This document describes S-HTTP/1.4. It differs from the previous
   memo in that it differs from the previous memo in its support of
   the Cryptographic Message Syntax (CMS) [[CMS](#ref-CMS)], a successor to PKCS-7;
   and hence now supports the Diffie-Hellman and the (NIST) Digital
   Signature Standard cryptosystems. CMS used in RSA mode is bits on the
   wire compatible with PKCS-7.

Rescorla & Schiffman          Experimental                      [Page 4]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[1.3](#section-1.3).  Processing Model

[1.3.1](#section-1.3.1).  Message Preparation

   The creation of an S-HTTP message can be thought of as a a function
   with three inputs:

      1. The cleartext message. This is either an HTTP message
      or some other data object. Note that since the cleartext message
      is carried transparently, headers and all, any version of HTTP
      can be carried within an S-HTTP wrapper.
      2. The receiver's cryptographic preferences and keying material.
      This is either explicitly specified by the receiver or subject
      to some default set of preferences.
      3. The sender's cryptographic preferences and keying material.
      This input to the function can be thought of as implicit
      since it exists only in the memory of the sender.

   In order to create an S-HTTP message, then, the sender integrates the
   sender's preferences with the receiver's preferences. The result of
   this is a list of cryptographic enhancements to be applied and keying
   material to be used to apply them. This may require some user
   intervention. For instance, there might be multiple keys available to
   sign the message. (See [Section 3.2.4.9.3](#section-3.2.4.9.3) for more on this topic.)
   Using this data, the sender applies the enhancements to the message
   clear-text to create the S-HTTP message.

   The processing steps required to transform the cleartext message into
   the S-HTTP message are described in Sections [2](#section-2) and [3](#section-3). The processing
   steps required to merge the sender's and receiver's preferences are
   described in Sections [3.2](#section-3.2).

[1.3.2](#section-1.3.2).  Message Recovery

   The recovery of an S-HTTP message can be thought of as a function of
   four distinct inputs:

      1. The S-HTTP message.
      2. The receiver's stated cryptographic preferences and keying
      material. The receiver has the opportunity to remember what
      cryptographic preferences it provided in order for this
      document to be dereferenced.
      3. The receiver's current cryptographic preferences and
      keying material.
      4. The sender's previously stated cryptographic options.
      The sender may have stated that he would perform certain
      cryptographic operations in this message. (Again, see
      sections [4](#section-4) and [5](#section-5) for details on how to do this.)

Rescorla & Schiffman          Experimental                      [Page 5]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   In order to recover an S-HTTP message, the receiver needs to read the
   headers to discover which cryptographic transformations were
   performed on the message, then remove the transformations using some
   combination of the sender's and receiver's keying material, while
   taking note of which enhancements were applied.

   The receiver may also choose to verify that the applied enhancements
   match both the enhancements that the sender said he would apply
   (input 4 above) and that the receiver requested (input 2 above) as
   well as the current preferences to see if the S-HTTP message was
   appropriately transformed. This process may require interaction with
   the user to verify that the enhancements are acceptable to the user.
   (See [Section 6.4](#section-6.4) for more on this topic.)

[1.4](#section-1.4).  Modes of Operation

   Message protection may be provided on three orthogonal axes:
   signature, authentication, and encryption. Any message may be signed,
   authenticated, encrypted, or any combination of these (including no
   protection).

   Multiple key management mechanisms are supported, including
   password-style manually shared secrets and public-key key exchange.
   In particular, provision has been made for prearranged (in an earlier
   transaction or out of band) symmetric session keys in order to send
   confidential messages to those who have no public key pair.

   Additionally, a challenge-response ("nonce") mechanism is provided to
   allow parties to assure themselves of transaction freshness.

[1.4.1](#section-1.4.1).  Signature

   If the digital signature enhancement is applied, an appropriate
   certificate may either be attached to the message (possibly along
   with a certificate chain) or the sender may expect the recipient to
   obtain the required certificate (chain) independently.

[1.4.2](#section-1.4.2).  Key Exchange and Encryption

   In support of bulk encryption, S-HTTP defines two key transfer
   mechanisms, one using public-key enveloped key exchange and another
   with externally arranged keys.

   In the former case, the symmetric-key cryptosystem parameter is
   passed encrypted under the receiver's public key.

Rescorla & Schiffman          Experimental                      [Page 6]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   In the latter mode, we encrypt the content using a prearranged
   session key, with key identification information specified on one of
   the header lines.

[1.4.3](#section-1.4.3).  Message Integrity and Sender Authentication

   Secure HTTP provides a means to verify message integrity and sender
   authenticity for a message via the computation of a Message
   Authentication Code (MAC), computed as a keyed hash over the document
   using a shared secret -- which could potentially have been arranged
   in a number of ways, e.g.: manual arrangement or 'inband' key
   management.  This technique requires neither the use of public key
   cryptography nor encryption.

   This mechanism is also useful for cases where it is appropriate to
   allow parties to identify each other reliably in a transaction
   without providing (third-party) non-repudiability for the
   transactions themselves. The provision of this mechanism is motivated
   by our bias that the action of "signing" a transaction should be
   explicit and conscious for the user, whereas many authentication
   needs (i.e., access control) can be met with a lighter-weight
   mechanism that retains the scalability advantages of public-key
   cryptography for key exchange.

[1.4.4](#section-1.4.4).  Freshness

   The protocol provides a simple challenge-response mechanism, allowing
   both parties to insure the freshness of transmissions. Additionally,
   the integrity protection provided to HTTP headers permits
   implementations to consider the Date: header allowable in HTTP
   messages as a freshness indicator, where appropriate (although this
   requires implementations to make allowances for maximum clock skew
   between parties, which we choose not to specify).

[1.5](#section-1.5).  Implementation Options

   In order to encourage widespread adoption of secure documents for the
   World-Wide Web in the face of the broad scope of application
   requirements, variability of user sophistication, and disparate
   implementation constraints, Secure HTTP deliberately caters to a
   variety of implementation options.  See [Section 8](#section-8) for implementation
   recommendations and requirements.

[2](#section-2).  Message Format

   Syntactically, Secure HTTP messages are the same as HTTP, consisting
   of a request or status line followed by headers and a body. However,
   the range of headers is different and the bodies are typically

Rescorla & Schiffman          Experimental                      [Page 7]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   cryptographically enhanced.

[2.1](#section-2.1).  Notational Conventions

   This document uses the augmented BNF from HTTP [[RFC-2616](/doc/html/rfc2616)]. You should
   refer to that document for a description of the syntax.

[2.2](#section-2.2).  Request Line

   In order to differentiate S-HTTP messages from HTTP messages and
   allow for special processing, the request line should use the special
   Secure" method and use the protocol designator "Secure-HTTP/1.4".
   Consequently, Secure-HTTP and HTTP processing can be intermixed on
   the same TCP port, e.g. port 80.  In order to prevent leakage of
   potentially sensitive information Request-URI should be "*". For
   example:

           Secure * Secure-HTTP/1.4

   When communicating via a proxy, the Request-URI should be consist of
   the AbsoluteURI. Typically, the rel path section should be replaced
   by "*" to minimize the information passed to in the clear.  (e.g.
   <http://www.terisa>.com/*); proxies should remove the appropriate
   amount of this information to minimize the threat of traffic
   analysis.  See [Section 7.2.2.1](#section-7.2.2.1) for a situation where providing more
   information is appropriate.

[2.3](#section-2.3).  The Status Line

   S-HTTP responses should use the protocol designator "Secure-
   HTTP/1.4".  For example:

           Secure-HTTP/1.4 200 OK

   Note that the status in the Secure HTTP response line does not
   indicate anything about the success or failure of the unwrapped HTTP
   request. Servers should always use 200 OK provided that the Secure
   HTTP processing is successful. This prevents analysis of success or
   failure for any request, which the correct recipient can determine
   from the encapsulated data. All case variations should be accepted.

[2.4](#section-2.4).  Secure HTTP Header Lines

   The header lines described in this section go in the header of a
   Secure HTTP message. All except 'Content-Type' and 'Content-Privacy-
   Domain' are optional. The message body shall be separated from the
   header block by two successive CRLFs.

Rescorla & Schiffman          Experimental                      [Page 8]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   All data and fields in header lines should be treated as case
   insensitive unless otherwise specified. Linear whitespace [[RFC-822](/doc/html/rfc822)]
   should be used only as a token separator unless otherwise quoted.
   Long header lines may be line folded in the style of [[RFC-822](/doc/html/rfc822)].

   This document refers to the header block following the S-HTTP
   request/response line and preceding the successive CRLFs collectively
   as "S-HTTP headers".

[2.4.1](#section-2.4.1).  Content-Privacy-Domain

   The two values defined by this document are 'MOSS' and 'CMS'.  CMS
   refers to the privacy enhancement specified in [section 2.6.1](#section-2.6.1). MOSS
   refers to the format defined in [[RFC-1847](/doc/html/rfc1847)] and [[RFC-1848](/doc/html/rfc1848)].

[2.4.2](#section-2.4.2).  Content-Type for CMS

   Under normal conditions, the terminal encapsulated content (after all
   privacy enhancements have been removed) would be an HTTP message. In
   this case, there shall be a Content-Type line reading:

           Content-Type: message/http

   The message/http content type is defined in [RFC-2616](/doc/html/rfc2616).

   If the inner message is an S-HTTP message, then the content type
   shall be 'application/s-http'. (See Appendix for the definition of
   this.)

   It is intended that these types be registered with IANA as MIME
   content types.

   The terminal content may be of some other type provided that the type
   is properly indicated by the use of an appropriate Content-Type
   header line. In this case, the header fields for the encapsulation of
   the terminal content apply to the terminal content (the 'final
   headers'). But in any case, final headers should themselves always be
   S-HTTP encapsulated, so that the applicable S-HTTP/HTTP headers are
   never passed unenhanced.

   S-HTTP encapsulation of non-HTTP data is a useful mechanism for
   passing pre-enhanced data (especially presigned data) without
   requiring that the HTTP headers themselves be pre-enhanced.

Rescorla & Schiffman          Experimental                      [Page 9]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[2.4.3](#section-2.4.3).  Content-Type for MOSS

   The Content-Type for MOSS shall be an acceptable MIME content type
   describing the cryptographic processing applied. (e.g.
   multipart/signed). The content type of the inner content is described
   in the content type line corresponding to that inner content, and for
   HTTP messages shall be 'message/http'.

[2.4.4](#section-2.4.4).  Prearranged-Key-Info

   This header line is intended to convey information about a key which
   has been arranged outside of the internal cryptographic format. One
   use of this is to permit in-band communication of session keys for
   return encryption in the case where one of the parties does not have
   a key pair. However, this should also be useful in the event that the
   parties choose to use some other mechanism, for instance, a one-time
   key list.

   This specification defines two methods for exchanging named keys,
   Inband, Outband. Inband indicates that the session key was exchanged
   previously, using a Key-Assign header of the corresponding method.
   Outband arrangements imply that agents have external access to key
   materials corresponding to a given name, presumably via database
   access or perhaps supplied immediately by a user from keyboard input.
   The syntax for the header line is:

     Prearranged-Key-Info =
      "Prearranged-Key-Info" ":" Hdr-Cipher "," CoveredDEK "," CoverKey-ID
     CoverKey-ID = method ":" key-name
     CoveredDEK = *HEX
     method = "inband" |  "outband"

   While chaining ciphers require an Initialization Vector (IV) [FIPS-
   81] to start off the chaining, that information is not carried by
   this field. Rather, it should be passed internal to the cryptographic
   format being used. Likewise, the bulk cipher used is specified in
   this fashion.

   <Hdr-Cipher> should be the name of the block cipher used to encrypt
   the session key (see [section 3.2.4.7](#section-3.2.4.7))

   <CoveredDEK> is the protected Data Encryption Key (a.k.a. transaction
   key) under which the encapsulated message was encrypted. It should be
   appropriately (randomly) generated by the sending agent, then
   encrypted under the cover of the negotiated key (a.k.a. session key)
   using the indicated header cipher, and then converted into hex.

Rescorla & Schiffman          Experimental                     [Page 10]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   In order to avoid name collisions, cover key namespaces must be
   maintained separately by host and port.

   Note that some Content-Privacy-Domains, notably likely future
   revisions of MOSS and CMS may have support for symmetric key
   management.

   The Prearranged-Key-Info field need not be used in such
   circumstances.  Rather, the native syntax is preferred. Keys
   exchanged with Key-Assign, however, may be used in this situation.

[2.4.5](#section-2.4.5).  MAC-Info

   This header is used to supply a Message Authenticity Check, providing
   both message authentication and integrity, computed from the message
   text, the time (optional -- to prevent replay attack), and a shared
   secret between client and server. The MAC should be computed over the
   encapsulated content of the S-HTTP message.  S-HTTP/1.1 defined that
   MACs should be computed using the following algorithm ('||' means
   concatenation):

        MAC = hex(H(Message||[<time>]||<shared key>))

   The time should be represented as an unsigned 32 bit quantity
   representing seconds since 00:00:00 GMT January 1, 1970 (the UNIX
   epoch), in network byte order. The shared key format is a local
   matter.

   Recent research [[VANO95](#ref-VANO95)] has demonstrated some weaknesses in this
   approach, and this memo introduces a new construction, derived from
   [[RFC-2104](/doc/html/rfc2104)]. In the name of backwards compatibility, we retain the
   previous constructions with the same names as before. However, we
   also introduce a new series of names (See [Section 3.2.4.8](#section-3.2.4.8) for the
   names) that obey a different (hopefully stronger) construction. (^
   means bitwise XOR)

   HMAC = hex(H(K' ^ pad2 || H(K' ^ pad1 ||[<time>]|| Message)))
   pad1 = the byte 0x36 repeated enough times to fill out a
                hash input block. (I.e. 64 times for both MD5 and SHA-1)
   pad2 = the byte 0x5c repeated enough times to fill out a
                hash input block.
   K' = H(<shared key>)

   The original HMAC construction is for the use of a key with length
   equal to the length of the hash output. Although it is considered
   safe to use a key of a different length (Note that strength cannot be
   increased past the length of the hash function itself, but can be
   reduced by using a shorter key.) [[KRAW96b](#ref-KRAW96b)] we hash the original key

Rescorla & Schiffman          Experimental                     [Page 11]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   to permit the use of shared keys (e.g. passphrases) longer than the
   length of the hash. It is noteworthy (though obvious) that this
   technique does not increase the strength of short keys.

   The format of the MAC-Info line is:

   MAC-Info =
   "MAC-Info" ":"  [hex-time],
   hash-alg, hex-hash-data, key-spec
   hex-time = <unsigned seconds since Unix epoch represented as HEX>
   hash-alg = <hash algorithms from [section 3.2.4.8](#section-3.2.4.8)>
   hex-hash-data = <computation as described above represented as HEX>
   Key-Spec = "null" | "dek" | Key-ID

   Key-Ids can refer either to keys bound using the Key-Assign header
   line or those bound in the same fashion as the Outband method
   described later. The use of a 'Null' key-spec implies that a zero
   length key was used, and therefore that the MAC merely represents a
   hash of the message text and (optionally) the time.  The special
   key-spec 'DEK' refers to the Data Exchange Key used to encrypt the
   following message body (it is an error to use the DEK key-spec in
   situations where the following message body is unencrypted).

   If the time is omitted from the MAC-Info line, it should simply not
   be included in the hash.

   Note that this header line can be used to provide a more advanced
   equivalent of the original HTTP Basic authentication mode in that the
   user can be asked to provide a username and password. However, the
   password remains private and message integrity can be assured.
   Moreover, this can be accomplished without encryption of any kind.

   In addition, MAC-Info permits fast message integrity verification (at
   the loss of non-repudiability) for messages, provided that the
   participants share a key (possibly passed using Key-Assign in a
   previous message).

   Note that some Content-Privacy-Domains, notably likely future
   revisions of MOSS and CMS may have support for symmetric integrity
   protection The MAC-Info field need not be used in such circumstances.
   Rather, the native syntax is preferred. Keys exchanged with Key-
   Assign, however, may be used in this situation.

[2.5](#section-2.5).  Content

   The content of the message is largely dependent upon the values of
   the Content-Privacy-Domain and Content-Transfer-Encoding fields.

Rescorla & Schiffman          Experimental                     [Page 12]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   For a CMS message, with '8BIT' Content-Transfer-Encoding, the content
   should simply be the CMS message itself.

   If the Content-Privacy-Domain is MOSS, the content should consist of
   a MOSS Security Multipart as described in [RFC1847](/doc/html/rfc1847).

   It is expected that once the privacy enhancements have been removed,
   the resulting (possibly protected) contents will be a normal HTTP
   request. Alternately, the content may be another Secure-HTTP message,
   in which case privacy enhancements should be unwrapped until clear
   content is obtained or privacy enhancements can no longer be removed.
   (This permits embedding of enhancements, such as sequential Signed
   and Enveloped enhancements.) Provided that all enhancements can be
   removed, the final de-enhanced content should be a valid HTTP request
   (or response) unless otherwise specified by the Content-Type line.

   Note that this recursive encapsulation of messages potentially
   permits security enhancements to be applied (or removed) for the
   benefit of intermediaries who may be a party to the transaction
   between a client and server (e.g., a proxy requiring client
   authentication).  How such intermediaries should indicate such
   processing is described in [Section 7.2.1](#section-7.2.1).

[2.6](#section-2.6).  Encapsulation Format Options

[2.6.1](#section-2.6.1).  Content-Privacy-Domain: CMS

   Content-Privacy-Domain 'CMS' follows the form of the CMS standard
   (see Appendix).

   Message protection may proceed on two orthogonal axes: signature and
   encryption. Any message may be either signed, encrypted, both, or
   neither. Note that the 'auth' protection mode of S-HTTP is provided
   independently of CMS coding via the MAC-Info header of [section 2.3.6](#section-2.3.6)
   since CMS does not support a 'KeyDigestedData' type, although it does
   support a 'DigestedData' type.

[2.6.1.1](#section-2.6.1.1).  Signature

   This enhancement uses the 'SignedData' type of CMS.  When digital
   signatures are used, an appropriate certificate may either be
   attached to the message (possibly along with a certificate chain) as
   specified in CMS or the sender may expect the recipient to obtain its
   certificate (and/or chain) independently.  Note that an explicitly
   allowed instance of this is a certificate signed with the private
   component corresponding to the public component being attested to.
   This shall be referred to as a self-signed certificate. What, if any,
   weight to give to such a certificate is a purely local matter.  In

Rescorla & Schiffman          Experimental                     [Page 13]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   either case, a purely signed message is precisely CMS compliant.

[2.6.1.2](#section-2.6.1.2).  Encryption

[2.6.1.2.1](#section-2.6.1.2.1).  Encryption -- normal, public key

   This enhancement is performed precisely as enveloping (using either '
   EnvelopedData' types) under CMS. A message encrypted in this fashion,
   signed or otherwise, is CMS compliant. To have a message which is
   both signed and encrypted, one simply creates the CMS SignedData
   production and encapsulates it in EnvelopedData as described in CMS.

[2.6.1.2.2](#section-2.6.1.2.2).  Encryption -- prearranged key

   This uses the 'EncryptedData' type of CMS. In this mode, we encrypt
   the content using a DEK encrypted under cover of a prearranged
   session key (how this key may be exchanged is discussed later), with
   key identification information specified on one of the header lines.
   The IV is in the EncryptedContentInfo type of the EncryptedData
   element.  To have a message which is both signed and encrypted, one
   simply creates the CMS SignedData production and encapsulates it in
   EncryptedData as described in CMS.

[2.6.2](#section-2.6.2).  Content-Privacy-Domain: MOSS

   The body of the message should be a MIME compliant message with
   content type that matches the Content-Type line in the S-HTTP
   headers.  Encrypted messages should use multipart/encrypted. Signed
   messages should use multipart/signed. However, since multipart/signed
   does not convey keying material, is is acceptable to use
   multipart/mixed where the first part is application/mosskey-data and
   the second part is multipart/mixed in order to convey certificates
   for use in verifying the signature.

   Implementation Note: When both encryption and signature are applied
   by the same agent, signature should in general be applied before
   encryption.

[2.6.3](#section-2.6.3).  Permitted HTTP headers

[2.6.3.1](#section-2.6.3.1).  Overview

   In general, HTTP [[RFC-2616](/doc/html/rfc2616)] headers should appear in the inner
   content (i.e. the message/http) of an S-HTTP message but should not
   appear in the S-HTTP message wrapper for security reasons. However,
   certain headers need to be visible to agents which do not have access
   to the encapsulated data. These headers may appear in the S-HTTP
   headers as well.

Rescorla & Schiffman          Experimental                     [Page 14]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   Please note that although brief descriptions of the general purposes
   of these headers are provided for clarity, the definitive reference
   is [[RFC-2616](/doc/html/rfc2616)].

[2.6.3.2](#section-2.6.3.2).  Host

   The host header specificies the internet host and port number of the
   resource being requested. This header should be used to disambiguate
   among multiple potential security contexts within which this message
   could be interpreted. Note that the unwrapped HTTP message will have
   it's own Host field (assuming it's an HTTP/1.1 message). If these
   fields do not match, the server should respond with a 400 status
   code.

[2.6.3.3](#section-2.6.3.3).  Connection

   The Connection field has precisely the same semantics in S-HTTP
   headers as it does in HTTP headers. This permits persistent
   connections to be used with S-HTTP.

[3](#section-3).  Cryptographic Parameters

[3.1](#section-3.1).  Options Headers

   As described in [Section 1.3.2](#section-1.3.2), every S-HTTP request is (at least
   conceptually) preconditioned by the negotiation options provided by
   the potential receiver. The two primary locations for these options
   are

           1. In the headers of an HTTP Request/Response.
           2. In the HTML which contains the anchor being dereferenced.

   There are two kinds of cryptographic options which may be provided:
   Negotiation options, as discussed in [Section 3.2](#section-3.2) convey a potential
   message recipient's cryptographic preferences. Keying options, as
   discussed in [Section 3.3](#section-3.3) provide keying material (or pointers to
   keying material) which may be of use to the sender when enhancing a
   message.

   Binding cryptographic options to anchors using HTML extensions is the
   topic of the companion document [[SHTML](#ref-SHTML)] and will not be treated here.

Rescorla & Schiffman          Experimental                     [Page 15]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[3.2](#section-3.2).  Negotiation Options

[3.2.1](#section-3.2.1).  Negotiation Overview

   Both parties are able to express their requirements and preferences
   regarding what cryptographic enhancements they will permit/require
   the other party to provide. The appropriate option choices depend on
   implementation capabilities and the requirements of particular
   applications.

   A negotiation header is a sequence of specifications each conforming
   to a four-part schema detailing:

        Property -- the option being negotiated, such as bulk encryption
        algorithm.

        Value -- the value being discussed for the property, such as
        DES-CBC

        Direction -- the direction which is to be affected, namely:
        during reception or origination (from the perspective of the
        originator).

        Strength -- strength of preference, namely: required, optional,
        refused

   As an example, the header line:

           SHTTP-Symmetric-Content-Algorithms: recv-optional=DES-CBC,RC2

   could be thought to say: "You are free to use DES-CBC or RC2 for bulk
   encryption for encrypting messages to me."

   We define new headers (to be used in the encapsulated HTTP header,
   not in the S-HTTP header) to permit negotiation of these matters.

[3.2.2](#section-3.2.2).  Negotiation Option Format

   The general format for negotiation options is:

           Option = Field ":" Key-val ";" *(Key-val)
           Key-val = Key "=" Value *("," Value)
           Key = Mode"-"Action             ; This is represented as one
                                           ; token without whitespace
           Mode = "orig" | "recv"
           Action = "optional" | "required" | "refused"

Rescorla & Schiffman          Experimental                     [Page 16]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   The <Mode> value indicates whether this <Key-val> refers to what the
   agent's actions are upon sending privacy enhanced messages as opposed
   to upon receiving them. For any given mode-action pair, the
   interpretation to be placed on the enhancements (<Value>s) listed is:

        'recv-optional:' The agent will process the enhancement if the
        other party uses it, but will also gladly process messages
        without the enhancement.

        'recv-required:' The agent will not process messages without
        this enhancement.

        'recv-refused:' The agent will not process messages with this
        enhancement.

        'orig-optional:' When encountering an agent which refuses this
        enhancement, the agent will not provide it, and when
        encountering an agent which requires it, this agent will provide
        it.

        'orig-required:' The agent will always generate the enhancement.

        'orig-refused:' The agent will never generate the enhancement.

   The behavior of agents which discover that they are communicating
   with an incompatible agent is at the discretion of the agents. It is
   inappropriate to blindly persist in a behavior that is known to be
   unacceptable to the other party. Plausible responses include simply
   terminating the connection, or, in the case of a server response,
   returning 'Not implemented 501'.

   Optional values are considered to be listed in decreasing order of
   preference. Agents are free to choose any member of the intersection
   of the optional lists (or none) however.

   If any <Key-Val> is left undefined, it should be assumed to be set to
   the default. Any key which is specified by an agent shall override
   any appearance of that key in any <Key-Val> in the default for that
   field.

Rescorla & Schiffman          Experimental                     [Page 17]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[3.2.3](#section-3.2.3).  Parametrization for Variable-length Key Ciphers

   For ciphers with variable key lengths, values may be parametrized
   using the syntax <cipher>'['<length>']'

   For example, 'RSA[1024]' represents a 1024 bit key for RSA. Ranges
   may be represented as

           <cipher>'['<bound1>'-'<bound2>']'

   For purposes of preferences, this notation should be treated as if it
   read (assuming x and y are integers)

           <cipher>[x], <cipher>[x+1],...<cipher>[y] (if x<y)

   and

           <cipher>[x], <cipher>[x-1],...<cipher>[y] (if x>y)

   The special value 'inf' may be used to denote infinite length.

   Using simply <cipher> for such a cipher shall be read as the maximum
   range possible with the given cipher.

[3.2.4](#section-3.2.4).  Negotiation Syntax

[3.2.4.1](#section-3.2.4.1).  SHTTP-Privacy-Domains

   This header refers to the Content-Privacy-Domain type of [section](#section-2.3.1)
   [2.3.1](#section-2.3.1). Acceptable values are as listed there. For instance,

                   SHTTP-Privacy-Domains: orig-required=cms;
                                          recv-optional=cms,MOSS

   would indicate that the agent always generates CMS compliant
   messages, but can read CMS or MOSS (or, unenhanced messages).

[3.2.4.2](#section-3.2.4.2).  SHTTP-Certificate-Types

   This indicates what sort of Public Key certificates the agent will
   accept. Currently defined values are 'X.509' and 'X.509v3'.

[3.2.4.3](#section-3.2.4.3).  SHTTP-Key-Exchange-Algorithms

   This header indicates which algorithms may be used for key exchange.
   Defined values are 'DH', 'RSA', 'Outband' and 'Inband'. DH refers to
   Diffie-Hellman X9.42 style enveloping. [DH] RSA refers to RSA
   enveloping. Outband refers to some sort of external key agreement.

Rescorla & Schiffman          Experimental                     [Page 18]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   Inband refers to [section 3.3.3.1](#section-3.3.3.1).

   The expected common configuration of clients having no certificates
   and servers having certificates would look like this (in a message
   sent by the server):

           SHTTP-Key-Exchange-Algorithms: orig-optional=Inband, DH;
                                         recv-required=DH

[3.2.4.4](#section-3.2.4.4).  SHTTP-Signature-Algorithms

   This header indicates what Digital Signature algorithms may be used.
   Defined values are 'RSA' [PKCS-1] and 'NIST-DSS' [[FIPS-186](#ref-FIPS-186)] Since
   NIST-DSS and RSA use variable length moduli the parametrization
   syntax of [section 3.2.3](#section-3.2.3) should be used.  Note that a key length
   specification may interact with the acceptability of a given
   certificate, since keys (and their lengths) are specified in public-
   key certificates.

[3.2.4.5](#section-3.2.4.5).  SHTTP-Message-Digest-Algorithms

   This indicates what message digest algorithms may be used.
   Previously defined values are 'RSA-MD2' [[RFC-1319](/doc/html/rfc1319)], 'RSA-MD5' [RFC-
   1321], 'NIST-SHS' [[FIPS-180](#ref-FIPS-180)].

[3.2.4.6](#section-3.2.4.6).  SHTTP-Symmetric-Content-Algorithms

   This header specifies the symmetric-key bulk cipher used to encrypt
   message content.  Defined values are:

   DES-CBC -- DES in Cipher Block Chaining (CBC) mode [[FIPS-81](#ref-FIPS-81)]
   DES-EDE-CBC -- 2 Key 3DES using Encrypt-Decrypt-Encrypt in outer
                  CBC mode
   DES-EDE3-CBC -- 3 Key 3DES using Encrypt-Decrypt-Encrypt in outer
                   CBC mode
   DESX-CBC -- RSA's DESX in CBC mode
   IDEA-CBC -- IDEA in CBC mode
   RC2-CBC -- RSA's RC2 in CBC mode
   CDMF-CBC -- IBM's CDMF (weakened key DES) [[JOHN93](#ref-JOHN93)] in CBC mode

   Since RC2 keys are variable length, the syntax of [section 3.2.3](#section-3.2.3)
   should be used.

Rescorla & Schiffman          Experimental                     [Page 19]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[3.2.4.7](#section-3.2.4.7).  SHTTP-Symmetric-Header-Algorithms

   This header specifies the symmetric-key cipher used to encrypt
   message headers.

   DES-ECB -- DES in Electronic Codebook (ECB) mode [[FIPS-81](#ref-FIPS-81)]
   DES-EDE-ECB -- 2 Key 3DES using Encrypt-Decrypt-Encrypt in ECB mode
   DES-EDE3-ECB -- 3 Key 3DES using Encrypt-Decrypt-Encrypt in ECB mode
   DESX-ECB -- RSA's DESX in ECB mode
   IDEA-ECB -- IDEA
   RC2-ECB -- RSA's RC2 in ECB mode
   CDMF-ECB -- IBM's CDMF in ECB mode

   Since RC2 is variable length, the syntax of [section 3.2.3](#section-3.2.3) should be
   used.

[3.2.4.8](#section-3.2.4.8).  SHTTP-MAC-Algorithms

   This header indicates what algorithms are acceptable for use in
   providing a symmetric key MAC. 'RSA-MD2', 'RSA-MD5' and 'NIST-SHS'
   persist from S-HTTP/1.1 using the old MAC construction. The tokens '
   RSA-MD2-HMAC', 'RSA-MD5-HMAC' and 'NIST-SHS-HMAC' indicate the new
   HMAC construction of 2.3.6 with the MD2, MD5, and SHA-1 algorithms
   respectively.

[3.2.4.9](#section-3.2.4.9).  SHTTP-Privacy-Enhancements

   This header indicates security enhancements to apply.  Possible
   values are 'sign', 'encrypt' and 'auth' indicating whether messages
   are signed, encrypted, or authenticated (i.e., provided with a MAC),
   respectively.

[3.2.4.10](#section-3.2.4.10).  Your-Key-Pattern

   This is a generalized pattern match syntax to describe identifiers
   for a large number of types of keying material. The general syntax
   is:

        Your-Key-Pattern =
                "Your-Key-Pattern" ":" key-use "," pattern-info
        key-use = "cover-key" | "auth-key" | "signing-key"

Rescorla & Schiffman          Experimental                     [Page 20]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[3.2.4.10.1](#section-3.2.4.10.1).  Cover Key Patterns

   This header specifies desired values for key names used for
   encryption of transaction keys using the Prearranged-Key-Info syntax
   of [section 2.3.5](#section-2.3.5).  The pattern-info syntax consists of a series of
   comma separated regular expressions. Commas should be escaped with
   backslashes if they appear in the regexps. The first pattern should
   be assumed to be the most preferred.

[3.2.4.10.2](#section-3.2.4.10.2).  Auth key patterns

   Auth-key patterns specify name forms desired for use for MAC
   authenticators.  The pattern-info syntax consists of a series of
   comma separated regular expressions. Commas should be escaped with
   backslashes if they appear in the regexps. The first pattern should
   be assumed to be the most preferred.

[3.2.4.10.3](#section-3.2.4.10.3).  Signing Key Pattern

   This parameter describes a pattern or patterns for what keys are
   acceptable for signing for the digital signature enhancement.  The
   pattern-info syntax for signing-key is:

           pattern-info = name-domain "," pattern-data

   The only currently defined name-domain is 'DN-1779'.  This parameter
   specifies desired values for fields of Distinguished Names.  DNs are
   considered to be represented as specified in [RFC1779](/doc/html/rfc1779), the order of
   fields and whitespace between fields is not significant.

   All [RFC1779](/doc/html/rfc1779) values should use ',' as a separator rather than ';',
   since ';' is used as a statement separator in S-HTTP.

   Pattern-data is a modified [RFC1779](/doc/html/rfc1779) string, with regular expressions
   permitted as field values.  Pattern match is performed field-wise,
   unspecified fields match any value (and therefore leaving the DN-
   Pattern entirely unspecified allows for any DN). Certificate chains
   may be matched as well (to allow for certificates without name
   subordination). DN chains are considered to be ordered left-to-right
   with the issuer of a given certificate on its immediate right,
   although issuers need not be specified. A trailing '.' indicates that
   the sequence of DNs is absolute. I.e. that the one furthest to the
   right is a root.

Rescorla & Schiffman          Experimental                     [Page 21]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   The syntax for the pattern values is,

        Value = DN-spec *("," Dn-spec)["."]
        Dn-spec = "/" *(Field-spec) "/"
        Field-spec := Attr = "Pattern"
        Attr = "CN" | "L" | "ST" | "O" |
                   "OU" | "C" | <or as appropriate>
        Pattern = <POSIX 1003.2 regular expressions>

   For example, to request that the other agent sign with a key
   certified by the RSA Persona CA (which uses name subordination) one
   could use the expression below.  Note the use of [RFC1779](/doc/html/rfc1779) quoting to
   protect the comma (an [RFC1779](/doc/html/rfc1779) field separator) and the POSIX 1003.2
   quoting to protect the dot (a regular expression metacharacter).

      Your-Key-Pattern: signing-key, DN-1779,
                   /OU=Persona Certificate, O="RSA Data Security,
   Inc\."/

[3.2.4.11](#section-3.2.4.11).  Example

   A representative header block for a server follows.

        SHTTP-Privacy-Domains: recv-optional=MOSS, CMS;
              orig-required=CMS
        SHTTP-Certificate-Types: recv-optional=X.509;
              orig-required=X.509
        SHTTP-Key-Exchange-Algorithms: recv-required=DH;
              orig-optional=Inband,DH
        SHTTP-Signature-Algorithms: orig-required=NIST-DSS;
              recv-required=NIST-DSS
        SHTTP-Privacy-Enhancements: orig-required=sign;
              orig-optional=encrypt

[3.2.4.12](#section-3.2.4.12).  Defaults

   Explicit negotiation parameters take precedence over default values.
   For a given negotiation option type, defaults for a given mode-action
   pair (such as 'orig-required') are implicitly merged unless
   explicitly overridden.

   The default values (these may be negotiated downward or upward) are:

        SHTTP-Privacy-Domains: orig-optional=CMS;
                               recv-optional=CMS
        SHTTP-Certificate-Types: orig-optional=X.509;
                                 recv-optional=X.509
        SHTTP-Key-Exchange-Algorithms: orig-optional=DH,Inband,Outband;

Rescorla & Schiffman          Experimental                     [Page 22]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

                                       recv-optional=DH,Inband,Outband
        SHTTP-Signature-Algorithms: orig-optional=NIST-DSS;
                                    recv-optional=NIST-DSS
        SHTTP-Message-Digest-Algorithms: orig-optional=RSA-MD5;
                                         recv-optional=RSA-MD5
        SHTTP-Symmetric-Content-Algorithms: orig-optional=DES-CBC;
                                            recv-optional=DES-CBC
        SHTTP-Symmetric-Header-Algorithms: orig-optional=DES-ECB;
                                           recv-optional=DES-ECB
        SHTTP-Privacy-Enhancements: orig-optional=sign,encrypt, auth;
                                            recv-required=encrypt;
                                            recv-optional=sign, auth
[3.3](#section-3.3).  Non-Negotiation Headers

   There are a number of options that are used to communicate or
   identify the potential recipient's keying material.

[3.3.1](#section-3.3.1).  Encryption-Identity

   This header identifies a potential principal for whom the message
   described by these options could be encrypted; Note that this
   explicitly permits return encryption under (say) public key without
   the other agent signing first (or under a different key than that of
   the signature). The syntax of the Encryption-Identity line is:

           Encryption-Identity =
                   "Encryption Identity" ":" name-class,key-sel,name-arg
           name-class = "DN-1779" | MOSS name forms

   The name-class is an ASCII string representing the domain within
   which the name is to be interpreted, in the spirit of MOSS. In
   addition to the MOSS name forms of [RFC1848](/doc/html/rfc1848), we add the DN-1779 name
   form to represent a more convenient form of distinguished name.

[3.3.1.1](#section-3.3.1.1).  DN-1779 Name Class

   The argument is an [RFC-1779](/doc/html/rfc1779) encoded DN.

[3.3.2](#section-3.3.2).  Certificate-Info

   In order to permit public key operations on DNs specified by
   Encryption-Identity headers without explicit certificate fetches by
   the receiver, the sender may include certification information in the
   Certificate-Info option. The format of this option is:

           Certificate-Info: <Cert-Fmt>','<Cert-Group>

   <Cert-Fmt> should be the type of <Cert-Group> being presented.

Rescorla & Schiffman          Experimental                     [Page 23]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   Defined values are 'PEM' and 'CMS'. CMS certificate groups are
   provided as a base-64 encoded CMS SignedData message containing
   sequences of certificates with or without the SignerInfo field. A PEM
   format certificate group is a list of comma-separated base64-encoded
   PEM certificates.

   Multiple Certificate-Info lines may be defined.

[3.3.3](#section-3.3.3).  Key-Assign

   This option serves to indicate that the agent wishes to bind a key to
   a symbolic name for (presumably) later reference.

   The general syntax of the key-assign header is:

        Key-Assign =
                "Key-Assign" ":" Method "," Key-Name ","
                Lifetime "," Ciphers ";" Method-args

        Key-name = string
        Lifetime = "this" | "reply" | ""
        Method ="inband"
        Ciphers = "null" | Cipher+
        Cipher" = <Header cipher from [section 3.2.4.7](#section-3.2.4.7)>
        kv = "4" | "5"

   Key-Name is the symbolic name to which this key is to be bound.
   Ciphers is a list of ciphers for which this key is potentially
   applicable (see the list of header ciphers in [section 3.2.4.7](#section-3.2.4.7)). The
   keyword 'null' should be used to indicate that it is inappropriate
   for use with ANY cipher. This is potentially useful for exchanging
   keys for MAC computation.

   Lifetime is a representation of the longest period of time during
   which the recipient of this message can expect the sender to accept
   that key. 'this' indicates that it is likely to be valid only for
   reading this transmission. 'reply' indicates that it is useful for a
   reply to this message.  If a Key-Assign with the reply lifetime
   appears in a CRYPTOPTS block, it indicates that it is good for at
   least one (but perhaps only one) dereference of this anchor.  An
   unspecified lifetime implies that this key may be reused for an
   indefinite number of transactions.

   Method should be one of a number of key exchange methods.  The only
   currently defined value is 'inband' referring to Inband keys (i.e.,
   direct assignment).

Rescorla & Schiffman          Experimental                     [Page 24]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   This header line may appear either in an unencapsulated header or in
   an encapsulated message, though when an uncovered key is being
   directly assigned, it may only appear in an encrypted encapsulated
   content. Assigning to a key that already exists causes that key to be
   overwritten.

   Keys defined by this header are referred to elsewhere in this
   specification as Key-IDs, which have the syntax:

        Key-ID = method ":" key-name

[3.3.3.1](#section-3.3.3.1).  Inband Key Assignment

   This refers to the direct assignment of an uncovered key to a
   symbolic name. Method-args should be just the desired session key
   encoded in hexidecimal as in:

        Key-Assign: inband,akey,reply,DES-ECB;0123456789abcdef

   Short keys should be derived from long keys by reading bits from left
   to right.

   Note that inband key assignment is especially important in order to
   permit confidential spontaneous communication between agents where
   one (but not both) of the agents have key pairs.  However, this
   mechanism is also useful to permit key changes without public key
   computations. The key information is carried in this header line must
   be in the inner secured HTTP request, therefore use in unencrypted
   messages is not permitted.

[3.3.4](#section-3.3.4).  Nonces

   Nonces are opaque, transient, session-oriented identifiers which may
   be used to provide demonstrations of freshness. Nonce values are a
   local matter, although they are might well be simply random numbers
   generated by the originator. The value is supplied simply to be
   returned by the recipient.

[3.3.4.1](#section-3.3.4.1).  Nonce

   This header is used by an originator to specify what value is to be
   returned in the reply. The field may be any value. Multiple nonces
   may be supplied, each to be echoed independently.

   The Nonce should be returned in a Nonce-Echo header line. See [section](#section-4.1.1)
   [4.1.1](#section-4.1.1).

Rescorla & Schiffman          Experimental                     [Page 25]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[3.4](#section-3.4).  Grouping Headers With SHTTP-Cryptopts

   In order for servers to bind a group of headers to an HTML anchor, it
   is possible to combine a number of headers on a single S-HTTP
   Cryptopts header line. The names of the anchors to which these
   headers apply is indicated with a 'scope' parameter.

[3.4.1](#section-3.4.1).  SHTTP-Cryptopts

   This option provides a set of cryptopts and a list of references to
   which it applies. (For HTML, these references would be named using
   the NAME tag). The names are provided in the scope attribute as a
   comma separated list and separated from the next header line by a
   semicolon. The format for the SHTTP-Cryptopts line is:

SHTTP-Cryptopts =
                   "SHTTP-Cryptopts" ":" scope ";" cryptopt-list
scope = "scope="<tag-spec>    ; This is all one token without whitespace
tag-spec = tag *("," tag) | ""
cryptopt-list = cryptopt *(";" cryptopt)
cryptopt = <S-HTTP cryptopt lines described below>
tag = <value used in HTML anchor NAME attribute>

      For example:

SHTTP-Cryptopts: scope=tag1,tag2;
                   SHTTP-Privacy-Domains:
                   orig-required=cms; recv-optional=cms,MOSS

   If a message contains both S-HTTP negotiation headers and headers
   grouped on SHTTP-Cryptopts line(s), the other headers shall be taken
   to apply to all anchors not bound on the SHTTP-Cryptopts line(s).
   Note that this is an all-or-nothing proposition. That is, if a
   SHTTP-Cryptopts header binds options to a reference, then none of
   these global options apply, even if some of the options headers do
   not appear in the bound options. Rather, the S-HTTP defaults found in
   [Section 3.2.4.11](#section-3.2.4.11) apply.

[4](#section-4).  New Header Lines for HTTP

   Two non-negotiation header lines for HTTP are defined here.

[4.1](#section-4.1).  Security-Scheme

   All S-HTTP compliant agents must generate the Security-Scheme header
   in the headers of all HTTP messages they generate. This header
   permits other agents to detect that they are communicating with an
   S-HTTP compliant agent and generate the appropriate cryptographic

Rescorla & Schiffman          Experimental                     [Page 26]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   options headers.

   For implementations compliant with this specification, the value must
   be 'S-HTTP/1.4'.

[4.1.1](#section-4.1.1).  Nonce-Echo

   The header is used to return the value provided in a previously
   received Nonce: field. This has to go in the encapsulated headers so
   that it an be cryptographically protected.

[5](#section-5).  (Retriable) Server Status Error Reports

   We describe here the special processing appropriate for client
   retries in the face of servers returning an error status.

[5.1](#section-5.1).  Retry for Option (Re)Negotiation

   A server may respond to a client request with an error code that
   indicates that the request has not completely failed but rather that
   the client may possibly achieve satisfaction through another request.
   HTTP already has this concept with the 3XX redirection codes.

   In the case of S-HTTP, it is conceivable (and indeed likely) that the
   server expects the client to retry his request using another set of
   cryptographic options. E.g., the document which contains the anchor
   that the client is dereferencing is old and did not require digital
   signature for the request in question, but the server now has a
   policy requiring signature for dereferencing this URL. These options
   should be carried in the header of the encapsulated HTTP message,
   precisely as client options are carried.

   The general idea is that the client will perform the retry in the
   manner indicated by the combination of the original request and the
   precise nature of the error and the cryptographic enhancements
   depending on the options carried in the server response.

   The guiding principle in client response to these errors should be to
   provide the user with the same sort of informed choice with regard to
   dereference of these anchors as with normal anchor dereference. For
   instance, in the case above, it would be inappropriate for the client
   to sign the request without requesting permission for the action.

Rescorla & Schiffman          Experimental                     [Page 27]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[5.2](#section-5.2).  Specific Retry Behavior

[5.2.1](#section-5.2.1).  Unauthorized 401, PaymentRequired 402

   The HTTP errors 'Unauthorized 401', 'PaymentRequired 402' represent
   failures of HTTP style authentication and payment schemes. While S-
   HTTP has no explicit support for these mechanisms, they can be
   performed under S-HTTP while taking advantage of the privacy services
   offered by S-HTTP. (There are other errors for S-HTTP specific
   authentication errors.)

[5.2.2](#section-5.2.2).  420 SecurityRetry

   This server status reply is provided so that the server may inform
   the client that although the current request is rejected, a retried
   request with different cryptographic enhancements is worth
   attempting. This header shall also be used in the case where an HTTP
   request has been made but an S-HTTP request should have been made.
   Obviously, this serves no useful purpose other than signalling an
   error if the original request should have been encrypted, but in
   other situations (e.g. access control) may be useful.

[5.2.2.1](#section-5.2.2.1).  SecurityRetries for S-HTTP Requests

   In the case of a request that was made as an SHTTP request, it
   indicates that for some reason the cryptographic enhancements applied
   to the request were unsatisfactory and that the request should be
   repeated with the options found in the response header.  Note that
   this can be used as a way to force a new public key negotiation if
   the session key in use has expired or to supply a unique nonce for
   the purposes of ensuring request freshness.

[5.2.2.2](#section-5.2.2.2).  SecurityRetries for HTTP Requests

   If the 420 code is returned in response to an HTTP request, it
   indicates that the request should be retried using S-HTTP and the
   cryptographic options indicated in the response header.

[5.2.3](#section-5.2.3).  421 BogusHeader

   This error code indicates that something about the S-HTTP request was
   bad. The error code is to be followed by an appropriate explanation,
   e.g.:

           421 BogusHeader Content-Privacy-Domain must be specified

Rescorla & Schiffman          Experimental                     [Page 28]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[5.2.4](#section-5.2.4).  422 SHTTP Proxy Authentication Required

   This response is analagous to the 420 response except that the
   options in the message refer to enhancements that the client must
   perform in order to satisfy the proxy.

[5.2.5](#section-5.2.5).  320 SHTTP Not Modifed

   This response code is specifically for use with proxy-server
   interaction where the proxy has placed the If-Modified-Since header
   in the S-HTTP headers of its request. This response indicates that
   the following S-HTTP message contains sufficient keying material for
   the proxy to forward the cached document for the new requestor.

   In general, this takes the form of an S-HTTP message where the actual
   enhanced content is missing, but all the headers and keying material
   are retained. (I.e. the optional content section of the CMS message
   has been removed.) So, if the original response was encrypted, the
   response contains the original DEK re-covered for the new recipient.
   (Notice that the server performs the same processing as it would have
   in the server side caching case of 7.1 except that the message body
   is elided.)

[5.2.6](#section-5.2.6).  Redirection 3XX

   These headers are again internal to HTTP, but may contain S-HTTP
   negotiation options of significance to S-HTTP. The request should be
   redirected in the sense of HTTP, with appropriate cryptographic
   precautions being observed.

[5.3](#section-5.3).  Limitations On Automatic Retries

   Permitting automatic client retry in response to this sort of server
   response permits several forms of attack.  Consider for the moment
   the simple credit card case:

       The user views a document which requires his credit card.  The
       user verifies that the DN of the intended recipient is acceptable
       and that the request will be encrypted and dereferences the
       anchor.  The attacker intercepts the server's reply and responds
       with a message encrypted under the client's public key containing
       the Moved 301 header. If the client were to automatically perform
       this redirect it would allow compromise of the user's credit
       card.

Rescorla & Schiffman          Experimental                     [Page 29]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[5.3.1](#section-5.3.1).  Automatic Encryption Retry

   This shows one possible danger of automatic retries -- potential
   compromise of encrypted information. While it is impossible to
   consider all possible cases, clients should never automatically
   reencrypt data unless the server requesting the retry proves that he
   already has the data. So, situations in which it would be acceptable
   to reencrypt would be if:

       1. The retry response was returned encrypted under an inband key
       freshly generated for the original request.
       2. The retry response was signed by the intended recipient of the
       original request.
       3. The original request used an outband key and the response is
       encrypted under that key.

   This is not an exhaustive list, however the browser author would be
   well advised to consider carefully before implementing automatic
   reencryption in other cases. Note that an appropriate behavior in
   cases where automatic reencryption is not appropriate is to query the
   user for permission.

[5.3.2](#section-5.3.2).  Automatic Signature Retry

   Since we discourage automatic (without user confirmation) signing in
   even the usual case, and given the dangers described above, it is
   prohibited to automatically retry signature enchancement.

[5.3.3](#section-5.3.3).  Automatic MAC Authentication Retry

   Assuming that all the other conditions are followed, it is
   permissible to automatically retry MAC authentication.

[6](#section-6).  Other Issues

[6.1](#section-6.1).  Compatibility of Servers with Old Clients

   Servers which receive requests in the clear which should be secured
   should return 'SecurityRetry 420' with header lines set to indicate
   the required privacy enhancements.

[6.2](#section-6.2).  URL Protocol Type

   We define a new URL protocol designator, 'shttp'. Use of this
   designator as part of an anchor URL implies that the target server is
   S-HTTP capable, and that a dereference of this URL should undergo S-
   HTTP processing.

Rescorla & Schiffman          Experimental                     [Page 30]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   Note that S-HTTP oblivious agents should not be willing to
   dereference a URL with an unknown protocol specifier, and hence
   sensitive data will not be accidentally sent in the clear by users of
   non-secure clients.

[6.3](#section-6.3).  Browser Presentation

[6.3.1](#section-6.3.1).  Transaction Security Status

   While preparing a secure message, the browser should provide a visual
   indication of the security of the transaction, as well as an
   indication of the party who will be able to read the message. While
   reading a signed and/or enveloped message, the browser should
   indicate this and (if applicable) the identity of the signer. Self-
   signed certificates should be clearly differentiated from those
   validated by a certification hierarchy.

[6.3.2](#section-6.3.2).  Failure Reporting

   Failure to authenticate or decrypt an S-HTTP message should be
   presented differently from a failure to retrieve the document.
   Compliant clients may at their option display unverifiable documents
   but must clearly indicate that they were unverifiable in a way
   clearly distinct from the manner in which they display documents
   which possessed no digital signatures or documents with verifiable
   signatures.

[6.3.3](#section-6.3.3).  Certificate Management

   Clients shall provide a method for determining that HTTP requests are
   to be signed and for determining which (assuming there are many)
   certificate is to be used for signature. It is suggested that users
   be presented with some sort of selection list from which they may
   choose a default. No signing should be performed without some sort of
   explicit user interface action, though such action may take the form
   of a persistent setting via a user preferences mechanism (although
   this is discouraged.)

[6.3.4](#section-6.3.4).  Anchor Dereference

   Clients shall provide a method to display the DN and certificate
   chain associated with a given anchor to be dereferenced so that users
   may determine for whom their data is being encrypted.  This should be
   distinct from the method for displaying who has signed the document
   containing the anchor since these are orthogonal pieces of encryption
   information.

Rescorla & Schiffman          Experimental                     [Page 31]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[7](#section-7).  Implementation Notes

[7.1](#section-7.1).  Preenhanced Data

   While S-HTTP has always supported preenhanced documents, in previous
   versions it was never made clear how to actually implement them.
   This section describes two methods for doing so: preenhancing the
   HTTP request/response and preenhancing the underlying data.

[7.1.1](#section-7.1.1).  Motivation

   The two primary motivations for preenhanced documents are security
   and performance. These advantages primarily accrue to signing but may
   also under special circumstances apply to confidentiality or
   repudiable (MAC-based) authentication.

   Consider the case of a server which repeatedly serves the same
   content to multiple clients. One such example would be a server which
   serves catalogs or price lists. Clearly, customers would like to be
   able to verify that these are actual prices. However, since the
   prices are typically the same to all comers, confidentiality is not
   an issue. (Note: see [Section 7.1.5](#section-7.1.5) below for how to deal with this
   case as well).

   Consequently, the server might wish to sign the document once and
   simply send the cached signed document out when a client makes a new
   request, avoiding the overhead of a private key operation each time.
   Note that conceivably, the signed document might have been generated
   by a third party and placed in the server's cache. The server might
   not even have the signing key! This illustrates the security benefit
   of presigning: Untrusted servers can serve authenticated data without
   risk even if the server is compromised.

[7.1.2](#section-7.1.2).  Presigned Requests/Responses

   The obvious implementation is simply to take a single
   request/response, cache it, and send it out in situations where a new
   message would otherwise be generated.

[7.1.3](#section-7.1.3).  Presigned Documents

   It is also possible using S-HTTP to sign the underlying data and send
   it as an S-HTTP messsage. In order to do this, one would take the
   signed document (a CMS or MOSS message) and attach both S-HTTP
   headers (e.g. the S-HTTP request/response line, the Content-Privacy-
   Domain) and the necessary HTTP headers (including a Content-Type that
   reflects the inner content).

Rescorla & Schiffman          Experimental                     [Page 32]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

           SECURE * Secure-HTTP/1.4
           Content-Type: text/html
           Content-Privacy-Domain: CMS

           Random signed message here...

   This message itself cannot be sent, but needs to be recursively
   encapsulated, as described in the next section.

[7.1.4](#section-7.1.4).  Recursive Encapsulation

   As required by [Section 7.3](#section-7.3), the result above needs to be itself
   encapsulated to protect the HTTP headers. the obvious case [and the
   one illustrated here] is when confidentiality is required, but the
   auth enhancement or even the null transform might be applied instead.
   That is, the message shown above can be used as the inner content of
   a new S-HTTP message, like so:

           SECURE * Secure-HTTP/1.4
           Content-Type: application/s-http
           Content-Privacy-Domain: CMS

           Encrypted version of the message above...

   To unfold this, the receiver would decode the outer S-HTTP message,
   reenter the (S-)HTTP parsing loop to process the new message, see
   that that too was S-HTTP, decode that, and recover the inner content.

   Note that this approach can also be used to provide freshness of
   server activity (though not of the document itself) while still
   providing nonrepudiation of the document data if a NONCE is included
   in the request.

[7.1.5](#section-7.1.5).  Preencrypted Messages

   Although preenhancement works best with signature, it can also be
   used with encryption under certain conditions. Consider the situation
   where the same confidential document is to be sent out repeatedly.
   The time spent to encrypt can be saved by caching the ciphertext and
   simply generating a new key exchange block for each recipient. [Note
   that this is logically equivalent to a multi- recipient message as
   defined in both MOSS and CMS and so care must be taken to use proper
   PKCS-1 padding if RSA is being used since otherwise, one may be open
   to a low encryption exponent attack [HAST96].

Rescorla & Schiffman          Experimental                     [Page 33]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[7.2](#section-7.2).  Proxy Interaction

   The use of S-HTTP presents implementation issues to the use of HTTP
   proxies. While simply having the proxy blindly forward responses is
   straightforward, it would be preferable if S-HTTP aware proxies were
   still able to cache responses in at least some circumstances. In
   addition, S-HTTP services should be usable to protect client-proxy
   authentication. This section describes how to achieve those goals
   using the mechanisms described above.

[7.2.1](#section-7.2.1).  Client-Proxy Authentication

   When an S-HTTP aware proxy receives a request (HTTP or S-HTTP) that
   (by whatever access control rules it uses) it requires to be S-HTTP
   authenticated (and if it isn't already so), it should return the 422
   response code (5.7.4).

   When the client receives the 422 response code, it should read the
   cryptographic options that the proxy sent and determine whether or
   not it is willing to apply that enhancement to the message. If the
   client is willing to meet these requirements, it should recursively
   encapsulate the request it previously sent using the appropriate
   options.  (Note that since the enhancement is recursively applied,
   even clients which are unwilling to send requests to servers in the
   clear may be willing to send the already encrypted message to the
   proxy without further encryption.) (See [Section 7.1](#section-7.1) for another
   example of a recursively encapsulated message)

   When the proxy receives such a message, it should strip the outer
   encapsulation to recover the message which should be sent to the
   server.

[8](#section-8).  Implementation Recommendations and Requirements

   All S-HTTP agents must support the MD5 message digest and MAC
   authentication. As of S-HTTP/1.4, all agents must also support the
   RSA-MD5-HMAC construction.

   All S-HTTP agents must support Outband, Inband, and DH key exchange.

   All agents must support encryption using DES-CBC.

   Agents must support signature generation and verification using
   NIST-DSS.

Rescorla & Schiffman          Experimental                     [Page 34]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[9](#section-9).  Protocol Syntax Summary

   We present below a summary of the main syntactic features of S-
   HTTP/1.4, excluding message encapsulation proper.

[9.1](#section-9.1).  S-HTTP (Unencapsulated) Headers

   Content-Privacy-Domain: ('CMS' | 'MOSS')
   Prearranged-Key-Info: <Hdr-Cipher>,<Key>,<Key-ID>
   Content-Type: 'message/http'
   MAC-Info: [hex(timeofday)',']<hash-alg>','hex(<hash-data>)','
           <key-spec>

[9.2](#section-9.2).  HTTP (Encapsulated) Non-negotiation Options

   Key-Assign: <Method>','<Key-Name>','<Lifetime>','
           <Ciphers>';'<Method-args>
   Encryption-Identity: <name-class>','<key-sel>','<name-args>
   Certificate-Info: <Cert-Fmt>','<Cert-Group>
   Nonce: <string>
   Nonce-Echo: <string>

[9.3](#section-9.3).  Encapsulated Negotiation Options

   SHTTP-Cryptopts: <scope>';'<string>(,<string>)*
   SHTTP-Privacy-Domains: ('CMS' | 'MOSS')
   SHTTP-Certificate-Types: ('X.509')
   SHTTP-Key-Exchange-Algorithms: ('DH', 'RSA' | 'Inband' | 'Outband')
   SHTTP-Signature-Algorithms: ('RSA' | 'NIST-DSS')
   SHTTP-Message-Digest-Algorithms:  ('RSA-MD2' | 'RSA-MD5' | 'NIST-SHS'
           'RSA-MD2-HMAC', 'RSA-MD5-HMAC', 'NIST-SHS-HMAC')
   SHTTP-Symmetric-Content-Algorithms: ('DES-CBC' | 'DES-EDE-CBC' |
           'DES-EDE3-CBC' | 'DESX-CBC' | 'CDMF-CBC' | 'IDEA-CBC' |
           'RC2-CBC' )
   SHTTP-Symmetric-Header-Algorithms: ('DES-ECB' | 'DES-EDE-ECB' |
           'DES-EDE3-EBC' | 'DESX-ECB' | 'CDMF-ECB' | 'IDEA-ECB' |
           'RC2-ECB')
   SHTTP-Privacy-Enhancements: ('sign' | 'encrypt' | 'auth')
   Your-Key-Pattern: <key-use>','<pattern-info>

[9.4](#section-9.4).  HTTP Methods

   Secure * Secure-HTTP/1.4

Rescorla & Schiffman          Experimental                     [Page 35]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[9.5](#section-9.5).  Server Status Reports

   Secure-HTTP/1.4 200 OK
   SecurityRetry 420
   BogusHeader 421 <reason>

[10](#section-10).  An Extended Example

   We provide here a contrived example of a series of S-HTTP requests
   and replies. Rows of equal signs are used to set off the narrative
   from sample message traces. Note that the actual encrypted or signed
   message bodies would normally be binary garbage. In an attempt to
   preserve readability while still using (mostly) genuine messages, the
   bodies of the requests have been base64 encoded. To regenerate actual
   S-HTTP messages, it is necessary to remove the base64 encoding from
   the message body.

[10.1](#section-10.1).  A request using RSA key exchange with Inband key reply

   Alice, using an S-HTTP-capable client, begins by making an HTTP
   request which yields the following response page:

   ============================================================
   200 OK HTTP/1.0
   Server-Name: Navaho-0.1.3.3alpha
   Certificate-Info: CMS,MIAGCSqGSIb3DQEHAqCAMIACAQExADCABgkqh
           kiG9w0BBwEAAKCAM
           IIBrTCCAUkCAgC2MA0GCSqGSIb3DQEBAgUAME0xCzAJBgNVBAYTAlVTMSAwH
           gYDVQQKExdSU0EgRGF0YSBTZWN1cml0eSwgSW5jLjEcMBoGA1UECxMTUGVyc
           29uYSBDZXJ0aWZpY2F0ZTAeFw05NDA0MDkwMDUwMzdaFw05NDA4MDIxODM4N
           TdaMGcxCzAJBgNVBAYTAlVTMSAwHgYDVQQKExdSU0EgRGF0YSBTZWN1cml0e
           SwgSW5jLjEcMBoGA1UECxMTUGVyc29uYSBDZXJ0aWZpY2F0ZTEYMBYGA1UEA
           xMPU2V0ZWMgQXN0cm9ub215MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAMy8Q
           cW7RMrB4sTdQ8Nmb2DFmJmkWn+el+NdeamIDElX/qw9mIQu4xNj1FfepfJNx
           zPvA0OtMKhy6+bkrlyMEU8CAwEAATANBgkqhkiG9w0BAQIFAANPAAYn7jDgi
           rhiIL4wnP8nGzUisGSpsFsF4/7z2P2wqne6Qk8Cg/Dstu3RyaN78vAMGP8d8
           2H5+Ndfhi2mRp4YHiGHz0HlK6VbPfnyvS2wdjCCAccwggFRAgUCQAAAFDANB
           gkqhkiG9w0BAQIFADBfMQswCQYDVQQGEwJVUzEgMB4GA1UEChMXUlNBIERhd
           GEgU2VjdXJpdHksIEluYy4xLjAsBgNVBAsTJUxvdyBBc3N1cmFuY2UgQ2Vyd
           GlmaWNhdGlvbiBBdXRob3JpdHkwHhcNOTQwMTA3MDAwMDAwWhcNOTYwMTA3M
           jM1OTU5WjBNMQswCQYDVQQGEwJVUzEgMB4GA1UEChMXUlNBIERhdGEgU2Vjd
           XJpdHksIEluYy4xHDAaBgNVBAsTE1BlcnNvbmEgQ2VydGlmaWNhdGUwaTANB
           gkqhkiG9w0BAQEFAANYADBVAk4GqghQDa9Xi/2zAdYEqJVIcYhlLN1FpI9tX
           Q1m6zZ39PYXK8Uhoj0Es7kWRv8hC04vqkOKwndWbzVtvoHQOmP8nOkkuBi+A
           QvgFoRcgOUCAwEAATANBgkqhkiG9w0BAQIFAANhAD/5Uo7xDdp49oZm9GoNc
           PhZcW1e+nojLvHXWAU/CBkwfcR+FSf4hQ5eFu1AjYv6Wqf430Xe9Et5+jgnM
           Tiq4LnwgTdA8xQX4elJz9QzQobkE3XVOjVAtCFcmiin80RB8AAAMYAAAAAAA
           AAAAA==

Rescorla & Schiffman          Experimental                     [Page 36]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   Encryption-Identity: DN-1779, null, CN=Setec Astronomy, OU=Persona
           Certificate,O="RSA Data Security, Inc.", C=US;
   SHTTP-Privacy-Enhancements: recv-required=encrypt

   <A name=tag1 HREF="shttp://www.setec.com/secret">
   Don't read this. </A>
   ============================================================

   An appropriate HTTP request to dereference this URL would be:

   ============================================================
   GET /secret HTTP/1.0
   Security-Scheme: S-HTTP/1.4
   User-Agent: Web-O-Vision 1.2beta
   Accept: *.*
   Key-Assign: Inband,1,reply,des-ecb;7878787878787878

   ============================================================

   The added Key-Assign line that would not have been in an ordinary
   HTTP request permits Bob (the server) to encrypt his reply to Alice,
   even though Alice does not have a public key, since they would share
   a key after the request is received by Bob.  This request has the
   following S-HTTP encapsulation:

   ============================================================
   Secure * Secure-HTTP/1.4
   Content-Type: message/http
   Content-Privacy-Domain: CMS

   MIAGCSqGSIb3DQEHA6CAMIACAQAxgDCBqQIBADBTME0xCzAJBgNVBAYTAlVTMSAw
   HgYDVQQKExdSU0EgRGF0YSBTZWN1cml0eSwgSW5jLjEcMBoGA1UECxMTUGVyc29u
   YSBDZXJ0aWZpY2F0ZQICALYwDQYJKoZIhvcNAQEBBQAEQCU/R+YCJSUsV6XLilHG
   cNVzwqKcWzmT/rZ+duOv8Ggb7oO/d8H3xUVGQ2LsX4kYGq2szwj8Q6eWhsmhf4oz
   lvMAADCABgkqhkiG9w0BBwEwEQYFKw4DAgcECFif7BadXlw3oIAEgZBNcMexKe16
   +mNxx8YQPukBCL0bWqS86lvws/AgRkKPELmysBi5lco8MBCsWK/fCyrnxIRHs1oK
   BXBVlsAhKkkusk1kCf/GbXSAphdSgG+d6LxrNZwHbBFOX6A2hYS63Iczd5bOVDDW
   Op2gcgUtMJq6k2LFrs4L7HHqRPPlqNJ6j5mFP4xkzOCNIQynpD1rV6EECMIk/T7k
   1JLSAAAAAAAAAAAAAA==
   ============================================================

   The data between the delimiters is a CMS message, RSA enveloped for
   Setec Astronomy.

   Bob decrypts the request, finds the document in question, and is
   ready to serve it back to Alice.

Rescorla & Schiffman          Experimental                     [Page 37]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   An appropriate HTTP server response would be:

   ============================================================
   HTTP/1.0 200 OK
   Security-Scheme: S-HTTP/1.4
   Content-Type: text/html

   Congratulations, you've won.
   <A href="/prize.html"
    CRYPTOPTS="Key-Assign: Inband,alice1,reply,des-ecb;020406080a0c0e0f;
    SHTTP-Privacy-Enhancements: recv-required=auth">Click here to
   claim your prize</A>
   ============================================================

   This HTTP response, encapsulated as an S-HTTP message becomes:

   ============================================================
   Secure * Secure-HTTP/1.4
   Content-Type: message/http
   Prearranged-Key-Info: des-ecb,697fa820df8a6e53,inband:1
   Content-Privacy-Domain: CMS

   MIAGCSqGSIb3DQEHBqCAMIACAQAwgAYJKoZIhvcNAQcBMBEGBSsOAwIHBAifqtdy
   x6uIMYCCARgvFzJtOZBn773DtmXlx037ck3giqnV0WC0QAx5f+fesAiGaxMqWcir
   r9XvT0nT0LgSQ/8tiLCDBEKdyCNgdcJAduy3D0r2sb5sNTT0TyL9uydG3w55vTnW
   aPbCPCWLudArI1UHDZbnoJICrVehxG/sYX069M8v6VO8PsJS7//hh1yM+0nekzQ5
   l1p0j7uWKu4W0csrlGqhLvEJanj6dQAGSTNCOoH3jzEXGQXntgesk8poFPfHdtj0
   5RH4MuJRajDmoEjlrNcnGl/BdHAd2JaCo6uZWGcnGAgVJ/TVfSVSwN5nlCK87tXl
   nL7DJwaPRYwxb3mnPKNq7ATiJPf5u162MbwxrddmiE7e3sST7naSN+GS0ateY5X7
   AAAAAAAAAAA=
   ============================================================

   The data between the delimiters is a CMS message encrypted under a
   randomly-chosen DEK which can be recovered by computing:

           DES-DECRYPT(inband:1,697fa820df8a6e53)

   where 'inband:1' is the key exchanged in the Key-Assign line in the
   original request.

Rescorla & Schiffman          Experimental                     [Page 38]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[10.2](#section-10.2).  A request using the auth enhancement

   There is a link on the HTML page that was just returned, which Alice
   dereferences, creating the HTTP message:

============================================================
GET /prize.html HTTP/1.0
Security-Scheme: S-HTTP/1.4
User-Agent: Web-O-Vision 1.1beta
Accept: *.*

============================================================

Which, when encapsulated as an S-HTTP message, becomes:

============================================================
Secure * Secure-HTTP/1.4
Content-Type: message/http
MAC-Info:31ff8122,rsa-md5,b3ca4575b841b5fc7553e69b0896c416,inband:alice1
Content-Privacy-Domain: CMS

MIAGCSqGSIb3DQEHAaCABGNHRVQgL3ByaXplLmh0bWwgSFRUUC8xLjAKU2VjdXJp
dHktU2NoZW1lOiBTLUhUVFAvMS4xClVzZXItQWdlbnQ6IFdlYi1PLVZpc2lvbiAx
LjFiZXRhCkFjY2VwdDogKi4qCgoAAAAA
============================================================

   The data between the delimiters is a CMS 'Data' representation of the
   request.

Rescorla & Schiffman          Experimental                     [Page 39]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

Appendix: A Review of CMS

   CMS ("Cryptographic Message Syntax Standard") is a cryptographic
   message encapsulation format, similar to PEM, based on RSA's PKCS-7
   cryptographic messaging syntax.

   CMS is only one of two encapsulation formats supported by S-HTTP, but
   it is to be preferred since it permits the least restricted set of
   negotiable options, and permits binary encoding.  In the interest of
   making this specification more self-contained, we summarize CMS here.

   CMS is defined in terms of OSI's Abstract Syntax Notation (ASN.1,
   defined in X.208), and is concretely represented using ASN.1's Basic
   Encoding Rules (BER, defined in X.209).  A CMS message is a sequence
   of typed content parts. There are six content types, recursively
   composable:

           Data -- Some bytes, with no enhancement.

           SignedData -- A content part, with zero or more signature
           blocks, and associated keying materials. Keying materials
           can be transported via the degenerate case of no signature
           blocks and no data.

           EnvelopedData -- One or more (per recipient) key exchange
           blocks and an encrypted content part.

           DigestedData -- A content part with a single digest block.

           EncryptedData -- An encrypted content part, with key
           materials externally provided.

   Here we will dispense with convention for the sake of ASN.1-impaired
   readers, and present a syntax for CMS in informal BNF (with much
   gloss).  In the actual encoding, most productions have explicit tag
   and length fields.

   Message = *Content
   Content = Data | SignedData | EnvelopedData |
                   DigestedData | EncryptedData
   Data = Bytes
   SignedData = *DigestAlg Content *Certificates
                    *CRLs SignerInfo*
   EnvelopedData = *RecipientInfo BulkCryptAlg
                   Encrypted(Content)

Rescorla & Schiffman          Experimental                     [Page 40]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   DigestedData = DigestAlg Content DigestBytes
   EncryptedData = BulkCryptAlg Encrypted(Bytes)
   SignerInfo = CertID ... Encrypted(DigestBytes) ...
   RecipientInfo = CertID KeyCryptAlg Encrypted(DEK)

Appendix: Internet Media Type message/s-http

   In addition to defining the S-HTTP/1.4 protocol, this document serves
   as the specification for the Internet media type "message/s-http".
   The following is to be registered with IANA.

           Media Type name:        message
           Media subtype name:     s-http
           Required parameters:    none
           Optional parameters:    version, msgtype

             version: The S-HTTP version number of the enclosed message
             (e.g. "1.4"). If not present, the version can be
                   determined from the first line of the body.

             msgtype: The message type -- "request" or "response".
                   If not present, the type can be determined from the
                   first line of the body.

             Encoding considerations: only "7bit", "8bit", or "binary"
                   are permitted.

             Security considerations: this is a security protocol.

Bibliography and References

   [BELL96]    Bellare, M., Canetti, R., Krawczyk, H., "Keying Hash
               Functions for Message Authentication", Preprint.

   [FIPS-46-1] Federal Information Processing Standards Publication
               (FIPS PUB) 46-1, Data Encryption Standard, Reaffirmed
               1988 January 22 (supersedes FIPS PUB 46, 1977 January
               15).

   [FIPS-81]   Federal Information Processing Standards Publication
               (FIPS PUB) 81, DES Modes of Operation, 1980 December 2.

   [FIPS-180]  Federal Information Processing Standards Publication
               (FIPS PUB) 180-1, "Secure Hash Standard", 1995 April 17.

   [FIPS-186]  Federal Information Processing Standards Publication
               (FIPS PUB) 186, Digital Signature Standard, 1994 May 19.

Rescorla & Schiffman          Experimental                     [Page 41]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   [HAST86]    Hastad, J., "On Using RSA With Low Exponents in a Public
               Key Network," Advances in Cryptology-CRYPTO 95
               Proceedings, Springer-Verlag, 1986.

   [JOHN93]    Johnson, D.B., Matyas, S.M., Le, A.V., Wilkins, J.D.,
               "Design of the Commercial Data Masking Facility Data
               Privacy Algorithm," Proceedings 1st ACM Conference on
               Computer & Communications Security, November 1993,
               Fairfax, VA., pp. 93-96.

   [KRAW96b]   Krawczyk, H. personal communication.

   [LAI92]     Lai, X. "On the Design and Security of Block Ciphers,"
               ETH Series in Information Processing, v. 1, Konstanz:
               Hartung-Gorre Verlag, 1992.

   [PKCS-6]    RSA Data Security, Inc. "Extended Certificate Syntax
               Standard", PKCS-6, Nov 1, 1993.

   [CMS]       Housley, R., "Cryptographic Message Syntax", [RFC 2630](/doc/html/rfc2630),
               June 1999.

   [RFC-822]   Crocker, D., "Standard For The Format Of ARPA Internet
               Text Messages", STD 11, [RFC 822](/doc/html/rfc822), August 1982.

   [RFC-1319]  Kaliski, B., "The MD2 Message-Digest Algorithm", [RFC](/doc/html/rfc1319)
               [1319](/doc/html/rfc1319), April 1992.

   [RFC-1321]  Rivest, R., "The MD5 Message-Digest Algorithm", [RFC 1321](/doc/html/rfc1321),
               April 1992.

   [RFC-1421]  Linn, J., "Privacy Enhancement for Internet Electronic
               Mail:  Part I: Message Encryption and Authentication
               Procedures", [RFC 1421](/doc/html/rfc1421), February 1993.

   [RFC-1422]  Kent, S., "Privacy Enhancement for Internet Electronic
               Mail:  Part II: Certificate-Based Key Management", [RFC](/doc/html/rfc1422)
               [1422](/doc/html/rfc1422), February 1993.

   [RFC-1779]  Kille, S., "A String Representation of Distinguished
               Names", [RFC 1779](/doc/html/rfc1779), March 1995.

   [RFC-2045]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
               Extensions (MIME) Part One: Format of Internet Message
               Bodies", [RFC 2045](/doc/html/rfc2045), September 1993.

   [RFC-1738]  T. Berners-Lee, "Uniform Resource Locators (URLs)", [RFC](/doc/html/rfc1738)
               [1738](/doc/html/rfc1738), December 1994.

Rescorla & Schiffman          Experimental                     [Page 42]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

   [RFC-1847]  Galvin, J., Murphy, S., Crocker, S., and N. Freed,
               "Security Muliparts for MIME: Multipart/Signed and
               Multipart/Encrypted", [RFC 1847](/doc/html/rfc1847), October 1995.

   [RFC-1848]  Crocker, S., Freed, N., Galvin, J., and S. Murphy, "MIME
               Object Security Services", [RFC 1848](/doc/html/rfc1848), October 1995.

   [RFC-1864]  Myers, J.  and M. Rose, "The Content-MD5 Header Field",
               [RFC 1864](/doc/html/rfc1864), October 1995.

   [RFC-2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
               Masinter, L., Leach, P. and T. Berners-Lee, "Hypertext
               Transfer Protocol -- HTTP/1.1" [RFC 2616](/doc/html/rfc2616), June 1999.

   [RFC-2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P.,
               Luotonen, A. and L. Stewart, "HTTP Authentication: Basic
               and Digest Access Authentication", [RFC 2617](/doc/html/rfc2617), June 1999.

   [RFC-2104]  Krawczyk, H., Bellare, M. and R.  Canetti, "HMAC: Keyed-
               Hashing for Message Authentication", [RFC 2104](/doc/html/rfc2104), February
               1997.

   [SHTML]     Rescorla, E. and A. Schiffman, "Security Extensions For
               HTML", [RFC 2659](/doc/html/rfc2659), August 1999.

   [VANO95]    B. Prennel and P. van Oorschot, "On the security of two
               MAC algorithms", to appear Eurocrypt'96.

   [X509]      CCITT Recommendation X.509 (1988), "The Directory -
               Authentication Framework".

Security Considerations

   This entire document is about security.

Rescorla & Schiffman          Experimental                     [Page 43]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

Authors' Addresses

   Eric Rescorla
   RTFM, Inc.
   30 Newell Road, #16
   East Palo Alto, CA 94303

   Phone: (650) 328-8631
   EMail: ekr@rtfm.com

   Allan M. Schiffman
   SPYRUS/Terisa
   5303 Betsy Ross Drive
   Santa Clara, CA 95054

   Phone: (408) 327-1901
   EMail: ams@terisa.com

Rescorla & Schiffman          Experimental                     [Page 44]
```

---

```

[RFC 2660](/doc/html/rfc2660)         The Secure HyperText Transfer Protocol      August 1999

[15](#section-15).  Full Copyright Statement

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.

Rescorla & Schiffman          Experimental                     [Page 45]

```

[Datatracker](/doc/rfc2660/)

RFC 2660

RFC
- Historic

* Info
* Contents
* Prefs

| Document | Document type |  | RFC - Historic  August 1999  [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") Status changed by [status-change-http-experiments-to-historic](/doc/status-change-http-experiments-to-historic/ "Status change of HTTP experiments to Historic") Was [draft-ietf-wts-shttp](/doc/draft-ietf-wts-shttp/06/) ([wts WG](/wg/wts/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [06](/doc/html/draft-ietf-wts-shttp-06) * [RFC 2660](/doc/html/rfc2660) |
|  | Compare versions |  | RFC 2660  draft-ietf-wts-shttp-06  draft-ietf-wts-shttp-05  draft-ietf-wts-shttp-04  draft-ietf-wts-shttp-03  draft-ietf-wts-shttp-02  draft-ietf-wts-shttp-01   RFC 2660  draft-ietf-wts-shttp-06  draft-ietf-wts-shttp-05  draft-ietf-wts-shttp-04  draft-ietf-wts-shttp-03  draft-ietf-wts-shttp-02  draft-ietf-wts-shttp-01   Side-by-side  Inline |
|  | Authors |  | [Eric Rescorla](/person/ekr%40rtfm.com "Datatracker profile of Eric Rescorla") , [Allan M. Schiffman](/person/ams%40terisa.com "Datatracker profile of Allan M. Schiffman")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc2660.txt) [html](https://www.rfc-editor.org/rfc/rfc2660.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc2660.txt.pdf) [bibtex](/doc/rfc2660/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](http://www-ns.rutgers.edu/www-security) |

[Report a datatracker bug](https://github.com/ietf-tools/datatracker/issues/new/choose)

Show sidebar by default

Yes

No

Tab to show by default

Info

Contents

HTMLization configuration

HTMLize the plaintext

Plaintextify the HTML

Maximum font size

Page dependencies

Inline

Reference

Citation links

 Go to reference section

Go to linked document

![](//analytics.ietf.org/piwik.php?idsite=7)



=== Content from tools.ietf.org_a7ffc121_20250121_031611.html ===


* Light
* Dark
* Auto

[RFC 7231

Proposed Standard](/doc/rfc7231/)

|  | Title |  | Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content |
| --- | --- | --- | --- |
| Document | Document type |  | RFC - Proposed Standard  June 2014  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=7231 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") Obsoleted by [RFC 9110](/doc/html/rfc9110 "HTTP Semantics") Obsoletes [RFC 2616](/doc/html/rfc2616 "Hypertext Transfer Protocol -- HTTP/1.1") Updates [RFC 2817](/doc/html/rfc2817 "Upgrading to TLS Within HTTP/1.1") Was [draft-ietf-httpbis-p2-semantics](/doc/draft-ietf-httpbis-p2-semantics/26/) ([httpbis WG](/wg/httpbis/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [18](/doc/html/draft-ietf-httpbis-p2-semantics-18) * [19](/doc/html/draft-ietf-httpbis-p2-semantics-19) * [20](/doc/html/draft-ietf-httpbis-p2-semantics-20) * [21](/doc/html/draft-ietf-httpbis-p2-semantics-21) * [22](/doc/html/draft-ietf-httpbis-p2-semantics-22) * [23](/doc/html/draft-ietf-httpbis-p2-semantics-23) * [24](/doc/html/draft-ietf-httpbis-p2-semantics-24) * [25](/doc/html/draft-ietf-httpbis-p2-semantics-25) * [26](/doc/html/draft-ietf-httpbis-p2-semantics-26) * [RFC 7231](/doc/html/rfc7231) |
|  | Compare versions |  | RFC 7231  draft-ietf-httpbis-p2-semantics-26  draft-ietf-httpbis-p2-semantics-25  draft-ietf-httpbis-p2-semantics-24  draft-ietf-httpbis-p2-semantics-23  draft-ietf-httpbis-p2-semantics-22  draft-ietf-httpbis-p2-semantics-21  draft-ietf-httpbis-p2-semantics-20  draft-ietf-httpbis-p2-semantics-19  draft-ietf-httpbis-p2-semantics-18  draft-ietf-httpbis-p2-semantics-17  draft-ietf-httpbis-p2-semantics-16  draft-ietf-httpbis-p2-semantics-15  draft-ietf-httpbis-p2-semantics-14  draft-ietf-httpbis-p2-semantics-13  draft-ietf-httpbis-p2-semantics-12  draft-ietf-httpbis-p2-semantics-11  draft-ietf-httpbis-p2-semantics-10  draft-ietf-httpbis-p2-semantics-09  draft-ietf-httpbis-p2-semantics-08  draft-ietf-httpbis-p2-semantics-07  draft-ietf-httpbis-p2-semantics-06  draft-ietf-httpbis-p2-semantics-05  draft-ietf-httpbis-p2-semantics-04  draft-ietf-httpbis-p2-semantics-03  draft-ietf-httpbis-p2-semantics-02  draft-ietf-httpbis-p2-semantics-01  draft-ietf-httpbis-p2-semantics-00   RFC 7231  draft-ietf-httpbis-p2-semantics-26  draft-ietf-httpbis-p2-semantics-25  draft-ietf-httpbis-p2-semantics-24  draft-ietf-httpbis-p2-semantics-23  draft-ietf-httpbis-p2-semantics-22  draft-ietf-httpbis-p2-semantics-21  draft-ietf-httpbis-p2-semantics-20  draft-ietf-httpbis-p2-semantics-19  draft-ietf-httpbis-p2-semantics-18  draft-ietf-httpbis-p2-semantics-17  draft-ietf-httpbis-p2-semantics-16  draft-ietf-httpbis-p2-semantics-15  draft-ietf-httpbis-p2-semantics-14  draft-ietf-httpbis-p2-semantics-13  draft-ietf-httpbis-p2-semantics-12  draft-ietf-httpbis-p2-semantics-11  draft-ietf-httpbis-p2-semantics-10  draft-ietf-httpbis-p2-semantics-09  draft-ietf-httpbis-p2-semantics-08  draft-ietf-httpbis-p2-semantics-07  draft-ietf-httpbis-p2-semantics-06  draft-ietf-httpbis-p2-semantics-05  draft-ietf-httpbis-p2-semantics-04  draft-ietf-httpbis-p2-semantics-03  draft-ietf-httpbis-p2-semantics-02  draft-ietf-httpbis-p2-semantics-01  draft-ietf-httpbis-p2-semantics-00   Side-by-side  Inline |
|  | Authors |  | [Roy T. Fielding](/person/fielding%40gbiv.com "Datatracker profile of Roy T. Fielding") , [Julian Reschke](/person/julian.reschke%40gmx.de "Datatracker profile of Julian Reschke")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc7231.txt) [html](https://www.rfc-editor.org/rfc/rfc7231.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc7231.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc7231.html) [bibtex](/doc/rfc7231/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](http://lists.w3.org/Archives/Public/ietf-http-wg/) |
|  |  |  | [Report a bug](https://github.com/ietf-tools/datatracker/issues/new/choose) |

```
Internet Engineering Task Force (IETF)                  R. Fielding, Ed.
Request for Comments: 7231                                         Adobe
Obsoletes: [2616](/doc/html/rfc2616)                                          J. Reschke, Ed.
Updates: [2817](/doc/html/rfc2817)                                                 greenbytes
Category: Standards Track                                      June 2014
ISSN: 2070-1721

     Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content

Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level protocol for distributed, collaborative, hypertext information
   systems.  This document defines the semantics of HTTP/1.1 messages,
   as expressed by request methods, request header fields, response
   status codes, and response header fields, along with the payload of
   messages (metadata and body content) and mechanisms for content
   negotiation.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in [Section 2 of RFC 5741](/doc/html/rfc5741#section-2).

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   <http://www.rfc-editor.org/info/rfc7231>.

Fielding & Reschke           Standards Track                    [Page 1]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to [BCP 78](/doc/html/bcp78) and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (<http://trustee.ietf.org/license-info>) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Fielding & Reschke           Standards Track                    [Page 2]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

Table of Contents

   [1](#section-1). Introduction ....................................................[6](#page-6)
      [1.1](#section-1.1). Conformance and Error Handling .............................[6](#page-6)
      [1.2](#section-1.2). Syntax Notation ............................................[6](#page-6)
   [2](#section-2). Resources .......................................................[7](#page-7)
   [3](#section-3). Representations .................................................[7](#page-7)
      [3.1](#section-3.1). Representation Metadata ....................................[8](#page-8)
           [3.1.1](#section-3.1.1). Processing Representation Data ......................[8](#page-8)
           [3.1.2](#section-3.1.2). Encoding for Compression or Integrity ..............[11](#page-11)
           [3.1.3](#section-3.1.3). Audience Language ..................................[13](#page-13)
           [3.1.4](#section-3.1.4). Identification .....................................[14](#page-14)
      [3.2](#section-3.2). Representation Data .......................................[17](#page-17)
      [3.3](#section-3.3). Payload Semantics .........................................[17](#page-17)
      [3.4](#section-3.4). Content Negotiation .......................................[18](#page-18)
           [3.4.1](#section-3.4.1). Proactive Negotiation ..............................[19](#page-19)
           [3.4.2](#section-3.4.2). Reactive Negotiation ...............................[20](#page-20)
   [4](#section-4). Request Methods ................................................[21](#page-21)
      [4.1](#section-4.1). Overview ..................................................[21](#page-21)
      [4.2](#section-4.2). Common Method Properties ..................................[22](#page-22)
           [4.2.1](#section-4.2.1). Safe Methods .......................................[22](#page-22)
           [4.2.2](#section-4.2.2). Idempotent Methods .................................[23](#page-23)
           [4.2.3](#section-4.2.3). Cacheable Methods ..................................[24](#page-24)
      [4.3](#section-4.3). Method Definitions ........................................[24](#page-24)
           [4.3.1](#section-4.3.1). GET ................................................[24](#page-24)
           [4.3.2](#section-4.3.2). HEAD ...............................................[25](#page-25)
           [4.3.3](#section-4.3.3). POST ...............................................[25](#page-25)
           [4.3.4](#section-4.3.4). PUT ................................................[26](#page-26)
           [4.3.5](#section-4.3.5). DELETE .............................................[29](#page-29)
           [4.3.6](#section-4.3.6). CONNECT ............................................[30](#page-30)
           [4.3.7](#section-4.3.7). OPTIONS ............................................[31](#page-31)
           [4.3.8](#section-4.3.8). TRACE ..............................................[32](#page-32)
   [5](#section-5). Request Header Fields ..........................................[33](#page-33)
      [5.1](#section-5.1). Controls ..................................................[33](#page-33)
           [5.1.1](#section-5.1.1). Expect .............................................[34](#page-34)
           [5.1.2](#section-5.1.2). Max-Forwards .......................................[36](#page-36)
      [5.2](#section-5.2). Conditionals ..............................................[36](#page-36)
      [5.3](#section-5.3). Content Negotiation .......................................[37](#page-37)
           [5.3.1](#section-5.3.1). Quality Values .....................................[37](#page-37)
           [5.3.2](#section-5.3.2). Accept .............................................[38](#page-38)
           [5.3.3](#section-5.3.3). Accept-Charset .....................................[40](#page-40)
           [5.3.4](#section-5.3.4). Accept-Encoding ....................................[41](#page-41)
           [5.3.5](#section-5.3.5). Accept-Language ....................................[42](#page-42)
      [5.4](#section-5.4). Authentication Credentials ................................[44](#page-44)
      [5.5](#section-5.5). Request Context ...........................................[44](#page-44)
           [5.5.1](#section-5.5.1). From ...............................................[44](#page-44)
           [5.5.2](#section-5.5.2). Referer ............................................[45](#page-45)
           [5.5.3](#section-5.5.3). User-Agent .........................................[46](#page-46)

Fielding & Reschke           Standards Track                    [Page 3]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   [6](#section-6). Response Status Codes ..........................................[47](#page-47)
      [6.1](#section-6.1). Overview of Status Codes ..................................[48](#page-48)
      [6.2](#section-6.2). Informational 1xx .........................................[50](#page-50)
           [6.2.1](#section-6.2.1). 100 Continue .......................................[50](#page-50)
           [6.2.2](#section-6.2.2). 101 Switching Protocols ............................[50](#page-50)
      [6.3](#section-6.3). Successful 2xx ............................................[51](#page-51)
           [6.3.1](#section-6.3.1). 200 OK .............................................[51](#page-51)
           [6.3.2](#section-6.3.2). 201 Created ........................................[52](#page-52)
           [6.3.3](#section-6.3.3). 202 Accepted .......................................[52](#page-52)
           [6.3.4](#section-6.3.4). 203 Non-Authoritative Information ..................[52](#page-52)
           [6.3.5](#section-6.3.5). 204 No Content .....................................[53](#page-53)
           [6.3.6](#section-6.3.6). 205 Reset Content ..................................[53](#page-53)
      [6.4](#section-6.4). Redirection 3xx ...........................................[54](#page-54)
           [6.4.1](#section-6.4.1). 300 Multiple Choices ...............................[55](#page-55)
           [6.4.2](#section-6.4.2). 301 Moved Permanently ..............................[56](#page-56)
           [6.4.3](#section-6.4.3). 302 Found ..........................................[56](#page-56)
           [6.4.4](#section-6.4.4). 303 See Other ......................................[57](#page-57)
           [6.4.5](#section-6.4.5). 305 Use Proxy ......................................[58](#page-58)
           [6.4.6](#section-6.4.6). 306 (Unused) .......................................[58](#page-58)
           [6.4.7](#section-6.4.7). 307 Temporary Redirect .............................[58](#page-58)
      [6.5](#section-6.5). Client Error 4xx ..........................................[58](#page-58)
           [6.5.1](#section-6.5.1). 400 Bad Request ....................................[58](#page-58)
           [6.5.2](#section-6.5.2). 402 Payment Required ...............................[59](#page-59)
           [6.5.3](#section-6.5.3). 403 Forbidden ......................................[59](#page-59)
           [6.5.4](#section-6.5.4). 404 Not Found ......................................[59](#page-59)
           [6.5.5](#section-6.5.5). 405 Method Not Allowed .............................[59](#page-59)
           [6.5.6](#section-6.5.6). 406 Not Acceptable .................................[60](#page-60)
           [6.5.7](#section-6.5.7). 408 Request Timeout ................................[60](#page-60)
           [6.5.8](#section-6.5.8). 409 Conflict .......................................[60](#page-60)
           [6.5.9](#section-6.5.9). 410 Gone ...........................................[60](#page-60)
           [6.5.10](#section-6.5.10). 411 Length Required ...............................[61](#page-61)
           [6.5.11](#section-6.5.11). 413 Payload Too Large .............................[61](#page-61)
           [6.5.12](#section-6.5.12). 414 URI Too Long ..................................[61](#page-61)
           [6.5.13](#section-6.5.13). 415 Unsupported Media Type ........................[62](#page-62)
           [6.5.14](#section-6.5.14). 417 Expectation Failed ............................[62](#page-62)
           [6.5.15](#section-6.5.15). 426 Upgrade Required ..............................[62](#page-62)
      [6.6](#section-6.6). Server Error 5xx ..........................................[62](#page-62)
           [6.6.1](#section-6.6.1). 500 Internal Server Error ..........................[63](#page-63)
           [6.6.2](#section-6.6.2). 501 Not Implemented ................................[63](#page-63)
           [6.6.3](#section-6.6.3). 502 Bad Gateway ....................................[63](#page-63)
           [6.6.4](#section-6.6.4). 503 Service Unavailable ............................[63](#page-63)
           [6.6.5](#section-6.6.5). 504 Gateway Timeout ................................[63](#page-63)
           [6.6.6](#section-6.6.6). 505 HTTP Version Not Supported .....................[64](#page-64)
   [7](#section-7). Response Header Fields .........................................[64](#page-64)
      [7.1](#section-7.1). Control Data ..............................................[64](#page-64)
ed            7.1.1. Origination Date ...................................[65](#page-65)
           [7.1.2](#section-7.1.2). Location ...........................................[68](#page-68)
           [7.1.3](#section-7.1.3). Retry-After ........................................[69](#page-69)

Fielding & Reschke           Standards Track                    [Page 4]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

           [7.1.4](#section-7.1.4). Vary ...............................................[70](#page-70)
      [7.2](#section-7.2). Validator Header Fields ...................................[71](#page-71)
      [7.3](#section-7.3). Authentication Challenges .................................[72](#page-72)
      [7.4](#section-7.4). Response Context ..........................................[72](#page-72)
           [7.4.1](#section-7.4.1). Allow ..............................................[72](#page-72)
           [7.4.2](#section-7.4.2). Server .............................................[73](#page-73)
   [8](#section-8). IANA Considerations ............................................[73](#page-73)
      [8.1](#section-8.1). Method Registry ...........................................[73](#page-73)
           [8.1.1](#section-8.1.1). Procedure ..........................................[74](#page-74)
           [8.1.2](#section-8.1.2). Considerations for New Methods .....................[74](#page-74)
           [8.1.3](#section-8.1.3). Registrations ......................................[75](#page-75)
      [8.2](#section-8.2). Status Code Registry ......................................[75](#page-75)
           [8.2.1](#section-8.2.1). Procedure ..........................................[75](#page-75)
           [8.2.2](#section-8.2.2). Considerations for New Status Codes ................[76](#page-76)
           [8.2.3](#section-8.2.3). Registrations ......................................[76](#page-76)
      [8.3](#section-8.3). Header Field Registry .....................................[77](#page-77)
           [8.3.1](#section-8.3.1). Considerations for New Header Fields ...............[78](#page-78)
           [8.3.2](#section-8.3.2). Registrations ......................................[80](#page-80)
      [8.4](#section-8.4). Content Coding Registry ...................................[81](#page-81)
           [8.4.1](#section-8.4.1). Procedure ..........................................[81](#page-81)
           [8.4.2](#section-8.4.2). Registrations ......................................[81](#page-81)
   [9](#section-9). Security Considerations ........................................[81](#page-81)
      [9.1](#section-9.1). Attacks Based on File and Path Names ......................[82](#page-82)
      [9.2](#section-9.2). Attacks Based on Command, Code, or Query Injection ........[82](#page-82)
      [9.3](#section-9.3). Disclosure of Personal Information ........................[83](#page-83)
      [9.4](#section-9.4). Disclosure of Sensitive Information in URIs ...............[83](#page-83)
      [9.5](#section-9.5). Disclosure of Fragment after Redirects ....................[84](#page-84)
      [9.6](#section-9.6). Disclosure of Product Information .........................[84](#page-84)
      [9.7](#section-9.7). Browser Fingerprinting ....................................[84](#page-84)
   [10](#section-10). Acknowledgments ...............................................[85](#page-85)
   [11](#section-11). References ....................................................[85](#page-85)
      [11.1](#section-11.1). Normative References .....................................[85](#page-85)
      [11.2](#section-11.2). Informative References ...................................[86](#page-86)
   [Appendix A](#appendix-A). Differences between HTTP and MIME .....................[89](#page-89)
      [A.1](#appendix-A.1). MIME-Version ..............................................[89](#page-89)
      [A.2](#appendix-A.2). Conversion to Canonical Form ..............................[89](#page-89)
      [A.3](#appendix-A.3). Conversion of Date Formats ................................[90](#page-90)
      [A.4](#appendix-A.4). Conversion of Content-Encoding ............................[90](#page-90)
      [A.5](#appendix-A.5). Conversion of Content-Transfer-Encoding ...................[90](#page-90)
      [A.6](#appendix-A.6). MHTML and Line Length Limitations .........................[90](#page-90)
   [Appendix B](#appendix-B). Changes from [RFC 2616](/doc/html/rfc2616) .................................[91](#page-91)
   [Appendix C](#appendix-C). Imported ABNF .........................................[93](#page-93)
   [Appendix D](#appendix-D). Collected ABNF ........................................[94](#page-94)
   Index .............................................................[97](#page-97)

Fielding & Reschke           Standards Track                    [Page 5]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[1](#section-1).  Introduction

   Each Hypertext Transfer Protocol (HTTP) message is either a request
   or a response.  A server listens on a connection for a request,
   parses each message received, interprets the message semantics in
   relation to the identified request target, and responds to that
   request with one or more response messages.  A client constructs
   request messages to communicate specific intentions, examines
   received responses to see if the intentions were carried out, and
   determines how to interpret the results.  This document defines
   HTTP/1.1 request and response semantics in terms of the architecture
   defined in [[RFC7230](/doc/html/rfc7230 "\"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\"")].

   HTTP provides a uniform interface for interacting with a resource
   ([Section 2](#section-2)), regardless of its type, nature, or implementation, via
   the manipulation and transfer of representations ([Section 3](#section-3)).

   HTTP semantics include the intentions defined by each request method
   ([Section 4](#section-4)), extensions to those semantics that might be described in
   request header fields ([Section 5](#section-5)), the meaning of status codes to
   indicate a machine-readable response ([Section 6](#section-6)), and the meaning of
   other control data and resource metadata that might be given in
   response header fields ([Section 7](#section-7)).

   This document also defines representation metadata that describe how
   a payload is intended to be interpreted by a recipient, the request
   header fields that might influence content selection, and the various
   selection algorithms that are collectively referred to as "content
   negotiation" ([Section 3.4](#section-3.4)).

[1.1](#section-1.1).  Conformance and Error Handling

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [[RFC2119](/doc/html/rfc2119 "\"Key words for use in RFCs to Indicate Requirement Levels\"")].

   Conformance criteria and considerations regarding error handling are
   defined in [Section 2.5 of [RFC7230]](/doc/html/rfc7230#section-2.5).

[1.2](#section-1.2).  Syntax Notation

   This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [[RFC5234](/doc/html/rfc5234 "\"Augmented BNF for Syntax Specifications: ABNF\"")] with a list extension, defined in [Section 7 of
   [RFC7230]](/doc/html/rfc7230#section-7), that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  [Appendix C](#appendix-C) describes rules imported from other
   documents.  [Appendix D](#appendix-D) shows the collected grammar with all list
   operators expanded to standard ABNF notation.

Fielding & Reschke           Standards Track                    [Page 6]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   This specification uses the terms "character", "character encoding
   scheme", "charset", and "protocol element" as they are defined in
   [[RFC6365](/doc/html/rfc6365 "\"Terminology Used in Internationalization in the IETF\"")].

[2](#section-2).  Resources

   The target of an HTTP request is called a "resource".  HTTP does not
   limit the nature of a resource; it merely defines an interface that
   might be used to interact with resources.  Each resource is
   identified by a Uniform Resource Identifier (URI), as described in
   [Section 2.7 of [RFC7230]](/doc/html/rfc7230#section-2.7).

   When a client constructs an HTTP/1.1 request message, it sends the
   target URI in one of various forms, as defined in ([Section 5.3 of
   [RFC7230]](/doc/html/rfc7230#section-5.3)).  When a request is received, the server reconstructs an
   effective request URI for the target resource ([Section 5.5 of
   [RFC7230]](/doc/html/rfc7230#section-5.5)).

   One design goal of HTTP is to separate resource identification from
   request semantics, which is made possible by vesting the request
   semantics in the request method ([Section 4](#section-4)) and a few
   request-modifying header fields ([Section 5](#section-5)).  If there is a conflict
   between the method semantics and any semantic implied by the URI
   itself, as described in [Section 4.2.1](#section-4.2.1), the method semantics take
   precedence.

[3](#section-3).  Representations

   Considering that a resource could be anything, and that the uniform
   interface provided by HTTP is similar to a window through which one
   can observe and act upon such a thing only through the communication
   of messages to some independent actor on the other side, an
   abstraction is needed to represent ("take the place of") the current
   or desired state of that thing in our communications.  That
   abstraction is called a representation [[REST](#ref-REST "\"Architectural Styles and the Design of Network-based Software Architectures\"")].

   For the purposes of HTTP, a "representation" is information that is
   intended to reflect a past, current, or desired state of a given
   resource, in a format that can be readily communicated via the
   protocol, and that consists of a set of representation metadata and a
   potentially unbounded stream of representation data.

   An origin server might be provided with, or be capable of generating,
   multiple representations that are each intended to reflect the
   current state of a target resource.  In such cases, some algorithm is
   used by the origin server to select one of those representations as
   most applicable to a given request, usually based on content
   negotiation.  This "selected representation" is used to provide the

Fielding & Reschke           Standards Track                    [Page 7]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   data and metadata for evaluating conditional requests [[RFC7232](/doc/html/rfc7232 "\"Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests\"")] and
   constructing the payload for 200 (OK) and 304 (Not Modified)
   responses to GET ([Section 4.3.1](#section-4.3.1)).

[3.1](#section-3.1).  Representation Metadata

   Representation header fields provide metadata about the
   representation.  When a message includes a payload body, the
   representation header fields describe how to interpret the
   representation data enclosed in the payload body.  In a response to a
   HEAD request, the representation header fields describe the
   representation data that would have been enclosed in the payload body
   if the same request had been a GET.

   The following header fields convey representation metadata:

   +-------------------+-----------------+
   | Header Field Name | Defined in...   |
   +-------------------+-----------------+
   | Content-Type      | [Section 3.1.1.5](#section-3.1.1.5) |
   | Content-Encoding  | [Section 3.1.2.2](#section-3.1.2.2) |
   | Content-Language  | [Section 3.1.3.2](#section-3.1.3.2) |
   | Content-Location  | [Section 3.1.4.2](#section-3.1.4.2) |
   +-------------------+-----------------+

[3.1.1](#section-3.1.1).  Processing Representation Data

[3.1.1.1](#section-3.1.1.1).  Media Type

   HTTP uses Internet media types [[RFC2046](/doc/html/rfc2046 "\"Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types\"")] in the Content-Type
   ([Section 3.1.1.5](#section-3.1.1.5)) and Accept ([Section 5.3.2](#section-5.3.2)) header fields in order
   to provide open and extensible data typing and type negotiation.
   Media types define both a data format and various processing models:
   how to process that data in accordance with each context in which it
   is received.

     media-type = type "/" subtype *( OWS ";" OWS parameter )
     type       = token
     subtype    = token

   The type/subtype MAY be followed by parameters in the form of
   name=value pairs.

     parameter      = token "=" ( token / quoted-string )

Fielding & Reschke           Standards Track                    [Page 8]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   The type, subtype, and parameter name tokens are case-insensitive.
   Parameter values might or might not be case-sensitive, depending on
   the semantics of the parameter name.  The presence or absence of a
   parameter might be significant to the processing of a media-type,
   depending on its definition within the media type registry.

   A parameter value that matches the token production can be
   transmitted either as a token or within a quoted-string.  The quoted
   and unquoted values are equivalent.  For example, the following
   examples are all equivalent, but the first is preferred for
   consistency:

     text/html;charset=utf-8
     text/html;charset=UTF-8
     Text/HTML;Charset="utf-8"
     text/html; charset="utf-8"

   Internet media types ought to be registered with IANA according to
   the procedures defined in [[BCP13](#ref-BCP13 "\"Media Type Specifications and Registration Procedures\"")].

      Note: Unlike some similar constructs in other header fields, media
      type parameters do not allow whitespace (even "bad" whitespace)
      around the "=" character.

[3.1.1.2](#section-3.1.1.2).  Charset

   HTTP uses charset names to indicate or negotiate the character
   encoding scheme of a textual representation [[RFC6365](/doc/html/rfc6365 "\"Terminology Used in Internationalization in the IETF\"")].  A charset is
   identified by a case-insensitive token.

     charset = token

   Charset names ought to be registered in the IANA "Character Sets"
   registry (<<http://www.iana.org/assignments/character-sets>>) according
   to the procedures defined in [[RFC2978](/doc/html/rfc2978 "\"IANA Charset Registration Procedures\"")].

[3.1.1.3](#section-3.1.1.3).  Canonicalization and Text Defaults

   Internet media types are registered with a canonical form in order to
   be interoperable among systems with varying native encoding formats.
   Representations selected or transferred via HTTP ought to be in
   canonical form, for many of the same reasons described by the
   Multipurpose Internet Mail Extensions (MIME) [[RFC2045](/doc/html/rfc2045 "\"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\"")].  However, the
   performance characteristics of email deployments (i.e., store and
   forward messages to peers) are significantly different from those
   common to HTTP and the Web (server-based information services).
   Furthermore, MIME's constraints for the sake of compatibility with
   older mail transfer protocols do not apply to HTTP (see [Appendix A](#appendix-A)).

Fielding & Reschke           Standards Track                    [Page 9]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   MIME's canonical form requires that media subtypes of the "text" type
   use CRLF as the text line break.  HTTP allows the transfer of text
   media with plain CR or LF alone representing a line break, when such
   line breaks are consistent for an entire representation.  An HTTP
   sender MAY generate, and a recipient MUST be able to parse, line
   breaks in text media that consist of CRLF, bare CR, or bare LF.  In
   addition, text media in HTTP is not limited to charsets that use
   octets 13 and 10 for CR and LF, respectively.  This flexibility
   regarding line breaks applies only to text within a representation
   that has been assigned a "text" media type; it does not apply to
   "multipart" types or HTTP elements outside the payload body (e.g.,
   header fields).

   If a representation is encoded with a content-coding, the underlying
   data ought to be in a form defined above prior to being encoded.

[3.1.1.4](#section-3.1.1.4).  Multipart Types

   MIME provides for a number of "multipart" types -- encapsulations of
   one or more representations within a single message body.  All
   multipart types share a common syntax, as defined in [Section 5.1.1 of
   [RFC2046]](/doc/html/rfc2046#section-5.1.1), and include a boundary parameter as part of the media type
   value.  The message body is itself a protocol element; a sender MUST
   generate only CRLF to represent line breaks between body parts.

   HTTP message framing does not use the multipart boundary as an
   indicator of message body length, though it might be used by
   implementations that generate or process the payload.  For example,
   the "multipart/form-data" type is often used for carrying form data
   in a request, as described in [[RFC2388](/doc/html/rfc2388 "\"Returning Values from Forms: multipart/ form-data\"")], and the "multipart/
   byteranges" type is defined by this specification for use in some 206
   (Partial Content) responses [[RFC7233](/doc/html/rfc7233 "\"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\"")].

[3.1.1.5](#section-3.1.1.5).  Content-Type

   The "Content-Type" header field indicates the media type of the
   associated representation: either the representation enclosed in the
   message payload or the selected representation, as determined by the
   message semantics.  The indicated media type defines both the data
   format and how that data is intended to be processed by a recipient,
   within the scope of the received message semantics, after any content
   codings indicated by Content-Encoding are decoded.

     Content-Type = media-type

Fielding & Reschke           Standards Track                   [Page 10]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   Media types are defined in [Section 3.1.1.1](#section-3.1.1.1).  An example of the field
   is

     Content-Type: text/html; charset=ISO-8859-4

   A sender that generates a message containing a payload body SHOULD
   generate a Content-Type header field in that message unless the
   intended media type of the enclosed representation is unknown to the
   sender.  If a Content-Type header field is not present, the recipient
   MAY either assume a media type of "application/octet-stream"
   ([[RFC2046], Section 4.5.1](/doc/html/rfc2046#section-4.5.1)) or examine the data to determine its type.

   In practice, resource owners do not always properly configure their
   origin server to provide the correct Content-Type for a given
   representation, with the result that some clients will examine a
   payload's content and override the specified type.  Clients that do
   so risk drawing incorrect conclusions, which might expose additional
   security risks (e.g., "privilege escalation").  Furthermore, it is
   impossible to determine the sender's intent by examining the data
   format: many data formats match multiple media types that differ only
   in processing semantics.  Implementers are encouraged to provide a
   means of disabling such "content sniffing" when it is used.

[3.1.2](#section-3.1.2).  Encoding for Compression or Integrity

[3.1.2.1](#section-3.1.2.1).  Content Codings

   Content coding values indicate an encoding transformation that has
   been or can be applied to a representation.  Content codings are
   primarily used to allow a representation to be compressed or
   otherwise usefully transformed without losing the identity of its
   underlying media type and without loss of information.  Frequently,
   the representation is stored in coded form, transmitted directly, and
   only decoded by the final recipient.

     content-coding   = token

   All content-coding values are case-insensitive and ought to be
   registered within the "HTTP Content Coding Registry", as defined in
   [Section 8.4](#section-8.4).  They are used in the Accept-Encoding ([Section 5.3.4](#section-5.3.4))
   and Content-Encoding ([Section 3.1.2.2](#section-3.1.2.2)) header fields.

Fielding & Reschke           Standards Track                   [Page 11]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   The following content-coding values are defined by this
   specification:

      compress (and x-compress): See [Section 4.2.1 of [RFC7230]](/doc/html/rfc7230#section-4.2.1).

      deflate: See [Section 4.2.2 of [RFC7230]](/doc/html/rfc7230#section-4.2.2).

      gzip (and x-gzip): See [Section 4.2.3 of [RFC7230]](/doc/html/rfc7230#section-4.2.3).

[3.1.2.2](#section-3.1.2.2).  Content-Encoding

   The "Content-Encoding" header field indicates what content codings
   have been applied to the representation, beyond those inherent in the
   media type, and thus what decoding mechanisms have to be applied in
   order to obtain data in the media type referenced by the Content-Type
   header field.  Content-Encoding is primarily used to allow a
   representation's data to be compressed without losing the identity of
   its underlying media type.

     Content-Encoding = 1#content-coding

   An example of its use is

     Content-Encoding: gzip

   If one or more encodings have been applied to a representation, the
   sender that applied the encodings MUST generate a Content-Encoding
   header field that lists the content codings in the order in which
   they were applied.  Additional information about the encoding
   parameters can be provided by other header fields not defined by this
   specification.

   Unlike Transfer-Encoding ([Section 3.3.1 of [RFC7230]](/doc/html/rfc7230#section-3.3.1)), the codings
   listed in Content-Encoding are a characteristic of the
   representation; the representation is defined in terms of the coded
   form, and all other metadata about the representation is about the
   coded form unless otherwise noted in the metadata definition.
   Typically, the representation is only decoded just prior to rendering
   or analogous usage.

   If the media type includes an inherent encoding, such as a data
   format that is always compressed, then that encoding would not be
   restated in Content-Encoding even if it happens to be the same
   algorithm as one of the content codings.  Such a content coding would
   only be listed if, for some bizarre reason, it is applied a second
   time to form the representation.  Likewise, an origin server might
   choose to publish the same data as multiple representations that
   differ only in whether the coding is defined as part of Content-Type

Fielding & Reschke           Standards Track                   [Page 12]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   or Content-Encoding, since some user agents will behave differently
   in their handling of each response (e.g., open a "Save as ..." dialog
   instead of automatic decompression and rendering of content).

   An origin server MAY respond with a status code of 415 (Unsupported
   Media Type) if a representation in the request message has a content
   coding that is not acceptable.

[3.1.3](#section-3.1.3).  Audience Language

[3.1.3.1](#section-3.1.3.1).  Language Tags

   A language tag, as defined in [[RFC5646](/doc/html/rfc5646 "\"Tags for Identifying Languages\"")], identifies a natural
   language spoken, written, or otherwise conveyed by human beings for
   communication of information to other human beings.  Computer
   languages are explicitly excluded.

   HTTP uses language tags within the Accept-Language and
   Content-Language header fields.  Accept-Language uses the broader
   language-range production defined in [Section 5.3.5](#section-5.3.5), whereas
   Content-Language uses the language-tag production defined below.

     language-tag = <Language-Tag, see [[RFC5646], Section 2.1](/doc/html/rfc5646#section-2.1)>

   A language tag is a sequence of one or more case-insensitive subtags,
   each separated by a hyphen character ("-", %x2D).  In most cases, a
   language tag consists of a primary language subtag that identifies a
   broad family of related languages (e.g., "en" = English), which is
   optionally followed by a series of subtags that refine or narrow that
   language's range (e.g., "en-CA" = the variety of English as
   communicated in Canada).  Whitespace is not allowed within a language
   tag.  Example tags include:

     fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN

   See [[RFC5646](/doc/html/rfc5646 "\"Tags for Identifying Languages\"")] for further information.

[3.1.3.2](#section-3.1.3.2).  Content-Language

   The "Content-Language" header field describes the natural language(s)
   of the intended audience for the representation.  Note that this
   might not be equivalent to all the languages used within the
   representation.

     Content-Language = 1#language-tag

Fielding & Reschke           Standards Track                   [Page 13]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   Language tags are defined in [Section 3.1.3.1](#section-3.1.3.1).  The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   representations according to the users' own preferred language.
   Thus, if the content is intended only for a Danish-literate audience,
   the appropriate field is

     Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences.  This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences.  For example, a rendition of the "Treaty of
   Waitangi", presented simultaneously in the original Maori and English
   versions, would call for

     Content-Language: mi, en

   However, just because multiple languages are present within a
   representation does not mean that it is intended for multiple
   linguistic audiences.  An example would be a beginner's language
   primer, such as "A First Lesson in Latin", which is clearly intended
   to be used by an English-literate audience.  In this case, the
   Content-Language would properly only include "en".

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.

[3.1.4](#section-3.1.4).  Identification

[3.1.4.1](#section-3.1.4.1).  Identifying a Representation

   When a complete or partial representation is transferred in a message
   payload, it is often desirable for the sender to supply, or the
   recipient to determine, an identifier for a resource corresponding to
   that representation.

   For a request message:

   o  If the request has a Content-Location header field, then the
      sender asserts that the payload is a representation of the
      resource identified by the Content-Location field-value.  However,
      such an assertion cannot be trusted unless it can be verified by
      other means (not defined by this specification).  The information
      might still be useful for revision history links.

Fielding & Reschke           Standards Track                   [Page 14]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   o  Otherwise, the payload is unidentified.

   For a response message, the following rules are applied in order
   until a match is found:

   1.  If the request method is GET or HEAD and the response status code
       is 200 (OK), 204 (No Content), 206 (Partial Content), or 304 (Not
       Modified), the payload is a representation of the resource
       identified by the effective request URI ([Section 5.5 of
       [RFC7230]](/doc/html/rfc7230#section-5.5)).

   2.  If the request method is GET or HEAD and the response status code
       is 203 (Non-Authoritative Information), the payload is a
       potentially modified or enhanced representation of the target
       resource as provided by an intermediary.

   3.  If the response has a Content-Location header field and its
       field-value is a reference to the same URI as the effective
       request URI, the payload is a representation of the resource
       identified by the effective request URI.

   4.  If the response has a Content-Location header field and its
       field-value is a reference to a URI different from the effective
       request URI, then the sender asserts that the payload is a
       representation of the resource identified by the Content-Location
       field-value.  However, such an assertion cannot be trusted unless
       it can be verified by other means (not defined by this
       specification).

   5.  Otherwise, the payload is unidentified.

[3.1.4.2](#section-3.1.4.2).  Content-Location

   The "Content-Location" header field references a URI that can be used
   as an identifier for a specific resource corresponding to the
   representation in this message's payload.  In other words, if one
   were to perform a GET request on this URI at the time of this
   message's generation, then a 200 (OK) response would contain the same
   representation that is enclosed as payload in this message.

     Content-Location = absolute-URI / partial-URI

   The Content-Location value is not a replacement for the effective
   Request URI ([Section 5.5 of [RFC7230]](/doc/html/rfc7230#section-5.5)).  It is representation
   metadata.  It has the same syntax and semantics as the header field
   of the same name defined for MIME body parts in [Section 4 of
   [RFC2557]](/doc/html/rfc2557#section-4).  However, its appearance in an HTTP message has some
   special implications for HTTP recipients.

Fielding & Reschke           Standards Track                   [Page 15]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   If Content-Location is included in a 2xx (Successful) response
   message and its value refers (after conversion to absolute form) to a
   URI that is the same as the effective request URI, then the recipient
   MAY consider the payload to be a current representation of that
   resource at the time indicated by the message origination date.  For
   a GET ([Section 4.3.1](#section-4.3.1)) or HEAD ([Section 4.3.2](#section-4.3.2)) request, this is the
   same as the default semantics when no Content-Location is provided by
   the server.  For a state-changing request like PUT ([Section 4.3.4](#section-4.3.4)) or
   POST ([Section 4.3.3](#section-4.3.3)), it implies that the server's response contains
   the new representation of that resource, thereby distinguishing it
   from representations that might only report about the action (e.g.,
   "It worked!").  This allows authoring applications to update their
   local copies without the need for a subsequent GET request.

   If Content-Location is included in a 2xx (Successful) response
   message and its field-value refers to a URI that differs from the
   effective request URI, then the origin server claims that the URI is
   an identifier for a different resource corresponding to the enclosed
   representation.  Such a claim can only be trusted if both identifiers
   share the same resource owner, which cannot be programmatically
   determined via HTTP.

   o  For a response to a GET or HEAD request, this is an indication
      that the effective request URI refers to a resource that is
      subject to content negotiation and the Content-Location
      field-value is a more specific identifier for the selected
      representation.

   o  For a 201 (Created) response to a state-changing method, a
      Content-Location field-value that is identical to the Location
      field-value indicates that this payload is a current
      representation of the newly created resource.

   o  Otherwise, such a Content-Location indicates that this payload is
      a representation reporting on the requested action's status and
      that the same report is available (for future access with GET) at
      the given URI.  For example, a purchase transaction made via a
      POST request might include a receipt document as the payload of
      the 200 (OK) response; the Content-Location field-value provides
      an identifier for retrieving a copy of that same receipt in the
      future.

   A user agent that sends Content-Location in a request message is
   stating that its value refers to where the user agent originally
   obtained the content of the enclosed representation (prior to any
   modifications made by that user agent).  In other words, the user
   agent is providing a back link to the source of the original
   representation.

Fielding & Reschke           Standards Track                   [Page 16]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   An origin server that receives a Content-Location field in a request
   message MUST treat the information as transitory request context
   rather than as metadata to be saved verbatim as part of the
   representation.  An origin server MAY use that context to guide in
   processing the request or to save it for other uses, such as within
   source links or versioning metadata.  However, an origin server MUST
   NOT use such context information to alter the request semantics.

   For example, if a client makes a PUT request on a negotiated resource
   and the origin server accepts that PUT (without redirection), then
   the new state of that resource is expected to be consistent with the
   one representation supplied in that PUT; the Content-Location cannot
   be used as a form of reverse content selection identifier to update
   only one of the negotiated representations.  If the user agent had
   wanted the latter semantics, it would have applied the PUT directly
   to the Content-Location URI.

[3.2](#section-3.2).  Representation Data

   The representation data associated with an HTTP message is either
   provided as the payload body of the message or referred to by the
   message semantics and the effective request URI.  The representation
   data is in a format and encoding defined by the representation
   metadata header fields.

   The data type of the representation data is determined via the header
   fields Content-Type and Content-Encoding.  These define a two-layer,
   ordered encoding model:

     representation-data := Content-Encoding( Content-Type( bits ) )

[3.3](#section-3.3).  Payload Semantics

   Some HTTP messages transfer a complete or partial representation as
   the message "payload".  In some cases, a payload might contain only
   the associated representation's header fields (e.g., responses to
   HEAD) or only some part(s) of the representation data (e.g., the 206
   (Partial Content) status code).

   The purpose of a payload in a request is defined by the method
   semantics.  For example, a representation in the payload of a PUT
   request ([Section 4.3.4](#section-4.3.4)) represents the desired state of the target
   resource if the request is successfully applied, whereas a
   representation in the payload of a POST request ([Section 4.3.3](#section-4.3.3))
   represents information to be processed by the target resource.

Fielding & Reschke           Standards Track                   [Page 17]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   In a response, the payload's purpose is defined by both the request
   method and the response status code.  For example, the payload of a
   200 (OK) response to GET ([Section 4.3.1](#section-4.3.1)) represents the current state
   of the target resource, as observed at the time of the message
   origination date ([Section 7.1.1.2](#section-7.1.1.2)), whereas the payload of the same
   status code in a response to POST might represent either the
   processing result or the new state of the target resource after
   applying the processing.  Response messages with an error status code
   usually contain a payload that represents the error condition, such
   that it describes the error state and what next steps are suggested
   for resolving it.

   Header fields that specifically describe the payload, rather than the
   associated representation, are referred to as "payload header
   fields".  Payload header fields are defined in other parts of this
   specification, due to their impact on message parsing.

   +-------------------+----------------------------+
   | Header Field Name | Defined in...              |
   +-------------------+----------------------------+
   | Content-Length    | [Section 3.3.2 of [RFC7230]](/doc/html/rfc7230#section-3.3.2) |
   | Content-Range     | [Section 4.2 of [RFC7233]](/doc/html/rfc7233#section-4.2)   |
   | Trailer           | [Section 4.4 of [RFC7230]](/doc/html/rfc7230#section-4.4)   |
   | Transfer-Encoding | [Section 3.3.1 of [RFC7230]](/doc/html/rfc7230#section-3.3.1) |
   +-------------------+----------------------------+

[3.4](#section-3.4).  Content Negotiation

   When responses convey payload information, whether indicating a
   success or an error, the origin server often has different ways of
   representing that information; for example, in different formats,
   languages, or encodings.  Likewise, different users or user agents
   might have differing capabilities, characteristics, or preferences
   that could influence which representation, among those available,
   would be best to deliver.  For this reason, HTTP provides mechanisms
   for content negotiation.

   This specification defines two patterns of content negotiation that
   can be made visible within the protocol: "proactive", where the
   server selects the representation based upon the user agent's stated
   preferences, and "reactive" negotiation, where the server provides a
   list of representations for the user agent to choose from.  Other
   patterns of content negotiation include "conditional content", where
   the representation consists of multiple parts that are selectively
   rendered based on user agent parameters, "active content", where the
   representation contains a script that makes additional (more
   specific) requests based on the user agent characteristics, and
   "Transparent Content Negotiation" ([[RFC2295](/doc/html/rfc2295 "\"Transparent Content Negotiation in HTTP\"")]), where content

Fielding & Reschke           Standards Track                   [Page 18]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   selection is performed by an intermediary.  These patterns are not
   mutually exclusive, and each has trade-offs in applicability and
   practicality.

   Note that, in all cases, HTTP is not aware of the resource semantics.
   The consistency with which an origin server responds to requests,
   over time and over the varying dimensions of content negotiation, and
   thus the "sameness" of a resource's observed representations over
   time, is determined entirely by whatever entity or algorithm selects
   or generates those responses.  HTTP pays no attention to the man
   behind the curtain.

[3.4.1](#section-3.4.1).  Proactive Negotiation

   When content negotiation preferences are sent by the user agent in a
   request to encourage an algorithm located at the server to select the
   preferred representation, it is called proactive negotiation (a.k.a.,
   server-driven negotiation).  Selection is based on the available
   representations for a response (the dimensions over which it might
   vary, such as language, content-coding, etc.) compared to various
   information supplied in the request, including both the explicit
   negotiation fields of [Section 5.3](#section-5.3) and implicit characteristics, such
   as the client's network address or parts of the User-Agent field.

   Proactive negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to a user agent, or when the server desires to send its
   "best guess" to the user agent along with the first response (hoping
   to avoid the round trip delay of a subsequent request if the "best
   guess" is good enough for the user).  In order to improve the
   server's guess, a user agent MAY send request header fields that
   describe its preferences.

   Proactive negotiation has serious disadvantages:

   o  It is impossible for the server to accurately determine what might
      be "best" for any given user, since that would require complete
      knowledge of both the capabilities of the user agent and the
      intended use for the response (e.g., does the user want to view it
      on screen or print it on paper?);

   o  Having the user agent describe its capabilities in every request
      can be both very inefficient (given that only a small percentage
      of responses have multiple representations) and a potential risk
      to the user's privacy;

   o  It complicates the implementation of an origin server and the
      algorithms for generating responses to a request; and,

Fielding & Reschke           Standards Track                   [Page 19]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   o  It limits the reusability of responses for shared caching.

   A user agent cannot rely on proactive negotiation preferences being
   consistently honored, since the origin server might not implement
   proactive negotiation for the requested resource or might decide that
   sending a response that doesn't conform to the user agent's
   preferences is better than sending a 406 (Not Acceptable) response.

   A Vary header field ([Section 7.1.4](#section-7.1.4)) is often sent in a response
   subject to proactive negotiation to indicate what parts of the
   request information were used in the selection algorithm.

[3.4.2](#section-3.4.2).  Reactive Negotiation

   With reactive negotiation (a.k.a., agent-driven negotiation),
   selection of the best response representation (regardless of the
   status code) is performed by the user agent after receiving an
   initial response from the origin server that contains a list of
   resources for alternative representations.  If the user agent is not
   satisfied by the initial response representation, it can perform a
   GET request on one or more of the alternative resources, selected
   based on metadata included in the list, to obtain a different form of
   representation for that response.  Selection of alternatives might be
   performed automatically by the user agent or manually by the user
   selecting from a generated (possibly hypertext) menu.

   Note that the above refers to representations of the response, in
   general, not representations of the resource.  The alternative
   representations are only considered representations of the target
   resource if the response in which those alternatives are provided has
   the semantics of being a representation of the target resource (e.g.,
   a 200 (OK) response to a GET request) or has the semantics of
   providing links to alternative representations for the target
   resource (e.g., a 300 (Multiple Choices) response to a GET request).

   A server might choose not to send an initial representation, other
   than the list of alternatives, and thereby indicate that reactive
   negotiation by the user agent is preferred.  For example, the
   alternatives listed in responses with the 300 (Multiple Choices) and
   406 (Not Acceptable) status codes include information about the
   available representations so that the user or user agent can react by
   making a selection.

   Reactive negotiation is advantageous when the response would vary
   over commonly used dimensions (such as type, language, or encoding),
   when the origin server is unable to determine a user agent's
   capabilities from examining the request, and generally when public
   caches are used to distribute server load and reduce network usage.

Fielding & Reschke           Standards Track                   [Page 20]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   Reactive negotiation suffers from the disadvantages of transmitting a
   list of alternatives to the user agent, which degrades user-perceived
   latency if transmitted in the header section, and needing a second
   request to obtain an alternate representation.  Furthermore, this
   specification does not define a mechanism for supporting automatic
   selection, though it does not prevent such a mechanism from being
   developed as an extension.

[4](#section-4).  Request Methods

[4.1](#section-4.1).  Overview

   The request method token is the primary source of request semantics;
   it indicates the purpose for which the client has made this request
   and what is expected by the client as a successful result.

   The request method's semantics might be further specialized by the
   semantics of some header fields when present in a request ([Section 5](#section-5))
   if those additional semantics do not conflict with the method.  For
   example, a client can send conditional request header fields
   ([Section 5.2](#section-5.2)) to make the requested action conditional on the current
   state of the target resource ([[RFC7232](/doc/html/rfc7232 "\"Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests\"")]).

     method = token

   HTTP was originally designed to be usable as an interface to
   distributed object systems.  The request method was envisioned as
   applying semantics to a target resource in much the same way as
   invoking a defined method on an identified object would apply
   semantics.  The method token is case-sensitive because it might be
   used as a gateway to object-based systems with case-sensitive method
   names.

   Unlike distributed objects, the standardized request methods in HTTP
   are not resource-specific, since uniform interfaces provide for
   better visibility and reuse in network-based systems [[REST](#ref-REST "\"Architectural Styles and the Design of Network-based Software Architectures\"")].  Once
   defined, a standardized method ought to have the same semantics when
   applied to any resource, though each resource determines for itself
   whether those semantics are implemented or allowed.

   This specification defines a number of standardized methods that are
   commonly used in HTTP, as outlined by the following table.  By
   convention, standardized methods are defined in all-uppercase
   US-ASCII letters.

Fielding & Reschke           Standards Track                   [Page 21]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   +---------+-------------------------------------------------+-------+
   | Method  | Description                                     | Sec.  |
   +---------+-------------------------------------------------+-------+
   | GET     | Transfer a current representation of the target | 4.3.1 |
   |         | resource.                                       |       |
   | HEAD    | Same as GET, but only transfer the status line  | 4.3.2 |
   |         | and header section.                             |       |
   | POST    | Perform resource-specific processing on the     | 4.3.3 |
   |         | request payload.                                |       |
   | PUT     | Replace all current representations of the      | 4.3.4 |
   |         | target resource with the request payload.       |       |
   | DELETE  | Remove all current representations of the       | 4.3.5 |
   |         | target resource.                                |       |
   | CONNECT | Establish a tunnel to the server identified by  | 4.3.6 |
   |         | the target resource.                            |       |
   | OPTIONS | Describe the communication options for the      | 4.3.7 |
   |         | target resource.                                |       |
   | TRACE   | Perform a message loop-back test along the path | 4.3.8 |
   |         | to the target resource.                         |       |
   +---------+-------------------------------------------------+-------+

   All general-purpose servers MUST support the methods GET and HEAD.
   All other methods are OPTIONAL.

   Additional methods, outside the scope of this specification, have
   been standardized for use in HTTP.  All such methods ought to be
   registered within the "Hypertext Transfer Protocol (HTTP) Method
   Registry" maintained by IANA, as defined in [Section 8.1](#section-8.1).

   The set of methods allowed by a target resource can be listed in an
   Allow header field ([Section 7.4.1](#section-7.4.1)).  However, the set of allowed
   methods can change dynamically.  When a request method is received
   that is unrecognized or not implemented by an origin server, the
   origin server SHOULD respond with the 501 (Not Implemented) status
   code.  When a request method is received that is known by an origin
   server but not allowed for the target resource, the origin server
   SHOULD respond with the 405 (Method Not Allowed) status code.

[4.2](#section-4.2).  Common Method Properties

[4.2.1](#section-4.2.1).  Safe Methods

   Request methods are considered "safe" if their defined semantics are
   essentially read-only; i.e., the client does not request, and does
   not expect, any state change on the origin server as a result of
   applying a safe method to a target resource.  Likewise, reasonable
   use of a safe method is not expected to cause any harm, loss of
   property, or unusual burden on the origin server.

Fielding & Reschke           Standards Track                   [Page 22]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   This definition of safe methods does not prevent an implementation
   from including behavior that is potentially harmful, that is not
   entirely read-only, or that causes side effects while invoking a safe
   method.  What is important, however, is that the client did not
   request that additional behavior and cannot be held accountable for
   it.  For example, most servers append request information to access
   log files at the completion of every response, regardless of the
   method, and that is considered safe even though the log storage might
   become full and crash the server.  Likewise, a safe request initiated
   by selecting an advertisement on the Web will often have the side
   effect of charging an advertising account.

   Of the request methods defined by this specification, the GET, HEAD,
   OPTIONS, and TRACE methods are defined to be safe.

   The purpose of distinguishing between safe and unsafe methods is to
   allow automated retrieval processes (spiders) and cache performance
   optimization (pre-fetching) to work without fear of causing harm.  In
   addition, it allows a user agent to apply appropriate constraints on
   the automated use of unsafe methods when processing potentially
   untrusted content.

   A user agent SHOULD distinguish between safe and unsafe methods when
   presenting potential actions to a user, such that the user can be
   made aware of an unsafe action before it is requested.

   When a resource is constructed such that parameters within the
   effective request URI have the effect of selecting an action, it is
   the resource owner's responsibility to ensure that the action is
   consistent with the request method semantics.  For example, it is
   common for Web-based content editing software to use actions within
   query parameters, such as "page?do=delete".  If the purpose of such a
   resource is to perform an unsafe action, then the resource owner MUST
   disable or disallow that action when it is accessed using a safe
   request method.  Failure to do so will result in unfortunate side
   effects when automated processes perform a GET on every URI reference
   for the sake of link maintenance, pre-fetching, building a search
   index, etc.

[4.2.2](#section-4.2.2).  Idempotent Methods

   A request method is considered "idempotent" if the intended effect on
   the server of multiple identical requests with that method is the
   same as the effect for a single such request.  Of the request methods
   defined by this specification, PUT, DELETE, and safe request methods
   are idempotent.

Fielding & Reschke           Standards Track                   [Page 23]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   Like the definition of safe, the idempotent property only applies to
   what has been requested by the user; a server is free to log each
   request separately, retain a revision control history, or implement
   other non-idempotent side effects for each idempotent request.

   Idempotent methods are distinguished because the request can be
   repeated automatically if a communication failure occurs before the
   client is able to read the server's response.  For example, if a
   client sends a PUT request and the underlying connection is closed
   before any response is received, then the client can establish a new
   connection and retry the idempotent request.  It knows that repeating
   the request will have the same intended effect, even if the original
   request succeeded, though the response might differ.

[4.2.3](#section-4.2.3).  Cacheable Methods

   Request methods can be defined as "cacheable" to indicate that
   responses to them are allowed to be stored for future reuse; for
   specific requirements see [[RFC7234](/doc/html/rfc7234 "\"Hypertext Transfer Protocol (HTTP/1.1): Caching\"")].  In general, safe methods that
   do not depend on a current or authoritative response are defined as
   cacheable; this specification defines GET, HEAD, and POST as
   cacheable, although the overwhelming majority of cache
   implementations only support GET and HEAD.

[4.3](#section-4.3).  Method Definitions

[4.3.1](#section-4.3.1).  GET

   The GET method requests transfer of a current selected representation
   for the target resource.  GET is the primary mechanism of information
   retrieval and the focus of almost all performance optimizations.
   Hence, when people speak of retrieving some identifiable information
   via HTTP, they are generally referring to making a GET request.

   It is tempting to think of resource identifiers as remote file system
   pathnames and of representations as being a copy of the contents of
   such files.  In fact, that is how many resources are implemented (see
   [Section 9.1](#section-9.1) for related security considerations).  However, there are
   no such limitations in practice.  The HTTP interface for a resource
   is just as likely to be implemented as a tree of content objects, a
   programmatic view on various database records, or a gateway to other
   information systems.  Even when the URI mapping mechanism is tied to
   a file system, an origin server might be configured to execute the
   files with the request as input and send the output as the
   representation rather than transfer the files directly.  Regardless,
   only the origin server needs to know how each of its resource

Fielding & Reschke           Standards Track                   [Page 24]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   identifiers corresponds to an implementation and how each
   implementation manages to select and send a current representation of
   the target resource in a response to GET.

   A client can alter the semantics of GET to be a "range request",
   requesting transfer of only some part(s) of the selected
   representation, by sending a Range header field in the request
   ([[RFC7233](/doc/html/rfc7233 "\"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\"")]).

   A payload within a GET request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.

   The response to a GET request is cacheable; a cache MAY use it to
   satisfy subsequent GET and HEAD requests unless otherwise indicated
   by the Cache-Control header field ([Section 5.2 of [RFC7234]](/doc/html/rfc7234#section-5.2)).

[4.3.2](#section-4.3.2).  HEAD

   The HEAD method is identical to GET except that the server MUST NOT
   send a message body in the response (i.e., the response terminates at
   the end of the header section).  The server SHOULD send the same
   header fields in response to a HEAD request as it would have sent if
   the request had been a GET, except that the payload header fields
   ([Section 3.3](#section-3.3)) MAY be omitted.  This method can be used for obtaining
   metadata about the selected representation without transferring the
   representation data and is often used for testing hypertext links for
   validity, accessibility, and recent modification.

   A payload within a HEAD request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.

   The response to a HEAD request is cacheable; a cache MAY use it to
   satisfy subsequent HEAD requests unless otherwise indicated by the
   Cache-Control header field ([Section 5.2 of [RFC7234]](/doc/html/rfc7234#section-5.2)).  A HEAD
   response might also have an effect on previously cached responses to
   GET; see [Section 4.3.5 of [RFC7234]](/doc/html/rfc7234#section-4.3.5).

[4.3.3](#section-4.3.3).  POST

   The POST method requests that the target resource process the
   representation enclosed in the request according to the resource's
   own specific semantics.  For example, POST is used for the following
   functions (among others):

   o  Providing a block of data, such as the fields entered into an HTML
      form, to a data-handling process;

Fielding & Reschke           Standards Track                   [Page 25]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   o  Posting a message to a bulletin board, newsgroup, mailing list,
      blog, or similar group of articles;

   o  Creating a new resource that has yet to be identified by the
      origin server; and

   o  Appending data to a resource's existing representation(s).

   An origin server indicates response semantics by choosing an
   appropriate status code depending on the result of processing the
   POST request; almost all of the status codes defined by this
   specification might be received in a response to POST (the exceptions
   being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not
   Satisfiable)).

   If one or more resources has been created on the origin server as a
   result of successfully processing a POST request, the origin server
   SHOULD send a 201 (Created) response containing a Location header
   field that provides an identifier for the primary resource created
   ([Section 7.1.2](#section-7.1.2)) and a representation that describes the status of the
   request while referring to the new resource(s).

   Responses to POST requests are only cacheable when they include
   explicit freshness information (see [Section 4.2.1 of [RFC7234]](/doc/html/rfc7234#section-4.2.1)).
   However, POST caching is not widely implemented.  For cases where an
   origin server wishes the client to be able to cache the result of a
   POST in a way that can be reused by a later GET, the origin server
   MAY send a 200 (OK) response containing the result and a
   Content-Location header field that has the same value as the POST's
   effective request URI ([Section 3.1.4.2](#section-3.1.4.2)).

   If the result of processing a POST would be equivalent to a
   representation of an existing resource, an origin server MAY redirect
   the user agent to that resource by sending a 303 (See Other) response
   with the existing resource's identifier in the Location field.  This
   has the benefits of providing the user agent a resource identifier
   and transferring the representation via a method more amenable to
   shared caching, though at the cost of an extra request if the user
   agent does not already have the representation cached.

[4.3.4](#section-4.3.4).  PUT

   The PUT method requests that the state of the target resource be
   created or replaced with the state defined by the representation
   enclosed in the request message payload.  A successful PUT of a given
   representation would suggest that a subsequent GET on that same
   target resource will result in an equivalent representation being
   sent in a 200 (OK) response.  However, there is no guarantee that

Fielding & Reschke           Standards Track                   [Page 26]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   such a state change will be observable, since the target resource
   might be acted upon by other user agents in parallel, or might be
   subject to dynamic processing by the origin server, before any
   subsequent GET is received.  A successful response only implies that
   the user agent's intent was achieved at the time of its processing by
   the origin server.

   If the target resource does not have a current representation and the
   PUT successfully creates one, then the origin server MUST inform the
   user agent by sending a 201 (Created) response.  If the target
   resource does have a current representation and that representation
   is successfully modified in accordance with the state of the enclosed
   representation, then the origin server MUST send either a 200 (OK) or
   a 204 (No Content) response to indicate successful completion of the
   request.

   An origin server SHOULD ignore unrecognized header fields received in
   a PUT request (i.e., do not save them as part of the resource state).

   An origin server SHOULD verify that the PUT representation is
   consistent with any constraints the server has for the target
   resource that cannot or will not be changed by the PUT.  This is
   particularly important when the origin server uses internal
   configuration information related to the URI in order to set the
   values for representation metadata on GET responses.  When a PUT
   representation is inconsistent with the target resource, the origin
   server SHOULD either make them consistent, by transforming the
   representation or changing the resource configuration, or respond
   with an appropriate error message containing sufficient information
   to explain why the representation is unsuitable.  The 409 (Conflict)
   or 415 (Unsupported Media Type) status codes are suggested, with the
   latter being specific to constraints on Content-Type values.

   For example, if the target resource is configured to always have a
   Content-Type of "text/html" and the representation being PUT has a
   Content-Type of "image/jpeg", the origin server ought to do one of:

   a.  reconfigure the target resource to reflect the new media type;

   b.  transform the PUT representation to a format consistent with that
       of the resource before saving it as the new resource state; or,

   c.  reject the request with a 415 (Unsupported Media Type) response
       indicating that the target resource is limited to "text/html",
       perhaps including a link to a different resource that would be a
       suitable target for the new representation.

Fielding & Reschke           Standards Track                   [Page 27]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   HTTP does not define exactly how a PUT method affects the state of an
   origin server beyond what can be expressed by the intent of the user
   agent request and the semantics of the origin server response.  It
   does not define what a resource might be, in any sense of that word,
   beyond the interface provided via HTTP.  It does not define how
   resource state is "stored", nor how such storage might change as a
   result of a change in resource state, nor how the origin server
   translates resource state into representations.  Generally speaking,
   all implementation details behind the resource interface are
   intentionally hidden by the server.

   An origin server MUST NOT send a validator header field
   ([Section 7.2](#section-7.2)), such as an ETag or Last-Modified field, in a
   successful response to PUT unless the request's representation data
   was saved without any transformation applied to the body (i.e., the
   resource's new representation data is identical to the representation
   data received in the PUT request) and the validator field value
   reflects the new representation.  This requirement allows a user
   agent to know when the representation body it has in memory remains
   current as a result of the PUT, thus not in need of being retrieved
   again from the origin server, and that the new validator(s) received
   in the response can be used for future conditional requests in order
   to prevent accidental overwrites ([Section 5.2](#section-5.2)).

   The fundamental difference between the POST and PUT methods is
   highlighted by the different intent for the enclosed representation.
   The target resource in a POST request is intended to handle the
   enclosed representation according to the resource's own semantics,
   whereas the enclosed representation in a PUT request is defined as
   replacing the state of the target resource.  Hence, the intent of PUT
   is idempotent and visible to intermediaries, even though the exact
   effect is only known by the origin server.

   Proper interpretation of a PUT request presumes that the user agent
   knows which target resource is desired.  A service that selects a
   proper URI on behalf of the client, after receiving a state-changing
   request, SHOULD be implemented using the POST method rather than PUT.
   If the origin server will not make the requested PUT state change to
   the target resource and instead wishes to have it applied to a
   different resource, such as when the resource has been moved to a
   different URI, then the origin server MUST send an appropriate 3xx
   (Redirection) response; the user agent MAY then make its own decision
   regarding whether or not to redirect the request.

   A PUT request applied to the target resource can have side effects on
   other resources.  For example, an article might have a URI for
   identifying "the current version" (a resource) that is separate from
   the URIs identifying each particular version (different resources

Fielding & Reschke           Standards Track                   [Page 28]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   that at one point shared the same state as the current version
   resource).  A successful PUT request on "the current version" URI
   might therefore create a new version resource in addition to changing
   the state of the target resource, and might also cause links to be
   added between the related resources.

   An origin server that allows PUT on a given target resource MUST send
   a 400 (Bad Request) response to a PUT request that contains a
   Content-Range header field ([Section 4.2 of [RFC7233]](/doc/html/rfc7233#section-4.2)), since the
   payload is likely to be partial content that has been mistakenly PUT
   as a full representation.  Partial content updates are possible by
   targeting a separately identified resource with state that overlaps a
   portion of the larger resource, or by using a different method that
   has been specifically defined for partial updates (for example, the
   PATCH method defined in [[RFC5789](/doc/html/rfc5789 "\"PATCH Method for HTTP\"")]).

   Responses to the PUT method are not cacheable.  If a successful PUT
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see [Section 4.4 of [RFC7234]](/doc/html/rfc7234#section-4.4)).

[4.3.5](#section-4.3.5).  DELETE

   The DELETE method requests that the origin server remove the
   association between the target resource and its current
   functionality.  In effect, this method is similar to the rm command
   in UNIX: it expresses a deletion operation on the URI mapping of the
   origin server rather than an expectation that the previously
   associated information be deleted.

   If the target resource has one or more current representations, they
   might or might not be destroyed by the origin server, and the
   associated storage might or might not be reclaimed, depending
   entirely on the nature of the resource and its implementation by the
   origin server (which are beyond the scope of this specification).
   Likewise, other implementation aspects of a resource might need to be
   deactivated or archived as a result of a DELETE, such as database or
   gateway connections.  In general, it is assumed that the origin
   server will only allow DELETE on resources for which it has a
   prescribed mechanism for accomplishing the deletion.

   Relatively few resources allow the DELETE method -- its primary use
   is for remote authoring environments, where the user has some
   direction regarding its effect.  For example, a resource that was
   previously created using a PUT request, or identified via the
   Location header field after a 201 (Created) response to a POST
   request, might allow a corresponding DELETE request to undo those
   actions.  Similarly, custom user agent implementations that implement

Fielding & Reschke           Standards Track                   [Page 29]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   an authoring function, such as revision control clients using HTTP
   for remote operations, might use DELETE based on an assumption that
   the server's URI space has been crafted to correspond to a version
   repository.

   If a DELETE method is successfully applied, the origin server SHOULD
   send a 202 (Accepted) status code if the action will likely succeed
   but has not yet been enacted, a 204 (No Content) status code if the
   action has been enacted and no further information is to be supplied,
   or a 200 (OK) status code if the action has been enacted and the
   response message includes a representation describing the status.

   A payload within a DELETE request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.

   Responses to the DELETE method are not cacheable.  If a DELETE
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see [Section 4.4 of [RFC7234]](/doc/html/rfc7234#section-4.4)).

[4.3.6](#section-4.3.6).  CONNECT

   The CONNECT method requests that the recipient establish a tunnel to
   the destination origin server identified by the request-target and,
   if successful, thereafter restrict its behavior to blind forwarding
   of packets, in both directions, until the tunnel is closed.  Tunnels
   are commonly used to create an end-to-end virtual connection, through
   one or more proxies, which can then be secured using TLS (Transport
   Layer Security, [[RFC5246](/doc/html/rfc5246 "\"The Transport Layer Security (TLS) Protocol Version 1.2\"")]).

   CONNECT is intended only for use in requests to a proxy.  An origin
   server that receives a CONNECT request for itself MAY respond with a
   2xx (Successful) status code to indicate that a connection is
   established.  However, most origin servers do not implement CONNECT.

   A client sending a CONNECT request MUST send the authority form of
   request-target ([Section 5.3 of [RFC7230]](/doc/html/rfc7230#section-5.3)); i.e., the request-target
   consists of only the host name and port number of the tunnel
   destination, separated by a colon.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80

   The recipient proxy can establish a tunnel either by directly
   connecting to the request-target or, if configured to use another
   proxy, by forwarding the CONNECT request to the next inbound proxy.
   Any 2xx (Successful) response indicates that the sender (and all

Fielding & Reschke           Standards Track                   [Page 30]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   inbound proxies) will switch to tunnel mode immediately after the
   blank line that concludes the successful response's header section;
   data received after that blank line is from the server identified by
   the request-target.  Any response other than a successful response
   indicates that the tunnel has not yet been formed and that the
   connection remains governed by HTTP.

   A tunnel is closed when a tunnel intermediary detects that either
   side has closed its connection: the intermediary MUST attempt to send
   any outstanding data that came from the closed side to the other
   side, close both connections, and then discard any remaining data
   left undelivered.

   Proxy authentication might be used to establish the authority to
   create a tunnel.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80
     Proxy-Authorization: basic aGVsbG86d29ybGQ=

   There are significant risks in establishing a tunnel to arbitrary
   servers, particularly when the destination is a well-known or
   reserved TCP port that is not intended for Web traffic.  For example,
   a CONNECT to a request-target of "example.com:25" would suggest that
   the proxy connect to the reserved port for SMTP traffic; if allowed,
   that could trick the proxy into relaying spam email.  Proxies that
   support CONNECT SHOULD restrict its use to a limited set of known
   ports or a configurable whitelist of safe request targets.

   A server MUST NOT send any Transfer-Encoding or Content-Length header
   fields in a 2xx (Successful) response to CONNECT.  A client MUST
   ignore any Content-Length or Transfer-Encoding header fields received
   in a successful response to CONNECT.

   A payload within a CONNECT request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.

   Responses to the CONNECT method are not cacheable.

[4.3.7](#section-4.3.7).  OPTIONS

   The OPTIONS method requests information about the communication
   options available for the target resource, at either the origin
   server or an intervening intermediary.  This method allows a client
   to determine the options and/or requirements associated with a
   resource, or the capabilities of a server, without implying a
   resource action.

Fielding & Reschke           Standards Track                   [Page 31]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   An OPTIONS request with an asterisk ("*") as the request-target
   ([Section 5.3 of [RFC7230]](/doc/html/rfc7230#section-5.3)) applies to the server in general rather
   than to a specific resource.  Since a server's communication options
   typically depend on the resource, the "*" request is only useful as a
   "ping" or "no-op" type of method; it does nothing beyond allowing the
   client to test the capabilities of the server.  For example, this can
   be used to test a proxy for HTTP/1.1 conformance (or lack thereof).

   If the request-target is not an asterisk, the OPTIONS request applies
   to the options that are available when communicating with the target
   resource.

   A server generating a successful response to OPTIONS SHOULD send any
   header fields that might indicate optional features implemented by
   the server and applicable to the target resource (e.g., Allow),
   including potential extensions not defined by this specification.
   The response payload, if any, might also describe the communication
   options in a machine or human-readable representation.  A standard
   format for such a representation is not defined by this
   specification, but might be defined by future extensions to HTTP.  A
   server MUST generate a Content-Length field with a value of "0" if no
   payload body is to be sent in the response.

   A client MAY send a Max-Forwards header field in an OPTIONS request
   to target a specific recipient in the request chain (see
   [Section 5.1.2](#section-5.1.2)).  A proxy MUST NOT generate a Max-Forwards header
   field while forwarding a request unless that request was received
   with a Max-Forwards field.

   A client that generates an OPTIONS request containing a payload body
   MUST send a valid Content-Type header field describing the
   representation media type.  Although this specification does not
   define any use for such a payload, future extensions to HTTP might
   use the OPTIONS body to make more detailed queries about the target
   resource.

   Responses to the OPTIONS method are not cacheable.

[4.3.8](#section-4.3.8).  TRACE

   The TRACE method requests a remote, application-level loop-back of
   the request message.  The final recipient of the request SHOULD
   reflect the message received, excluding some fields described below,
   back to the client as the message body of a 200 (OK) response with a
   Content-Type of "message/http" ([Section 8.3.1 of [RFC7230]](/doc/html/rfc7230#section-8.3.1)).  The
   final recipient is either the origin server or the first server to
   receive a Max-Forwards value of zero (0) in the request
   ([Section 5.1.2](#section-5.1.2)).

Fielding & Reschke           Standards Track                   [Page 32]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   A client MUST NOT generate header fields in a TRACE request
   containing sensitive data that might be disclosed by the response.
   For example, it would be foolish for a user agent to send stored user
   credentials [[RFC7235](/doc/html/rfc7235 "\"Hypertext Transfer Protocol (HTTP/1.1): Authentication\"")] or cookies [[RFC6265](/doc/html/rfc6265 "\"HTTP State Management Mechanism\"")] in a TRACE request.  The
   final recipient of the request SHOULD exclude any request header
   fields that are likely to contain sensitive data when that recipient
   generates the response body.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information.  The value of the Via header field ([Section 5.7.1 of
   [RFC7230]](/doc/html/rfc7230#section-5.7.1)) is of particular interest, since it acts as a trace of the
   request chain.  Use of the Max-Forwards header field allows the
   client to limit the length of the request chain, which is useful for
   testing a chain of proxies forwarding messages in an infinite loop.

   A client MUST NOT send a message body in a TRACE request.

   Responses to the TRACE method are not cacheable.

[5](#section-5).  Request Header Fields

   A client sends request header fields to provide more information
   about the request context, make the request conditional based on the
   target resource state, suggest preferred formats for the response,
   supply authentication credentials, or modify the expected request
   processing.  These fields act as request modifiers, similar to the
   parameters on a programming language method invocation.

[5.1](#section-5.1).  Controls

   Controls are request header fields that direct specific handling of
   the request.

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Cache-Control     | [Section 5.2 of [RFC7234]](/doc/html/rfc7234#section-5.2) |
   | Expect            | [Section 5.1.1](#section-5.1.1)            |
   | Host              | [Section 5.4 of [RFC7230]](/doc/html/rfc7230#section-5.4) |
   | Max-Forwards      | [Section 5.1.2](#section-5.1.2)            |
   | Pragma            | [Section 5.4 of [RFC7234]](/doc/html/rfc7234#section-5.4) |
   | Range             | [Section 3.1 of [RFC7233]](/doc/html/rfc7233#section-3.1) |
   | TE                | [Section 4.3 of [RFC7230]](/doc/html/rfc7230#section-4.3) |
   +-------------------+--------------------------+

Fielding & Reschke           Standards Track                   [Page 33]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[5.1.1](#section-5.1.1).  Expect

   The "Expect" header field in a request indicates a certain set of
   behaviors (expectations) that need to be supported by the server in
   order to properly handle this request.  The only such expectation
   defined by this specification is 100-continue.

     Expect  = "100-continue"

   The Expect field-value is case-insensitive.

   A server that receives an Expect field-value other than 100-continue
   MAY respond with a 417 (Expectation Failed) status code to indicate
   that the unexpected expectation cannot be met.

   A 100-continue expectation informs recipients that the client is
   about to send a (presumably large) message body in this request and
   wishes to receive a 100 (Continue) interim response if the
   request-line and header fields are not sufficient to cause an
   immediate success, redirect, or error response.  This allows the
   client to wait for an indication that it is worthwhile to send the
   message body before actually doing so, which can improve efficiency
   when the message body is huge or when the client anticipates that an
   error is likely (e.g., when sending a state-changing method, for the
   first time, without previously verified authentication credentials).

   For example, a request that begins with

     PUT /somewhere/fun HTTP/1.1
     Host: origin.example.com
     Content-Type: video/h264
     Content-Length: 1234567890987
     Expect: 100-continue

   allows the origin server to immediately respond with an error
   message, such as 401 (Unauthorized) or 405 (Method Not Allowed),
   before the client starts filling the pipes with an unnecessary data
   transfer.

   Requirements for clients:

   o  A client MUST NOT generate a 100-continue expectation in a request
      that does not include a message body.

   o  A client that will wait for a 100 (Continue) response before
      sending the request message body MUST send an Expect header field
      containing a 100-continue expectation.

Fielding & Reschke           Standards Track                   [Page 34]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   o  A client that sends a 100-continue expectation is not required to
      wait for any specific length of time; such a client MAY proceed to
      send the message body even if it has not yet received a response.
      Furthermore, since 100 (Continue) responses cannot be sent through
      an HTTP/1.0 intermediary, such a client SHOULD NOT wait for an
      indefinite period before sending the message body.

   o  A client that receives a 417 (Expectation Failed) status code in
      response to a request containing a 100-continue expectation SHOULD
      repeat that request without a 100-continue expectation, since the
      417 response merely indicates that the response chain does not
      support expectations (e.g., it passes through an HTTP/1.0 server).

   Requirements for servers:

   o  A server that receives a 100-continue expectation in an HTTP/1.0
      request MUST ignore that expectation.

   o  A server MAY omit sending a 100 (Continue) response if it has
      already received some or all of the message body for the
      corresponding request, or if the framing indicates that there is
      no message body.

   o  A server that sends a 100 (Continue) response MUST ultimately send
      a final status code, once the message body is received and
      processed, unless the connection is closed prematurely.

   o  A server that responds with a final status code before reading the
      entire message body SHOULD indicate in that response whether it
      intends to close the connection or continue reading and discarding
      the request message (see [Section 6.6 of [RFC7230]](/doc/html/rfc7230#section-6.6)).

   An origin server MUST, upon receiving an HTTP/1.1 (or later)
   request-line and a complete header section that contains a
   100-continue expectation and indicates a request message body will
   follow, either send an immediate response with a final status code,
   if that status can be determined by examining just the request-line
   and header fields, or send an immediate 100 (Continue) response to
   encourage the client to send the request's message body.  The origin
   server MUST NOT wait for the message body before sending the 100
   (Continue) response.

   A proxy MUST, upon receiving an HTTP/1.1 (or later) request-line and
   a complete header section that contains a 100-continue expectation
   and indicates a request message body will follow, either send an
   immediate response with a final status code, if that status can be
   determined by examining just the request-line and header fields, or
   begin forwarding the request toward the origin server by sending a

Fielding & Reschke           Standards Track                   [Page 35]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   corresponding request-line and header section to the next inbound
   server.  If the proxy believes (from configuration or past
   interaction) that the next inbound server only supports HTTP/1.0, the
   proxy MAY generate an immediate 100 (Continue) response to encourage
   the client to begin sending the message body.

      Note: The Expect header field was added after the original
      publication of HTTP/1.1 [[RFC2068](/doc/html/rfc2068 "\"Hypertext Transfer Protocol -- HTTP/1.1\"")] as both the means to request an
      interim 100 (Continue) response and the general mechanism for
      indicating must-understand extensions.  However, the extension
      mechanism has not been used by clients and the must-understand
      requirements have not been implemented by many servers, rendering
      the extension mechanism useless.  This specification has removed
      the extension mechanism in order to simplify the definition and
      processing of 100-continue.

[5.1.2](#section-5.1.2).  Max-Forwards

   The "Max-Forwards" header field provides a mechanism with the TRACE
   ([Section 4.3.8](#section-4.3.8)) and OPTIONS ([Section 4.3.7](#section-4.3.7)) request methods to limit
   the number of times that the request is forwarded by proxies.  This
   can be useful when the client is attempting to trace a request that
   appears to be failing or looping mid-chain.

     Max-Forwards = 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message can be forwarded.

   Each intermediary that receives a TRACE or OPTIONS request containing
   a Max-Forwards header field MUST check and update its value prior to
   forwarding the request.  If the received value is zero (0), the
   intermediary MUST NOT forward the request; instead, the intermediary
   MUST respond as the final recipient.  If the received Max-Forwards
   value is greater than zero, the intermediary MUST generate an updated
   Max-Forwards field in the forwarded message with a field-value that
   is the lesser of a) the received value decremented by one (1) or b)
   the recipient's maximum supported value for Max-Forwards.

   A recipient MAY ignore a Max-Forwards header field received with any
   other request methods.

[5.2](#section-5.2).  Conditionals

   The HTTP conditional request header fields [[RFC7232](/doc/html/rfc7232 "\"Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests\"")] allow a client
   to place a precondition on the state of the target resource, so that
   the action corresponding to the method semantics will not be applied
   if the precondition evaluates to false.  Each precondition defined by

Fielding & Reschke           Standards Track                   [Page 36]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   this specification consists of a comparison between a set of
   validators obtained from prior representations of the target resource
   to the current state of validators for the selected representation
   ([Section 7.2](#section-7.2)).  Hence, these preconditions evaluate whether the state
   of the target resource has changed since a given state known by the
   client.  The effect of such an evaluation depends on the method
   semantics and choice of conditional, as defined in [Section 5 of
   [RFC7232]](/doc/html/rfc7232#section-5).

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | If-Match            | [Section 3.1 of [RFC7232]](/doc/html/rfc7232#section-3.1) |
   | If-None-Match       | [Section 3.2 of [RFC7232]](/doc/html/rfc7232#section-3.2) |
   | If-Modified-Since   | [Section 3.3 of [RFC7232]](/doc/html/rfc7232#section-3.3) |
   | If-Unmodified-Since | [Section 3.4 of [RFC7232]](/doc/html/rfc7232#section-3.4) |
   | If-Range            | [Section 3.2 of [RFC7233]](/doc/html/rfc7233#section-3.2) |
   +---------------------+--------------------------+

[5.3](#section-5.3).  Content Negotiation

   The following request header fields are sent by a user agent to
   engage in proactive negotiation of the response content, as defined
   in [Section 3.4.1](#section-3.4.1).  The preferences sent in these fields apply to any
   content in the response, including representations of the target
   resource, representations of error or processing status, and
   potentially even the miscellaneous text strings that might appear
   within the protocol.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | Accept            | [Section 5.3.2](#section-5.3.2) |
   | Accept-Charset    | [Section 5.3.3](#section-5.3.3) |
   | Accept-Encoding   | [Section 5.3.4](#section-5.3.4) |
   | Accept-Language   | [Section 5.3.5](#section-5.3.5) |
   +-------------------+---------------+

[5.3.1](#section-5.3.1).  Quality Values

   Many of the request header fields for proactive negotiation use a
   common parameter, named "q" (case-insensitive), to assign a relative
   "weight" to the preference for that associated kind of content.  This
   weight is referred to as a "quality value" (or "qvalue") because the
   same parameter name is often used within server configurations to
   assign a weight to the relative quality of the various
   representations that can be selected for a resource.

Fielding & Reschke           Standards Track                   [Page 37]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   The weight is normalized to a real number in the range 0 through 1,
   where 0.001 is the least preferred and 1 is the most preferred; a
   value of 0 means "not acceptable".  If no "q" parameter is present,
   the default weight is 1.

     weight = OWS ";" OWS "q=" qvalue
     qvalue = ( "0" [ "." 0*3DIGIT ] )
            / ( "1" [ "." 0*3("0") ] )

   A sender of qvalue MUST NOT generate more than three digits after the
   decimal point.  User configuration of these values ought to be
   limited in the same fashion.

[5.3.2](#section-5.3.2).  Accept

   The "Accept" header field can be used by user agents to specify
   response media types that are acceptable.  Accept header fields can
   be used to indicate that the request is specifically limited to a
   small set of desired types, as in the case of a request for an
   in-line image.

     Accept = #( media-range [ accept-params ] )

     media-range    = ( "*/*"
                      / ( type "/" "*" )
                      / ( type "/" subtype )
                      ) *( OWS ";" OWS parameter )
     accept-params  = weight *( accept-ext )
     accept-ext = OWS ";" OWS token [ "=" ( token / quoted-string ) ]

   The asterisk "*" character is used to group media types into ranges,
   with "*/*" indicating all media types and "type/*" indicating all
   subtypes of that type.  The media-range can include media type
   parameters that are applicable to that range.

   Each media-range might be followed by zero or more applicable media
   type parameters (e.g., charset), an optional "q" parameter for
   indicating a relative weight ([Section 5.3.1](#section-5.3.1)), and then zero or more
   extension parameters.  The "q" parameter is necessary if any
   extensions (accept-ext) are present, since it acts as a separator
   between the two parameter sets.

      Note: Use of the "q" parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice.  Although this prevents any media type parameter named
      "q" from being used with a media range, such an event is believed
      to be unlikely given the lack of any "q" parameters in the IANA

Fielding & Reschke           Standards Track                   [Page 38]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

      media type registry and the rare usage of any media type
      parameters in Accept.  Future media types are discouraged from
      registering any parameter named "q".

   The example

     Accept: audio/*; q=0.2, audio/basic

   is interpreted as "I prefer audio/basic, but send me any audio type
   if it is the best available after an 80% markdown in quality".

   A request without any Accept header field implies that the user agent
   will accept any media type in response.  If the header field is
   present in a request and none of the available representations for
   the response have a media type that is listed as acceptable, the
   origin server can either honor the header field by sending a 406 (Not
   Acceptable) response or disregard the header field by treating the
   response as if it is not subject to content negotiation.

   A more elaborate example is

     Accept: text/plain; q=0.5, text/html,
             text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as "text/html and text/x-c are
   the equally preferred media types, but if they do not exist, then
   send the text/x-dvi representation, and if that does not exist, send
   the text/plain representation".

   Media ranges can be overridden by more specific media ranges or
   specific media types.  If more than one media range applies to a
   given type, the most specific reference has precedence.  For example,

     Accept: text/*, text/plain, text/plain;format=flowed, */*

   have the following precedence:

   1.  text/plain;format=flowed

   2.  text/plain

   3.  text/*

   4.  */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   that matches the type.  For example,

Fielding & Reschke           Standards Track                   [Page 39]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

     Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
             text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

   +-------------------+---------------+
   | Media Type        | Quality Value |
   +-------------------+---------------+
   | text/html;level=1 | 1             |
   | text/html         | 0.7           |
   | text/plain        | 0.3           |
   | image/jpeg        | 0.5           |
   | text/html;level=2 | 0.4           |
   | text/html;level=3 | 0.7           |
   +-------------------+---------------+

   Note: A user agent might be provided with a default set of quality
   values for certain media ranges.  However, unless the user agent is a
   closed system that cannot interact with other rendering agents, this
   default set ought to be configurable by the user.

[5.3.3](#section-5.3.3).  Accept-Charset

   The "Accept-Charset" header field can be sent by a user agent to
   indicate what charsets are acceptable in textual response content.
   This field allows user agents capable of understanding more
   comprehensive or special-purpose charsets to signal that capability
   to an origin server that is capable of representing information in
   those charsets.

     Accept-Charset = 1#( ( charset / "*" ) [ weight ] )

   Charset names are defined in [Section 3.1.1.2](#section-3.1.1.2).  A user agent MAY
   associate a quality value with each charset to indicate the user's
   relative preference for that charset, as defined in [Section 5.3.1](#section-5.3.1).
   An example is

     Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value "*", if present in the Accept-Charset field,
   matches every charset that is not mentioned elsewhere in the
   Accept-Charset field.  If no "*" is present in an Accept-Charset
   field, then any charsets not explicitly mentioned in the field are
   considered "not acceptable" to the client.

   A request without any Accept-Charset header field implies that the
   user agent will accept any charset in response.  Most general-purpose
   user agents do not send Accept-Charset, unless specifically

Fielding & Reschke           Standards Track                   [Page 40]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   configured to do so, because a detailed list of supported charsets
   makes it easier for a server to identify an individual by virtue of
   the user agent's request characteristics ([Section 9.7](#section-9.7)).

   If an Accept-Charset header field is present in a request and none of
   the available representations for the response has a charset that is
   listed as acceptable, the origin server can either honor the header
   field, by sending a 406 (Not Acceptable) response, or disregard the
   header field by treating the resource as if it is not subject to
   content negotiation.

[5.3.4](#section-5.3.4).  Accept-Encoding

   The "Accept-Encoding" header field can be used by user agents to
   indicate what response content-codings ([Section 3.1.2.1](#section-3.1.2.1)) are
   acceptable in the response.  An "identity" token is used as a synonym
   for "no encoding" in order to communicate when no encoding is
   preferred.

     Accept-Encoding  = #( codings [ weight ] )
     codings          = content-coding / "identity" / "*"

   Each codings value MAY be given an associated quality value
   representing the preference for that encoding, as defined in
   [Section 5.3.1](#section-5.3.1).  The asterisk "*" symbol in an Accept-Encoding field
   matches any available content-coding not explicitly listed in the
   header field.

   For example,

     Accept-Encoding: compress, gzip
     Accept-Encoding:
     Accept-Encoding: *
     Accept-Encoding: compress;q=0.5, gzip;q=1.0
     Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A request without an Accept-Encoding header field implies that the
   user agent has no preferences regarding content-codings.  Although
   this allows the server to use any content-coding in a response, it
   does not imply that the user agent will be able to correctly process
   all encodings.

   A server tests whether a content-coding for a given representation is
   acceptable using these rules:

   1.  If no Accept-Encoding field is in the request, any content-coding
       is considered acceptable by the user agent.

Fielding & Reschke           Standards Track                   [Page 41]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   2.  If the representation has no content-coding, then it is
       acceptable by default unless specifically excluded by the
       Accept-Encoding field stating either "identity;q=0" or "*;q=0"
       without a more specific entry for "identity".

   3.  If the representation's content-coding is one of the
       content-codings listed in the Accept-Encoding field, then it is
       acceptable unless it is accompanied by a qvalue of 0.  (As
       defined in [Section 5.3.1](#section-5.3.1), a qvalue of 0 means "not acceptable".)

   4.  If multiple content-codings are acceptable, then the acceptable
       content-coding with the highest non-zero qvalue is preferred.

   An Accept-Encoding header field with a combined field-value that is
   empty implies that the user agent does not want any content-coding in
   response.  If an Accept-Encoding header field is present in a request
   and none of the available representations for the response have a
   content-coding that is listed as acceptable, the origin server SHOULD
   send a response without any content-coding.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings.  This means that qvalues might
      not work and are not permitted with x-gzip or x-compress.

[5.3.5](#section-5.3.5).  Accept-Language

   The "Accept-Language" header field can be used by user agents to
   indicate the set of natural languages that are preferred in the
   response.  Language tags are defined in [Section 3.1.3.1](#section-3.1.3.1).

     Accept-Language = 1#( language-range [ weight ] )
     language-range  =
               <language-range, see [[RFC4647], Section 2.1](/doc/html/rfc4647#section-2.1)>

   Each language-range can be given an associated quality value
   representing an estimate of the user's preference for the languages
   specified by that range, as defined in [Section 5.3.1](#section-5.3.1).  For example,

     Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: "I prefer Danish, but will accept British English and
   other types of English".

   A request without any Accept-Language header field implies that the
   user agent will accept any language in response.  If the header field
   is present in a request and none of the available representations for
   the response have a matching language tag, the origin server can
   either disregard the header field by treating the response as if it

Fielding & Reschke           Standards Track                   [Page 42]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   is not subject to content negotiation or honor the header field by
   sending a 406 (Not Acceptable) response.  However, the latter is not
   encouraged, as doing so can prevent users from accessing content that
   they might be able to use (with translation software, for example).

   Note that some recipients treat the order in which language tags are
   listed as an indication of descending priority, particularly for tags
   that are assigned equal quality values (no value is the same as q=1).
   However, this behavior cannot be relied upon.  For consistency and to
   maximize interoperability, many user agents assign each language tag
   a unique quality value while also listing them in order of decreasing
   quality.  Additional discussion of language priority lists can be
   found in [Section 2.3 of [RFC4647]](/doc/html/rfc4647#section-2.3).

   For matching, [Section 3 of [RFC4647]](/doc/html/rfc4647#section-3) defines several matching
   schemes.  Implementations can offer the most appropriate matching
   scheme for their requirements.  The "Basic Filtering" scheme
   ([[RFC4647], Section 3.3.1](/doc/html/rfc4647#section-3.3.1)) is identical to the matching scheme that
   was previously defined for HTTP in [Section 14.4 of [RFC2616]](/doc/html/rfc2616#section-14.4).

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header field with the complete linguistic
   preferences of the user in every request ([Section 9.7](#section-9.7)).

   Since intelligibility is highly dependent on the individual user,
   user agents need to allow user control over the linguistic preference
   (either through configuration of the user agent itself or by
   defaulting to a user controllable system setting).  A user agent that
   does not provide such control to the user MUST NOT send an
   Accept-Language header field.

      Note: User agents ought to provide guidance to users when setting
      a preference, since users are rarely familiar with the details of
      language matching as described above.  For example, users might
      assume that on selecting "en-gb", they will be served any kind of
      English document if British English is not available.  A user
      agent might suggest, in such a case, to add "en" to the list for
      better matching behavior.

Fielding & Reschke           Standards Track                   [Page 43]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[5.4](#section-5.4).  Authentication Credentials

   Two header fields are used for carrying authentication credentials,
   as defined in [[RFC7235](/doc/html/rfc7235 "\"Hypertext Transfer Protocol (HTTP/1.1): Authentication\"")].  Note that various custom mechanisms for
   user authentication use the Cookie header field for this purpose, as
   defined in [[RFC6265](/doc/html/rfc6265 "\"HTTP State Management Mechanism\"")].

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | Authorization       | [Section 4.2 of [RFC7235]](/doc/html/rfc7235#section-4.2) |
   | Proxy-Authorization | [Section 4.4 of [RFC7235]](/doc/html/rfc7235#section-4.4) |
   +---------------------+--------------------------+

[5.5](#section-5.5).  Request Context

   The following request header fields provide additional information
   about the request context, including information about the user, user
   agent, and resource behind the request.

   +-------------------+---------------+
   | Header Field Name | Defined in... |
   +-------------------+---------------+
   | From              | [Section 5.5.1](#section-5.5.1) |
   | Referer           | [Section 5.5.2](#section-5.5.2) |
   | User-Agent        | [Section 5.5.3](#section-5.5.3) |
   +-------------------+---------------+

[5.5.1](#section-5.5.1).  From

   The "From" header field contains an Internet email address for a
   human user who controls the requesting user agent.  The address ought
   to be machine-usable, as defined by "mailbox" in [Section 3.4 of
   [RFC5322]](/doc/html/rfc5322#section-3.4):

     From    = mailbox

     mailbox = <mailbox, see [[RFC5322], Section 3.4](/doc/html/rfc5322#section-3.4)>

   An example is:

     From: webmaster@example.org

   The From header field is rarely sent by non-robotic user agents.  A
   user agent SHOULD NOT send a From header field without explicit
   configuration by the user, since that might conflict with the user's
   privacy interests or their site's security policy.

Fielding & Reschke           Standards Track                   [Page 44]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   A robotic user agent SHOULD send a valid From header field so that
   the person responsible for running the robot can be contacted if
   problems occur on servers, such as if the robot is sending excessive,
   unwanted, or invalid requests.

   A server SHOULD NOT use the From header field for access control or
   authentication, since most recipients will assume that the field
   value is public information.

[5.5.2](#section-5.5.2).  Referer

   The "Referer" [sic] header field allows the user agent to specify a
   URI reference for the resource from which the target URI was obtained
   (i.e., the "referrer", though the field name is misspelled).  A user
   agent MUST NOT include the fragment and userinfo components of the
   URI reference [[RFC3986](/doc/html/rfc3986 "\"Uniform Resource Identifier (URI): Generic Syntax\"")], if any, when generating the Referer field
   value.

     Referer = absolute-URI / partial-URI

   The Referer header field allows servers to generate back-links to
   other resources for simple analytics, logging, optimized caching,
   etc.  It also allows obsolete or mistyped links to be found for
   maintenance.  Some servers use the Referer header field as a means of
   denying links from other sites (so-called "deep linking") or
   restricting cross-site request forgery (CSRF), but not all requests
   contain it.

   Example:

     Referer: http://www.example.org/hypertext/Overview.html

   If the target URI was obtained from a source that does not have its
   own URI (e.g., input from the user keyboard, or an entry within the
   user's bookmarks/favorites), the user agent MUST either exclude the
   Referer field or send it with a value of "about:blank".

   The Referer field has the potential to reveal information about the
   request context or browsing history of the user, which is a privacy
   concern if the referring resource's identifier reveals personal
   information (such as an account name) or a resource that is supposed
   to be confidential (such as behind a firewall or internal to a
   secured service).  Most general-purpose user agents do not send the
   Referer header field when the referring resource is a local "file" or
   "data" URI.  A user agent MUST NOT send a Referer header field in an
   unsecured HTTP request if the referring page was received with a
   secure protocol.  See [Section 9.4](#section-9.4) for additional security
   considerations.

Fielding & Reschke           Standards Track                   [Page 45]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   Some intermediaries have been known to indiscriminately remove
   Referer header fields from outgoing requests.  This has the
   unfortunate side effect of interfering with protection against CSRF
   attacks, which can be far more harmful to their users.
   Intermediaries and user agent extensions that wish to limit
   information disclosure in Referer ought to restrict their changes to
   specific edits, such as replacing internal domain names with
   pseudonyms or truncating the query and/or path components.  An
   intermediary SHOULD NOT modify or delete the Referer header field
   when the field value shares the same scheme and host as the request
   target.

[5.5.3](#section-5.5.3).  User-Agent

   The "User-Agent" header field contains information about the user
   agent originating the request, which is often used by servers to help
   identify the scope of reported interoperability problems, to work
   around or tailor responses to avoid particular user agent
   limitations, and for analytics regarding browser or operating system
   use.  A user agent SHOULD send a User-Agent field in each request
   unless specifically configured not to do so.

     User-Agent = product *( RWS ( product / comment ) )

   The User-Agent field-value consists of one or more product
   identifiers, each followed by zero or more comments ([Section 3.2 of
   [RFC7230]](/doc/html/rfc7230#section-3.2)), which together identify the user agent software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   user agent software.  Each product identifier consists of a name and
   optional version.

     product         = token ["/" product-version]
     product-version = token

   A sender SHOULD limit generated product identifiers to what is
   necessary to identify the product; a sender MUST NOT generate
   advertising or other nonessential information within the product
   identifier.  A sender SHOULD NOT generate information in
   product-version that is not a version identifier (i.e., successive
   versions of the same product name ought to differ only in the
   product-version portion of the product identifier).

   Example:

     User-Agent: CERN-LineMode/2.15 libwww/2.17b3

Fielding & Reschke           Standards Track                   [Page 46]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   A user agent SHOULD NOT generate a User-Agent field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed User-Agent
   field values increase request latency and the risk of a user being
   identified against their wishes ("fingerprinting").

   Likewise, implementations are encouraged not to use the product
   tokens of other implementations in order to declare compatibility
   with them, as this circumvents the purpose of the field.  If a user
   agent masquerades as a different user agent, recipients can assume
   that the user intentionally desires to see responses tailored for
   that identified user agent, even if they might not work as well for
   the actual user agent being used.

[6](#section-6).  Response Status Codes

   The status-code element is a three-digit integer code giving the
   result of the attempt to understand and satisfy the request.

   HTTP status codes are extensible.  HTTP clients are not required to
   understand the meaning of all registered status codes, though such
   understanding is obviously desirable.  However, a client MUST
   understand the class of any status code, as indicated by the first
   digit, and treat an unrecognized status code as being equivalent to
   the x00 status code of that class, with the exception that a
   recipient MUST NOT cache a response with an unrecognized status code.

   For example, if an unrecognized status code of 471 is received by a
   client, the client can assume that there was something wrong with its
   request and treat the response as if it had received a 400 (Bad
   Request) status code.  The response message will usually contain a
   representation that explains the status.

   The first digit of the status-code defines the class of response.
   The last two digits do not have any categorization role.  There are
   five values for the first digit:

   o  1xx (Informational): The request was received, continuing process

   o  2xx (Successful): The request was successfully received,
      understood, and accepted

   o  3xx (Redirection): Further action needs to be taken in order to
      complete the request

   o  4xx (Client Error): The request contains bad syntax or cannot be
      fulfilled

Fielding & Reschke           Standards Track                   [Page 47]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   o  5xx (Server Error): The server failed to fulfill an apparently
      valid request

[6.1](#section-6.1).  Overview of Status Codes

   The status codes listed below are defined in this specification,
   [Section 4 of [RFC7232]](/doc/html/rfc7232#section-4), [Section 4 of [RFC7233]](/doc/html/rfc7233#section-4), and [Section 3 of
   [RFC7235]](/doc/html/rfc7235#section-3).  The reason phrases listed here are only recommendations
   -- they can be replaced by local equivalents without affecting the
   protocol.

   Responses with status codes that are defined as cacheable by default
   (e.g., 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501 in
   this specification) can be reused by a cache with heuristic
   expiration unless otherwise indicated by the method definition or
   explicit cache controls [[RFC7234](/doc/html/rfc7234 "\"Hypertext Transfer Protocol (HTTP/1.1): Caching\"")]; all other status codes are not
   cacheable by default.

Fielding & Reschke           Standards Track                   [Page 48]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   +------+-------------------------------+--------------------------+
   | Code | Reason-Phrase                 | Defined in...            |
   +------+-------------------------------+--------------------------+
   | 100  | Continue                      | [Section 6.2.1](#section-6.2.1)            |
   | 101  | Switching Protocols           | [Section 6.2.2](#section-6.2.2)            |
   | 200  | OK                            | [Section 6.3.1](#section-6.3.1)            |
   | 201  | Created                       | [Section 6.3.2](#section-6.3.2)            |
   | 202  | Accepted                      | [Section 6.3.3](#section-6.3.3)            |
   | 203  | Non-Authoritative Information | [Section 6.3.4](#section-6.3.4)            |
   | 204  | No Content                    | [Section 6.3.5](#section-6.3.5)            |
   | 205  | Reset Content                 | [Section 6.3.6](#section-6.3.6)            |
   | 206  | Partial Content               | [Section 4.1 of [RFC7233]](/doc/html/rfc7233#section-4.1) |
   | 300  | Multiple Choices              | [Section 6.4.1](#section-6.4.1)            |
   | 301  | Moved Permanently             | [Section 6.4.2](#section-6.4.2)            |
   | 302  | Found                         | [Section 6.4.3](#section-6.4.3)            |
   | 303  | See Other                     | [Section 6.4.4](#section-6.4.4)            |
   | 304  | Not Modified                  | [Section 4.1 of [RFC7232]](/doc/html/rfc7232#section-4.1) |
   | 305  | Use Proxy                     | [Section 6.4.5](#section-6.4.5)            |
   | 307  | Temporary Redirect            | [Section 6.4.7](#section-6.4.7)            |
   | 400  | Bad Request                   | [Section 6.5.1](#section-6.5.1)            |
   | 401  | Unauthorized                  | [Section 3.1 of [RFC7235]](/doc/html/rfc7235#section-3.1) |
   | 402  | Payment Required              | [Section 6.5.2](#section-6.5.2)            |
   | 403  | Forbidden                     | [Section 6.5.3](#section-6.5.3)            |
   | 404  | Not Found                     | [Section 6.5.4](#section-6.5.4)            |
   | 405  | Method Not Allowed            | [Section 6.5.5](#section-6.5.5)            |
   | 406  | Not Acceptable                | [Section 6.5.6](#section-6.5.6)            |
   | 407  | Proxy Authentication Required | [Section 3.2 of [RFC7235]](/doc/html/rfc7235#section-3.2) |
   | 408  | Request Timeout               | [Section 6.5.7](#section-6.5.7)            |
   | 409  | Conflict                      | [Section 6.5.8](#section-6.5.8)            |
   | 410  | Gone                          | [Section 6.5.9](#section-6.5.9)            |
   | 411  | Length Required               | [Section 6.5.10](#section-6.5.10)           |
   | 412  | Precondition Failed           | [Section 4.2 of [RFC7232]](/doc/html/rfc7232#section-4.2) |
   | 413  | Payload Too Large             | [Section 6.5.11](#section-6.5.11)           |
   | 414  | URI Too Long                  | [Section 6.5.12](#section-6.5.12)           |
   | 415  | Unsupported Media Type        | [Section 6.5.13](#section-6.5.13)           |
   | 416  | Range Not Satisfiable         | [Section 4.4 of [RFC7233]](/doc/html/rfc7233#section-4.4) |
   | 417  | Expectation Failed            | [Section 6.5.14](#section-6.5.14)           |
   | 426  | Upgrade Required              | [Section 6.5.15](#section-6.5.15)           |
   | 500  | Internal Server Error         | [Section 6.6.1](#section-6.6.1)            |
   | 501  | Not Implemented               | [Section 6.6.2](#section-6.6.2)            |
   | 502  | Bad Gateway                   | [Section 6.6.3](#section-6.6.3)            |
   | 503  | Service Unavailable           | [Section 6.6.4](#section-6.6.4)            |
   | 504  | Gateway Timeout               | [Section 6.6.5](#section-6.6.5)            |
   | 505  | HTTP Version Not Supported    | [Section 6.6.6](#section-6.6.6)            |
   +------+-------------------------------+--------------------------+

Fielding & Reschke           Standards Track                   [Page 49]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   Note that this list is not exhaustive -- it does not include
   extension status codes defined in other specifications.  The complete
   list of status codes is maintained by IANA.  See [Section 8.2](#section-8.2) for
   details.

[6.2](#section-6.2).  Informational 1xx

   The 1xx (Informational) class of status code indicates an interim
   response for communicating connection status or request progress
   prior to completing the requested action and sending a final
   response. 1xx responses are terminated by the first empty line after
   the status-line (the empty line signaling the end of the header
   section).  Since HTTP/1.0 did not define any 1xx status codes, a
   server MUST NOT send a 1xx response to an HTTP/1.0 client.

   A client MUST be able to parse one or more 1xx responses received
   prior to a final response, even if the client does not expect one.  A
   user agent MAY ignore unexpected 1xx responses.

   A proxy MUST forward 1xx responses unless the proxy itself requested
   the generation of the 1xx response.  For example, if a proxy adds an
   "Expect: 100-continue" field when it forwards a request, then it need
   not forward the corresponding 100 (Continue) response(s).

[6.2.1](#section-6.2.1).  100 Continue

   The 100 (Continue) status code indicates that the initial part of a
   request has been received and has not yet been rejected by the
   server.  The server intends to send a final response after the
   request has been fully received and acted upon.

   When the request contains an Expect header field that includes a
   100-continue expectation, the 100 response indicates that the server
   wishes to receive the request payload body, as described in
   [Section 5.1.1](#section-5.1.1).  The client ought to continue sending the request and
   discard the 100 response.

   If the request did not contain an Expect header field containing the
   100-continue expectation, the client can simply discard this interim
   response.

[6.2.2](#section-6.2.2).  101 Switching Protocols

   The 101 (Switching Protocols) status code indicates that the server
   understands and is willing to comply with the client's request, via
   the Upgrade header field ([Section 6.7 of [RFC7230]](/doc/html/rfc7230#section-6.7)), for a change in
   the application protocol being used on this connection.  The server

Fielding & Reschke           Standards Track                   [Page 50]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   MUST generate an Upgrade header field in the response that indicates
   which protocol(s) will be switched to immediately after the empty
   line that terminates the 101 response.

   It is assumed that the server will only agree to switch protocols
   when it is advantageous to do so.  For example, switching to a newer
   version of HTTP might be advantageous over older versions, and
   switching to a real-time, synchronous protocol might be advantageous
   when delivering resources that use such features.

[6.3](#section-6.3).  Successful 2xx

   The 2xx (Successful) class of status code indicates that the client's
   request was successfully received, understood, and accepted.

[6.3.1](#section-6.3.1).  200 OK

   The 200 (OK) status code indicates that the request has succeeded.
   The payload sent in a 200 response depends on the request method.
   For the methods defined by this specification, the intended meaning
   of the payload can be summarized as:

   GET  a representation of the target resource;

   HEAD  the same representation as GET, but without the representation
      data;

   POST  a representation of the status of, or results obtained from,
      the action;

   PUT, DELETE  a representation of the status of the action;

   OPTIONS  a representation of the communications options;

   TRACE  a representation of the request message as received by the end
      server.

   Aside from responses to CONNECT, a 200 response always has a payload,
   though an origin server MAY generate a payload body of zero length.
   If no payload is desired, an origin server ought to send 204 (No
   Content) instead.  For CONNECT, no payload is allowed because the
   successful result is a tunnel, which begins immediately after the 200
   response header section.

   A 200 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   [Section 4.2.2 of [RFC7234]](/doc/html/rfc7234#section-4.2.2)).

Fielding & Reschke           Standards Track                   [Page 51]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[6.3.2](#section-6.3.2).  201 Created

   The 201 (Created) status code indicates that the request has been
   fulfilled and has resulted in one or more new resources being
   created.  The primary resource created by the request is identified
   by either a Location header field in the response or, if no Location
   field is received, by the effective request URI.

   The 201 response payload typically describes and links to the
   resource(s) created.  See [Section 7.2](#section-7.2) for a discussion of the meaning
   and purpose of validator header fields, such as ETag and
   Last-Modified, in a 201 response.

[6.3.3](#section-6.3.3).  202 Accepted

   The 202 (Accepted) status code indicates that the request has been
   accepted for processing, but the processing has not been completed.
   The request might or might not eventually be acted upon, as it might
   be disallowed when processing actually takes place.  There is no
   facility in HTTP for re-sending a status code from an asynchronous
   operation.

   The 202 response is intentionally noncommittal.  Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed.  The representation sent with this
   response ought to describe the request's current status and point to
   (or embed) a status monitor that can provide the user with an
   estimate of when the request will be fulfilled.

[6.3.4](#section-6.3.4).  203 Non-Authoritative Information

   The 203 (Non-Authoritative Information) status code indicates that
   the request was successful but the enclosed payload has been modified
   from that of the origin server's 200 (OK) response by a transforming
   proxy ([Section 5.7.2 of [RFC7230]](/doc/html/rfc7230#section-5.7.2)).  This status code allows the
   proxy to notify recipients when a transformation has been applied,
   since that knowledge might impact later decisions regarding the
   content.  For example, future cache validation requests for the
   content might only be applicable along the same request path (through
   the same proxies).

   The 203 response is similar to the Warning code of 214 Transformation
   Applied ([Section 5.5 of [RFC7234]](/doc/html/rfc7234#section-5.5)), which has the advantage of being
   applicable to responses with any status code.

Fielding & Reschke           Standards Track                   [Page 52]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   A 203 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   [Section 4.2.2 of [RFC7234]](/doc/html/rfc7234#section-4.2.2)).

[6.3.5](#section-6.3.5).  204 No Content

   The 204 (No Content) status code indicates that the server has
   successfully fulfilled the request and that there is no additional
   content to send in the response payload body.  Metadata in the
   response header fields refer to the target resource and its selected
   representation after the requested action was applied.

   For example, if a 204 status code is received in response to a PUT
   request and the response contains an ETag header field, then the PUT
   was successful and the ETag field-value contains the entity-tag for
   the new representation of that target resource.

   The 204 response allows a server to indicate that the action has been
   successfully applied to the target resource, while implying that the
   user agent does not need to traverse away from its current "document
   view" (if any).  The server assumes that the user agent will provide
   some indication of the success to its user, in accord with its own
   interface, and apply any new or updated metadata in the response to
   its active representation.

   For example, a 204 status code is commonly used with document editing
   interfaces corresponding to a "save" action, such that the document
   being saved remains available to the user for editing.  It is also
   frequently used with interfaces that expect automated data transfers
   to be prevalent, such as within distributed version control systems.

   A 204 response is terminated by the first empty line after the header
   fields because it cannot contain a message body.

   A 204 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   [Section 4.2.2 of [RFC7234]](/doc/html/rfc7234#section-4.2.2)).

[6.3.6](#section-6.3.6).  205 Reset Content

   The 205 (Reset Content) status code indicates that the server has
   fulfilled the request and desires that the user agent reset the
   "document view", which caused the request to be sent, to its original
   state as received from the origin server.

   This response is intended to support a common data entry use case
   where the user receives content that supports data entry (a form,
   notepad, canvas, etc.), enters or manipulates data in that space,

Fielding & Reschke           Standards Track                   [Page 53]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   causes the entered data to be submitted in a request, and then the
   data entry mechanism is reset for the next entry so that the user can
   easily initiate another input action.

   Since the 205 status code implies that no additional content will be
   provided, a server MUST NOT generate a payload in a 205 response.  In
   other words, a server MUST do one of the following for a 205
   response: a) indicate a zero-length body for the response by
   including a Content-Length header field with a value of 0; b)
   indicate a zero-length payload for the response by including a
   Transfer-Encoding header field with a value of chunked and a message
   body consisting of a single chunk of zero-length; or, c) close the
   connection immediately after sending the blank line terminating the
   header section.

[6.4](#section-6.4).  Redirection 3xx

   The 3xx (Redirection) class of status code indicates that further
   action needs to be taken by the user agent in order to fulfill the
   request.  If a Location header field ([Section 7.1.2](#section-7.1.2)) is provided, the
   user agent MAY automatically redirect its request to the URI
   referenced by the Location field value, even if the specific status
   code is not understood.  Automatic redirection needs to done with
   care for methods not known to be safe, as defined in [Section 4.2.1](#section-4.2.1),
   since the user might not wish to redirect an unsafe request.

   There are several types of redirects:

   1.  Redirects that indicate the resource might be available at a
       different URI, as provided by the Location field, as in the
       status codes 301 (Moved Permanently), 302 (Found), and 307
       (Temporary Redirect).

   2.  Redirection that offers a choice of matching resources, each
       capable of representing the original request target, as in the
       300 (Multiple Choices) status code.

   3.  Redirection to a different resource, identified by the Location
       field, that can represent an indirect response to the request, as
       in the 303 (See Other) status code.

   4.  Redirection to a previously cached result, as in the 304 (Not
       Modified) status code.

      Note: In HTTP/1.0, the status codes 301 (Moved Permanently) and
      302 (Found) were defined for the first type of redirect
      ([[RFC1945], Section 9.3](/doc/html/rfc1945#section-9.3)).  Early user agents split on whether the
      method applied to the redirect target would be the same as the

Fielding & Reschke           Standards Track                   [Page 54]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

      original request or would be rewritten as GET.  Although HTTP
      originally defined the former semantics for 301 and 302 (to match
      its original implementation at CERN), and defined 303 (See Other)
      to match the latter semantics, prevailing practice gradually
      converged on the latter semantics for 301 and 302 as well.  The
      first revision of HTTP/1.1 added 307 (Temporary Redirect) to
      indicate the former semantics without being impacted by divergent
      practice.  Over 10 years later, most user agents still do method
      rewriting for 301 and 302; therefore, this specification makes
      that behavior conformant when the original request is POST.

   A client SHOULD detect and intervene in cyclical redirections (i.e.,
   "infinite" redirection loops).

      Note: An earlier version of this specification recommended a
      maximum of five redirections ([[RFC2068], Section 10.3](/doc/html/rfc2068#section-10.3)).  Content
      developers need to be aware that some clients might implement such
      a fixed limitation.

[6.4.1](#section-6.4.1).  300 Multiple Choices

   The 300 (Multiple Choices) status code indicates that the target
   resource has more than one representation, each with its own more
   specific identifier, and information about the alternatives is being
   provided so that the user (or user agent) can select a preferred
   representation by redirecting its request to one or more of those
   identifiers.  In other words, the server desires that the user agent
   engage in reactive negotiation to select the most appropriate
   representation(s) for its needs ([Section 3.4](#section-3.4)).

   If the server has a preferred choice, the server SHOULD generate a
   Location header field containing a preferred choice's URI reference.
   The user agent MAY use the Location field value for automatic
   redirection.

   For request methods other than HEAD, the server SHOULD generate a
   payload in the 300 response containing a list of representation
   metadata and URI reference(s) from which the user or user agent can
   choose the one most preferred.  The user agent MAY make a selection
   from that list automatically if it understands the provided media
   type.  A specific format for automatic selection is not defined by
   this specification because HTTP tries to remain orthogonal to the
   definition of its payloads.  In practice, the representation is
   provided in some easily parsed format believed to be acceptable to
   the user agent, as determined by shared design or content
   negotiation, or in some commonly accepted hypertext format.

Fielding & Reschke           Standards Track                   [Page 55]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   A 300 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   [Section 4.2.2 of [RFC7234]](/doc/html/rfc7234#section-4.2.2)).

      Note: The original proposal for the 300 status code defined the
      URI header field as providing a list of alternative
      representations, such that it would be usable for 200, 300, and
      406 responses and be transferred in responses to the HEAD method.
      However, lack of deployment and disagreement over syntax led to
      both URI and Alternates (a subsequent proposal) being dropped from
      this specification.  It is possible to communicate the list using
      a set of Link header fields [[RFC5988](/doc/html/rfc5988 "\"Web Linking\"")], each with a relationship of
      "alternate", though deployment is a chicken-and-egg problem.

[6.4.2](#section-6.4.2).  301 Moved Permanently

   The 301 (Moved Permanently) status code indicates that the target
   resource has been assigned a new permanent URI and any future
   references to this resource ought to use one of the enclosed URIs.
   Clients with link-editing capabilities ought to automatically re-link
   references to the effective request URI to one or more of the new
   references sent by the server, where possible.

   The server SHOULD generate a Location header field in the response
   containing a preferred URI reference for the new permanent URI.  The
   user agent MAY use the Location field value for automatic
   redirection.  The server's response payload usually contains a short
   hypertext note with a hyperlink to the new URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.

   A 301 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   [Section 4.2.2 of [RFC7234]](/doc/html/rfc7234#section-4.2.2)).

[6.4.3](#section-6.4.3).  302 Found

   The 302 (Found) status code indicates that the target resource
   resides temporarily under a different URI.  Since the redirection
   might be altered on occasion, the client ought to continue to use the
   effective request URI for future requests.

Fielding & Reschke           Standards Track                   [Page 56]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.

[6.4.4](#section-6.4.4).  303 See Other

   The 303 (See Other) status code indicates that the server is
   redirecting the user agent to a different resource, as indicated by a
   URI in the Location header field, which is intended to provide an
   indirect response to the original request.  A user agent can perform
   a retrieval request targeting that URI (a GET or HEAD request if
   using HTTP), which might also be redirected, and present the eventual
   result as an answer to the original request.  Note that the new URI
   in the Location header field is not considered equivalent to the
   effective request URI.

   This status code is applicable to any HTTP method.  It is primarily
   used to allow the output of a POST action to redirect the user agent
   to a selected resource, since doing so provides the information
   corresponding to the POST response in a form that can be separately
   identified, bookmarked, and cached, independent of the original
   request.

   A 303 response to a GET request indicates that the origin server does
   not have a representation of the target resource that can be
   transferred by the server over HTTP.  However, the Location field
   value refers to a resource that is descriptive of the target
   resource, such that making a retrieval request on that other resource
   might result in a representation that is useful to recipients without
   implying that it represents the original target resource.  Note that
   answers to the questions of what can be represented, what
   representations are adequate, and what might be a useful description
   are outside the scope of HTTP.

   Except for responses to a HEAD request, the representation of a 303
   response ought to contain a short hypertext note with a hyperlink to
   the same URI reference provided in the Location header field.

Fielding & Reschke           Standards Track                   [Page 57]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[6.4.5](#section-6.4.5).  305 Use Proxy

   The 305 (Use Proxy) status code was defined in a previous version of
   this specification and is now deprecated (Appendix B).

[6.4.6](#section-6.4.6).  306 (Unused)

   The 306 status code was defined in a previous version of this
   specification, is no longer used, and the code is reserved.

[6.4.7](#section-6.4.7).  307 Temporary Redirect

   The 307 (Temporary Redirect) status code indicates that the target
   resource resides temporarily under a different URI and the user agent
   MUST NOT change the request method if it performs an automatic
   redirection to that URI.  Since the redirection can change over time,
   the client ought to continue using the original effective request URI
   for future requests.

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: This status code is similar to 302 (Found), except that it
      does not allow changing the request method from POST to GET.  This
      specification defines no equivalent counterpart for 301 (Moved
      Permanently) ([[RFC7238](/doc/html/rfc7238 "\"The Hypertext Transfer Protocol (HTTP) Status Code 308 (Permanent Redirect)\"")], however, defines the status code 308
      (Permanent Redirect) for this purpose).

[6.5](#section-6.5).  Client Error 4xx

   The 4xx (Client Error) class of status code indicates that the client
   seems to have erred.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition.  These status codes are applicable to any request method.
   User agents SHOULD display any included representation to the user.

[6.5.1](#section-6.5.1).  400 Bad Request

   The 400 (Bad Request) status code indicates that the server cannot or
   will not process the request due to something that is perceived to be
   a client error (e.g., malformed request syntax, invalid request
   message framing, or deceptive request routing).

Fielding & Reschke           Standards Track                   [Page 58]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[6.5.2](#section-6.5.2).  402 Payment Required

   The 402 (Payment Required) status code is reserved for future use.

[6.5.3](#section-6.5.3).  403 Forbidden

   The 403 (Forbidden) status code indicates that the server understood
   the request but refuses to authorize it.  A server that wishes to
   make public why the request has been forbidden can describe that
   reason in the response payload (if any).

   If authentication credentials were provided in the request, the
   server considers them insufficient to grant access.  The client
   SHOULD NOT automatically repeat the request with the same
   credentials.  The client MAY repeat the request with new or different
   credentials.  However, a request might be forbidden for reasons
   unrelated to the credentials.

   An origin server that wishes to "hide" the current existence of a
   forbidden target resource MAY instead respond with a status code of
   404 (Not Found).

[6.5.4](#section-6.5.4).  404 Not Found

   The 404 (Not Found) status code indicates that the origin server did
   not find a current representation for the target resource or is not
   willing to disclose that one exists.  A 404 status code does not
   indicate whether this lack of representation is temporary or
   permanent; the 410 (Gone) status code is preferred over 404 if the
   origin server knows, presumably through some configurable means, that
   the condition is likely to be permanent.

   A 404 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   [Section 4.2.2 of [RFC7234]](/doc/html/rfc7234#section-4.2.2)).

[6.5.5](#section-6.5.5).  405 Method Not Allowed

   The 405 (Method Not Allowed) status code indicates that the method
   received in the request-line is known by the origin server but not
   supported by the target resource.  The origin server MUST generate an
   Allow header field in a 405 response containing a list of the target
   resource's currently supported methods.

   A 405 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   [Section 4.2.2 of [RFC7234]](/doc/html/rfc7234#section-4.2.2)).

Fielding & Reschke           Standards Track                   [Page 59]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[6.5.6](#section-6.5.6).  406 Not Acceptable

   The 406 (Not Acceptable) status code indicates that the target
   resource does not have a current representation that would be
   acceptable to the user agent, according to the proactive negotiation
   header fields received in the request ([Section 5.3](#section-5.3)), and the server
   is unwilling to supply a default representation.

   The server SHOULD generate a payload containing a list of available
   representation characteristics and corresponding resource identifiers
   from which the user or user agent can choose the one most
   appropriate.  A user agent MAY automatically select the most
   appropriate choice from that list.  However, this specification does
   not define any standard for such automatic selection, as described in
   [Section 6.4.1](#section-6.4.1).

[6.5.7](#section-6.5.7).  408 Request Timeout

   The 408 (Request Timeout) status code indicates that the server did
   not receive a complete request message within the time that it was
   prepared to wait.  A server SHOULD send the "close" connection option
   ([Section 6.1 of [RFC7230]](/doc/html/rfc7230#section-6.1)) in the response, since 408 implies that
   the server has decided to close the connection rather than continue
   waiting.  If the client has an outstanding request in transit, the
   client MAY repeat that request on a new connection.

[6.5.8](#section-6.5.8).  409 Conflict

   The 409 (Conflict) status code indicates that the request could not
   be completed due to a conflict with the current state of the target
   resource.  This code is used in situations where the user might be
   able to resolve the conflict and resubmit the request.  The server
   SHOULD generate a payload that includes enough information for a user
   to recognize the source of the conflict.

   Conflicts are most likely to occur in response to a PUT request.  For
   example, if versioning were being used and the representation being
   PUT included changes to a resource that conflict with those made by
   an earlier (third-party) request, the origin server might use a 409
   response to indicate that it can't complete the request.  In this
   case, the response representation would likely contain information
   useful for merging the differences based on the revision history.

[6.5.9](#section-6.5.9).  410 Gone

   The 410 (Gone) status code indicates that access to the target
   resource is no longer available at the origin server and that this
   condition is likely to be permanent.  If the origin server does not

Fielding & Reschke           Standards Track                   [Page 60]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   know, or has no facility to determine, whether or not the condition
   is permanent, the status code 404 (Not Found) ought to be used
   instead.

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed.  Such an event is common
   for limited-time, promotional services and for resources belonging to
   individuals no longer associated with the origin server's site.  It
   is not necessary to mark all permanently unavailable resources as
   "gone" or to keep the mark for any length of time -- that is left to
   the discretion of the server owner.

   A 410 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   [Section 4.2.2 of [RFC7234]](/doc/html/rfc7234#section-4.2.2)).

[6.5.10](#section-6.5.10).  411 Length Required

   The 411 (Length Required) status code indicates that the server
   refuses to accept the request without a defined Content-Length
   ([Section 3.3.2 of [RFC7230]](/doc/html/rfc7230#section-3.3.2)).  The client MAY repeat the request if
   it adds a valid Content-Length header field containing the length of
   the message body in the request message.

[6.5.11](#section-6.5.11).  413 Payload Too Large

   The 413 (Payload Too Large) status code indicates that the server is
   refusing to process a request because the request payload is larger
   than the server is willing or able to process.  The server MAY close
   the connection to prevent the client from continuing the request.

   If the condition is temporary, the server SHOULD generate a
   Retry-After header field to indicate that it is temporary and after
   what time the client MAY try again.

[6.5.12](#section-6.5.12).  414 URI Too Long

   The 414 (URI Too Long) status code indicates that the server is
   refusing to service the request because the request-target ([Section](/doc/html/rfc7230#section-5.3)
   [5.3 of [RFC7230]](/doc/html/rfc7230#section-5.3)) is longer than the server is willing to interpret.
   This rare condition is only likely to occur when a client has
   improperly converted a POST request to a GET request with long query
   information, when the client has descended into a "black hole" of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself) or when the server is under attack by a client attempting to
   exploit potential security holes.

Fielding & Reschke           Standards Track                   [Page 61]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   A 414 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   [Section 4.2.2 of [RFC7234]](/doc/html/rfc7234#section-4.2.2)).

[6.5.13](#section-6.5.13).  415 Unsupported Media Type

   The 415 (Unsupported Media Type) status code indicates that the
   origin server is refusing to service the request because the payload
   is in a format not supported by this method on the target resource.
   The format problem might be due to the request's indicated
   Content-Type or Content-Encoding, or as a result of inspecting the
   data directly.

[6.5.14](#section-6.5.14).  417 Expectation Failed

   The 417 (Expectation Failed) status code indicates that the
   expectation given in the request's Expect header field
   ([Section 5.1.1](#section-5.1.1)) could not be met by at least one of the inbound
   servers.

[6.5.15](#section-6.5.15).  426 Upgrade Required

   The 426 (Upgrade Required) status code indicates that the server
   refuses to perform the request using the current protocol but might
   be willing to do so after the client upgrades to a different
   protocol.  The server MUST send an Upgrade header field in a 426
   response to indicate the required protocol(s) ([Section 6.7 of
   [RFC7230]](/doc/html/rfc7230#section-6.7)).

   Example:

     HTTP/1.1 426 Upgrade Required
     Upgrade: HTTP/3.0
     Connection: Upgrade
     Content-Length: 53
     Content-Type: text/plain

     This service requires use of the HTTP/3.0 protocol.

[6.6](#section-6.6).  Server Error 5xx

   The 5xx (Server Error) class of status code indicates that the server
   is aware that it has erred or is incapable of performing the
   requested method.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent

Fielding & Reschke           Standards Track                   [Page 62]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   condition.  A user agent SHOULD display any included representation
   to the user.  These response codes are applicable to any request
   method.

[6.6.1](#section-6.6.1).  500 Internal Server Error

   The 500 (Internal Server Error) status code indicates that the server
   encountered an unexpected condition that prevented it from fulfilling
   the request.

[6.6.2](#section-6.6.2).  501 Not Implemented

   The 501 (Not Implemented) status code indicates that the server does
   not support the functionality required to fulfill the request.  This
   is the appropriate response when the server does not recognize the
   request method and is not capable of supporting it for any resource.

   A 501 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   [Section 4.2.2 of [RFC7234]](/doc/html/rfc7234#section-4.2.2)).

[6.6.3](#section-6.6.3).  502 Bad Gateway

   The 502 (Bad Gateway) status code indicates that the server, while
   acting as a gateway or proxy, received an invalid response from an
   inbound server it accessed while attempting to fulfill the request.

[6.6.4](#section-6.6.4).  503 Service Unavailable

   The 503 (Service Unavailable) status code indicates that the server
   is currently unable to handle the request due to a temporary overload
   or scheduled maintenance, which will likely be alleviated after some
   delay.  The server MAY send a Retry-After header field
   ([Section 7.1.3](#section-7.1.3)) to suggest an appropriate amount of time for the
   client to wait before retrying the request.

      Note: The existence of the 503 status code does not imply that a
      server has to use it when becoming overloaded.  Some servers might
      simply refuse the connection.

[6.6.5](#section-6.6.5).  504 Gateway Timeout

   The 504 (Gateway Timeout) status code indicates that the server,
   while acting as a gateway or proxy, did not receive a timely response
   from an upstream server it needed to access in order to complete the
   request.

Fielding & Reschke           Standards Track                   [Page 63]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[6.6.6](#section-6.6.6).  505 HTTP Version Not Supported

   The 505 (HTTP Version Not Supported) status code indicates that the
   server does not support, or refuses to support, the major version of
   HTTP that was used in the request message.  The server is indicating
   that it is unable or unwilling to complete the request using the same
   major version as the client, as described in [Section 2.6 of
   [RFC7230]](/doc/html/rfc7230#section-2.6), other than with this error message.  The server SHOULD
   generate a representation for the 505 response that describes why
   that version is not supported and what other protocols are supported
   by that server.

[7](#section-7).  Response Header Fields

   The response header fields allow the server to pass additional
   information about the response beyond what is placed in the
   status-line.  These header fields give information about the server,
   about further access to the target resource, or about related
   resources.

   Although each response header field has a defined meaning, in
   general, the precise semantics might be further refined by the
   semantics of the request method and/or response status code.

[7.1](#section-7.1).  Control Data

   Response header fields can supply control data that supplements the
   status code, directs caching, or instructs the client where to go
   next.

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Age               | [Section 5.1 of [RFC7234]](/doc/html/rfc7234#section-5.1) |
   | Cache-Control     | [Section 5.2 of [RFC7234]](/doc/html/rfc7234#section-5.2) |
   | Expires           | [Section 5.3 of [RFC7234]](/doc/html/rfc7234#section-5.3) |
   | Date              | [Section 7.1.1.2](#section-7.1.1.2)          |
   | Location          | [Section 7.1.2](#section-7.1.2)            |
   | Retry-After       | [Section 7.1.3](#section-7.1.3)            |
   | Vary              | [Section 7.1.4](#section-7.1.4)            |
   | Warning           | [Section 5.5 of [RFC7234]](/doc/html/rfc7234#section-5.5) |
   +-------------------+--------------------------+

Fielding & Reschke           Standards Track                   [Page 64]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[7.1.1](#section-7.1.1).  Origination Date

[7.1.1.1](#section-7.1.1.1).  Date/Time Formats

   Prior to 1995, there were three different formats commonly used by
   servers to communicate timestamps.  For compatibility with old
   implementations, all three are defined here.  The preferred format is
   a fixed-length and single-zone subset of the date and time
   specification used by the Internet Message Format [[RFC5322](/doc/html/rfc5322 "\"Internet Message Format\"")].

     HTTP-date    = IMF-fixdate / obs-date

   An example of the preferred format is

     Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate

   Examples of the two obsolete formats are

     Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete [RFC 850](/doc/html/rfc850) format
     Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format

   A recipient that parses a timestamp value in an HTTP header field
   MUST accept all three HTTP-date formats.  When a sender generates a
   header field that contains one or more timestamps defined as
   HTTP-date, the sender MUST generate those timestamps in the
   IMF-fixdate format.

   An HTTP-date value represents time as an instance of Coordinated
   Universal Time (UTC).  The first two formats indicate UTC by the
   three-letter abbreviation for Greenwich Mean Time, "GMT", a
   predecessor of the UTC name; values in the asctime format are assumed
   to be in UTC.  A sender that generates HTTP-date values from a local
   clock ought to use NTP ([[RFC5905](/doc/html/rfc5905 "\"Network Time Protocol Version 4: Protocol and Algorithms Specification\"")]) or some similar protocol to
   synchronize its clock to UTC.

   Preferred format:

     IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
     ; fixed length/zone/capitalization subset of the format
     ; see [Section 3.3 of [RFC5322]](/doc/html/rfc5322#section-3.3)

     day-name     = %x4D.6F.6E ; "Mon", case-sensitive
                  / %x54.75.65 ; "Tue", case-sensitive
                  / %x57.65.64 ; "Wed", case-sensitive
                  / %x54.68.75 ; "Thu", case-sensitive
                  / %x46.72.69 ; "Fri", case-sensitive
                  / %x53.61.74 ; "Sat", case-sensitive
                  / %x53.75.6E ; "Sun", case-sensitive

Fielding & Reschke           Standards Track                   [Page 65]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

     date1        = day SP month SP year
                  ; e.g., 02 Jun 1982

     day          = 2DIGIT
     month        = %x4A.61.6E ; "Jan", case-sensitive
                  / %x46.65.62 ; "Feb", case-sensitive
                  / %x4D.61.72 ; "Mar", case-sensitive
                  / %x41.70.72 ; "Apr", case-sensitive
                  / %x4D.61.79 ; "May", case-sensitive
                  / %x4A.75.6E ; "Jun", case-sensitive
                  / %x4A.75.6C ; "Jul", case-sensitive
                  / %x41.75.67 ; "Aug", case-sensitive
                  / %x53.65.70 ; "Sep", case-sensitive
                  / %x4F.63.74 ; "Oct", case-sensitive
                  / %x4E.6F.76 ; "Nov", case-sensitive
                  / %x44.65.63 ; "Dec", case-sensitive
     year         = 4DIGIT

     GMT          = %x47.4D.54 ; "GMT", case-sensitive

     time-of-day  = hour ":" minute ":" second
                  ; 00:00:00 - 23:59:60 (leap second)

     hour         = 2DIGIT
     minute       = 2DIGIT
     second       = 2DIGIT

   Obsolete formats:

     obs-date     = [rfc850](/doc/html/rfc850)-date / asctime-date

     [rfc850](/doc/html/rfc850)-date  = day-name-l "," SP date2 SP time-of-day SP GMT
     date2        = day "-" month "-" 2DIGIT
                  ; e.g., 02-Jun-82

     day-name-l   = %x4D.6F.6E.64.61.79    ; "Monday", case-sensitive
            / %x54.75.65.73.64.61.79       ; "Tuesday", case-sensitive
            / %x57.65.64.6E.65.73.64.61.79 ; "Wednesday", case-sensitive
            / %x54.68.75.72.73.64.61.79    ; "Thursday", case-sensitive
            / %x46.72.69.64.61.79          ; "Friday", case-sensitive
            / %x53.61.74.75.72.64.61.79    ; "Saturday", case-sensitive
            / %x53.75.6E.64.61.79          ; "Sunday", case-sensitive

     asctime-date = day-name SP date3 SP time-of-day SP year
     date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
                  ; e.g., Jun  2

Fielding & Reschke           Standards Track                   [Page 66]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   HTTP-date is case sensitive.  A sender MUST NOT generate additional
   whitespace in an HTTP-date beyond that specifically included as SP in
   the grammar.  The semantics of day-name, day, month, year, and
   time-of-day are the same as those defined for the Internet Message
   Format constructs with the corresponding name ([[RFC5322](/doc/html/rfc5322 "\"Internet Message Format\"")], [Section](#section-3.3)
   [3.3](#section-3.3)).

   Recipients of a timestamp value in [rfc850](/doc/html/rfc850)-date format, which uses a
   two-digit year, MUST interpret a timestamp that appears to be more
   than 50 years in the future as representing the most recent year in
   the past that had the same last two digits.

   Recipients of timestamp values are encouraged to be robust in parsing
   timestamps unless otherwise restricted by the field definition.  For
   example, messages are occasionally forwarded over HTTP from a
   non-HTTP source that might generate any of the date and time
   specifications defined by the Internet Message Format.

      Note: HTTP requirements for the date/time stamp format apply only
      to their usage within the protocol stream.  Implementations are
      not required to use these formats for user presentation, request
      logging, etc.

[7.1.1.2](#section-7.1.1.2).  Date

   The "Date" header field represents the date and time at which the
   message was originated, having the same semantics as the Origination
   Date Field (orig-date) defined in [Section 3.6.1 of [RFC5322]](/doc/html/rfc5322#section-3.6.1).  The
   field value is an HTTP-date, as defined in [Section 7.1.1.1](#section-7.1.1.1).

     Date = HTTP-date

   An example is

     Date: Tue, 15 Nov 1994 08:12:31 GMT

   When a Date header field is generated, the sender SHOULD generate its
   field value as the best available approximation of the date and time
   of message generation.  In theory, the date ought to represent the
   moment just before the payload is generated.  In practice, the date
   can be generated at any time during message origination.

   An origin server MUST NOT send a Date header field if it does not
   have a clock capable of providing a reasonable approximation of the
   current instance in Coordinated Universal Time.  An origin server MAY
   send a Date header field if the response is in the 1xx
   (Informational) or 5xx (Server Error) class of status codes.  An
   origin server MUST send a Date header field in all other cases.

Fielding & Reschke           Standards Track                   [Page 67]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   A recipient with a clock that receives a response message without a
   Date header field MUST record the time it was received and append a
   corresponding Date header field to the message's header section if it
   is cached or forwarded downstream.

   A user agent MAY send a Date header field in a request, though
   generally will not do so unless it is believed to convey useful
   information to the server.  For example, custom applications of HTTP
   might convey a Date if the server is expected to adjust its
   interpretation of the user's request based on differences between the
   user agent and server clocks.

[7.1.2](#section-7.1.2).  Location

   The "Location" header field is used in some responses to refer to a
   specific resource in relation to the response.  The type of
   relationship is defined by the combination of request method and
   status code semantics.

     Location = URI-reference

   The field value consists of a single URI-reference.  When it has the
   form of a relative reference ([[RFC3986], Section 4.2](/doc/html/rfc3986#section-4.2)), the final
   value is computed by resolving it against the effective request URI
   ([[RFC3986], Section 5](/doc/html/rfc3986#section-5)).

   For 201 (Created) responses, the Location value refers to the primary
   resource created by the request.  For 3xx (Redirection) responses,
   the Location value refers to the preferred target resource for
   automatically redirecting the request.

   If the Location value provided in a 3xx (Redirection) response does
   not have a fragment component, a user agent MUST process the
   redirection as if the value inherits the fragment component of the
   URI reference used to generate the request target (i.e., the
   redirection inherits the original reference's fragment, if any).

   For example, a GET request generated for the URI reference
   "http://www.example.org/~tim" might result in a 303 (See Other)
   response containing the header field:

     Location: /People.html#tim

   which suggests that the user agent redirect to
   "http://www.example.org/People.html#tim"

Fielding & Reschke           Standards Track                   [Page 68]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   Likewise, a GET request generated for the URI reference
   "http://www.example.org/index.html#larry" might result in a 301
   (Moved Permanently) response containing the header field:

     Location: http://www.example.net/index.html

   which suggests that the user agent redirect to
   "http://www.example.net/index.html#larry", preserving the original
   fragment identifier.

   There are circumstances in which a fragment identifier in a Location
   value would not be appropriate.  For example, the Location header
   field in a 201 (Created) response is supposed to provide a URI that
   is specific to the created resource.

      Note: Some recipients attempt to recover from Location fields that
      are not valid URI references.  This specification does not mandate
      or define such processing, but does allow it for the sake of
      robustness.

      Note: The Content-Location header field ([Section 3.1.4.2](#section-3.1.4.2)) differs
      from Location in that the Content-Location refers to the most
      specific resource corresponding to the enclosed representation.
      It is therefore possible for a response to contain both the
      Location and Content-Location header fields.

[7.1.3](#section-7.1.3).  Retry-After

   Servers send the "Retry-After" header field to indicate how long the
   user agent ought to wait before making a follow-up request.  When
   sent with a 503 (Service Unavailable) response, Retry-After indicates
   how long the service is expected to be unavailable to the client.
   When sent with any 3xx (Redirection) response, Retry-After indicates
   the minimum time that the user agent is asked to wait before issuing
   the redirected request.

   The value of this field can be either an HTTP-date or a number of
   seconds to delay after the response is received.

     Retry-After = HTTP-date / delay-seconds

   A delay-seconds value is a non-negative decimal integer, representing
   time in seconds.

     delay-seconds  = 1*DIGIT

Fielding & Reschke           Standards Track                   [Page 69]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   Two examples of its use are

     Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
     Retry-After: 120

   In the latter example, the delay is 2 minutes.

[7.1.4](#section-7.1.4).  Vary

   The "Vary" header field in a response describes what parts of a
   request message, aside from the method, Host header field, and
   request target, might influence the origin server's process for
   selecting and representing this response.  The value consists of
   either a single asterisk ("*") or a list of header field names
   (case-insensitive).

     Vary = "*" / 1#field-name

   A Vary field value of "*" signals that anything about the request
   might play a role in selecting the response representation, possibly
   including elements outside the message syntax (e.g., the client's
   network address).  A recipient will not be able to determine whether
   this response is appropriate for a later request without forwarding
   the request to the origin server.  A proxy MUST NOT generate a Vary
   field with a "*" value.

   A Vary field value consisting of a comma-separated list of names
   indicates that the named request header fields, known as the
   selecting header fields, might have a role in selecting the
   representation.  The potential selecting header fields are not
   limited to those defined by this specification.

   For example, a response that contains

     Vary: accept-encoding, accept-language

   indicates that the origin server might have used the request's
   Accept-Encoding and Accept-Language fields (or lack thereof) as
   determining factors while choosing the content for this response.

   An origin server might send Vary with a list of fields for two
   purposes:

   1.  To inform cache recipients that they MUST NOT use this response
       to satisfy a later request unless the later request has the same
       values for the listed fields as the original request ([Section 4.1
       of [RFC7234]](/doc/html/rfc7234#section-4.1)).  In other words, Vary expands the cache key
       required to match a new request to the stored cache entry.

Fielding & Reschke           Standards Track                   [Page 70]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   2.  To inform user agent recipients that this response is subject to
       content negotiation ([Section 5.3](#section-5.3)) and that a different
       representation might be sent in a subsequent request if
       additional parameters are provided in the listed header fields
       (proactive negotiation).

   An origin server SHOULD send a Vary header field when its algorithm
   for selecting a representation varies based on aspects of the request
   message other than the method and request target, unless the variance
   cannot be crossed or the origin server has been deliberately
   configured to prevent cache transparency.  For example, there is no
   need to send the Authorization field name in Vary because reuse
   across users is constrained by the field definition ([Section 4.2 of
   [RFC7235]](/doc/html/rfc7235#section-4.2)).  Likewise, an origin server might use Cache-Control
   directives ([Section 5.2 of [RFC7234]](/doc/html/rfc7234#section-5.2)) to supplant Vary if it
   considers the variance less significant than the performance cost of
   Vary's impact on caching.

[7.2](#section-7.2).  Validator Header Fields

   Validator header fields convey metadata about the selected
   representation ([Section 3](#section-3)).  In responses to safe requests, validator
   fields describe the selected representation chosen by the origin
   server while handling the response.  Note that, depending on the
   status code semantics, the selected representation for a given
   response is not necessarily the same as the representation enclosed
   as response payload.

   In a successful response to a state-changing request, validator
   fields describe the new representation that has replaced the prior
   selected representation as a result of processing the request.

   For example, an ETag header field in a 201 (Created) response
   communicates the entity-tag of the newly created resource's
   representation, so that it can be used in later conditional requests
   to prevent the "lost update" problem [[RFC7232](/doc/html/rfc7232 "\"Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests\"")].

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | ETag              | [Section 2.3 of [RFC7232]](/doc/html/rfc7232#section-2.3) |
   | Last-Modified     | [Section 2.2 of [RFC7232]](/doc/html/rfc7232#section-2.2) |
   +-------------------+--------------------------+

Fielding & Reschke           Standards Track                   [Page 71]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[7.3](#section-7.3).  Authentication Challenges

   Authentication challenges indicate what mechanisms are available for
   the client to provide authentication credentials in future requests.

   +--------------------+--------------------------+
   | Header Field Name  | Defined in...            |
   +--------------------+--------------------------+
   | WWW-Authenticate   | [Section 4.1 of [RFC7235]](/doc/html/rfc7235#section-4.1) |
   | Proxy-Authenticate | [Section 4.3 of [RFC7235]](/doc/html/rfc7235#section-4.3) |
   +--------------------+--------------------------+

[7.4](#section-7.4).  Response Context

   The remaining response header fields provide more information about
   the target resource for potential use in later requests.

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Accept-Ranges     | [Section 2.3 of [RFC7233]](/doc/html/rfc7233#section-2.3) |
   | Allow             | [Section 7.4.1](#section-7.4.1)            |
   | Server            | [Section 7.4.2](#section-7.4.2)            |
   +-------------------+--------------------------+

[7.4.1](#section-7.4.1).  Allow

   The "Allow" header field lists the set of methods advertised as
   supported by the target resource.  The purpose of this field is
   strictly to inform the recipient of valid request methods associated
   with the resource.

     Allow = #method

   Example of use:

     Allow: GET, HEAD, PUT

   The actual set of allowed methods is defined by the origin server at
   the time of each request.  An origin server MUST generate an Allow
   field in a 405 (Method Not Allowed) response and MAY do so in any
   other response.  An empty Allow field value indicates that the
   resource allows no methods, which might occur in a 405 response if
   the resource has been temporarily disabled by configuration.

   A proxy MUST NOT modify the Allow header field -- it does not need to
   understand all of the indicated methods in order to handle them
   according to the generic message handling rules.

Fielding & Reschke           Standards Track                   [Page 72]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[7.4.2](#section-7.4.2).  Server

   The "Server" header field contains information about the software
   used by the origin server to handle the request, which is often used
   by clients to help identify the scope of reported interoperability
   problems, to work around or tailor requests to avoid particular
   server limitations, and for analytics regarding server or operating
   system use.  An origin server MAY generate a Server field in its
   responses.

     Server = product *( RWS ( product / comment ) )

   The Server field-value consists of one or more product identifiers,
   each followed by zero or more comments ([Section 3.2 of [RFC7230]](/doc/html/rfc7230#section-3.2)),
   which together identify the origin server software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   origin server software.  Each product identifier consists of a name
   and optional version, as defined in [Section 5.5.3](#section-5.5.3).

   Example:

     Server: CERN/3.0 libwww/2.17

   An origin server SHOULD NOT generate a Server field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed Server field
   values increase response latency and potentially reveal internal
   implementation details that might make it (slightly) easier for
   attackers to find and exploit known security holes.

[8](#section-8).  IANA Considerations

[8.1](#section-8.1).  Method Registry

   The "Hypertext Transfer Protocol (HTTP) Method Registry" defines the
   namespace for the request method token ([Section 4](#section-4)).  The method
   registry has been created and is now maintained at
   <<http://www.iana.org/assignments/http-methods>>.

Fielding & Reschke           Standards Track                   [Page 73]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[8.1.1](#section-8.1.1).  Procedure

   HTTP method registrations MUST include the following fields:

   o  Method Name (see [Section 4](#section-4))

   o  Safe ("yes" or "no", see [Section 4.2.1](#section-4.2.1))

   o  Idempotent ("yes" or "no", see [Section 4.2.2](#section-4.2.2))

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   [[RFC5226], Section 4.1](/doc/html/rfc5226#section-4.1)).

[8.1.2](#section-8.1.2).  Considerations for New Methods

   Standardized methods are generic; that is, they are potentially
   applicable to any resource, not just one particular media type, kind
   of resource, or application.  As such, it is preferred that new
   methods be registered in a document that isn't specific to a single
   application or data format, since orthogonal technologies deserve
   orthogonal specification.

   Since message parsing ([Section 3.3 of [RFC7230]](/doc/html/rfc7230#section-3.3)) needs to be
   independent of method semantics (aside from responses to HEAD),
   definitions of new methods cannot change the parsing algorithm or
   prohibit the presence of a message body on either the request or the
   response message.  Definitions of new methods can specify that only a
   zero-length message body is allowed by requiring a Content-Length
   header field with a value of "0".

   A new method definition needs to indicate whether it is safe
   ([Section 4.2.1](#section-4.2.1)), idempotent ([Section 4.2.2](#section-4.2.2)), cacheable
   ([Section 4.2.3](#section-4.2.3)), what semantics are to be associated with the payload
   body if any is present in the request and what refinements the method
   makes to header field or status code semantics.  If the new method is
   cacheable, its definition ought to describe how, and under what
   conditions, a cache can store a response and use it to satisfy a
   subsequent request.  The new method ought to describe whether it can
   be made conditional ([Section 5.2](#section-5.2)) and, if so, how a server responds
   when the condition is false.  Likewise, if the new method might have
   some use for partial response semantics ([[RFC7233](/doc/html/rfc7233 "\"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\"")]), it ought to
   document this, too.

      Note: Avoid defining a method name that starts with "M-", since
      that prefix might be misinterpreted as having the semantics
      assigned to it by [[RFC2774](/doc/html/rfc2774 "\"An HTTP Extension Framework\"")].

Fielding & Reschke           Standards Track                   [Page 74]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[8.1.3](#section-8.1.3).  Registrations

   The "Hypertext Transfer Protocol (HTTP) Method Registry" has been
   populated with the registrations below:

   +---------+------+------------+---------------+
   | Method  | Safe | Idempotent | Reference     |
   +---------+------+------------+---------------+
   | CONNECT | no   | no         | [Section 4.3.6](#section-4.3.6) |
   | DELETE  | no   | yes        | [Section 4.3.5](#section-4.3.5) |
   | GET     | yes  | yes        | [Section 4.3.1](#section-4.3.1) |
   | HEAD    | yes  | yes        | [Section 4.3.2](#section-4.3.2) |
   | OPTIONS | yes  | yes        | [Section 4.3.7](#section-4.3.7) |
   | POST    | no   | no         | [Section 4.3.3](#section-4.3.3) |
   | PUT     | no   | yes        | [Section 4.3.4](#section-4.3.4) |
   | TRACE   | yes  | yes        | [Section 4.3.8](#section-4.3.8) |
   +---------+------+------------+---------------+

[8.2](#section-8.2).  Status Code Registry

   The "Hypertext Transfer Protocol (HTTP) Status Code Registry" defines
   the namespace for the response status-code token ([Section 6](#section-6)).  The
   status code registry is maintained at
   <<http://www.iana.org/assignments/http-status-codes>>.

   This section replaces the registration procedure for HTTP Status
   Codes previously defined in [Section 7.1 of [RFC2817]](/doc/html/rfc2817#section-7.1).

[8.2.1](#section-8.2.1).  Procedure

   A registration MUST include the following fields:

   o  Status Code (3 digits)

   o  Short Description

   o  Pointer to specification text

   Values to be added to the HTTP status code namespace require IETF
   Review (see [[RFC5226], Section 4.1](/doc/html/rfc5226#section-4.1)).

Fielding & Reschke           Standards Track                   [Page 75]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[8.2.2](#section-8.2.2).  Considerations for New Status Codes

   When it is necessary to express semantics for a response that are not
   defined by current status codes, a new status code can be registered.
   Status codes are generic; they are potentially applicable to any
   resource, not just one particular media type, kind of resource, or
   application of HTTP.  As such, it is preferred that new status codes
   be registered in a document that isn't specific to a single
   application.

   New status codes are required to fall under one of the categories
   defined in [Section 6](#section-6).  To allow existing parsers to process the
   response message, new status codes cannot disallow a payload,
   although they can mandate a zero-length payload body.

   Proposals for new status codes that are not yet widely deployed ought
   to avoid allocating a specific number for the code until there is
   clear consensus that it will be registered; instead, early drafts can
   use a notation such as "4NN", or "3N0" .. "3N9", to indicate the
   class of the proposed status code(s) without consuming a number
   prematurely.

   The definition of a new status code ought to explain the request
   conditions that would cause a response containing that status code
   (e.g., combinations of request header fields and/or method(s)) along
   with any dependencies on response header fields (e.g., what fields
   are required, what fields can modify the semantics, and what header
   field semantics are further refined when used with the new status
   code).

   The definition of a new status code ought to specify whether or not
   it is cacheable.  Note that all status codes can be cached if the
   response they occur in has explicit freshness information; however,
   status codes that are defined as being cacheable are allowed to be
   cached without explicit freshness information.  Likewise, the
   definition of a status code can place constraints upon cache
   behavior.  See [[RFC7234](/doc/html/rfc7234 "\"Hypertext Transfer Protocol (HTTP/1.1): Caching\"")] for more information.

   Finally, the definition of a new status code ought to indicate
   whether the payload has any implied association with an identified
   resource ([Section 3.1.4.1](#section-3.1.4.1)).

[8.2.3](#section-8.2.3).  Registrations

   The status code registry has been updated with the registrations
   below:

Fielding & Reschke           Standards Track                   [Page 76]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   +-------+-------------------------------+----------------+
   | Value | Description                   | Reference      |
   +-------+-------------------------------+----------------+
   | 100   | Continue                      | [Section 6.2.1](#section-6.2.1)  |
   | 101   | Switching Protocols           | [Section 6.2.2](#section-6.2.2)  |
   | 200   | OK                            | [Section 6.3.1](#section-6.3.1)  |
   | 201   | Created                       | [Section 6.3.2](#section-6.3.2)  |
   | 202   | Accepted                      | [Section 6.3.3](#section-6.3.3)  |
   | 203   | Non-Authoritative Information | [Section 6.3.4](#section-6.3.4)  |
   | 204   | No Content                    | [Section 6.3.5](#section-6.3.5)  |
   | 205   | Reset Content                 | [Section 6.3.6](#section-6.3.6)  |
   | 300   | Multiple Choices              | [Section 6.4.1](#section-6.4.1)  |
   | 301   | Moved Permanently             | [Section 6.4.2](#section-6.4.2)  |
   | 302   | Found                         | [Section 6.4.3](#section-6.4.3)  |
   | 303   | See Other                     | [Section 6.4.4](#section-6.4.4)  |
   | 305   | Use Proxy                     | [Section 6.4.5](#section-6.4.5)  |
   | 306   | (Unused)                      | [Section 6.4.6](#section-6.4.6)  |
   | 307   | Temporary Redirect            | [Section 6.4.7](#section-6.4.7)  |
   | 400   | Bad Request                   | [Section 6.5.1](#section-6.5.1)  |
   | 402   | Payment Required              | [Section 6.5.2](#section-6.5.2)  |
   | 403   | Forbidden                     | [Section 6.5.3](#section-6.5.3)  |
   | 404   | Not Found                     | [Section 6.5.4](#section-6.5.4)  |
   | 405   | Method Not Allowed            | [Section 6.5.5](#section-6.5.5)  |
   | 406   | Not Acceptable                | [Section 6.5.6](#section-6.5.6)  |
   | 408   | Request Timeout               | [Section 6.5.7](#section-6.5.7)  |
   | 409   | Conflict                      | [Section 6.5.8](#section-6.5.8)  |
   | 410   | Gone                          | [Section 6.5.9](#section-6.5.9)  |
   | 411   | Length Required               | [Section 6.5.10](#section-6.5.10) |
   | 413   | Payload Too Large             | [Section 6.5.11](#section-6.5.11) |
   | 414   | URI Too Long                  | [Section 6.5.12](#section-6.5.12) |
   | 415   | Unsupported Media Type        | [Section 6.5.13](#section-6.5.13) |
   | 417   | Expectation Failed            | [Section 6.5.14](#section-6.5.14) |
   | 426   | Upgrade Required              | [Section 6.5.15](#section-6.5.15) |
   | 500   | Internal Server Error         | [Section 6.6.1](#section-6.6.1)  |
   | 501   | Not Implemented               | [Section 6.6.2](#section-6.6.2)  |
   | 502   | Bad Gateway                   | [Section 6.6.3](#section-6.6.3)  |
   | 503   | Service Unavailable           | [Section 6.6.4](#section-6.6.4)  |
   | 504   | Gateway Timeout               | [Section 6.6.5](#section-6.6.5)  |
   | 505   | HTTP Version Not Supported    | [Section 6.6.6](#section-6.6.6)  |
   +-------+-------------------------------+----------------+

[8.3](#section-8.3).  Header Field Registry

   HTTP header fields are registered within the "Message Headers"
   registry located at
   <<http://www.iana.org/assignments/message-headers>>, as defined by
   [[BCP90](#ref-BCP90 "\"Registration Procedures for Message Header Fields\"")].

Fielding & Reschke           Standards Track                   [Page 77]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[8.3.1](#section-8.3.1).  Considerations for New Header Fields

   Header fields are key:value pairs that can be used to communicate
   data about the message, its payload, the target resource, or the
   connection (i.e., control data).  See [Section 3.2 of [RFC7230]](/doc/html/rfc7230#section-3.2) for a
   general definition of header field syntax in HTTP messages.

   The requirements for header field names are defined in [[BCP90](#ref-BCP90 "\"Registration Procedures for Message Header Fields\"")].

   Authors of specifications defining new fields are advised to keep the
   name as short as practical and not to prefix the name with "X-"
   unless the header field will never be used on the Internet.  (The
   "X-" prefix idiom has been extensively misused in practice; it was
   intended to only be used as a mechanism for avoiding name collisions
   inside proprietary software or intranet processing, since the prefix
   would ensure that private names never collide with a newly registered
   Internet name; see [[BCP178](#ref-BCP178 "\"Deprecating the \"")] for further information).

   New header field values typically have their syntax defined using
   ABNF ([[RFC5234](/doc/html/rfc5234 "\"Augmented BNF for Syntax Specifications: ABNF\"")]), using the extension defined in [Section 7 of
   [RFC7230]](/doc/html/rfc7230#section-7) as necessary, and are usually constrained to the range of
   US-ASCII characters.  Header fields needing a greater range of
   characters can use an encoding such as the one defined in [[RFC5987](/doc/html/rfc5987 "\"Character Set and Language Encoding for Hypertext Transfer Protocol (HTTP) Header Field Parameters\"")].

   Leading and trailing whitespace in raw field values is removed upon
   field parsing ([Section 3.2.4 of [RFC7230]](/doc/html/rfc7230#section-3.2.4)).  Field definitions where
   leading or trailing whitespace in values is significant will have to
   use a container syntax such as quoted-string ([Section 3.2.6 of
   [RFC7230]](/doc/html/rfc7230#section-3.2.6)).

   Because commas (",") are used as a generic delimiter between
   field-values, they need to be treated with care if they are allowed
   in the field-value.  Typically, components that might contain a comma
   are protected with double-quotes using the quoted-string ABNF
   production.

   For example, a textual date and a URI (either of which might contain
   a comma) could be safely carried in field-values like these:

     Example-URI-Field: "http://example.com/a.html,foo",
                        "http://without-a-comma.example.com/"
     Example-Date-Field: "Sat, 04 May 1996", "Wed, 14 Sep 2005"

   Note that double-quote delimiters almost always are used with the
   quoted-string production; using a different syntax inside
   double-quotes will likely cause unnecessary confusion.

Fielding & Reschke           Standards Track                   [Page 78]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   Many header fields use a format including (case-insensitively) named
   parameters (for instance, Content-Type, defined in [Section 3.1.1.5](#section-3.1.1.5)).
   Allowing both unquoted (token) and quoted (quoted-string) syntax for
   the parameter value enables recipients to use existing parser
   components.  When allowing both forms, the meaning of a parameter
   value ought to be independent of the syntax used for it (for an
   example, see the notes on parameter handling for media types in
   [Section 3.1.1.1](#section-3.1.1.1)).

   Authors of specifications defining new header fields are advised to
   consider documenting:

   o  Whether the field is a single value or whether it can be a list
      (delimited by commas; see [Section 3.2 of [RFC7230]](/doc/html/rfc7230#section-3.2)).

      If it does not use the list syntax, document how to treat messages
      where the field occurs multiple times (a sensible default would be
      to ignore the field, but this might not always be the right
      choice).

      Note that intermediaries and software libraries might combine
      multiple header field instances into a single one, despite the
      field's definition not allowing the list syntax.  A robust format
      enables recipients to discover these situations (good example:
      "Content-Type", as the comma can only appear inside quoted
      strings; bad example: "Location", as a comma can occur inside a
      URI).

   o  Under what conditions the header field can be used; e.g., only in
      responses or requests, in all messages, only on responses to a
      particular request method, etc.

   o  Whether the field should be stored by origin servers that
      understand it upon a PUT request.

   o  Whether the field semantics are further refined by the context,
      such as by existing request methods or status codes.

   o  Whether it is appropriate to list the field-name in the Connection
      header field (i.e., if the header field is to be hop-by-hop; see
      [Section 6.1 of [RFC7230]](/doc/html/rfc7230#section-6.1)).

   o  Under what conditions intermediaries are allowed to insert,
      delete, or modify the field's value.

Fielding & Reschke           Standards Track                   [Page 79]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   o  Whether it is appropriate to list the field-name in a Vary
      response header field (e.g., when the request header field is used
      by an origin server's content selection algorithm; see
      [Section 7.1.4](#section-7.1.4)).

   o  Whether the header field is useful or allowable in trailers (see
      [Section 4.1 of [RFC7230]](/doc/html/rfc7230#section-4.1)).

   o  Whether the header field ought to be preserved across redirects.

   o  Whether it introduces any additional security considerations, such
      as disclosure of privacy-related data.

[8.3.2](#section-8.3.2).  Registrations

   The "Message Headers" registry has been updated with the following
   permanent registrations:

   +-------------------+----------+----------+-----------------+
   | Header Field Name | Protocol | Status   | Reference       |
   +-------------------+----------+----------+-----------------+
   | Accept            | http     | standard | [Section 5.3.2](#section-5.3.2)   |
   | Accept-Charset    | http     | standard | [Section 5.3.3](#section-5.3.3)   |
   | Accept-Encoding   | http     | standard | [Section 5.3.4](#section-5.3.4)   |
   | Accept-Language   | http     | standard | [Section 5.3.5](#section-5.3.5)   |
   | Allow             | http     | standard | [Section 7.4.1](#section-7.4.1)   |
   | Content-Encoding  | http     | standard | [Section 3.1.2.2](#section-3.1.2.2) |
   | Content-Language  | http     | standard | [Section 3.1.3.2](#section-3.1.3.2) |
   | Content-Location  | http     | standard | [Section 3.1.4.2](#section-3.1.4.2) |
   | Content-Type      | http     | standard | [Section 3.1.1.5](#section-3.1.1.5) |
   | Date              | http     | standard | [Section 7.1.1.2](#section-7.1.1.2) |
   | Expect            | http     | standard | [Section 5.1.1](#section-5.1.1)   |
   | From              | http     | standard | [Section 5.5.1](#section-5.5.1)   |
   | Location          | http     | standard | [Section 7.1.2](#section-7.1.2)   |
   | Max-Forwards      | http     | standard | [Section 5.1.2](#section-5.1.2)   |
   | MIME-Version      | http     | standard | [Appendix A.1](#appendix-A.1)    |
   | Referer           | http     | standard | [Section 5.5.2](#section-5.5.2)   |
   | Retry-After       | http     | standard | [Section 7.1.3](#section-7.1.3)   |
   | Server            | http     | standard | [Section 7.4.2](#section-7.4.2)   |
   | User-Agent        | http     | standard | [Section 5.5.3](#section-5.5.3)   |
   | Vary              | http     | standard | [Section 7.1.4](#section-7.1.4)   |
   +-------------------+----------+----------+-----------------+

   The change controller for the above registrations is: "IETF
   (iesg@ietf.org) - Internet Engineering Task Force".

Fielding & Reschke           Standards Track                   [Page 80]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[8.4](#section-8.4).  Content Coding Registry

   The "HTTP Content Coding Registry" defines the namespace for content
   coding names ([Section 4.2 of [RFC7230]](/doc/html/rfc7230#section-4.2)).  The content coding registry
   is maintained at <<http://www.iana.org/assignments/http-parameters>>.

[8.4.1](#section-8.4.1).  Procedure

   Content coding registrations MUST include the following fields:

   o  Name

   o  Description

   o  Pointer to specification text

   Names of content codings MUST NOT overlap with names of transfer
   codings ([Section 4 of [RFC7230]](/doc/html/rfc7230#section-4)), unless the encoding transformation
   is identical (as is the case for the compression codings defined in
   [Section 4.2 of [RFC7230]](/doc/html/rfc7230#section-4.2)).

   Values to be added to this namespace require IETF Review (see [Section](/doc/html/rfc5226#section-4.1)
   [4.1 of [RFC5226]](/doc/html/rfc5226#section-4.1)) and MUST conform to the purpose of content coding
   defined in this section.

[8.4.2](#section-8.4.2).  Registrations

   The "HTTP Content Coding Registry" has been updated with the
   registrations below:

   +----------+----------------------------------------+---------------+
   | Name     | Description                            | Reference     |
   +----------+----------------------------------------+---------------+
   | identity | Reserved (synonym for "no encoding" in | [Section 5.3.4](#section-5.3.4) |
   |          | Accept-Encoding)                       |               |
   +----------+----------------------------------------+---------------+

[9](#section-9).  Security Considerations

   This section is meant to inform developers, information providers,
   and users of known security concerns relevant to HTTP semantics and
   its use for transferring information over the Internet.
   Considerations related to message syntax, parsing, and routing are
   discussed in [Section 9 of [RFC7230]](/doc/html/rfc7230#section-9).

   The list of considerations below is not exhaustive.  Most security
   concerns related to HTTP semantics are about securing server-side
   applications (code behind the HTTP interface), securing user agent

Fielding & Reschke           Standards Track                   [Page 81]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   processing of payloads received via HTTP, or secure use of the
   Internet in general, rather than security of the protocol.  Various
   organizations maintain topical information and links to current
   research on Web application security (e.g., [[OWASP](#ref-OWASP "\"A Guide to Building Secure Web Applications and Web Services\"")]).

[9.1](#section-9.1).  Attacks Based on File and Path Names

   Origin servers frequently make use of their local file system to
   manage the mapping from effective request URI to resource
   representations.  Most file systems are not designed to protect
   against malicious file or path names.  Therefore, an origin server
   needs to avoid accessing names that have a special significance to
   the system when mapping the request target to files, folders, or
   directories.

   For example, UNIX, Microsoft Windows, and other operating systems use
   ".." as a path component to indicate a directory level above the
   current one, and they use specially named paths or file names to send
   data to system devices.  Similar naming conventions might exist
   within other types of storage systems.  Likewise, local storage
   systems have an annoying tendency to prefer user-friendliness over
   security when handling invalid or unexpected characters,
   recomposition of decomposed characters, and case-normalization of
   case-insensitive names.

   Attacks based on such special names tend to focus on either denial-
   of-service (e.g., telling the server to read from a COM port) or
   disclosure of configuration and source files that are not meant to be
   served.

[9.2](#section-9.2).  Attacks Based on Command, Code, or Query Injection

   Origin servers often use parameters within the URI as a means of
   identifying system services, selecting database entries, or choosing
   a data source.  However, data received in a request cannot be
   trusted.  An attacker could construct any of the request data
   elements (method, request-target, header fields, or body) to contain
   data that might be misinterpreted as a command, code, or query when
   passed through a command invocation, language interpreter, or
   database interface.

   For example, SQL injection is a common attack wherein additional
   query language is inserted within some part of the request-target or
   header fields (e.g., Host, Referer, etc.).  If the received data is
   used directly within a SELECT statement, the query language might be
   interpreted as a database command instead of a simple string value.
   This type of implementation vulnerability is extremely common, in
   spite of being easy to prevent.

Fielding & Reschke           Standards Track                   [Page 82]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   In general, resource implementations ought to avoid use of request
   data in contexts that are processed or interpreted as instructions.
   Parameters ought to be compared to fixed strings and acted upon as a
   result of that comparison, rather than passed through an interface
   that is not prepared for untrusted data.  Received data that isn't
   based on fixed parameters ought to be carefully filtered or encoded
   to avoid being misinterpreted.

   Similar considerations apply to request data when it is stored and
   later processed, such as within log files, monitoring tools, or when
   included within a data format that allows embedded scripts.

[9.3](#section-9.3).  Disclosure of Personal Information

   Clients are often privy to large amounts of personal information,
   including both information provided by the user to interact with
   resources (e.g., the user's name, location, mail address, passwords,
   encryption keys, etc.) and information about the user's browsing
   activity over time (e.g., history, bookmarks, etc.).  Implementations
   need to prevent unintentional disclosure of personal information.

[9.4](#section-9.4).  Disclosure of Sensitive Information in URIs

   URIs are intended to be shared, not secured, even when they identify
   secure resources.  URIs are often shown on displays, added to
   templates when a page is printed, and stored in a variety of
   unprotected bookmark lists.  It is therefore unwise to include
   information within a URI that is sensitive, personally identifiable,
   or a risk to disclose.

   Authors of services ought to avoid GET-based forms for the submission
   of sensitive data because that data will be placed in the
   request-target.  Many existing servers, proxies, and user agents log
   or display the request-target in places where it might be visible to
   third parties.  Such services ought to use POST-based form submission
   instead.

   Since the Referer header field tells a target site about the context
   that resulted in a request, it has the potential to reveal
   information about the user's immediate browsing history and any
   personal information that might be found in the referring resource's
   URI.  Limitations on the Referer header field are described in
   [Section 5.5.2](#section-5.5.2) to address some of its security considerations.

Fielding & Reschke           Standards Track                   [Page 83]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[9.5](#section-9.5).  Disclosure of Fragment after Redirects

   Although fragment identifiers used within URI references are not sent
   in requests, implementers ought to be aware that they will be visible
   to the user agent and any extensions or scripts running as a result
   of the response.  In particular, when a redirect occurs and the
   original request's fragment identifier is inherited by the new
   reference in Location ([Section 7.1.2](#section-7.1.2)), this might have the effect of
   disclosing one site's fragment to another site.  If the first site
   uses personal information in fragments, it ought to ensure that
   redirects to other sites include a (possibly empty) fragment
   component in order to block that inheritance.

[9.6](#section-9.6).  Disclosure of Product Information

   The User-Agent ([Section 5.5.3](#section-5.5.3)), Via ([Section 5.7.1 of [RFC7230]](/doc/html/rfc7230#section-5.7.1)), and
   Server ([Section 7.4.2](#section-7.4.2)) header fields often reveal information about
   the respective sender's software systems.  In theory, this can make
   it easier for an attacker to exploit known security holes; in
   practice, attackers tend to try all potential holes regardless of the
   apparent software versions being used.

   Proxies that serve as a portal through a network firewall ought to
   take special precautions regarding the transfer of header information
   that might identify hosts behind the firewall.  The Via header field
   allows intermediaries to replace sensitive machine names with
   pseudonyms.

[9.7](#section-9.7).  Browser Fingerprinting

   Browser fingerprinting is a set of techniques for identifying a
   specific user agent over time through its unique set of
   characteristics.  These characteristics might include information
   related to its TCP behavior, feature capabilities, and scripting
   environment, though of particular interest here is the set of unique
   characteristics that might be communicated via HTTP.  Fingerprinting
   is considered a privacy concern because it enables tracking of a user
   agent's behavior over time without the corresponding controls that
   the user might have over other forms of data collection (e.g.,
   cookies).  Many general-purpose user agents (i.e., Web browsers) have
   taken steps to reduce their fingerprints.

   There are a number of request header fields that might reveal
   information to servers that is sufficiently unique to enable
   fingerprinting.  The From header field is the most obvious, though it
   is expected that From will only be sent when self-identification is
   desired by the user.  Likewise, Cookie header fields are deliberately

Fielding & Reschke           Standards Track                   [Page 84]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   designed to enable re-identification, so fingerprinting concerns only
   apply to situations where cookies are disabled or restricted by the
   user agent's configuration.

   The User-Agent header field might contain enough information to
   uniquely identify a specific device, usually when combined with other
   characteristics, particularly if the user agent sends excessive
   details about the user's system or extensions.  However, the source
   of unique information that is least expected by users is proactive
   negotiation ([Section 5.3](#section-5.3)), including the Accept, Accept-Charset,
   Accept-Encoding, and Accept-Language header fields.

   In addition to the fingerprinting concern, detailed use of the
   Accept-Language header field can reveal information the user might
   consider to be of a private nature.  For example, understanding a
   given language set might be strongly correlated to membership in a
   particular ethnic group.  An approach that limits such loss of
   privacy would be for a user agent to omit the sending of
   Accept-Language except for sites that have been whitelisted, perhaps
   via interaction after detecting a Vary header field that indicates
   language negotiation might be useful.

   In environments where proxies are used to enhance privacy, user
   agents ought to be conservative in sending proactive negotiation
   header fields.  General-purpose user agents that provide a high
   degree of header field configurability ought to inform users about
   the loss of privacy that might result if too much detail is provided.
   As an extreme privacy measure, proxies could filter the proactive
   negotiation header fields in relayed requests.

[10](#section-10).  Acknowledgments

   See [Section 10 of [RFC7230]](/doc/html/rfc7230#section-10).

[11](#section-11).  References

[11.1](#section-11.1).  Normative References

   [RFC2045]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies", [RFC 2045](/doc/html/rfc2045), November 1996.

   [RFC2046]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types", [RFC 2046](/doc/html/rfc2046),
              November 1996.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", [BCP 14](/doc/html/bcp14), [RFC 2119](/doc/html/rfc2119), March 1997.

Fielding & Reschke           Standards Track                   [Page 85]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              [RFC 3986](/doc/html/rfc3986), January 2005.

   [RFC4647]  Phillips, A., Ed. and M. Davis, Ed., "Matching of Language
              Tags", [BCP 47](/doc/html/bcp47), [RFC 4647](/doc/html/rfc4647), September 2006.

   [RFC5234]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, [RFC 5234](/doc/html/rfc5234), January 2008.

   [RFC5646]  Phillips, A., Ed. and M. Davis, Ed., "Tags for Identifying
              Languages", [BCP 47](/doc/html/bcp47), [RFC 5646](/doc/html/rfc5646), September 2009.

   [RFC6365]  Hoffman, P. and J. Klensin, "Terminology Used in
              Internationalization in the IETF", [BCP 166](/doc/html/bcp166), [RFC 6365](/doc/html/rfc6365),
              September 2011.

   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              [RFC 7230](/doc/html/rfc7230), June 2014.

   [RFC7232]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests", [RFC 7232](/doc/html/rfc7232),
              June 2014.

   [RFC7233]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              "Hypertext Transfer Protocol (HTTP/1.1): Range Requests",
              [RFC 7233](/doc/html/rfc7233), June 2014.

   [RFC7234]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "Hypertext Transfer Protocol (HTTP/1.1): Caching",
              [RFC 7234](/doc/html/rfc7234), June 2014.

   [RFC7235]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Authentication", [RFC 7235](/doc/html/rfc7235), June 2014.

[11.2](#section-11.2).  Informative References

   [BCP13]    Freed, N., Klensin, J., and T. Hansen, "Media Type
              Specifications and Registration Procedures", [BCP 13](/doc/html/bcp13),
              [RFC 6838](/doc/html/rfc6838), January 2013.

   [BCP178]   Saint-Andre, P., Crocker, D., and M. Nottingham,
              "Deprecating the "X-" Prefix and Similar Constructs in
              Application Protocols", [BCP 178](/doc/html/bcp178), [RFC 6648](/doc/html/rfc6648), June 2012.

Fielding & Reschke           Standards Track                   [Page 86]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   [BCP90]    Klyne, G., Nottingham, M., and J. Mogul, "Registration
              Procedures for Message Header Fields", [BCP 90](/doc/html/bcp90), [RFC 3864](/doc/html/rfc3864),
              September 2004.

   [OWASP]    van der Stock, A., Ed., "A Guide to Building Secure Web
              Applications and Web Services", The Open Web Application
              Security Project (OWASP) 2.0.1, July 2005,
              <<https://www.owasp.org/>>.

   [REST]     Fielding, R., "Architectural Styles and the Design of
              Network-based Software Architectures",
              Doctoral Dissertation, University of California, Irvine,
              September 2000,
              <<http://roy.gbiv.com/pubs/dissertation/top.htm>>.

   [RFC1945]  Berners-Lee, T., Fielding, R., and H. Nielsen, "Hypertext
              Transfer Protocol -- HTTP/1.0", [RFC 1945](/doc/html/rfc1945), May 1996.

   [RFC2049]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
              Extensions (MIME) Part Five: Conformance Criteria and
              Examples", [RFC 2049](/doc/html/rfc2049), November 1996.

   [RFC2068]  Fielding, R., Gettys, J., Mogul, J., Nielsen, H., and T.
              Berners-Lee, "Hypertext Transfer Protocol -- HTTP/1.1",
              [RFC 2068](/doc/html/rfc2068), January 1997.

   [RFC2295]  Holtman, K. and A. Mutz, "Transparent Content Negotiation
              in HTTP", [RFC 2295](/doc/html/rfc2295), March 1998.

   [RFC2388]  Masinter, L., "Returning Values from Forms:  multipart/
              form-data", [RFC 2388](/doc/html/rfc2388), August 1998.

   [RFC2557]  Palme, F., Hopmann, A., Shelness, N., and E. Stefferud,
              "MIME Encapsulation of Aggregate Documents, such as HTML
              (MHTML)", [RFC 2557](/doc/html/rfc2557), March 1999.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", [RFC 2616](/doc/html/rfc2616), June 1999.

   [RFC2774]  Frystyk, H., Leach, P., and S. Lawrence, "An HTTP
              Extension Framework", [RFC 2774](/doc/html/rfc2774), February 2000.

   [RFC2817]  Khare, R. and S. Lawrence, "Upgrading to TLS Within
              HTTP/1.1", [RFC 2817](/doc/html/rfc2817), May 2000.

   [RFC2978]  Freed, N. and J. Postel, "IANA Charset Registration
              Procedures", [BCP 19](/doc/html/bcp19), [RFC 2978](/doc/html/rfc2978), October 2000.

Fielding & Reschke           Standards Track                   [Page 87]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", [BCP 26](/doc/html/bcp26), [RFC 5226](/doc/html/rfc5226),
              May 2008.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", [RFC 5246](/doc/html/rfc5246), August 2008.

   [RFC5322]  Resnick, P., "Internet Message Format", [RFC 5322](/doc/html/rfc5322),
              October 2008.

   [RFC5789]  Dusseault, L. and J. Snell, "PATCH Method for HTTP",
              [RFC 5789](/doc/html/rfc5789), March 2010.

   [RFC5905]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              "Network Time Protocol Version 4: Protocol and Algorithms
              Specification", [RFC 5905](/doc/html/rfc5905), June 2010.

   [RFC5987]  Reschke, J., "Character Set and Language Encoding for
              Hypertext Transfer Protocol (HTTP) Header Field
              Parameters", [RFC 5987](/doc/html/rfc5987), August 2010.

   [RFC5988]  Nottingham, M., "Web Linking", [RFC 5988](/doc/html/rfc5988), October 2010.

   [RFC6265]  Barth, A., "HTTP State Management Mechanism", [RFC 6265](/doc/html/rfc6265),
              April 2011.

   [RFC6266]  Reschke, J., "Use of the Content-Disposition Header Field
              in the Hypertext Transfer Protocol (HTTP)", [RFC 6266](/doc/html/rfc6266),
              June 2011.

   [RFC7238]  Reschke, J., "The Hypertext Transfer Protocol (HTTP)
              Status Code 308 (Permanent Redirect)", [RFC 7238](/doc/html/rfc7238),
              June 2014.

Fielding & Reschke           Standards Track                   [Page 88]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

[Appendix A](#appendix-A).  Differences between HTTP and MIME

   HTTP/1.1 uses many of the constructs defined for the Internet Message
   Format [[RFC5322](/doc/html/rfc5322 "\"Internet Message Format\"")] and the Multipurpose Internet Mail Extensions (MIME)
   [[RFC2045](/doc/html/rfc2045 "\"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\"")] to allow a message body to be transmitted in an open
   variety of representations and with extensible header fields.
   However, [RFC 2045](/doc/html/rfc2045) is focused only on email; applications of HTTP have
   many characteristics that differ from email; hence, HTTP has features
   that differ from MIME.  These differences were carefully chosen to
   optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from MIME.
   Proxies and gateways to and from strict MIME environments need to be
   aware of these differences and provide the appropriate conversions
   where necessary.

[A.1](#appendix-A.1).  MIME-Version

   HTTP is not a MIME-compliant protocol.  However, messages can include
   a single MIME-Version header field to indicate what version of the
   MIME protocol was used to construct the message.  Use of the
   MIME-Version header field indicates that the message is in full
   conformance with the MIME protocol (as defined in [[RFC2045](/doc/html/rfc2045 "\"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\"")]).
   Senders are responsible for ensuring full conformance (where
   possible) when exporting HTTP messages to strict MIME environments.

[A.2](#appendix-A.2).  Conversion to Canonical Form

   MIME requires that an Internet mail body part be converted to
   canonical form prior to being transferred, as described in [Section 4
   of [RFC2049]](/doc/html/rfc2049#section-4).  [Section 3.1.1.3](#section-3.1.1.3) of this document describes the forms
   allowed for subtypes of the "text" media type when transmitted over
   HTTP.  [[RFC2046](/doc/html/rfc2046 "\"Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types\"")] requires that content with a type of "text"
   represent line breaks as CRLF and forbids the use of CR or LF outside
   of line break sequences.  HTTP allows CRLF, bare CR, and bare LF to
   indicate a line break within text content.

   A proxy or gateway from HTTP to a strict MIME environment ought to
   translate all line breaks within the text media types described in
   [Section 3.1.1.3](#section-3.1.1.3) of this document to the [RFC 2049](/doc/html/rfc2049) canonical form of
   CRLF.  Note, however, this might be complicated by the presence of a
   Content-Encoding and by the fact that HTTP allows the use of some
   charsets that do not use octets 13 and 10 to represent CR and LF,
   respectively.

Fielding & Reschke           Standards Track                   [Page 89]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   Conversion will break any cryptographic checksums applied to the
   original content unless the original content is already in canonical
   form.  Therefore, the canonical form is recommended for any content
   that uses such checksums in HTTP.

[A.3](#appendix-A.3).  Conversion of Date Formats

   HTTP/1.1 uses a restricted set of date formats ([Section 7.1.1.1](#section-7.1.1.1)) to
   simplify the process of date comparison.  Proxies and gateways from
   other protocols ought to ensure that any Date header field present in
   a message conforms to one of the HTTP/1.1 formats and rewrite the
   date if necessary.

[A.4](#appendix-A.4).  Conversion of Content-Encoding

   MIME does not include any concept equivalent to HTTP/1.1's
   Content-Encoding header field.  Since this acts as a modifier on the
   media type, proxies and gateways from HTTP to MIME-compliant
   protocols ought to either change the value of the Content-Type header
   field or decode the representation before forwarding the message.
   (Some experimental applications of Content-Type for Internet mail
   have used a media-type parameter of ";conversions=<content-coding>"
   to perform a function equivalent to Content-Encoding.  However, this
   parameter is not part of the MIME standards).

[A.5](#appendix-A.5).  Conversion of Content-Transfer-Encoding

   HTTP does not use the Content-Transfer-Encoding field of MIME.
   Proxies and gateways from MIME-compliant protocols to HTTP need to
   remove any Content-Transfer-Encoding prior to delivering the response
   message to an HTTP client.

   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where "safe
   transport" is defined by the limitations of the protocol being used.
   Such a proxy or gateway ought to transform and label the data with an
   appropriate Content-Transfer-Encoding if doing so will improve the
   likelihood of safe transport over the destination protocol.

[A.6](#appendix-A.6).  MHTML and Line Length Limitations

   HTTP implementations that share code with MHTML [[RFC2557](/doc/html/rfc2557 "\"MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)\"")]
   implementations need to be aware of MIME line length limitations.
   Since HTTP does not have this limitation, HTTP does not fold long
   lines.  MHTML messages being transported by HTTP follow all
   conventions of MHTML, including line length limitations and folding,
   canonicalization, etc., since HTTP transfers message-bodies as

Fielding & Reschke           Standards Track                   [Page 90]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   payload and, aside from the "multipart/byteranges" type (Appendix A
   of [[RFC7233](/doc/html/rfc7233 "\"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\"")]), does not interpret the content or any MIME header
   lines that might be contained therein.

[Appendix B](#appendix-B).  Changes from [RFC 2616](/doc/html/rfc2616)

   The primary changes in this revision have been editorial in nature:
   extracting the messaging syntax and partitioning HTTP semantics into
   separate documents for the core features, conditional requests,
   partial requests, caching, and authentication.  The conformance
   language has been revised to clearly target requirements and the
   terminology has been improved to distinguish payload from
   representations and representations from resources.

   A new requirement has been added that semantics embedded in a URI be
   disabled when those semantics are inconsistent with the request
   method, since this is a common cause of interoperability failure.
   ([Section 2](#section-2))

   An algorithm has been added for determining if a payload is
   associated with a specific identifier.  ([Section 3.1.4.1](#section-3.1.4.1))

   The default charset of ISO-8859-1 for text media types has been
   removed; the default is now whatever the media type definition says.
   Likewise, special treatment of ISO-8859-1 has been removed from the
   Accept-Charset header field.  ([Section 3.1.1.3](#section-3.1.1.3) and [Section 5.3.3](#section-5.3.3))

   The definition of Content-Location has been changed to no longer
   affect the base URI for resolving relative URI references, due to
   poor implementation support and the undesirable effect of potentially
   breaking relative links in content-negotiated resources.
   ([Section 3.1.4.2](#section-3.1.4.2))

   To be consistent with the method-neutral parsing algorithm of
   [[RFC7230](/doc/html/rfc7230 "\"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\"")], the definition of GET has been relaxed so that requests
   can have a body, even though a body has no meaning for GET.
   ([Section 4.3.1](#section-4.3.1))

   Servers are no longer required to handle all Content-* header fields
   and use of Content-Range has been explicitly banned in PUT requests.
   ([Section 4.3.4](#section-4.3.4))

   Definition of the CONNECT method has been moved from [[RFC2817](/doc/html/rfc2817 "\"Upgrading to TLS Within HTTP/1.1\"")] to
   this specification.  ([Section 4.3.6](#section-4.3.6))

   The OPTIONS and TRACE request methods have been defined as being
   safe.  ([Section 4.3.7](#section-4.3.7) and [Section 4.3.8](#section-4.3.8))

Fielding & Reschke           Standards Track                   [Page 91]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   The Expect header field's extension mechanism has been removed due to
   widely-deployed broken implementations.  ([Section 5.1.1](#section-5.1.1))

   The Max-Forwards header field has been restricted to the OPTIONS and
   TRACE methods; previously, extension methods could have used it as
   well.  ([Section 5.1.2](#section-5.1.2))

   The "about:blank" URI has been suggested as a value for the Referer
   header field when no referring URI is applicable, which distinguishes
   that case from others where the Referer field is not sent or has been
   removed.  ([Section 5.5.2](#section-5.5.2))

   The following status codes are now cacheable (that is, they can be
   stored and reused by a cache without explicit freshness information
   present): 204, 404, 405, 414, 501.  ([Section 6](#section-6))

   The 201 (Created) status description has been changed to allow for
   the possibility that more than one resource has been created.
   ([Section 6.3.2](#section-6.3.2))

   The definition of 203 (Non-Authoritative Information) has been
   broadened to include cases of payload transformations as well.
   ([Section 6.3.4](#section-6.3.4))

   The set of request methods that are safe to automatically redirect is
   no longer closed; user agents are able to make that determination
   based upon the request method semantics.  The redirect status codes
   301, 302, and 307 no longer have normative requirements on response
   payloads and user interaction.  ([Section 6.4](#section-6.4))

   The status codes 301 and 302 have been changed to allow user agents
   to rewrite the method from POST to GET.  (Sections [6.4.2](#section-6.4.2) and [6.4.3](#section-6.4.3))

   The description of the 303 (See Other) status code has been changed
   to allow it to be cached if explicit freshness information is given,
   and a specific definition has been added for a 303 response to GET.
   ([Section 6.4.4](#section-6.4.4))

   The 305 (Use Proxy) status code has been deprecated due to security
   concerns regarding in-band configuration of a proxy.  ([Section 6.4.5](#section-6.4.5))

   The 400 (Bad Request) status code has been relaxed so that it isn't
   limited to syntax errors.  ([Section 6.5.1](#section-6.5.1))

   The 426 (Upgrade Required) status code has been incorporated from
   [[RFC2817](/doc/html/rfc2817 "\"Upgrading to TLS Within HTTP/1.1\"")].  ([Section 6.5.15](#section-6.5.15))

Fielding & Reschke           Standards Track                   [Page 92]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   The target of requirements on HTTP-date and the Date header field
   have been reduced to those systems generating the date, rather than
   all systems sending a date.  ([Section 7.1.1](#section-7.1.1))

   The syntax of the Location header field has been changed to allow all
   URI references, including relative references and fragments, along
   with some clarifications as to when use of fragments would not be
   appropriate.  ([Section 7.1.2](#section-7.1.2))

   Allow has been reclassified as a response header field, removing the
   option to specify it in a PUT request.  Requirements relating to the
   content of Allow have been relaxed; correspondingly, clients are not
   required to always trust its value.  ([Section 7.4.1](#section-7.4.1))

   A Method Registry has been defined.  ([Section 8.1](#section-8.1))

   The Status Code Registry has been redefined by this specification;
   previously, it was defined in [Section 7.1 of [RFC2817]](/doc/html/rfc2817#section-7.1).
   ([Section 8.2](#section-8.2))

   Registration of content codings has been changed to require IETF
   Review.  ([Section 8.4](#section-8.4))

   The Content-Disposition header field has been removed since it is now
   defined by [[RFC6266](/doc/html/rfc6266 "\"Use of the Content-Disposition Header Field in the Hypertext Transfer Protocol (HTTP)\"")].

   The Content-MD5 header field has been removed because it was
   inconsistently implemented with respect to partial responses.

[Appendix C](#appendix-C).  Imported ABNF

   The following core rules are included by reference, as defined in
   [Appendix B.1 of [RFC5234]](/doc/html/rfc5234#appendix-B.1): ALPHA (letters), CR (carriage return),
   CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double
   quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF
   (line feed), OCTET (any 8-bit sequence of data), SP (space), and
   VCHAR (any visible US-ASCII character).

   The rules below are defined in [[RFC7230](/doc/html/rfc7230 "\"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\"")]:

     BWS           = <BWS, see [[RFC7230], Section 3.2.3](/doc/html/rfc7230#section-3.2.3)>
     OWS           = <OWS, see [[RFC7230], Section 3.2.3](/doc/html/rfc7230#section-3.2.3)>
     RWS           = <RWS, see [[RFC7230], Section 3.2.3](/doc/html/rfc7230#section-3.2.3)>
     URI-reference = <URI-reference, see [[RFC7230], Section 2.7](/doc/html/rfc7230#section-2.7)>
     absolute-URI  = <absolute-URI, see [[RFC7230], Section 2.7](/doc/html/rfc7230#section-2.7)>
     comment       = <comment, see [[RFC7230], Section 3.2.6](/doc/html/rfc7230#section-3.2.6)>
     field-name    = <comment, see [[RFC7230], Section 3.2](/doc/html/rfc7230#section-3.2)>
     partial-URI   = <partial-URI, see [[RFC7230], Section 2.7](/doc/html/rfc7230#section-2.7)>

Fielding & Reschke           Standards Track                   [Page 93]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

     quoted-string = <quoted-string, see [[RFC7230], Section 3.2.6](/doc/html/rfc7230#section-3.2.6)>
     token         = <token, see [[RFC7230], Section 3.2.6](/doc/html/rfc7230#section-3.2.6)>

[Appendix D](#appendix-D).  Collected ABNF

   In the collected ABNF below, list rules are expanded as per [Section](/doc/html/rfc7230#section-1.2)
   [1.2 of [RFC7230]](/doc/html/rfc7230#section-1.2).

   Accept = [ ( "," / ( media-range [ accept-params ] ) ) *( OWS "," [
    OWS ( media-range [ accept-params ] ) ] ) ]
   Accept-Charset = *( "," OWS ) ( ( charset / "*" ) [ weight ] ) *( OWS
    "," [ OWS ( ( charset / "*" ) [ weight ] ) ] )
   Accept-Encoding = [ ( "," / ( codings [ weight ] ) ) *( OWS "," [ OWS
    ( codings [ weight ] ) ] ) ]
   Accept-Language = *( "," OWS ) ( language-range [ weight ] ) *( OWS
    "," [ OWS ( language-range [ weight ] ) ] )
   Allow = [ ( "," / method ) *( OWS "," [ OWS method ] ) ]

   BWS = <BWS, see [[RFC7230], Section 3.2.3](/doc/html/rfc7230#section-3.2.3)>

   Content-Encoding = *( "," OWS ) content-coding *( OWS "," [ OWS
    content-coding ] )
   Content-Language = *( "," OWS ) language-tag *( OWS "," [ OWS
    language-tag ] )
   Content-Location = absolute-URI / partial-URI
   Content-Type = media-type

   Date = HTTP-date

   Expect = "100-continue"

   From = mailbox

   GMT = %x47.4D.54 ; GMT

   HTTP-date = IMF-fixdate / obs-date

   IMF-fixdate = day-name "," SP date1 SP time-of-day SP GMT

   Location = URI-reference

   Max-Forwards = 1*DIGIT

   OWS = <OWS, see [[RFC7230], Section 3.2.3](/doc/html/rfc7230#section-3.2.3)>

   RWS = <RWS, see [[RFC7230], Section 3.2.3](/doc/html/rfc7230#section-3.2.3)>
   Referer = absolute-URI / partial-URI
   Retry-After = HTTP-date / delay-seconds

Fielding & Reschke           Standards Track                   [Page 94]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   Server = product *( RWS ( product / comment ) )

   URI-reference = <URI-reference, see [[RFC7230], Section 2.7](/doc/html/rfc7230#section-2.7)>
   User-Agent = product *( RWS ( product / comment ) )

   Vary = "*" / ( *( "," OWS ) field-name *( OWS "," [ OWS field-name ]
    ) )

   absolute-URI = <absolute-URI, see [[RFC7230], Section 2.7](/doc/html/rfc7230#section-2.7)>
   accept-ext = OWS ";" OWS token [ "=" ( token / quoted-string ) ]
   accept-params = weight *accept-ext
   asctime-date = day-name SP date3 SP time-of-day SP year

   charset = token
   codings = content-coding / "identity" / "*"
   comment = <comment, see [[RFC7230], Section 3.2.6](/doc/html/rfc7230#section-3.2.6)>
   content-coding = token

   date1 = day SP month SP year
   date2 = day "-" month "-" 2DIGIT
   date3 = month SP ( 2DIGIT / ( SP DIGIT ) )
   day = 2DIGIT
   day-name = %x4D.6F.6E ; Mon
    / %x54.75.65 ; Tue
    / %x57.65.64 ; Wed
    / %x54.68.75 ; Thu
    / %x46.72.69 ; Fri
    / %x53.61.74 ; Sat
    / %x53.75.6E ; Sun
   day-name-l = %x4D.6F.6E.64.61.79 ; Monday
    / %x54.75.65.73.64.61.79 ; Tuesday
    / %x57.65.64.6E.65.73.64.61.79 ; Wednesday
    / %x54.68.75.72.73.64.61.79 ; Thursday
    / %x46.72.69.64.61.79 ; Friday
    / %x53.61.74.75.72.64.61.79 ; Saturday
    / %x53.75.6E.64.61.79 ; Sunday
   delay-seconds = 1*DIGIT

   field-name = <comment, see [[RFC7230], Section 3.2](/doc/html/rfc7230#section-3.2)>

   hour = 2DIGIT

   language-range = <language-range, see [[RFC4647], Section 2.1](/doc/html/rfc4647#section-2.1)>
   language-tag = <Language-Tag, see [[RFC5646], Section 2.1](/doc/html/rfc5646#section-2.1)>

   mailbox = <mailbox, see [[RFC5322], Section 3.4](/doc/html/rfc5322#section-3.4)>
   media-range = ( "*/*" / ( type "/*" ) / ( type "/" subtype ) ) *( OWS
    ";" OWS parameter )

Fielding & Reschke           Standards Track                   [Page 95]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   media-type = type "/" subtype *( OWS ";" OWS parameter )
   method = token
   minute = 2DIGIT
   month = %x4A.61.6E ; Jan
    / %x46.65.62 ; Feb
    / %x4D.61.72 ; Mar
    / %x41.70.72 ; Apr
    / %x4D.61.79 ; May
    / %x4A.75.6E ; Jun
    / %x4A.75.6C ; Jul
    / %x41.75.67 ; Aug
    / %x53.65.70 ; Sep
    / %x4F.63.74 ; Oct
    / %x4E.6F.76 ; Nov
    / %x44.65.63 ; Dec

   obs-date = [rfc850](/doc/html/rfc850)-date / asctime-date

   parameter = token "=" ( token / quoted-string )
   partial-URI = <partial-URI, see [[RFC7230], Section 2.7](/doc/html/rfc7230#section-2.7)>
   product = token [ "/" product-version ]
   product-version = token
   quoted-string = <quoted-string, see [[RFC7230], Section 3.2.6](/doc/html/rfc7230#section-3.2.6)>
   qvalue = ( "0" [ "." *3DIGIT ] ) / ( "1" [ "." *3"0" ] )

   [rfc850](/doc/html/rfc850)-date = day-name-l "," SP date2 SP time-of-day SP GMT

   second = 2DIGIT
   subtype = token

   time-of-day = hour ":" minute ":" second
   token = <token, see [[RFC7230], Section 3.2.6](/doc/html/rfc7230#section-3.2.6)>
   type = token

   weight = OWS ";" OWS "q=" qvalue

   year = 4DIGIT

Fielding & Reschke           Standards Track                   [Page 96]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

Index

   1
      1xx Informational (status code class)  50

   2
      2xx Successful (status code class)  51

   3
      3xx Redirection (status code class)  54

   4
      4xx Client Error (status code class)  58

   5
      5xx Server Error (status code class)  62

   1
      100 Continue (status code)  50
      100-continue (expect value)  34
      101 Switching Protocols (status code)  50

   2
      200 OK (status code)  51
      201 Created (status code)  52
      202 Accepted (status code)  52
      203 Non-Authoritative Information (status code)  52
      204 No Content (status code)  53
      205 Reset Content (status code)  53

   3
      300 Multiple Choices (status code)  55
      301 Moved Permanently (status code)  56
      302 Found (status code)  56
      303 See Other (status code)  57
      305 Use Proxy (status code)  58
      306 (Unused) (status code)  58
      307 Temporary Redirect (status code)  58

   4
      400 Bad Request (status code)  58
      402 Payment Required (status code)  59
      403 Forbidden (status code)  59
      404 Not Found (status code)  59
      405 Method Not Allowed (status code)  59
      406 Not Acceptable (status code)  59
      408 Request Timeout (status code)  60
      409 Conflict (status code)  60

Fielding & Reschke           Standards Track                   [Page 97]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

      410 Gone (status code)  60
      411 Length Required (status code)  61
      413 Payload Too Large (status code)  61
      414 URI Too Long (status code)  61
      415 Unsupported Media Type (status code)  62
      417 Expectation Failed (status code)  62
      426 Upgrade Required (status code)  62

   5
      500 Internal Server Error (status code)  63
      501 Not Implemented (status code)  63
      502 Bad Gateway (status code)  63
      503 Service Unavailable (status code)  63
      504 Gateway Timeout (status code)  63
      505 HTTP Version Not Supported (status code)  64

   A
      Accept header field  38
      Accept-Charset header field  40
      Accept-Encoding header field  41
      Accept-Language header field  42
      Allow header field  72

   C
      cacheable  24
      compress (content coding)  11
      conditional request  36
      CONNECT method  30
      content coding  11
      content negotiation  6
      Content-Encoding header field  12
      Content-Language header field  13
      Content-Location header field  15
      Content-Transfer-Encoding header field  89
      Content-Type header field  10

   D
      Date header field  67
      deflate (content coding)  11
      DELETE method  29

   E
      Expect header field  34

   F
      From header field  44

Fielding & Reschke           Standards Track                   [Page 98]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   G
      GET method  24
      Grammar
         Accept  38
         Accept-Charset  40
         Accept-Encoding  41
         accept-ext  38
         Accept-Language  42
         accept-params  38
         Allow  72
         asctime-date  66
         charset  9
         codings  41
         content-coding  11
         Content-Encoding  12
         Content-Language  13
         Content-Location  15
         Content-Type  10
         Date  67
         date1  65
         day  65
         day-name  65
         day-name-l  65
         delay-seconds  69
         Expect  34
         From  44
         GMT  65
         hour  65
         HTTP-date  65
         IMF-fixdate  65
         language-range  42
         language-tag  13
         Location  68
         Max-Forwards  36
         media-range  38
         media-type  8
         method  21
         minute  65
         month  65
         obs-date  66
         parameter  8
         product  46
         product-version  46
         qvalue  38
         Referer  45
         Retry-After  69
         [rfc850](/doc/html/rfc850)-date  66
         second  65

Fielding & Reschke           Standards Track                   [Page 99]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

         Server  73
         subtype  8
         time-of-day  65
         type  8
         User-Agent  46
         Vary  70
         weight  38
         year  65
      gzip (content coding)  11

   H
      HEAD method  25

   I
      idempotent  23

   L
      Location header field  68

   M
      Max-Forwards header field  36
      MIME-Version header field  89

   O
      OPTIONS method  31

   P
      payload  17
      POST method  25
      PUT method  26

   R
      Referer header field  45
      representation  7
      Retry-After header field  69

   S
      safe  22
      selected representation  7, 71
      Server header field  73
      Status Codes Classes
         1xx Informational  50
         2xx Successful  51
         3xx Redirection  54
         4xx Client Error  58
         5xx Server Error  62

Fielding & Reschke           Standards Track                  [Page 100]
```

---

```

[RFC 7231](/doc/html/rfc7231)             HTTP/1.1 Semantics and Content            June 2014

   T
      TRACE method  32

   U
      User-Agent header field  46

   V
      Vary header field  70

   X
      x-compress (content coding)  11
      x-gzip (content coding)  11

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   <http://roy.gbiv.com/>

   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   <http://greenbytes.de/tech/webdav/>

Fielding & Reschke           Standards Track                  [Page 101]

```

[Datatracker](/doc/rfc7231/)

RFC 7231

RFC
- Proposed Standard

* Info
* Contents
* Prefs

| Document | Document type |  | RFC - Proposed Standard  June 2014  [View errata](https://www.rfc-editor.org/errata_search.php?rfc=7231 "Click to view errata.") [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") Obsoleted by [RFC 9110](/doc/html/rfc9110 "HTTP Semantics") Obsoletes [RFC 2616](/doc/html/rfc2616 "Hypertext Transfer Protocol -- HTTP/1.1") Updates [RFC 2817](/doc/html/rfc2817 "Upgrading to TLS Within HTTP/1.1") Was [draft-ietf-httpbis-p2-semantics](/doc/draft-ietf-httpbis-p2-semantics/26/) ([httpbis WG](/wg/httpbis/about/)) |
| --- | --- | --- | --- |
|  | Select version |  | * [18](/doc/html/draft-ietf-httpbis-p2-semantics-18) * [19](/doc/html/draft-ietf-httpbis-p2-semantics-19) * [20](/doc/html/draft-ietf-httpbis-p2-semantics-20) * [21](/doc/html/draft-ietf-httpbis-p2-semantics-21) * [22](/doc/html/draft-ietf-httpbis-p2-semantics-22) * [23](/doc/html/draft-ietf-httpbis-p2-semantics-23) * [24](/doc/html/draft-ietf-httpbis-p2-semantics-24) * [25](/doc/html/draft-ietf-httpbis-p2-semantics-25) * [26](/doc/html/draft-ietf-httpbis-p2-semantics-26) * [RFC 7231](/doc/html/rfc7231) |
|  | Compare versions |  | RFC 7231  draft-ietf-httpbis-p2-semantics-26  draft-ietf-httpbis-p2-semantics-25  draft-ietf-httpbis-p2-semantics-24  draft-ietf-httpbis-p2-semantics-23  draft-ietf-httpbis-p2-semantics-22  draft-ietf-httpbis-p2-semantics-21  draft-ietf-httpbis-p2-semantics-20  draft-ietf-httpbis-p2-semantics-19  draft-ietf-httpbis-p2-semantics-18  draft-ietf-httpbis-p2-semantics-17  draft-ietf-httpbis-p2-semantics-16  draft-ietf-httpbis-p2-semantics-15  draft-ietf-httpbis-p2-semantics-14  draft-ietf-httpbis-p2-semantics-13  draft-ietf-httpbis-p2-semantics-12  draft-ietf-httpbis-p2-semantics-11  draft-ietf-httpbis-p2-semantics-10  draft-ietf-httpbis-p2-semantics-09  draft-ietf-httpbis-p2-semantics-08  draft-ietf-httpbis-p2-semantics-07  draft-ietf-httpbis-p2-semantics-06  draft-ietf-httpbis-p2-semantics-05  draft-ietf-httpbis-p2-semantics-04  draft-ietf-httpbis-p2-semantics-03  draft-ietf-httpbis-p2-semantics-02  draft-ietf-httpbis-p2-semantics-01  draft-ietf-httpbis-p2-semantics-00   RFC 7231  draft-ietf-httpbis-p2-semantics-26  draft-ietf-httpbis-p2-semantics-25  draft-ietf-httpbis-p2-semantics-24  draft-ietf-httpbis-p2-semantics-23  draft-ietf-httpbis-p2-semantics-22  draft-ietf-httpbis-p2-semantics-21  draft-ietf-httpbis-p2-semantics-20  draft-ietf-httpbis-p2-semantics-19  draft-ietf-httpbis-p2-semantics-18  draft-ietf-httpbis-p2-semantics-17  draft-ietf-httpbis-p2-semantics-16  draft-ietf-httpbis-p2-semantics-15  draft-ietf-httpbis-p2-semantics-14  draft-ietf-httpbis-p2-semantics-13  draft-ietf-httpbis-p2-semantics-12  draft-ietf-httpbis-p2-semantics-11  draft-ietf-httpbis-p2-semantics-10  draft-ietf-httpbis-p2-semantics-09  draft-ietf-httpbis-p2-semantics-08  draft-ietf-httpbis-p2-semantics-07  draft-ietf-httpbis-p2-semantics-06  draft-ietf-httpbis-p2-semantics-05  draft-ietf-httpbis-p2-semantics-04  draft-ietf-httpbis-p2-semantics-03  draft-ietf-httpbis-p2-semantics-02  draft-ietf-httpbis-p2-semantics-01  draft-ietf-httpbis-p2-semantics-00   Side-by-side  Inline |
|  | Authors |  | [Roy T. Fielding](/person/fielding%40gbiv.com "Datatracker profile of Roy T. Fielding") , [Julian Reschke](/person/julian.reschke%40gmx.de "Datatracker profile of Julian Reschke")   Email authors |
|  | RFC stream |  | IETF Logo IETF Logo |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc7231.txt) [html](https://www.rfc-editor.org/rfc/rfc7231.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc7231.txt.pdf) [w/errata](https://www.rfc-editor.org/rfc/inline-errata/rfc7231.html) [bibtex](/doc/rfc7231/bibtex/) |
|  | Additional resources |  | [Mailing list discussion](http://lists.w3.org/Archives/Public/ietf-http-wg/) |

[Report a datatracker bug](https://github.com/ietf-tools/datatracker/issues/new/choose)

Show sidebar by default

Yes

No

Tab to show by default

Info

Contents

HTMLization configuration

HTMLize the plaintext

Plaintextify the HTML

Maximum font size

Page dependencies

Inline

Reference

Citation links

 Go to reference section

Go to linked document

![](//analytics.ietf.org/piwik.php?idsite=7)



=== Content from medium.com_40d1289c_20250121_031612.html ===
[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2F6ddd0aed2ddf&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&source=---top_nav_layout_nav----------------------------------)

Sign up

[Sign in](/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2Fcoreshield%2Frouter-exploiting-6ddd0aed2ddf&source=post_page---top_nav_layout_nav-----------------------global_nav-----------)

[Write](/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---top_nav_layout_nav-----------------------new_post_topnav-----------)

Sign up

[Sign in](/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2Fcoreshield%2Frouter-exploiting-6ddd0aed2ddf&source=post_page---top_nav_layout_nav-----------------------global_nav-----------)

![](https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png)
# Router Exploiting

[![Filipi Pires](https://miro.medium.com/v2/resize:fill:88:88/1*f988jsRYWvTYjvLPkpj0Bw.png)](/%40filipi86?source=post_page---byline--6ddd0aed2ddf--------------------------------)[![CoreShield](https://miro.medium.com/v2/resize:fill:48:48/1*RUGYLK6N1LTlJr7WIQvFow.png)](https://medium.com/coreshield?source=post_page---byline--6ddd0aed2ddf--------------------------------)

[Filipi Pires](/%40filipi86?source=post_page---byline--6ddd0aed2ddf--------------------------------)

·

[Follow](/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2F7c5ea898d3fc&operation=register&redirect=https%3A%2F%2Fmedium.com%2Fcoreshield%2Frouter-exploiting-6ddd0aed2ddf&user=Filipi+Pires&userId=7c5ea898d3fc&source=post_page-7c5ea898d3fc--byline--6ddd0aed2ddf---------------------post_header-----------)

Published in[CoreShield](https://medium.com/coreshield?source=post_page---byline--6ddd0aed2ddf--------------------------------)·6 min read·Apr 4, 2020

--

Listen

Share

# Exploiting **Connect Box EuroDOCSIS 3.0**

# **Abstract**

*Nowadays, routers are an integral part of today’s home and small office networks. Usually, these kind of devices are implemented in many places with default configuration and are, typically, managed by people who do not have any special technical knowledge. Often poorly configured and vulnerable, such devices are an easy target for network-based attacks, allowing cyber-criminals to quickly and easily gain control over a network. I bet you heard the latest news about the “Infected 500,000 Devices That Could Cut Users Off From The Internet”. Over Half a Million Routers Infected by Destructive VPNFilter Malware. In this article we explain how to get admin credentials the in Connect Box DOCSIS 3.0 Voice Gateway router it was possible sniffing the HTTP traffic packets, within the same tested network, and perform some tests it is possible discover a vulnerability in the authentication process known as Cleartext Transmission of Sensitive Information. This router that has been tested is in Poland by the internet service provider UPC. This company provides services in many EU countries. This flaw it is register in through CVE — CVE-2019–19967 (https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19967) and according* ***National Vulnerability Database-NVD*** *this vulnerability has been signed by basescore : 7.5 high (https://nvd.nist.gov/vuln/detail/CVE-2019-19967).*

*Keywords: Router Exploitation, Security, CyberSecurity.*

# Connect Box — UPC Router

The Connect Box is the worldwide most compact EuroDOCSIS 3.0 Voice Gateway which provides the ideal all-in-one wired and wireless solution, designed for your home, home office, or small business/enterprise. It can be used in households with one or more computers capable of wireless connectivity for remote access to the wireless gateway.

![]()

Source: google images

The purpose of this exploration is to validate the security applied to the standard implementation of the router, as well as to guarantee the application of the main security models, whether in a home user or in a corporate environment.

We performed this proof of concept to get obtain the administrator credentials of the Connect Box DOCSIS 3.0 Voice Gateway router, it was possible to successfully perform, when sniffing the HTTP traffic packets, within the same tested network, when we perform some tests we discover a vulnerability in this router in the Authentication process known as **Cleartext Transmission of Sensitive Information.**

After discovering this flaw, we communicated the manufacturer about it, which put us in contact with the development team to assist in the improvement process, we also registered this failure through CVE — CVE-2019–19967 (https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19967)

This router that has been tested is in Poland by the internet service provider UPC. This company provides services in many EU countries.

# Understanding Authentication Process

The first step in this kind of exploration is to understand how the application handles with the authentication process, as well as, the responses that are “*printed*” on the authentication page.

![]()

Figure 1: created by owner (2020)

When put this information in the application (tried “*admin*” access), we received the error return, as you can see in figure 1, but the text in the box, doesn’t in password for, after that, as you can see in the in figure 2, about the input form it is with *type* as “text”.

![]()

Figure 2: created by owner (2020)

In this case, a recommendation it is use in the input form to this authentication input **type=password**, as you can see in the figure 3. However, this would be just a visual protection, we still can’t know how the password treatment is done, when and how authentication is performed, for that we need to use some network sniffer to check how this request and return authentication works in the network communication.

![]()

Figure 3: created by owner (2020)

# **Looking Network Communication**

I have been used the attacker machine with the **IP Address: 192.168.0.45** to run the **Wireshark** and received all traffic the network, after that I’ve used victim machine — **Victim 1–192.168.0.80**

![]()

Figure 5: **Victim Machine**
 created by owner (2020)

![]()

Figure 5: **Attacker Machine**
 created by owner (2020)

# **Wireshark Analysis.**

We tried to access with the password “*admin*”, however we receive the “login incorrect” information printed in the web page, so we went to see how Wireshark received this Authentication, my intention here, it was to discovery, what kind of encryption for authentication the application have used, but for my surprise, as you can see in the figure 6, the authentication not use none encrypt process the password is pass in the network in clear text, in this case we can to think about vulnerability known by MITRE as **Cleartext Transmission of Sensitive Information** ([http://cwe.mitre.org/data/definitions/319.html)](http://cwe.mitre.org/data/definitions/319.html%29.)

![]()

Figure 6: created by owner (2020)

So now, we just need to receive a valid authentication, when you try to connect with your correct password, just be happy, because the Admin Authentication, it will be in ClearText, for anyone that is receiving network traffic in the same network.

![]()

Figure 7: created by owner (2020)

Another important poins is, If an attacker has access on this pcap file in other machine, as you can see in windows machine below (figure 8), when this attacker opens in the Wireshark and he starts to analyze this file, we can see the same behavior in authentication process in clear text without simple protection.

![]()

Figure 8: created by owner (2020)

# **Conclusion**

As we can see in this article, a simple cryptographic flaw in the process of web page authentication, can greatly compromise the security of a home user when a company that use this router, this vulnerability it is known as the software transmits sensitive or security-critical data in cleartext in a communication channel that can be sniffed by unauthorized actor and it was signed as CVE-2019–19967 (https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19967)

You can configure a web application with some type of hidden, encoded, protection, or then some authentication with encryption, or based on some token, so there are many ways to increase the security level of your router.

So, I recommend reading some RFC — HTTP Hypertext Transfer Protocol, to understand the operation, as well as ways of protection.

# Publications

[## PenTest: Build Your Own Pentest Lab in 2020

### Dear PenTest Readers, We are extremely happy to present you the first 2020 edition of PenTest Mag! The main focus of…

pentestmag.com](https://pentestmag.com/product/pentest-build-your-own-pentest-lab-in-2020/?source=post_page-----6ddd0aed2ddf--------------------------------)[## The Cyber Security Hub™ posted on LinkedIn

### Research paper: Exploiting Connect Box - via Filipi Pires...

www.linkedin.com](https://www.linkedin.com/feed/update/urn%3Ali%3Aactivity%3A6633366352042307585/?source=post_page-----6ddd0aed2ddf--------------------------------)[## filipi86/ConnectBoxDOCSIS-3.0

### The Connect Box is the worldwide most compact EuroDOCSIS 3.0 Voice Gateway which provides the ideal all-in-one wired…

github.com](https://github.com/filipi86/ConnectBoxDOCSIS-3.0?source=post_page-----6ddd0aed2ddf--------------------------------)
# **References**

<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19967> — Access at 16/01/2020
<https://nvd.nist.gov/vuln/detail/CVE-2019-19967> — Access at 27/08/2020
<https://github.com/filipi86/ConnectBoxDOCSIS-3.0> — Access at 16/01/2020
RFC 2660 — <https://tools.ietf.org/html/rfc2660> — Access at 16/01/2020
RFC 7231 — <https://tools.ietf.org/html/rfc7231> — Access at 16/01/2020
RFC 2818 — <https://tools.ietf.org/html/rfc2818> — Access at 16/01/2020
RFC 2612 — <https://tools.ietf.org/html/rfc2616> — Access at 16/01/2020
<http://cwe.mitre.org/data/definitions/319.html> — Acess at 27/01/2020
Official Document form UPC — <https://www.upc.ch/pdf/support/manuals/en/internet/ConnectBox/connect-box-manual.pdf> — Access at 16/01/2020

[Router Exploitation](/tag/router-exploitation?source=post_page-----6ddd0aed2ddf--------------------------------)[Security](/tag/security?source=post_page-----6ddd0aed2ddf--------------------------------)[Cybersecurity](/tag/cybersecurity?source=post_page-----6ddd0aed2ddf--------------------------------)[Hacking](/tag/hacking?source=post_page-----6ddd0aed2ddf--------------------------------)[Vulnerability](/tag/vulnerability?source=post_page-----6ddd0aed2ddf--------------------------------)

--

--

[![CoreShield](https://miro.medium.com/v2/resize:fill:96:96/1*RUGYLK6N1LTlJr7WIQvFow.png)](https://medium.com/coreshield?source=post_page---post_publication_info--6ddd0aed2ddf--------------------------------)[![CoreShield](https://miro.medium.com/v2/resize:fill:128:128/1*RUGYLK6N1LTlJr7WIQvFow.png)](https://medium.com/coreshield?source=post_page---post_publication_info--6ddd0aed2ddf--------------------------------)[## Published in CoreShield](https://medium.com/coreshield?source=post_page---post_publication_info--6ddd0aed2ddf--------------------------------)[40 Followers](/coreshield/followers?source=post_page---post_publication_info--6ddd0aed2ddf--------------------------------)·[Last published Dec 10, 2020](/coreshield/fireeye-hacked-b710f716b5ec?source=post_page---post_publication_info--6ddd0aed2ddf--------------------------------)

We work at ZUP IT and research new technologies and new ways to make Information Security an Cool Experience

[![Filipi Pires](https://miro.medium.com/v2/resize:fill:96:96/1*f988jsRYWvTYjvLPkpj0Bw.png)](/%40filipi86?source=post_page---post_author_info--6ddd0aed2ddf--------------------------------)[![Filipi Pires](https://miro.medium.com/v2/resize:fill:128:128/1*f988jsRYWvTYjvLPkpj0Bw.png)](/%40filipi86?source=post_page---post_author_info--6ddd0aed2ddf--------------------------------)Follow[## Written by Filipi Pires](/%40filipi86?source=post_page---post_author_info--6ddd0aed2ddf--------------------------------)[40 Followers](/%40filipi86/followers?source=post_page---post_author_info--6ddd0aed2ddf--------------------------------)·[19 Following](/%40filipi86/following?source=post_page---post_author_info--6ddd0aed2ddf--------------------------------)

Global Threat Researcher and CyberSecurity Advocate, Speaker at events in many countries such as US, Canada, France, Spain, Germany, Poland, and others

Follow
## No responses yet

[Help](https://help.medium.com/hc/en-us?source=post_page-----6ddd0aed2ddf--------------------------------)[Status](https://medium.statuspage.io/?source=post_page-----6ddd0aed2ddf--------------------------------)[About](/about?autoplay=1&source=post_page-----6ddd0aed2ddf--------------------------------)[Careers](/jobs-at-medium/work-at-medium-959d1a85284e?source=post_page-----6ddd0aed2ddf--------------------------------)[Press](pressinquiries%40medium.com?source=post_page-----6ddd0aed2ddf--------------------------------)[Blog](https://blog.medium.com/?source=post_page-----6ddd0aed2ddf--------------------------------)[Privacy](https://policy.medium.com/medium-privacy-policy-f03bf92035c9?source=post_page-----6ddd0aed2ddf--------------------------------)[Terms](https://policy.medium.com/medium-terms-of-service-9db0094a1e0f?source=post_page-----6ddd0aed2ddf--------------------------------)[Text to speech](https://speechify.com/medium?source=post_page-----6ddd0aed2ddf--------------------------------)[Teams](/business?source=post_page-----6ddd0aed2ddf--------------------------------)



=== Content from tools.ietf.org_b15db3ea_20250121_031614.html ===


* Light
* Dark
* Auto

[RFC 7

Unknown](/doc/rfc7/)

|  | Title |  | Host-IMP interface |
| --- | --- | --- | --- |
| Document | Document type |  | RFC - Unknown  May 1969  [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") This RFC was published on the Legacy stream. This RFC is **not endorsed by the IETF** and has **no formal standing** in the [IETF standards process](/doc/rfc2026/). |
| --- | --- | --- | --- |
|  | Select version |  | * [RFC 7](/doc/html/rfc7) |
|  | Authors |  | Email authors |
|  | RFC stream |  | Legacy |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc7.txt) [html](https://www.rfc-editor.org/rfc/rfc7.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc7.txt.pdf) [bibtex](/doc/rfc7/bibtex/) |
|  |  |  | [Report a bug](https://github.com/ietf-tools/datatracker/issues/new/choose) |

```
Network Working Group                                         G. Deloche
Request for Comment: 7           University of California at Los Angeles
NIC: 4693                                                       May 1969

                           Host-Imp Interface

      G. Deloche      -->  Prof. J. Estrin
                           Prof. L. Kleinrock
                           Prof. B Bussel
                           D. Mandell
                           S. Crocker
                           L. Bonamy

   Object: Arpa Network - Specification Outlines for Host-IMP (HI)
   Interface Programs.

                                  Outline

   I.  Introduction

   II.  Scope of the software organization.
           II-1    Network program
           II-2    Handler program

   III.  Questions

   [The original of [RFC 7](/doc/html/rfc7) was hand-written, and only partially illegible
   copies exist.  [RFC 7](/doc/html/rfc7) was later typed int NLS by the Augmentation
   Research Center (ARC) at SRI.  The following is the best
   reconstruction we could do.  RFC Editor.]

Deloche                                                         [Page 1]
```

---

```

[RFC 7](/doc/html/rfc7)                      Host-IMP Interface                   May 1969

[I](#appendix-I).  Introduction

   This paper is concerned with the preliminary software design of the
   Host IMP interface.  Its main purpose is on the one hand to define
   functions that will be implemented, and on the other hand to provide
   a base for discussions and ...(unreadable).

   This study is based upon a study of the BBN Report No. 763.

II.  Scope of the software organization.

   The system is based upon two main programs: the Handler program that
   drives the channel hardware unit, and the Network program which
   carries out the user's transmission requests.

   As the communication is full duplex, each of these programs can be
   viewed as divided into two parts: one is concerned with the output
   data, the other with the input. (See Fig. 1)

   These two programs exchange data through a pool of buffers, and
   logical information through an interface table.

   In the following we only focus on the output part of each program
   (See Fig. 2).  The input part would be very similar.

II-1.   Network program.

II-1-1. Multiplex function.

   This program multiplexes the outgoing messages (and distributes the
   incoming messages).  The multiplexing consists in stacking up all the
   user's (or caller, or party) requests and filling up the pool of
   buffers so as to keep the handler busy emitting.

   Multiplexing (and distribution) is based on the link identification
   numbers.  (Link = logical connection between two users).  The
   multiplexing problem is closely related to the interface between a
   user's program and the network program, that is in
   fact...(unreadable) operating system (See below: Questions).

II-1-2.  Output message processing.

   When a user's program wants to send out text it should indicate the
   following information (through a macro, or as call parameters): text
   location, text length in bytes, and destination.

Deloche                                                         [Page 2]
```

---

```

[RFC 7](/doc/html/rfc7)                      Host-IMP Interface                   May 1969

   Using these data the Network program:

      *  prepares a 16 bit Host heading (1 bit: trace, 2 bits: spares, 8
         bits: link identification no., 5 bits: destination host)

      *  inserts a 16 bits marking between the header and the text so as
         to start the text at a word boundary.  This marking consists of
         a one preceding the first bit of the text and, in turn,
         preceded by fifteen zeros to fill up the gap.

      *  checks the length of the user's text - if it exceeds 1006 bytes

          +-                                                     -+
          |8080 (max host message length) - 32 (heading + marking)|
          |-------------------------------------------------------|
          |                8 (byte = 8 bits)                      |
          +-                                                     -+

   the program breaks down the text into a sequence of messages whose
   maximum length is 1006 bytes - Each of these messages is preceded by
   a heading as explained above.

   Remark: in that case one of the heading space bits could be used for
   indicating that several messages belong to the same text.

      *  _transcodes_ the EBCDIC characters constituting the messages
         into ASCII characters.

      *  _fills_ the buffers of the pool with the content of the
         messages.

      *  _updates_ the content of the interface table and moves the
         filling pointers (see below).

II-2.  Handler program.

   This program is initiated either by the network program, or by the
   I/O interrupt.

   This program will be very short.  It will be coded in master mode
   (privileged instructions) and should be integrated in the I/O
   supervisor of the operating system.

Deloche                                                         [Page 3]
```

---

```

[RFC 7](/doc/html/rfc7)                      Host-IMP Interface                   May 1969

   This program:

      *  _controls_ the channel hardware unit.  It initiates the
         emission, eventually provides data chaining between the
         buffers, tests the different device status upon receiving an
         interrupt.

      *  _empties_ the buffers that are filled up by the network
         program.

      *  _explores_ and _updates_ the interface table (see below).

      *  can eventually insure a control transmission procedure with the
         IMP (See Questions).

II-3  Buffers and Interface Table.

II-3-1  Buffers.

   They should be large enough for containing the maximum host message
   text + heading and marking (1006 + 4 = 1010 bytes).

   Consequently the buffer size could be chosen equal to 256 words (1024
   bytes).  As for the buffer number it will determine the link
   utilization frequency -

II-3-2  Interface table.

   It is through this table that the network program informs the handler
   with the location and length of the emitting data.

   This table could be a ring table with 2 pointers: one for filling,
   the other for extracting.  They are respectively updated by the
   network and the handler program.

Deloche                                                         [Page 4]
```

---

```

[RFC 7](/doc/html/rfc7)                      Host-IMP Interface                   May 1969

                      [Length] of the message
                           contained
                           in the buffer
                               ^
                               |
           +--------------+----------+
           | Buffer addr. | nb bytes |
           +--------------+----------+
           |              |          | <== Filling pointer
           +--------------+----------+         |
           |                         |         V
           |                         |
           //                        //
           |                         |
           |                         |
           |                         |
           +--------------+----------+
           | Buffer addr. | nb bytes | <== eEtracting pointer
           +--------------+----------+         |
           | Buffer addr. | nb bytes |         V
           +--------------+----------+

III.  Questions.

III-1.  Why is there not a simple control procedure between the HOST and
        the IMP?  What happens if a message, issued from the HOST,
        reaches the IMP with an error due to the transmission?

   From the BBN specifications it appears that this error will be
   transmitted as far [as] the receiving HOST.

   In that case must an HOST-HOST control procedure be provided?

III-2.  Where will the special channel hardware unit be connected
        (MIOP/SIOP)?

   How will this device be notified of an outgoing message end in order
   to start the padding?

   (The program will provide to the MIOP SIOP the number of bytes of the
   outgoing message, and will receive back an interrupt when the last
   byte is sent out.  Is it that signal which will be also sent to the
   special device?)

   Vice versa how does the Handler know the length of the incoming
   message?  From the contents of the previous one or should this

Deloche                                                         [Page 5]
```

---

```

[RFC 7](/doc/html/rfc7)                      Host-IMP Interface                   May 1969

   program always ready to receive a message of maximum length?  (Then
   an interrupt should be triggered when the real end is detected by the
   hardware).

III-3.  When does the Gordo documentation will be available in order to
        design the user-network program interface.  What are the
        mechanisms for program initiations, transferring parameters from
        one program to another, etc...

                           HOST (Sigma 7) <--|/|--> Outside world
   Users                                     |/|
    |                                        |/|
    |                                        |/|   Special  Standard
    V                                        |/|      |       |
         +--------------+   +------------+   |/|      V   |   V
    o----|              |   |            |   |/|   +------+------+
         |   Output     |-->|   Output   |-->|/|-->|      |      |-->IMP
    . . .|              |   |            |   |/|   |             |
         |              |   |            |   |/|   |      |      |
    o----| (Multiplex)  |   |            |   |/|   |             |
         |_ _ _ _ _ _ _ |   |_ _ _ _ _ _ |   |/|   | _ _ _| _ _ _|
    o----|              |   |            |   |/|   |      |      |
         |   Input      |<--|    Input   |<--|/|<--|             |<--IMP
    . . .|              |   |            |   |/|   |      |      |
         |              |   |            |   |/|   |             |
    o----|(Distribution)|   |            |   |/|   +------|------+
         |              |   |            |   |/|       HARDWARE
         +--------------+   +------------+   |/|       Interface
             NETWORK          HANDLER        |/|
             Program          Program        |/|
                                             |/|    (Fig. 1)

Deloche                                                         [Page 6]
```

---

```

[RFC 7](/doc/html/rfc7)                      Host-IMP Interface                   May 1969

                                                   +------------------+
                                                   | | |              |
                                                   | | | interface    |
                                                   | | |              |
                                                   |                  |
                                                   | ====> Data       |
                                                   |                  |
                                                   | ----- Logical    |
                                                   |       information|
                                                   +------------------+

                      + - - - - - - - - - - - - - -+
                      |                            |
                              interface table
                      |        +----------+        |               | |
        | |              +---->|          |<----+                  | |
        | |           |  |     +----------+     |  |   interrupt   | |
        | |           ^  |                      |     +----<-------| |
        | |           |  |    +-          -+    |  |  |            | |
        | |           |  V    |  _________ |    V  V  V            | |
   o----| |-+  +---------+-+  | |         ||  +-+--+--+---+        | |
        | |  \ |+---------+|  | |_________||  |+---------+|        | |
        | |   \||         ||  |            |  ||         ||        | |
        | |    +|         ||  | - - - - - -|  ||         ||        | |
        | |    ||         ||  |            |  ||         ||        | |
    - - - - - -|| NETWORK ||=>-  _________ -=>|| HANDLER ||=======>| |
        | |    +| Progr.  ||  | |         ||  || Progr.  ||        | |
        | |   /||         ||  | |_________||  ||         ||        | |
        | |  / |+---------+|  |            |  |+---------+|        | |
   o----| |-+  +-----------+  |  _________ |  +----+------+        | |
   ^    | |                   | |         ||       |               | |
   |    | |                   | |_________||       +--->---------->| |
   |     ^                    +-    ^     -+         Commands      | |
   Users |                          |                              | |
         |                    Pool of buffers                      | |
       User's                                                       ^
      Interface                                                     |
                                                              Hardware
                                                             Interface

                           (Fig. 2)

         [ This RFC was put into machine readable form for entry ]
   [ into the online RFC archives by Bob German & Lorrie Shiota 1/02 ]

Deloche                                                         [Page 7]

```

[Datatracker](/doc/rfc7/)

RFC 7

RFC
- Unknown

* Info
* Contents
* Prefs

| Document | Document type |  | RFC - Unknown  May 1969  [Report errata](https://www.rfc-editor.org/errata.php#reportnew "Click to report an error in the document.") This RFC was published on the Legacy stream. This RFC is **not endorsed by the IETF** and has **no formal standing** in the [IETF standards process](/doc/rfc2026/). |
| --- | --- | --- | --- |
|  | Select version |  | * [RFC 7](/doc/html/rfc7) |
|  | Authors |  | Email authors |
|  | RFC stream |  | Legacy |
|  | Other formats |  | [txt](https://www.rfc-editor.org/rfc/rfc7.txt) [html](https://www.rfc-editor.org/rfc/rfc7.html) [pdf](https://www.rfc-editor.org/rfc/pdfrfc/rfc7.txt.pdf) [bibtex](/doc/rfc7/bibtex/) |

[Report a datatracker bug](https://github.com/ietf-tools/datatracker/issues/new/choose)

Show sidebar by default

Yes

No

Tab to show by default

Info

Contents

HTMLization configuration

HTMLize the plaintext

Plaintextify the HTML

Maximum font size

Page dependencies

Inline

Reference

Citation links

 Go to reference section

Go to linked document

![](//analytics.ietf.org/piwik.php?idsite=7)


