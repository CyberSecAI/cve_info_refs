```
{
  "guidelines_version": "0.0.1",
  "cve_id": "CVE-2019-11413",
  "relevant_content": [
    {
      "source": "security.gentoo.org_d9fcbc35_20250120_231848.html",
      "is_relevant": true,
      "information": "Multiple vulnerabilities have been found in mujs, the worst of which could result in a Denial of Service condition.\n\n### References\n\n*   [CVE-2019-11413](https://nvd.nist.gov/vuln/detail/CVE-2019-11413)"
    },
    {
      "source": "lists.fedoraproject.org_810f28e0_20250120_231846.html",
       "is_relevant": true,
      "information": "A new version of mujs is now available for Fedora and EPEL. Besides generic enhancements and bugfixes, this release also fixes three tracked security issues: CVE-2019-11411, CVE-2019-11412 and CVE-2019-11413.\n\nReferences:\n\n[ 1 ] Bug #1873066 - CVE-2019-11413 mujs: DoS in regexp.c [fedora-all]\n<https://bugzilla.redhat.com/show_bug.cgi?id=1873066>\n[ 2 ] Bug #1873067 - CVE-2019-11413 mujs: DoS in regexp.c [epel-8]\n<https://bugzilla.redhat.com/show_bug.cgi?id=1873067>"
    },
     {
      "source": "lists.fedoraproject.org_501fd8ff_20250120_231847.html",
       "is_relevant": true,
      "information": "A new version of mujs is now available for Fedora and EPEL. Besides generic enhancements and bugfixes, this release also fixes three tracked security issues: CVE-2019-11411, CVE-2019-11412 and CVE-2019-11413.\n\nReferences:\n\n[ 1 ] Bug #1873066 - CVE-2019-11413 mujs: DoS in regexp.c [fedora-all]\n<https://bugzilla.redhat.com/show_bug.cgi?id=1873066>\n[ 2 ] Bug #1873067 - CVE-2019-11413 mujs: DoS in regexp.c [epel-8]\n<https://bugzilla.redhat.com/show_bug.cgi?id=1873067>"
    },
    {
      "source": "lists.fedoraproject.org_2a9ba3fd_20250120_231846.html",
       "is_relevant": true,
       "information": "A new version of mujs is now available for Fedora and EPEL. Besides generic enhancements and bugfixes, this release also fixes three tracked security issues: CVE-2019-11411, CVE-2019-11412 and CVE-2019-11413.\n\nReferences:\n\n[ 1 ] Bug #1873066 - CVE-2019-11413 mujs: DoS in regexp.c [fedora-all]\n<https://bugzilla.redhat.com/show_bug.cgi?id=1873066>\n[ 2 ] Bug #1873067 - CVE-2019-11413 mujs: DoS in regexp.c [epel-8]\n<https://bugzilla.redhat.com/show_bug.cgi?id=1873067>"
    },
    {
      "source": "bugzilla.redhat.com_b0d1a2db_20250121_012200.html",
      "is_relevant": true,
      "information": "CVE-2019-11413 mujs: DoS in regexp.c [epel-8]\n\nThis is an automatically created tracking bug!\n\nIt was created to ensure that one or more security vulnerabilities are fixed in affected versions of epel-8.\n\nFor comments that are specific to the vulnerability please use bugs filed against the \"Security Response\" product referenced in the \"Blocks\" field.\n\nBlocks: [CVE-2019-11413](show_bug.cgi?id=1873065 \"CLOSED UPSTREAM - CVE-2019-11413 mujs: DoS in regexp.c\")"
    },
    {
      "source": "bugzilla.redhat.com_beb0740b_20250121_012204.html",
      "is_relevant": true,
      "information": "CVE-2019-11413 mujs: DoS in regexp.c [fedora-all]\n\nThis is an automatically created tracking bug!\n\nIt was created to ensure that one or more security vulnerabilities are fixed in affected versions of fedora-all.\n\nFor comments that are specific to the vulnerability please use bugs filed against the \"Security Response\" product referenced in the \"Blocks\" field.\n\nBlocks: [CVE-2019-11413](show_bug.cgi?id=1873065 \"CLOSED UPSTREAM - CVE-2019-11413 mujs: DoS in regexp.c\")"
    },
     {
      "source": "www.ghostscript.com_c5311a86_20250120_231842.html",
      "is_relevant": true,
      "information": "Bug 700937: Limit recursion in regexp matcher.\n\nAlso handle negative return code as an error in the JS bindings.\n\n--- a/jsregexp.c\n+++ b/jsregexp.c\n@@ -46,7 +47,10 @@\n  }\n  }\n \n  if (!js_regexec(re->prog, text, &m, opts)) {\n+ result = js_regexec(re->prog, text, &m, opts);\n+ if (result < 0)\n+ js_error(J, \"regexec failed\");\n+ if (result == 0) {\n\n---\n+++ b/jsstring.c\n@@ -4,6 +4,14 @@\n #include \"utf.h\"\n #include \"regexp.h\"\n \n+static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n+{\n+ int result = js_regexec(prog, string, sub, eflags);\n+ if (result < 0)\n+ js_error(J, \"regexec failed\");\n+ return result;\n+}\n\n\n@@ -343,7 +351,7 @@ static void Sp_match(js_State *J)\n  a = text;\n  e = text + strlen(text);\n  while (a <= e) {\n- if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+ if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n  break;\n\n---\n+++ b/regexp.c\n@@ -16,6 +16,7 @@\n #define REPINF 255\n #define MAXSUB REG_MAXSUB\n #define MAXPROG (32 << 10)\n+#define MAXREC 1024\n \n typedef struct Reclass Reclass;\n typedef struct Renode Renode;\n@@ -967,87 +968,101 @@ static int strncmpcanon(const char *a, const char *b, int n)\n  return 0;\n  }\n \n-static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out)\n+static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out, int depth)\n {\n  Resub scratch;\n+ int result;\n+ int i;\n+ Rune c;\n \n+ /* stack overflow */\n+ if (depth > MAXREC)\n+ return -1;\n+ for (;;) {\n+ switch (pc->opcode) {\n+ case I_END:\n+ return 1;\n+ return 0;\n+ case I_JUMP:\n+ pc = pc->x;\n+ break;\n+ case I_SPLIT:\n+ scratch = *out;\n+ if (match(pc->x, sp, bol, flags, &scratch)) {\n+ result = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+ if (result == -1)\n+ return -1;\n+ if (result == 0) {\n+ *out = scratch;\n+ return 1;\n+ return 0;\n+ }\n+ pc = pc->y;\n+ break;\n\n+ case I_PLA:\n+ if (!match(pc->x, sp, bol, flags, out))\n+ return 0;\n+ result = match(pc->x, sp, bol, flags, out, depth+1);\n+ if (result == -1)\n+ return -1;\n+ if (result == 1)\n+ return 1;\n+ pc = pc->y;\n+ break;\n+ case I_NLA:\n+ scratch = *out;\n+ if (match(pc->x, sp, bol, flags, &scratch))\n+ return 0;\n+ result = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+ if (result == -1)\n+ return -1;\n+ if (result == 0)\n+ return 1;\n+ pc = pc->y;\n+ break;\n\n+ case I_ANYNL:\n+ sp += chartorune(&c, sp);\n+ if (c == 0)\n+ return 0;\n+ return 1;\n+ pc = pc + 1;\n+ break;\n+ case I_ANY:\n+ sp += chartorune(&c, sp);\n+ if (c == 0)\n+ return 0;\n+ return 1;\n+ if (isnewline(c))\n+ return 0;\n+ return 1;\n+ pc = pc + 1;\n+ break;\n+ case I_CHAR:\n+ sp += chartorune(&c, sp);\n+ if (c == 0)\n+ return 0;\n+ return 1;\n+ if (flags & REG_ICASE)\n+ c = canon(c);\n+ if (c != pc->c)\n+ return 0;\n+ return 1;\n+ pc = pc + 1;\n+ break;\n+ case I_CCLASS:\n+ sp += chartorune(&c, sp);\n+ if (c == 0)\n+ return 0;\n+ return 1;\n+ if (flags & REG_ICASE) {\n+ if (!incclasscanon(pc->cc, canon(c)))\n+ return 0;\n+ return 1;\n+ } else {\n+ if (!incclass(pc->cc, c))\n+ return 0;\n+ return 1;\n+ }\n+ pc = pc + 1;\n+ break;\n+ case I_NCCLASS:\n+ sp += chartorune(&c, sp);\n+ if (c == 0)\n+ return 0;\n+ return 1;\n+ if (flags & REG_ICASE) {\n+ if (incclasscanon(pc->cc, canon(c)))\n+ return 0;\n+ return 1;\n+ } else {\n+ if (incclass(pc->cc, c))\n+ return 0;\n+ return 1;\n+ }\n+ pc = pc + 1;\n+ break;\n@@ -1055,10 +1070,10 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n  i = out->sub[pc->n].ep - out->sub[pc->n].sp;\n  if (flags & REG_ICASE) {\n  if (strncmpcanon(sp, out->sub[pc->n].sp, i))\n+ return 0;\n+ return 1;\n  } else {\n  if (strncmp(sp, out->sub[pc->n].sp, i))\n+ return 0;\n+ return 1;\n  }\n  if (i > 0)\n  sp += i;\n@@ -1076,7 +1091,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n  break;\n  }\n  }\n- return 0;\n+ return 1;\n  case I_EOL:\n  if (*sp == 0) {\n  pc = pc + 1;\n@@ -1088,19 +1103,19 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n  break;\n  }\n  }\n- return 0;\n+ return 1;\n  case I_WORD:\n  i = sp > bol && iswordchar(sp[-1]);\n  i ^= iswordchar(sp[0]);\n  if (!i)\n+ return 0;\n+ return 1;\n  pc = pc + 1;\n  break;\n  case I_NWORD:\n  i = sp > bol && iswordchar(sp[-1]);\n  i ^= iswordchar(sp[0]);\n  if (i)\n+ return 0;\n+ return 1;\n  pc = pc + 1;\n  break;\n \n@@ -1113,7 +1128,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n  pc = pc + 1;\n  break;\n  default:\n- return 0;\n+ return 1;\n  }\n  }\n  }\n@@ -1130,7 +1145,7 @@ int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n  for (i = 0; i < MAXSUB; ++i)\n  sub->sub[i].sp = sub->sub[i].ep = NULL;\n \n- return !match(prog->start, sp, sp, prog->flags | eflags, sub);\n+ return match(prog->start, sp, sp, prog->flags | eflags, sub, 0);\n  }\n \n #ifdef TEST"
     },
      {
      "source": "github.com_d796da9d_20250120_231845.html",
      "is_relevant": true,
      "information": "Bug 700937: Limit recursion in regexp matcher.\n\nAlso handle negative return code as an error in the JS bindings.\n\n--- a/jsregexp.c\n+++ b/jsregexp.c\n@@ -46,7 +47,10 @@\n  }\n  }\n \n  if (!js_regexec(re->prog, text, &m, opts)) {\n+ result = js_regexec(re->prog, text, &m, opts);\n+ if (result < 0)\n+ js_error(J, \"regexec failed\");\n+ if (result == 0) {\n\n---\n+++ b/jsstring.c\n@@ -4,6 +4,14 @@\n #include \"utf.h\"\n #include \"regexp.h\"\n \n+static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n+{\n+ int result = js_regexec(prog, string, sub, eflags);\n+ if (result < 0)\n+ js_error(J, \"regexec failed\");\n+ return result;\n+}\n\n\n@@ -343,7 +351,7 @@ static void Sp_match(js_State *J)\n  a = text;\n  e = text + strlen(text);\n  while (a <= e) {\n- if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n+ if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n  break;\n\n---\n+++ b/regexp.c\n@@ -16,6 +16,7 @@\n #define REPINF 255\n #define MAXSUB REG_MAXSUB\n #define MAXPROG (32 << 10)\n+#define MAXREC 1024\n \n typedef struct Reclass Reclass;\n typedef struct Renode Renode;\n@@ -967,87 +968,101 @@ static int strncmpcanon(const char *a, const char *b, int n)\n  return 0;\n  }\n \n-static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out)\n+static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out, int depth)\n {\n  Resub scratch;\n+ int result;\n+ int i;\n+ Rune c;\n \n+ /* stack overflow */\n+ if (depth > MAXREC)\n+ return -1;\n+ for (;;) {\n+ switch (pc->opcode) {\n+ case I_END:\n+ return 1;\n+ return 0;\n+ case I_JUMP:\n+ pc = pc->x;\n+ break;\n+ case I_SPLIT:\n+ scratch = *out;\n+ if (match(pc->x, sp, bol, flags, &scratch)) {\n+ result = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+ if (result == -1)\n+ return -1;\n+ if (result == 0) {\n+ *out = scratch;\n+ return 1;\n+ return 0;\n+ }\n+ pc = pc->y;\n+ break;\n\n+ case I_PLA:\n+ if (!match(pc->x, sp, bol, flags, out))\n+ return 0;\n+ result = match(pc->x, sp, bol, flags, out, depth+1);\n+ if (result == -1)\n+ return -1;\n+ if (result == 1)\n+ return 1;\n+ pc = pc->y;\n+ break;\n+ case I_NLA:\n+ scratch = *out;\n+ if (match(pc->x, sp, bol, flags, &scratch))\n+ return 0;\n+ result = match(pc->x, sp, bol, flags, &scratch, depth+1);\n+ if (result == -1)\n+ return -1;\n+ if (result == 0)\n+ return 1;\n+ pc = pc->y;\n+ break;\n\n+ case I_ANYNL:\n+ sp += chartorune(&c, sp);\n+ if (c == 0)\n+ return 0;\n+ return 1;\n+ pc = pc + 1;\n+ break;\n+ case I_ANY:\n+ sp += chartorune(&c, sp);\n+ if (c == 0)\n+ return 0;\n+ return 1;\n+ if (isnewline(c))\n+ return 0;\n+ return 1;\n+ pc = pc + 1;\n+ break;\n+ case I_CHAR:\n+ sp += chartorune(&c, sp);\n+ if (c == 0)\n+ return 0;\n+ return 1;\n+ if (flags & REG_ICASE)\n+ c = canon(c);\n+ if (c != pc->c)\n+ return 0;\n+ return 1;\n+ pc = pc + 1;\n+ break;\n+ case I_CCLASS:\n+ sp += chartorune(&c, sp);\n+ if (c == 0)\n+ return 0;\n+ return 1;\n+ if (flags & REG_ICASE) {\n+ if (!incclasscanon(pc->cc, canon(c)))\n+ return 0;\n+ return 1;\n+ } else {\n+ if (!incclass(pc->cc, c))\n+ return 0;\n+ return 1;\n+ }\n+ pc = pc + 1;\n+ break;\n+ case I_NCCLASS:\n+ sp += chartorune(&c, sp);\n+ if (c == 0)\n+ return 0;\n+ return 1;\n+ if (flags & REG_ICASE) {\n+ if (incclasscanon(pc->cc, canon(c)))\n+ return 0;\n+ return 1;\n+ } else {\n+ if (incclass(pc->cc, c))\n+ return 0;\n+ return 1;\n+ }\n+ pc = pc + 1;\n+ break;\n@@ -1055,10 +1070,10 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n  i = out->sub[pc->n].ep - out->sub[pc->n].sp;\n  if (flags & REG_ICASE) {\n  if (strncmpcanon(sp, out->sub[pc->n].sp, i))\n+ return 0;\n+ return 1;\n  } else {\n  if (strncmp(sp, out->sub[pc->n].sp, i))\n+ return 0;\n+ return 1;\n  }\n  if (i > 0)\n  sp += i;\n@@ -1076,7 +1091,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n  break;\n  }\n  }\n- return 0;\n+ return 1;\n  case I_EOL:\n  if (*sp == 0) {\n  pc = pc + 1;\n@@ -1088,19 +1103,19 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n  break;\n  }\n  }\n- return 0;\n+ return 1;\n  case I_WORD:\n  i = sp > bol && iswordchar(sp[-1]);\n  i ^= iswordchar(sp[0]);\n  if (!i)\n+ return 0;\n+ return 1;\n  pc = pc + 1;\n  break;\n  case I_NWORD:\n  i = sp > bol && iswordchar(sp[-1]);\n  i ^= iswordchar(sp[0]);\n  if (i)\n+ return 0;\n+ return 1;\n  pc = pc + 1;\n  break;\n \n@@ -1113,7 +1128,7 @@ static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *\n  pc = pc + 1;\n  break;\n  default:\n- return 0;\n+ return 1;\n  }\n  }\n  }\n@@ -1130,7 +1145,7 @@ int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n  for (i = 0; i < MAXSUB; ++i)\n  sub->sub[i].sp = sub->sub[i].ep = NULL;\n \n- return !match(prog->start, sp, sp, prog->flags | eflags, sub);\n+ return match(prog->start, sp, sp, prog->flags | eflags, sub, 0);\n  }\n \n #ifdef TEST"
    }
  ],
  "vulnerability_details": {
    "root_cause": "The vulnerability is due to unlimited recursion in the regular expression matching engine, specifically in the `match` function within the `regexp.c` file.",
    "weaknesses": [
      "Uncontrolled recursion",
      "Denial of service"
    ],
    "impact": "A specially crafted regular expression can cause excessive recursion leading to a stack overflow and denial of service.",
    "attack_vectors": [
      "Crafted regular expression input to a vulnerable function."
    ],
    "required_capabilities": "The attacker needs to provide a malicious regular expression to the affected mujs component. "
  }
}
```