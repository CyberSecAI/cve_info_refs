=== Content from eprint.iacr.org_b745c4fc_20250124_134255.html ===
An Attack on CFB Mode Encryption As Used By OpenPGP

Serge Mister & Robert Zuccherato

Entrust, Inc., 1000 Innovation Drive, Ottawa, Ontario, Canada K2K 3E7
{serge.mister,robert.zuccherato}@entrust.com

Abstract. This paper describes an adaptive-chosen-ciphertext attack on the Cipher Feedback (CFB)
mode of encryption as used in OpenPGP. In most circumstances it will allow an attacker to determine
16 bits of any block of plaintext with about 215 oracle queries for the initial setup work and 215 oracle
queries for each block. Standard CFB mode encryption does not appear to be aﬀected by this attack. It
applies to a particular variation of CFB used by OpenPGP. In particular it exploits an ad-hoc integrity
check feature in OpenPGP which was meant as a “quick check” to determine the correctness of the
decrypting symmetric key.

Keywords: OpenPGP, Cipher-Feedback Mode, encryption, chosen-ciphertext attacks

1 Introduction

The OpenPGP Message Format is described in RFC 2440 [4]. It is a very popular and commonly
used format for signing and encrypting data ﬁles, particularly for signing and encrypting email.
The formats described in the OpenPGP RFC have been implemented in a wide variety of popular
freeware and commercial encryption products. Symmetric encryption in OpenPGP is performed
using a variant of the standard Cipher-Feedback (CFB) Mode for block ciphers.

Adaptive chosen-ciphertext attacks on cryptographic protocols allow an attacker to decrypt a
ciphertext C, getting the plaintext M , by submitting a series of chosen- ciphertexts C0
6= C to
an oracle which returns information on the decryption. The ciphertexts can be adaptively cho-
sen so that information on previous decryptions is available before the next chosen ciphertext is
submitted. These attacks have been used in the past to attack the RSA PKCS #1 v1.5 [11] en-
cryption scheme [3], the Cipher-Block-Chaining (CBC) Mode of encryption when used with certain
exploitable redundancies (e.g. padding schemes) [13, 2] and the OpenPGP CFB mode [12, 10] itself.
The attack on the OpenPGP CFB mode was able to obtain the entire plaintext using one oracle
query which returned to the attacker the entire decryption of C0.

This paper describes an adaptive chosen-ciphertext attack on the OpenPGP CFB mode of
encryption. The attack requires an oracle that returns information on an ad-hoc integrity check in
the OpenPGP CFB mode. We show that this oracle is likely instantiated in most applications that
include OpenPGP. With about 215 oracle queries for an initial setup and about 215 queries for each
block, the attacker can determine the ﬁrst two bytes of plaintext in each block. The attack does
require that the attacker also know the ﬁrst two bytes of plaintext of any one block to bootstrap
the process, but we show how to likely obtain these bytes in the majority of circumstances.

We believe that the presence of this attack will require future versions of OpenPGP software to

disable the ad-hoc integrity check in the OpenPGP CFB mode.

2 Cipher-Feedback (CFB) Mode

This section will ﬁrst describe the standard Cipher Feedback (CFB) mode of operation for block
ciphers. The particular variant of CFB mode that is used in OpenPGP will then be described.

The standard CFB mode, by itself, does not appear to be aﬀected by the results in this paper.
However, if the data that has been encrypted using standard CFB mode has also been padded to
produce an integer number of blocks of plaintext and there exists an oracle for determining when
an encrypted message has been correctly padded, the techniques introduced in this paper along
with the ideas in [13, 2] can be used to decrypt part or all of any ciphertext block.

2.1 Standard CFB Mode

We describe the standard CFB mode of operation as described in ANSI X9.52 [1] and NIST Special
Publication 800-38A [7]. We will assume that the block size of the underlying block cipher, the
block size of the CFB mode and the size of the feedback variable are all b bytes, since this is the
case for the variant used by OpenPGP. We are doing this simply for ease of explanation and note
that nothing in this paper depends upon this fact.

Let EK(·) be encryption with the symmetric key K by the underlying block cipher. Let ⊕ be
bitwise exclusive-or. The plaintext message to be encrypted will be M = (M1, M2, . . . , Mn) where
each Mi is b bytes long. A random b-byte initialization vector IV is required in order to produce
the ciphertext C = (C1, C2, . . . , Cn) as

C1 = EK(IV ) ⊕ M1
C2 = EK(C1) ⊕ M2

...

Ci = EK(Ci−1) ⊕ Mi

...

Cn = EK(Cn−1) ⊕ Mn.

2.2 OpenPGP CFB Mode

The OpenPGP Message Format [4] uses a variant on the standard CFB mode. The main diﬀerence
with the OpenPGP variant is that a plaintext initialization vector, as described above, is not used,
but instead a random block R is encrypted as the ﬁrst block of ciphertext. Two bytes of R are
repeated in the second block in order to quickly check whether the session key K is incorrect upon
decryption. We note that this “quick check” is really an integrity check on the key and it is this
ad-hoc integrity mechanism, used in a mode of operation that wasn’t designed to accommodate it,
that allows the attack.

Let 0 be the b-byte all zero block. By Xi,j or [X]i,j we will mean the ith and jth bytes of the
block X and by Xi−j or [X]i−j we will mean the ith through jth bytes of X. The concatenation
operation will be represented by ||. Then, using notation as introduced in the previous section, the
ciphertext C = (C1, C2, . . . , Cn+2) is computed as

C1 = EK(0) ⊕ R
C2 = EK(C1)1,2 ⊕ Rb−1,b
C3 = EK([C1]3−b||C2) ⊕ M1
C4 = EK(C3) ⊕ M2

...

Ci = EK(Ci−1) ⊕ Mi−2

...

Cn+2 = EK(Cn+1) ⊕ Mn.

We note here that C2 is not a full b-byte block, but instead consists of just 2 bytes. We will

leave this slight abuse of notation as it will be useful later on.

The random number R is not sent to the receiver to use directly. Its purpose is to provide
a random initial value on which to apply the block cipher and encrypt the ﬁrst plaintext block
M1 and thus plays the role of the initialization vector in standard CFB mode. Note though that
repetition of the two bytes of R in the computation of C1 and C2 allows the recipient to quickly
check, after decrypting only blocks C1 and C2 whether or not the session key is likely correct. This
is done by comparing the b + 1st and b + 2nd blocks with the b − 1st and bth blocks. If they match,
then the current key was likely the one used to encrypt the data and the remaining blocks can
be decrypted. If they don’t match, then the key is likely in error, and decryption can be halted.
The OpenPGP speciﬁcation (RFC 2440) describes this “quick check” and most implementations of
OpenPGP include it. However, this is really an ad-hoc integrity check that leaks crucial information,
as we shall see.

3 Attacking the OpenPGP CFB Mode

This section will describe the attack in detail. First we will describe the oracle required and the
information that can be obtained from a successful oracle query. Then we will look at the format of
the OpenPGP messages that are being decrypted and show that certain bits of M1 can be predicted.
We will then use the oracle and the known plaintext bits to determine 16 bits from any block of
ciphertext.

3.1 The Oracle

This attack requires the presence of an oracle O that, when given a purported ciphertext C en-
crypted using the OpenPGP CFB mode of operation with a given key, will correctly determine
whether or not the integrity check described in Section 2.2 was successful. We note that this oracle
is likely to be implemented in practical implementations of OpenPGP. RFC 2440 requires that
implementations implement this check to prevent obviously incorrect ciphertexts from being de-
crypted. Further details on the practical aspects of implementing this oracle will be discussed in
Section 3.3.

Let’s assume that such an oracle does, in fact, exist. Then if the oracle query is successful we

know that for the purported ciphertext C,

[C1]b−1,b ⊕ [EK(0)]b−1,b = C2 ⊕ EK(C1)1,2.

(1)

We note that C1 and C2 are known since they are part of the ciphertext C. If we knew EK(C1)1,2,
then we could determine [EK(0)]b−1,b and similarly if we knew [EK(0)]b−1,b, then we could deter-
mine EK(C1)1,2. The method for the attack is now clear. We need to construct a message so that
we know EK(C1)1,2, that will allow us to obtain [EK(0)]b−1,b. This value is the same for all mes-
sages encrypted using K. Then, we can use that information to determine EK(C1)1,2 in specially
constructed messages, from which we will get the ﬁrst two bytes of any plaintext block.

3.2 Obtaining Some Known Plaintext

In order for the attack described in this paper to work, the ﬁrst two bytes of any one message block
Mi must be known by the attacker. In this section, we will describe how an attacker can plausibly
determine the ﬁrst two bytes of M1 in the majority of circumstances.

According to RFC 2440, the message M that is encrypted using the OpenPGP CFB mode con-
sists entirely of a complete OpenPGP message. Both GnuPG (available at http://www.gnupg.org)
and PGP Freeware (available at http://www.pgp.com) compress data by default before encrypting
it. Thus, in the vast majority of circumstances, the encrypted message will consist of a compressed
data packet. We will examine this situation ﬁrst.

When the data being encrypted is a compressed data packet, the ﬁrst two bytes of this packet are
very predictable. The ﬁrst byte consists of a “packet tag”, which indicates the format of the packet
contents. If the packet is compressed, then this packet tag will typically take the value 0xA3. The
second byte indicates the compression algorithm used. Typically this will be 0x01 to represent the
ZIP compression algorithm. Other common values for the second byte are 0x00 for uncompressed
data, 0x02 for ZLIB compression and 0x03 for BZip2 compression. Thus, if the attacker knows that
the encrypted data is compressed, then the ﬁrst two bytes will either be known or can be determined
by trying a small number of possible values. If it is not known that the data is a compressed data
packet, then the attacker can reasonably guess that it has been and thus guess the ﬁrst two bytes.
If it is known that the encrypted data is not a compressed data packet, then there are a small
number of choices for the ﬁrst two bytes of M1. The ﬁrst byte will again be a “packet tag” to
indicate the format of the packet contents. There are only a small number of possible packet tags
likely to be used (14 are deﬁned in the OpenPGP RFC). The second byte will either be the length
of the encrypted message, or a portion of the length, depending upon whether or not more than
one byte is required to represent the length. It is not unreasonable to assume that the attacker
may know, or be able to guess, the packet type of the encrypted message and will likely be able to
deduce the length from the message itself. Thus, it is not unreasonable to assume that the attacker
will know, or be able to deduce the ﬁrst two bytes of M1.

Once the attacker knows [M1]1,2 then, from the deﬁnition of the OpenPGP CFB mode, it
immediately also knows EK([C1]3−b||C2)1,2. In the general case, if the attacker knows [Mi+1]1,2 for
i ≥ 1 then it also knows [EK(Ci)]1,2. We will assume that the attacker knows one of these values.

3.3 The Initial Setup Work

In this section we will describe how the attacker can determine [EK(0)]b−1,b. We will assume that
the attacker has intercepted C = EK(M ) and knows the ﬁrst two bytes of some plaintext block.
As we saw in the last section, this is not an unreasonable assumption. We will ﬁrst consider the
situation where the attacker knows the ﬁrst two bytes of M1, next we will consider the situation
where the attacker knows the ﬁrst two bytes of Mi+1 for i ≥ 1.

When the attacker knows the ﬁrst two bytes of M1, the attacker will construct a ciphertext
C0 = ([C1]3−b||C2, D, C3, C4, . . .) for particular values of D and submit it to the oracle to determine
whether or not it is a properly constructed ciphertext. In other words, the oracle will determine
whether or not the integrity check in the OpenPGP CFB mode was successful. When it is successful,
we can use Equation (1) to determine [EK(0)]b−1,b.

In this situation, the attacker should use the following algorithm to determine [EK(0)]b−1,b.

1. Let D be a two byte integer representing the value 0.
2. Construct C0 = ([C1]3−b||C2, D, C3, C4, . . .).
3. Submit C0 to the oracle O. If the oracle returns “success” then

[EK(0)]b−1,b = C2 ⊕ D ⊕ EK([C1]3−b||C2)1,2.

Otherwise, let D = D + 1 and goto Step 1.

The correctness of this result follows immediately from Equation (1), the construction of C0
and the fact that we are exhausting over all possible values of D. We note that from the previous
section, the attacker knows EK([C1]3−b||C2)1,2 and thus can, in fact compute [EK(0)]b−1,b.

We will now consider the more general case when the attacker knows the ﬁrst two bytes of Mi+1
for i ≥ 1. This time the attacker will construct a ciphertext C0 = (Ci, D, C3, C4, . . .) and proceed
as in the previous case. The attacker would use the following algorithm to determine [EK(0)]b−1,b.

1. Let D be a two byte integer representing the value 0.
2. Construct C0 = (Ci, D, C3, C4, . . .).
3. Submit C0 to the oracle O. If the oracle returns “success” then

[EK(0)]b−1,b = [Ci]b−1,b ⊕ D ⊕ [EK(Ci)]1,2.

Otherwise, let D = D + 1 and goto Step 1.

Here we note that the attacker knows [EK(Ci)]1,2 from the results in the previous section and

thus can also compute [EK(0)]b−1,b.

It is clear that in either of these situations the oracle will return “success” for some value
of D less than 216. Thus, we would expect that, on average, our attacker would require about
215 = 32, 768 oracle queries in order to determine [EK(0)]b−1,b.

3.4 Determining 16 Bits of Any Plaintext Block

Once our attacker has determined [EK(0)]b−1,b, the ﬁrst two bytes of any plaintext block can be
determined with about 215 queries to the oracle. It is a simple variation on the algorithms in the
previous section that provides it to the attacker.

In order to determine [Mi+1]1,2 for any i ≥ 1 the attacker should use the following algorithm.

1. Let D be a two byte integer representing the value 0.
2. Construct C0 = (Ci+2, D, C3, C4, . . .).
3. Submit C0 to the oracle O. If the oracle returns “success” then

[EK(Ci+2)]1,2 = [Ci+2]b−1,b ⊕ D ⊕ [EK(0)]b−1,b.

Otherwise, let D = D + 1 and goto Step 1.
4. Then [Mi+1]1,2 = [EK(Ci+2)]1,2 ⊕ [Ci+3]1,2.

Again, the correctness of this result follows immediately from Equation (1), the construction of
C0 and the fact that we are exhausting over all possible values of D. As in the previous section we
would expect that the attacker would require on average about 215 oracle queries to determine the
ﬁrst two bytes of any plaintext block.

In the general case where the ﬁrst two bytes of M1 are not already known, they can be obtained

by a simple modiﬁcation to the above algorithm in which Ci+2 is replaced by [C1]3−b||C2.

3.5 The Attack Without Plaintext

We note that the attack can be implemented even if it is not possible to know the ﬁrst two bytes of
some plaintext block. In this situation, we can simply replace the assumed known value [M1]1,2 with
an indeterminate, say Z and implement the algorithms in Sections 3.3 and 3.4. Note that now all
of the formulae still carry through, including the “⊕Z” term. Now instead of actually determining
[Mi+1]1,2 for any i ≥ 1, we determine [Mi+1]1,2 ⊕ Z. If enough of these values are recovered and if
the values of the [Mi+1]1,2 can be bounded, then Z can be determined, thus revealing the plaintext.
For example, if it is known that all of the Mi are ASCII text, then it wouldn’t take very many

values of [Mi+1]1,2 ⊕ Z to be recovered before Z could be determined.

Thus, we see that under the reasonable assumption that an attacker can determine the ﬁrst
two bytes of any one message block, with one-time initial work of about 215 oracle queries, the ﬁrst
two bytes of any other message block can be determined with about 215 oracle queries per message
block. The following section will consider the question of the likelihood of this particular oracle
existing.

3.6 Extending the Attack To Other Modes

We note that this attack is not really an attack on CFB mode encryption, but an attack on the two
repeated bytes in the ﬁrst two blocks of an OpenPGP encrypted message. It is likely that similar
attacks would be possible with any non-authenticated encryption mode whenever the decryptor
checks for repeated bytes. For example, Hal Finney has pointed out that a similar attack is possible
against CBC mode if the decryptor checks for such a plaintext stutter [8].

As with the attack on padding in CBC mode, we note that in all of these situations the decryptor
is checking for a speciﬁc redundancy when using a non-authenticated mode. This practice leaks too
much information to the attacker. Such checks should be disabled or an authenticated mode of
operation should be used whenever possible.

4 The Attack in Practice

In previous sections we showed that if a certain oracle exists, then under reasonable assumptions
it is possible for an attacker to determine the ﬁrst two bytes of any plaintext block. This section
will examine how likely it is that the required oracle will exist in practice.

We ﬁrst note that the required oracle O simply implements the integrity check required in the
OpenPGP standard. Thus it is not unreasonable to expect that most implementations would leak
this kind of information. This is not a very “powerful” oracle in the sense that it is not leaking a
great deal of information. We contrast this with the oracle required in the attack on the OpenPGP
CFB mode described in [12, 10]. In that attack only a single oracle query is required to determine
the entire plaintext, however, the oracle must return the decryption of the chosen ciphertext. In
most environments it is not likely that the attacker will actually have access to the decryption of
the chosen ciphertext. It is not unreasonable though to assume that error information is obtained
either directly, or through side-channels.

4.1 Non-Server-Based OpenPGP Users

By a “non-server-based OpenPGP user” we refer to a human user interacting with an OpenPGP-
enabled application. This is, by far, the most common scenario of OpenPGP-based applications. In
this scenario it is not unreasonable to assume that some error information regarding the decryption
of any ciphertext will be leaked to an attacker. However, it is not likely at all that a human user
will attempt to decrypt over 32,000 messages whose decryptions actually fail without realizing that
there is a problem and discontinuing.

Thus, we view an attack in this situation as unlikely and will not consider it any further.

4.2 Server-Based OpenPGP Users

A “server-based OpenPGP user” is an automated process that responds to requests that have been
encrypted for it using OpenPGP. It attempts to decrypt the request and respond to it appropriately.
This is a much less likely scenario than in the previous section. In this situation it is more likely
that information on errors (including decryption errors) will be returned to the requester, which in
this case could be an attacker.

There are at least two ways in which an attacker could gain information that would instantiate
the oracle. The server could return an error directly to the attacker that the integrity check in the
OpenPGP CFB mode failed. As we will see in the next section, some common OpenPGP toolkits
do, in fact return error codes which could allow server-based OpenPGP users to, unwittingly,
instantiate the oracle. Even if this error code is not returned, information on whether or not the
integrity check was successful can likely be obtained through timing or other information. RFC
2440 says that the integrity check “allows the receiver to immediately check whether the session
key is incorrect”. Thus, most implementations would abandon the decryption process immediately
if the check failed thereby allowing timing attacks to determine the result of the check. As we will
see in the next section, this is what happens.

We also need the oracle to use the same symmetric key K each time that it is invoked. This is not
diﬃcult to do. After constructing the ciphertext C0 as described in previous sections, this ciphertext
should simply be packaged in a standard OpenPGP message. The Public-Key Encrypted Session
Key Packet in this message should always contain the same value as in the original OpenPGP

message that is being attacked. This packet will contain the key K encrypted for the victim. Each
time that the chosen ciphertext is sent to the victim, he/she will decrypt and thus use the same
key K each time.

4.3 Common Toolkits May Instantiate the Oracle

To determine the likelihood of this oracle being instantiated we looked at two common toolkits that
implement the OpenPGP RFC. We considered GnuPG 1.2.6 [9] and Cryptix OpenPGP [6].

In GnuPG 1.2.6, the integrity check is performed in the decrypt data() function call. If the
integrity check is not successful, then the error G10ERR BAD KEY is returned and decryption is
abandoned. Thus, it is not unreasonable to expect that some server-based applications based upon
this toolkit would leak this error information either directly, or based upon timing information.

In the Cryptix OpenPGP toolkit, the PGPEncryptedDataPacket.decrypt() method performs
the integrity check. If the integrity check is not successful then an exception is thrown with “No good
session key found” and decryption doesn’t proceed. Thus, again, it is not unreasonable to expect
that some server-based applications based upon this toolkit would leak this error information either
directly, or based upon timing or other information.

4.4 Implementing the Attack

We implemented the attack on GnuPG 1.2.4. As it turns out, GnuPG is very helpful in that it
appears to display the error “decryption failed: bad key” if and only if our oracle does not
return success.

We encrypted data with compression turned oﬀ and without MDC (see next Section). This
was only for ease of implementation, as we have seen (and shall see) this is not required. We then
implemented the algorithms in Sections 3.3 and 3.4 as batch scripts cycling through all possible
values of D. When we did not get a “decryption failed: bad key” we knew that the integrity
check was successful and could utilize the given formulae to produce the plaintext. We note that in
all of our experiments we only received one value of D that did not give a “decryption failed:
bad key” error.

Implemented on a 1.8 GHz Pentium M processor running Windows XP Professional, it took
under 2 hours to exhaust all values of D. Thus, with less than 4 hours of work an attacker could
obtain the ﬁrst two bytes of any plaintext block. The ﬁrst two bytes of additional plaintext blocks
could be obtained with an additional 2 hours each.

4.5 The Eﬀect of Compression

When 64-bit blocks are used an attacker can obtain at most 25% of the plaintext and when 128-
bit blocks are being used at most 12.5%. If the plaintext is uncompressed data this would be
devistating. However, typically plaintext OpenPGP data is compressed. In this situation it is not
clear if obtaining even 25% of the compressed data will compromise any of the uncompressed data.
This is a big mitigating factor against the attack in practice.

5 Attack Prevention

In this section we examine two potential methods for avoiding this attack. One method does not
work, the other does.

5.1 Integrity Protected Data Packet Doesn’t Work

The OpenPGP RFC is currently up for revision [5] and a new packet type will be included that
provides additional integrity protection for encrypted data. GnuPG also implements this additional
packet type, called the Symmetrically Encrypted Integrity Protected Data Packet. Encryption using
this packet type diﬀers from the non-integrity protected version in two ways. First, the OpenPGP
CFB mode of encryption as described is not used. Instead b + 2 random bytes, with the b + 1st
and b + 2nd bytes matching the b − 1st and bth bytes, are preﬁxed to the message and then the
standard CFB mode is used to encrypt the preﬁxed message. As previously, the repeated bytes
should be checked and decryption abandoned if they do not match. Second, the entire plaintext
message, including the preﬁx is hashed. The hash value, known as an MDC, is appended to the
message and encrypted using CFB mode as well.

Let us ﬁrst consider the modiﬁed CFB mode of operation. We note that, in general, the attack
described still works with slight modiﬁcations (e.g. replace C2 with [C2]1,2). However, it will likely
now become more diﬃcult for an attacker to obtain the ﬁrst two bytes of a plaintext message block
in order to bootstrap the attack. Notice that now the suggested known plaintext will be in bytes 3
and 4 of the plaintext corresponding to C2. If the ﬁrst two bytes of any plaintext message block is
known, however, the attack will still be valid.

The purpose of the hash is to detect modiﬁcations of the message by the attacker. The attack
described in this paper involves modiﬁcations to the message and the hash will, in fact, detect it.
However, since the check of the hash occurs after the decryption of the entire plaintext and the ad-
hoc integrity check of the bytes in C1 and C2 occurs before the decryption of the entire plaintext,
it is still likely that information that instantiates the oracle will be leaked. In fact, since a hash will
now need to be computed before determining whether or not the plaintext is valid in addition to
decrypting the message, it is likely that timing attacks to determine the information will be more
eﬀective. We note that GnuPG implements this new packet type and still returns diﬀerent error
codes for the two errors and abandons decryption if the repeated bytes do not match.

Thus, this packet type, by itself, will not prevent this attack, although it may make it more

diﬃcult to start.

5.2 The Solution

The only method that appears to always work in thwarting this attack is to not instantiate the
required oracle. Thus, implementations should not do the check that the repeated bytes in the ﬁrst
two blocks match. If the non-integrity protected packet type is being used, then the data should all
be decrypted and an attempt should be made at parsing it. If the integrity protected packet type
is being used, then the entire ciphertext should, again, be decrypted and the hash calculated and
checked. If it doesn’t match, then an error can be thrown.

Unfortunately, for backwards compatibility with the substantial installed user-base it is not
possible to remove these random repeated bytes from the encrypted data format. However, future
versions should simply ignore these bytes.

If a similar “quick check” that would allow OpenPGP users to quickly determine whether
or not the given symmetric key is correct is required, then one possible solution is to include a
cryptographic hash of the symmetric key with the ciphertext. The message recipient could then
compute the hash of the purported symmetric key and compare it with the given value before

decrypting. Note that this solution would not provide an integrity check on the entire message and
would require changes to the OpenPGP RFC.

6 Conclusion

We have described an attack on the OpenPGP CFB mode of operation. This attack works under
reasonable assumptions about the knowledge of certain plaintext bytes and requires an oracle which
is likely instantiated in most applications using OpenPGP. However, since the attack requires 215
oracle queries, on average, for the initial setup and 215 oracle queries to determine the ﬁrst two
bytes of any plaintext block, it likely won’t eﬀect applications with human end users. Server-based
applications would be more vulnerable to attack though. In order to thwart this attack, future
implementations should not perform the ad-hoc integrity check in the OpenPGP CFB mode.

Acknowledgements. We would like to thank Jon Callas, Hal Finney and Don Johnson for their
helpful comments.

References

1. ANSI X9.52 – 1998, “Triple Data Encryption Algorithm Modes Of Operation”, American National Standards

Institute, July 29, 1998.

2. J. Black and H. Urtubia, “Side-Channel Attacks on Symmetric Encryption Schemes: The Case for Authenticated

Encryption,” In Proceedings of the 11th USENIX Security Symposium, pp. 327-338, 2002.
Available at http://www.usenix.org/events/sec02/full papers/black/black html/

3. D. Bleichenbacher. “Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS
#1.” In H. Krawczyk, editor, Advances in Cryptology – Crypto ’98, volume 1462 of Lecture Notes in Computer
Science, pp. 1 - 12. Springer Verlag, 1998.

4. J. Callas, L. Donnerhacke, H. Finney, and R. Thayer, “OpenPGP Message Format,” RFC 2440, Nov 1998.
5. J. Callas, L. Donnerhacke, H. Finney, and R. Thayer, “OpenPGP Message Format,” draft-ietf-openpgp-

rfc2440bis-XX.txt, work in progress.
6. Cryptix OpenPGP, 20041006 snapshot.
Available at http://www.cryptix.org/

7. M. Dworkin, “Recommendation for Block Cipher Modes of Operation,” US Department of Commerce, NIST

Special Publication 800-38A, 2001.
Available at http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf

8. H. Finney, personal communications.
9. The GNU Privacy Guard, version 1.2.6.
Available at http://www.gnupg.org/

10. K. Jallad, J. Katz, and B. Schneier, “Implementation of Chosen-Ciphertext Attacks against PGP and GnuPG,”

In Proceedings of the 5th International Conference on Information Security, pp. 90-101, 2002.

11. B. Kaliski, “PKCS #7: RSA Encryption, Version 1.5,” RFC 2313, Mar 1998.
12. J. Katz and B. Schneier, “A Chosen Ciphertext Attack against Several E-Mail Encryption Protocols,”

InProceedings of the 9th USENIX Security Symposium pp. 241-246, 2000.
Available at http://www.usenix.org/publications/library/proceedings/sec2000/katz.html

13. S. Vaudenay, “Security Flaws Induced by CBC Padding-Applications to SSL, IPSEC, WTLS . . .,” In Lars Knud-
sen, editor Advances in Cryptology – EUROCRYPT 2002, volume 2332 of Lecture Notes in Computer Science,
pp. 534-545, Springer-Verlag, 2002.



=== Content from www.kb.cert.org_27092ab4_20250124_134256.html ===


search

menu

icon-carat-right

cmu-wordmark

* ×
* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* [Search](/vuls/search/)
* [Report a Vulnerability](/vuls/report/)
* [Disclosure Guidance](/vuls/guidance/)
* [VINCE](/vince/)

[[Carnegie Mellon University](https://www.cmu.edu)](https://www.cmu.edu/)

# [Software Engineering Institute](https://www.sei.cmu.edu/)

## CERT Coordination Center

* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* [Search](/vuls/search/)
* [Report a Vulnerability](/vuls/report/)
* [Disclosure Guidance](/vuls/guidance/)
* [VINCE](/vince/)

* [Home](/vuls/)
* [Notes](/vuls/bypublished/desc/)
* Current:  VU#303094

## OpenPGP vulnerable to chosen-ciphertext attacks in cipher feedback (CFB) mode

#### Vulnerability Note VU#303094

Original Release Date: 2005-02-11 | Last Revised: 2005-05-23

---

### Overview

A vulnerability in OpenPGP may allow attackers to recover partial plaintexts from OpenPGP messages that use symmetric encryption.

### Description

| A vulnerability in OpenPGP can be used by attackers to recover partial plaintexts from messages employing symmetric encryption. Researchers Serge Mister and Robert Zuccherato of [Entrust](http://www.entrust.com/) have developed [a chosen-ciphertext attack method](http://eprint.iacr.org/2005/033) that can be used against OpenPGP messages encrypted using cipher feedback (CFB) mode. The attack takes advantage of an integrity check feature that is intended to save time by aborting futile and possibly lengthy decryption attempts.  **Preconditions**The attack described by Mister and Zuccherato has two significant preconditions. First, it requires an oracle that reveals whether or not the integrity check was successful. This condition can be satisfied directly (when an integrity check failure message is available) or indirectly (by observing timing differences between failed and successful integrity checks). Second, it requires knowledge of the first two bytes of any one message block; this condition can be satisfied by the OpenPGP message format, which defines several packet headers with well-known values that will appear in the first two bytes of the encrypted message. **Limitations**There are two important limitations that reduce the severity of this attack. One, Mister and Zuccherato have determined that it requires a one-time setup cost of 215 oracle queries and an additional cost of 215 oracle queries per block. This reduces the viability of the attack against a human user because very few people are willing to attempt to decrypt the same message over 32,000 times. However, this attack is feasible against server-based implementations of OpenPGP, where it might be possible to make repeated decryption attempts against an automated system without being detected. Two, the attack only recovers the first two bytes of each encrypted block. Assuming a block size of 64 bits, an attacker can recover only 25% of the plaintext from an intercepted message.For detailed information on this attack method, please read ["An Attack on CFB Mode Encryption As Used By OpenPGP,"](http://eprint.iacr.org/2005/033) written by Serge Mister and Robert Zuccherato. |
| --- |

### Impact

| Attackers may be able to recover partial plaintexts from OpenPGP messages that use symmetric encryption. |
| --- |

### Solution

| **Apply a patch from your vendor**Several vendors that implement OpenPGP have elected to reduce the exposure of this vulnerability by disabling the integrity check feature in public-key encryption modes. This is intended as a precautionary measure until the vulnerability can be fully addressed by modifying the OpenPGP standard ([RFC 2440](http://www.ietf.org/rfc/rfc2440.txt)). For a discussion of this issue and the response of the OpenPGP Working Group, please read "[OpenPGP flaw prompts quick fix](http://www.pgp.com/library/ctocorner/openpgp.html)".The vendor section of this document contains a list of vendors that we have contacted regarding this issue and will be updated with vendor responses as they are provided. |
| --- |

### Vendor Information

303094
Filter by status:
All
Affected
Not Affected
Unknown

Filter by content:
 Additional information available

 Sort by:
Status
Alphabetical

Expand all

**Javascript is disabled. Click [here](/vuls/vendor/VU%23303094/) to view vendors.**
### [OpenPGP](#JPLA-69HMKK) Affected

Notified:  February 10, 2005  Updated: February 11, 2005

### Status

Affected

### Vendor Statement

We have not received a statement from the vendor.

### Vendor Information

The vendor has not provided us with any further information regarding this vulnerability.

### Addendum

For a discussion of this issue and the response of the OpenPGP Working Group, please read "[OpenPGP flaw prompts quick fix](http://www.pgp.com/library/ctocorner/openpgp.html)", available at:

<http://www.pgp.com/library/ctocorner/openpgp.html>

If you have feedback, comments, or additional information about this vulnerability, please send us email.

### [GNU Privacy Guard](#JPLA-69HMLG) Unknown

Notified:  February 11, 2005  Updated: February 11, 2005

### Status

Unknown

### Vendor Statement

We have not received a statement from the vendor.

### Vendor Information

The vendor has not provided us with any further information regarding this vulnerability.

### Addendum

US-CERT has no additional comments at this time.

If you have feedback, comments, or additional information about this vulnerability, please send us email.

### [Hush Communications](#JPLA-69HMMG) Unknown

Updated:  February 11, 2005

### Status

Unknown

### Vendor Statement

We have not received a statement from the vendor.

### Vendor Information

The vendor has not provided us with any further information regarding this vulnerability.

### Addendum

US-CERT has no additional comments at this time.

If you have feedback, comments, or additional information about this vulnerability, please send us email.

### [PGP](#JPLA-69HMM2) Unknown

Notified:  February 11, 2005  Updated: February 11, 2005

### Status

Unknown

### Vendor Statement

We have not received a statement from the vendor.

### Vendor Information

The vendor has not provided us with any further information regarding this vulnerability.

### Addendum

US-CERT has no additional comments at this time.

If you have feedback, comments, or additional information about this vulnerability, please send us email.

### CVSS Metrics

| Group | Score | Vector |
| --- | --- | --- |
| Base |  |  |
| Temporal |  |  |
| Environmental |  |  |

### References

* <http://eprint.iacr.org/2005/033>
* <http://www.pgp.com/library/ctocorner/openpgp.html>
* <http://www.ietf.org/rfc/rfc2440.txt>
### Acknowledgements

This vulnerability was discovered by Serge Mister and Robert Zuccherato of Entrust.

This document was written by Jeffrey P. Lanza and Will Dormann.

### Other Information

| **CVE IDs:** | [CVE-2005-0366](http://web.nvd.nist.gov/vuln/detail/CVE-2005-0366) |
| --- | --- |
| **Severity Metric:** | 3.07 |
| **Date Public:** | 2005-02-10 |
| **Date First Published:** | 2005-02-11 |
| **Date Last Updated:** | 2005-05-23 13:38 UTC |
| **Document Revision:** | 25 |

* [About vulnerability notes](https://vuls.cert.org/confluence/display/VIN/Vulnerability%2BNote%2BHelp)
* Contact us about this vulnerability
* [Provide a vendor statement](https://vuls.cert.org/confluence/display/VIN/Case%2BHandling#CaseHandling-Givingavendorstatusandstatement)

Sponsored by [CISA.](https://www.cisa.gov/cybersecurity)

 [Download PGP Key](https://vuls.cert.org/confluence/pages/viewpage.action?pageId=25985026)

[Read CERT/CC Blog](https://insights.sei.cmu.edu/cert/)

[Learn about Vulnerability Analysis](https://www.sei.cmu.edu/research-capabilities/all-work/display.cfm?customel_datapageid_4050=21304)

Carnegie Mellon University

Software Engineering Institute

4500 Fifth Avenue

Pittsburgh, PA 15213-2612

412-268-5800

[Office Locations](http://www.sei.cmu.edu/locations/index.cfm) | [Additional Sites Directory](http://www.sei.cmu.edu/additional-sites-directory/index.cfm) | [Legal](https://vuls.cert.org/confluence/display/VIN/VINCE%2BCode%2Bof%2BConduct#VINCECodeofConduct-TermsofUse) | [Privacy Notice](https://www.sei.cmu.edu/legal/privacy-notice/index.cfm) | [CMU Ethics Hotline](https://www.cmu.edu/hr/ethics-hotline/) | [www.sei.cmu.edu](http://www.sei.cmu.edu)

Â©2022 Carnegie Mellon University

[Contact SEI](https://www.sei.cmu.edu/contact-us/)
#### Contact CERT/CC

 412-268-5800



=== Content from www.mandriva.com_624d776f_20250124_134257.html ===


* [Tuxedo.org](https://tuxedo.org/ "Go to: Tuxedo")
* Store
* Mandriva Linux
* Enterprise Solutions
* Contact Us
* Language ![](/sites/all/themes/mandriva_customer/images/arrow-grey-bottom.gif)
  + English (International)
  + Français
  + Ð ÑÑÑÐºÐ¸Ð¹

# [Mandriva](/mandriva/)

* Download
* Mandriva Linux
* Community
* Help

## One

### The Linux desktopthat's easy to try and easy to keep

Download
![Mandriva One](/sites/all/themes/mandriva_customer/images/front/packshot_Mandriva_One.png)

## Powerpack

### Mandriva Linux- and more

Download
![Mandriva Linux Powerpack](/sites/all/themes/mandriva_customer/images/front/en-49.png)

## Mandriva Flash

### The mobile and installable Linux desktopon a USB key

Buy on Store
![Mandriva Flash](/sites/all/themes/mandriva_customer/images/front/mandriva-flash2.png)

### [Community](community)

* User Forums
* Support - FAQ
* Free Software
* Become a member

### Enterprise Solutions

* Enterprise Linux Products
* Asset Management Solution
* Professional Services
* Support & Maintenance

* Go to site »

### Mandriva Partners

* Worldwide offices
* Partner Program
* Technology Partners
* OEM
* Classmate PC with Mandriva Linux

### News

* Mandriva presents the launch of its new mobile desktop: Mandriva Flash 2008 Spring
* Speaking about Mandriva Linux 2008 Spring in media
* Speaking about Mandriva Linux 2008 Spring in media
* Mandriva presents its latest distribution: Mandriva Linux 2008 Spring
* Mandriva and Novatice Technologies present Edutice, The ready to use solution dedicated to educationand multimedia spaces
* # [Top 50 Online Casinos UK in 2023](https://montycasinos.com/online-casinos/)

more

* Download
  + Mandriva Linux 2008
  + Writing an ISO image
* Mandriva Linux
  + One
  + Powerpack
  + Mandriva Flash
* Community
  + Start
  + Register
  + Stay informed
  + Participate
  + Free software
* Help
  + Getting help
  + Knowledge Base
  + Documentation
  + Forums
  + Support Requests
  + Customer Care
  + Enterprise Support
* Enterprise Solutions
  + Products
  + Support
  + Services
  + Partners
  + Go to site »

Language
English (International)
Français
Ð ÑÑÑÐºÐ¸Ð¹

* © 2007 Mandriva S.A.
* About Us
* Legal Information
* Privacy Policy
* Contact Us



=== Content from www.gentoo.org_d2a25254_20250124_134255.html ===

[![Gentoo](https://assets.gentoo.org/tyrian/v2/site-logo.png)](/ "Back to the homepage")
Security

[**Get Gentoo!**](https://get.gentoo.org/)
gentoo.org sites
[gentoo.org](https://www.gentoo.org/ "Main Gentoo website")
[Wiki](https://wiki.gentoo.org/ "Find and contribute documentation")
[Bugs](https://bugs.gentoo.org/ "Report issues and find common issues")
[Forums](https://forums.gentoo.org/ "Discuss with the community")
[Packages](https://packages.gentoo.org/ "Find software for your Gentoo")

[Planet](https://planet.gentoo.org/ "Find out what's going on in the developer community")
[Archives](https://archives.gentoo.org/ "Read up on past discussions")
[Sources](https://sources.gentoo.org/ "Browse our source code")

[Infra Status](https://infra-status.gentoo.org/ "Get updates on the services provided by Gentoo")

* [Home](/)
* [Stay informed](/subscribe)
* [Advisories](/glsa)

# GnuPG: OpenPGP protocol attack — GLSA **200503-29**

Automated systems using GnuPG may leak plaintext portions of an encrypted
message.

### Affected packages

| Package | **app-crypt/gnupg** on all architectures |
| --- | --- |
| Affected versions | < **1.4.1** |
| Unaffected versions | >= **1.4.1** |

### Background

GnuPG is complete and free replacement for PGP, a tool for secure
communication and data storage.

### Description

A flaw has been identified in an integrity checking mechanism of
the OpenPGP protocol.

### Impact

An automated system using GnuPG that allows an attacker to
repeatedly discover the outcome of an integrity check (perhaps by
observing the time required to return a response, or via overly verbose
error messages) could theoretically reveal a small portion of
plaintext.

### Workaround

There is no known workaround at this time.

### Resolution

All GnuPG users should upgrade to the latest version:

```
 # emerge --sync
 # emerge --ask --oneshot --verbose ">=app-crypt/gnupg-1.4.1"
```
### References

* [CERT VU#303094](https://www.kb.cert.org/vuls/id/303094)
* [CAN-2005-0366](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-0366)

**Release date**

March 24, 2005

**Latest revision**

March 24, 2005: 01

**Severity**

low

**Exploitable**

remote

**Bugzilla entries**

* [85547](https://bugs.gentoo.org/show_bug.cgi?id=85547)

### Questions or comments?

Please feel free to contact us.

**© 2001–2020 Gentoo Foundation, Inc.**



=== Content from eprint.iacr.org_4135c272_20250124_134253.html ===

# What a lovely hat

#### Is it made out of [tin foil](https://iacr.org/tinfoil.html)?

[![IACR Logo](/img/iacrlogo_small.png)](https://iacr.org/)

[Cryptology ePrint Archive](/)

* Papers
  Updates from the last:+ [7 days](/days/7)
  + [31 days](/days/31)
  + [6 months](/days/183)
  + [365 days](/days/365)
  + ---
  + [Listing by year](/byyear)
  + [All papers](/complete)
  + [Compact view](/complete/compact)
  + [Subscribe](https://www.iacr.org/news/subscribe)
  + ---
  + [How to cite](/citation.html)
  + ---
  + [Harvesting metadata](/rss)
* Submissions
  + [Submit a paper](/submit)
  + [Revise or withdraw a paper](/revise)
  + [Acceptance and publishing conditions](/operations.html)
* About
  + [Goals and history](/about.html)
  + [News](/news.html)
  + [Statistics](/stats)
  + [Contact](/contact.html)

![Search Button](/img/search.svg)

Search

[Advanced search](/search)

#### Paper 2005/033

### An Attack on CFB Mode Encryption As Used By OpenPGP

Serge Mister and Robert Zuccherato

##### Abstract

This paper describes an adaptive-chosen-ciphertext attack on the Cipher Feedback (CFB) mode of encryption as used in OpenPGP. In most circumstances it will allow an attacker to determine 16 bits of any block of plaintext with about $2^{15}$ oracle queries for the initial
setup work and $2^{15}$ oracle queries for each block. Standard CFB mode encryption does not appear to be affected by this attack. It applies to a particular variation of CFB used by OpenPGP. In particular it exploits an ad-hoc integrity check feature in OpenPGP which was meant as a "quick check" to determine the correctness of the decrypting symmetric key.

##### Metadata

Available format(s)

[![](/img/file-pdf.svg)PDF](/2005/033.pdf)

Category
[Cryptographic protocols](/search?category=PROTOCOLS)
Publication info
Published elsewhere. Unknown where it was published
Keywords
[applications](/search?q=applications)[cryptanalysis](/search?q=cryptanalysis)
Contact author(s)
robert zuccherato @ entrust com

History
2005-02-10: received
Short URL
<https://ia.cr/2005/033>
License
[![Creative Commons Attribution](/img/license/CC_BY.svg "Creative Commons Attribution")

CC BY](https://creativecommons.org/licenses/by/4.0/)

**BibTeX**
![](/img/copy-outline.svg)Copy to clipboard

```

@misc{cryptoeprint:2005/033,
      author = {Serge Mister and Robert Zuccherato},
      title = {An Attack on {CFB} Mode Encryption As Used By {OpenPGP}},
      howpublished = {Cryptology {ePrint} Archive, Paper 2005/033},
      year = {2005},
      url = {https://eprint.iacr.org/2005/033}
}

```

[![IACR Logo](/img/iacrlogo_small.png)](https://iacr.org/)

Note: In order to protect the privacy of readers, eprint.iacr.org
does not use cookies or embedded third party content.


